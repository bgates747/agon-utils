PC     Output      Line
040000             0001   ;
040000             0002   ; Title:	test
040000             0003   ; Author:	Brandon Gates
040000             0004   ; Created:	29/10/2024
040000             0005   
040000             0006       ASSUME	ADL = 1
040000             0007       INCLUDE "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  ; 09/04/2024:   Adapter to ez80asm
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ;FFOBJID	.STRUCT
040000             0196*  ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ;	id:		DS	2	; Hosting volume mount ID
040000             0198*  ;	attr:		DS	1	; Object attribute;
040000             0199*  ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ;
040000             0204*  ; File object structure (FIL)
040000             0205*  ;
040000             0206*  ;FIL .STRUCT
040000             0207*  ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ;	flag:		DS	1	; File status flags
040000             0209*  ;	err:		DS	1	; Abort flag (error code)
040000             0210*  ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  ;DIR .STRUCT
040000             0220*  ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*  ;	dptr:		DS	4	; Current read/write offset
040000             0222*  ;	clust:		DS	4	; Current cluster
040000             0223*  ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ;
040000             0229*  ; File information structure (FILINFO)
040000             0230*  ;
040000             0231*  ;FILINFO .STRUCT
040000             0232*  ;	fsize:		DS 	4	; File size
040000             0233*  ;	fdate:		DS	2	; Modified date;
040000             0234*  ;	ftime:		DS	2	; Modified time
040000             0235*  ;	fattrib:	DS	1	; File attribute
040000             0236*  ;	altname:	DS	13	; Alternative file name
040000             0237*  ;	fname:		DS	256	; Primary file name
040000             0238*  ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  			MACRO	MOSCALL function
040000             0246*  			LD	A, function
040000             0247*  			RST.L	08h
040000             0248*  			ENDMACRO
040000             0008       ORG 0x0B0000 ; Is a moslet
0B0000             0009   
0B0000             0010       MACRO PROGNAME
0B0000             0011       ASCIZ "scratch.bin"
0B0000             0012       ENDMACRO
0B0000             0013   
0B0000             0014   ; STANDARD MOSLET INCLUDES
0B0000             0015       include "init.inc"
0B0000             0001*  ;
0B0000             0002*  ; Title:	Copy - Initialisation Code
0B0000             0003*  ; Author:	Dean Belfield, Lennart Benschop
0B0000             0004*  ; Created:	06/11/2022
0B0000             0005*  ; Last Updated:	26/12/2022
0B0000             0006*  ;
0B0000             0007*  ; Modinfo:
0B0000             0008*  ; 17/12/2022:	Added parameter processing
0B0000             0009*  ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
0B0000             0010*  ; Changed:      08/04/2924 adapt to ez80asm
0B0000             0011*  
0B0000             0012*  
0B0000             0013*  argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B0000             0014*  
0B0000             0015*  ;
0B0000             0016*  ; Start in ADL mode
0B0000             0017*  ;
0B0000 C3 45 00 0B 0018*  			JP	_start			; Jump to start
0B0004             0019*  ;
0B0004             0020*  ; The header stuff is from byte 64 onwards
0B0004             0021*  ;
0B0004             0022*  
0B0004             0023*  _exec_name:
0B0004             0024*  			PROGNAME			; The executable name, only used in argv
0B0004 73 63 72 61 0001*M     ASCIZ "scratch.bin"
       74 63 68 2E 
       62 69 6E 00 
0B0010             0025*  
0B0010 FF FF FF FF 0026*  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B0040             0027*  
0B0040 4D 4F 53    0028*  			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0029*  			DB	00h			; MOS header version 0
0B0044 01          0030*  			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0031*  ;
0B0045             0032*  ; And the code follows on immediately after the header
0B0045             0033*  ;
0B0045 F5          0034*  _start:			PUSH	AF			; Preserve the registers
0B0046 C5          0035*  			PUSH	BC
0B0047 D5          0036*  			PUSH	DE
0B0048 DD E5       0037*  			PUSH	IX
0B004A FD E5       0038*  			PUSH	IY
0B004C ED 6E       0039*  			LD	A, MB			; Save MB
0B004E F5          0040*  			PUSH 	AF
0B004F AF          0041*  			XOR 	A
0B0050 ED 6D       0042*  			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0043*  
0B0052 DD 21 B9 00 0044*  			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B0057 DD E5       0045*  			PUSH	IX
0B0059 CD 70 00 0B 0046*  			CALL	_parse_params		; Parse the parameters
0B005D DD E1       0047*  			POP	IX			; IX: argv
0B005F 06 00       0048*  			LD	B, 0			;  C: argc
0B0061 CD D5 19 0B 0049*  			CALL	_main			; Start user code
0B0065             0050*  
0B0065 F1          0051*  			POP 	AF
0B0066 ED 6D       0052*  			LD	MB, A
0B0068 FD E1       0053*  			POP	IY			; Restore registers
0B006A DD E1       0054*  			POP	IX
0B006C D1          0055*  			POP	DE
0B006D C1          0056*  			POP	BC
0B006E F1          0057*  			POP	AF
0B006F C9          0058*  			RET
0B0070             0059*  
0B0070             0060*  ; Parse the parameter string into a C array
0B0070             0061*  ; Parameters
0B0070             0062*  ; - HL: Address of parameter string
0B0070             0063*  ; - IX: Address for array pointer storage
0B0070             0064*  ; Returns:
0B0070             0065*  ; -  C: Number of parameters parsed
0B0070             0066*  ;
0B0070 01 04 00 0B 0067*  _parse_params:		LD	BC, _exec_name
0B0074 DD 0F 00    0068*  			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0077 ED 32 03    0069*  			LEA     IX, IX+3
0B007A CD B2 00 0B 0070*  			CALL	_skip_spaces		; Skip HL past any leading spaces
0B007E             0071*  ;
0B007E 01 01 00 00 0072*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0082 06 0F       0073*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0084             0074*  ;
0B0084             0075*  _parse_params_1:
0B0084 C5          0076*  			PUSH	BC			; Stack ARGC
0B0085 E5          0077*  			PUSH	HL			; Stack start address of token
0B0086 CD A3 00 0B 0078*  			CALL	_get_token		; Get the next token
0B008A 79          0079*  			LD	A, C			; A: Length of the token in characters
0B008B D1          0080*  			POP	DE			; Start address of token (was in HL)
0B008C C1          0081*  			POP	BC			; ARGC
0B008D B7          0082*  			OR	A			; Check for A=0 (no token found) OR at end of string
0B008E C8          0083*  			RET	Z
0B008F             0084*  ;
0B008F DD 1F 00    0085*  			LD	(IX+0), DE		; Store the pointer to the token
0B0092 E5          0086*  			PUSH	HL			; DE=HL
0B0093 D1          0087*  			POP	DE
0B0094 CD B2 00 0B 0088*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0098 AF          0089*  			XOR	A
0B0099 12          0090*  			LD	(DE), A			; Zero-terminate the token
0B009A ED 32 03    0091*  			LEA  	IX, IX+3			; Advance to next pointer position
0B009D 0C          0092*  			INC	C			; Increment ARGC
0B009E 79          0093*  			LD	A, C			; Check for C >= A
0B009F B8          0094*  			CP	B
0B00A0 38 E2       0095*  			JR	C, _parse_params_1	; And loop
0B00A2 C9          0096*  			RET
0B00A3             0097*  
0B00A3             0098*  ; Get the next token
0B00A3             0099*  ; Parameters:
0B00A3             0100*  ; - HL: Address of parameter string
0B00A3             0101*  ; Returns:
0B00A3             0102*  ; - HL: Address of first character after token
0B00A3             0103*  ; -  C: Length of token (in characters)
0B00A3             0104*  ;
0B00A3 0E 00       0105*  _get_token:		LD	C, 0			; Initialise length
0B00A5 7E          0106*  @@:			LD	A, (HL)			; Get the character from the parameter string
0B00A6 B7          0107*  			OR	A			; Exit if 0 (end of parameter string in MOS)
0B00A7 C8          0108*  			RET 	Z
0B00A8 FE 0D       0109*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AA C8          0110*  			RET	Z
0B00AB FE 20       0111*  			CP	' '			; Exit if space (end of token)
0B00AD C8          0112*  			RET	Z
0B00AE 23          0113*  			INC	HL			; Advance to next character
0B00AF 0C          0114*  			INC 	C			; Increment length
0B00B0 18 F3       0115*  			JR	@B
0B00B2             0116*  
0B00B2             0117*  ; Skip spaces in the parameter string
0B00B2             0118*  ; Parameters:
0B00B2             0119*  ; - HL: Address of parameter string
0B00B2             0120*  ; Returns:
0B00B2             0121*  ; - HL: Address of next none-space character
0B00B2             0122*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00B2             0123*  ;
0B00B2 7E          0124*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B3 FE 20       0125*  			CP	' '			; Exit if not space
0B00B5 C0          0126*  			RET	NZ
0B00B6 23          0127*  			INC	HL			; Advance to next character
0B00B7 18 F9       0128*  			JR	_skip_spaces		; Increment length
0B00B9             0129*  
0B00B9             0130*  ; Storage for the argv array pointers
0B00B9             0131*  ;
0B00B9 00 00 00 00 0132*  argv_ptrs:		BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B00E9             0016       include "parse.inc"
0B00E9             0001*  ;
0B00E9             0002*  ; Title:	Number Parsing Functions
0B00E9             0003*  ; Author:	Dean Belfield
0B00E9             0004*  ; Created:	15/11/2022
0B00E9             0005*  ; Last Updated:	15/11/2022
0B00E9             0006*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B00E9             0007*  ; Modinfo:
0B00E9             0008*  ; 2024/04/08    Adapt for ez80asm
0B00E9             0009*  
0B00E9             0010*  ; Read a number and convert to binary
0B00E9             0011*  ; If prefixed with &, will read as hex, otherwise decimal
0B00E9             0012*  ;   Inputs: HL: Pointer in string buffer
0B00E9             0013*  ;  Outputs: HL: Updated text pointer
0B00E9             0014*  ;           DE: Value
0B00E9             0015*  ;            A: Terminator (spaces skipped)
0B00E9             0016*  ;            F: Carry set if valid number, otherwise reset
0B00E9             0017*  ; Destroys: A,D,E,H,L,F
0B00E9             0018*  ;
0B00E9 11 00 00 00 0019*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B00ED CD B2 00 0B 0020*  			CALL		_skip_spaces		; Skip whitespace
0B00F1 7E          0021*  			LD		A, (HL)			; Read first character
0B00F2 B7          0022*  			OR		A			; Check for end of string
0B00F3 C8          0023*  			RET		Z			; Return with no carry if not
0B00F4 C5          0024*  			PUSH		BC			; Preserve BC
0B00F5 FE 26       0025*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B00F7 20 23       0026*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B00F9 23          0027*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B00FA             0028*  ;
0B00FA 7E          0029*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B00FB CD 3D 01 0B 0030*  			CALL   	 	UPPRC			; Convert to uppercase
0B00FF D6 30       0031*  			SUB		'0'			; Normalise to 0
0B0101 38 37       0032*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0103 FE 0A       0033*  			CP 		10			; Check if >= 10
0B0105 38 06       0034*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0107 D6 07       0035*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0109 FE 10       0036*  			CP 		16			; Check for > F
0B010B 30 2D       0037*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B010D             0038*  ;
0B010D E5          0039*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B010E D5          0040*  			PUSH		DE			; LD HL, DE
0B010F E1          0041*  			POP		HL
0B0110 29          0042*  			ADD		HL, HL
0B0111 29          0043*  			ADD		HL, HL
0B0112 29          0044*  			ADD		HL, HL
0B0113 29          0045*  			ADD		HL, HL
0B0114 E5          0046*  			PUSH		HL			; LD DE, HL
0B0115 D1          0047*  			POP		DE
0B0116 E1          0048*  			POP		HL			; Restore HL
0B0117 B3          0049*  			OR      	E			; OR the new digit in to the least significant nibble
0B0118 5F          0050*  			LD      	E, A
0B0119             0051*  ;
0B0119 23          0052*  			INC		HL			; Onto the next character
0B011A 18 DE       0053*  			JR      	ASC_TO_NUMBER1		; And loop
0B011C             0054*  ;
0B011C 7E          0055*  ASC_TO_NUMBER3:		LD		A, (HL)
0B011D D6 30       0056*  			SUB		'0'			; Normalise to 0
0B011F 38 19       0057*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0121 FE 0A       0058*  			CP		10			; Check if >= 10
0B0123 30 15       0059*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0125             0060*  ;
0B0125 E5          0061*  			PUSH		HL			; Stack HL
0B0126 D5          0062*  			PUSH		DE			; LD HL, DE
0B0127 E1          0063*  			POP		HL
0B0128 E5          0064*  			PUSH		HL			; LD BC, HL
0B0129 C1          0065*  			POP		BC
0B012A 29          0066*  			ADD		HL, HL 			; x 2
0B012B 29          0067*  			ADD		HL, HL 			; x 4
0B012C 09          0068*  			ADD		HL, BC 			; x 5
0B012D 29          0069*  			ADD		HL, HL 			; x 10
0B012E 01 00 00 00 0070*  			LD		BC, 0
0B0132 4F          0071*  			LD 		C, A			; LD BCU, A
0B0133 09          0072*  			ADD		HL, BC			; Add BCU to HL
0B0134 E5          0073*  			PUSH		HL			; LD DE, HL
0B0135 D1          0074*  			POP		DE
0B0136 E1          0075*  			POP		HL			; Restore HL
0B0137             0076*  ;
0B0137 23          0077*  			INC		HL
0B0138 18 E2       0078*  			JR		ASC_TO_NUMBER3
0B013A C1          0079*  ASC_TO_NUMBER4:		POP		BC
0B013B 37          0080*  			SCF					; We have a valid number so set carry
0B013C C9          0081*  			RET
0B013D             0082*  
0B013D             0083*  
0B013D             0084*  ; Convert a character to upper case
0B013D             0085*  ;  A: Character to convert
0B013D             0086*  ;
0B013D E6 7F       0087*  UPPRC:  		AND     	7FH
0B013F FE 60       0088*  			CP      	'`'
0B0141 D8          0089*  			RET     	C
0B0142 E6 5F       0090*  			AND     	5FH			; Convert to upper case
0B0144 C9          0091*  			RET
0B0145             0092*  
0B0145             0093*  
0B0145             0094*  ;------------------------------------------------------------------------
0B0145             0095*  ; Read a number and convert to binary (decimal only)
0B0145             0096*  ; Inputs: hl: Pointer in string buffer
0B0145             0097*  ; Outputs: hl: Updated text pointer
0B0145             0098*  ;         de: Value
0B0145             0099*  ;         a: Terminator (spaces skipped)
0B0145             0100*  ;         f: Carry set if valid number, otherwise reset
0B0145             0101*  ; Destroys: a, d, e, h, l, f
0B0145             0102*  ;------------------------------------------------------------------------
0B0145             0103*  asc_to_s24:
0B0145 3E 01       0104*      ld a,1 ; set sign flag
0B0147 32 93 01 0B 0105*      ld (@sign),a ; store sign flag
0B014B             0106*  
0B014B 11 00 00 00 0107*      ld de, 0 ; initialise de
0B014F             0108*      ; call _skip_spaces ; skip whitespace
0B014F             0109*  
0B014F 7E          0110*      ld a, (hl) ; read first character
0B0150 B7          0111*      or a ; check for end of string
0B0151 C8          0112*      ret z ; return with no carry if not
0B0152             0113*  
0B0152 C5          0114*      push bc ; preserve bc
0B0153             0115*  
0B0153 FE 2D       0116*      cp '-' ; check for negative number
0B0155 C2 5F 01 0B 0117*      jp nz,@loop ; number is positive, nothing more to do
0B0159 AF          0118*      xor a ; sign flag to zero
0B015A 32 93 01 0B 0119*      ld (@sign),a ; store sign flag
0B015E 23          0120*      inc hl ; skip '-'
0B015F             0121*  
0B015F             0122*  @loop:
0B015F 7E          0123*      ld a, (hl)
0B0160 D6 30       0124*      sub '0' ; normalise to 0
0B0162 38 19       0125*      jr c, @integer_end ; return if < ascii '0'
0B0164 FE 0A       0126*      cp 10 ; check if >= 10
0B0166 30 15       0127*      jr nc, @integer_end ; return if >= 10
0B0168 E5          0128*      push hl ; stack hl
0B0169 D5          0129*      push de ; ld hl, de
0B016A E1          0130*      pop hl
0B016B E5          0131*      push hl ; ld bc, hl
0B016C C1          0132*      pop bc
0B016D 29          0133*      add hl, hl ; x 2
0B016E 29          0134*      add hl, hl ; x 4
0B016F 09          0135*      add hl, bc ; x 5
0B0170 29          0136*      add hl, hl ; x 10
0B0171 01 00 00 00 0137*      ld bc, 0
0B0175 4F          0138*      ld c, a ; ld bcu, a
0B0176 09          0139*      add hl, bc ; add bcu to hl
0B0177 E5          0140*      push hl ; ld de, hl
0B0178 D1          0141*      pop de
0B0179 E1          0142*      pop hl ; restore hl
0B017A 23          0143*      inc hl
0B017B 18 E2       0144*      jr @loop
0B017D             0145*  
0B017D             0146*  @integer_end:
0B017D C1          0147*      pop bc ; send bc back how she came in
0B017E 3A 93 01 0B 0148*      ld a, (@sign) ; get sign flag
0B0182 3D          0149*      dec a ; check if negative
0B0183 F2 91 01 0B 0150*      jp p,@pos ; positive number
0B0187             0151*  
0B0187             0152*  ; Negate de
0B0187 E5          0153*      push hl ; save text pointer
0B0188 21 00 00 00 0154*      ld hl, 0
0B018C AF          0155*      xor a ; clear carry
0B018D ED 52       0156*      sbc hl, de ; subtract DE from HL
0B018F EB          0157*      ex de, hl ; DE = 0-HL
0B0190 E1          0158*      pop hl ; restore text pointer
0B0191             0159*  
0B0191             0160*  @pos:
0B0191 37          0161*      scf ; we have a valid number so set carry
0B0192 C9          0162*      ret
0B0193             0163*  
0B0193 00          0164*  @sign: db 0 ; sign flag buffer
0B0194             0165*  
0B0194             0166*  
0B0194             0167*  ;------------------------------------------------------------------------
0B0194             0168*  ; Read a number and convert to binary (decimal only)
0B0194             0169*  ; Inputs: hl: Pointer in string buffer
0B0194             0170*  ; Outputs: hl: Updated text pointer
0B0194             0171*  ;         de: Value
0B0194             0172*  ;         a: Terminator (spaces skipped)
0B0194             0173*  ;         f: Carry set if valid number, otherwise reset
0B0194             0174*  ; Destroys: a, d, e, h, l, f
0B0194             0175*  ;------------------------------------------------------------------------
0B0194             0176*  asc_to_s168:
0B0194 3E 01       0177*      ld a,1 ; set sign flag
0B0196 32 53 02 0B 0178*      ld (@sign),a ; store sign flag
0B019A             0179*  
0B019A 11 00 00 00 0180*      ld de, 0 ; initialise de
0B019E ED 53 4B 02 0181*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B01A3 ED 53 4F 02 0182*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B01A8             0183*  
0B01A8             0184*      ; call _skip_spaces ; skip whitespace
0B01A8             0185*  
0B01A8 7E          0186*      ld a, (hl) ; read first character
0B01A9 B7          0187*      or a ; check for end of string
0B01AA C8          0188*      ret z ; return with no carry if not
0B01AB             0189*  
0B01AB C5          0190*      push bc ; preserve bc
0B01AC             0191*  
0B01AC FE 2D       0192*      cp '-' ; check for negative number
0B01AE C2 B8 01 0B 0193*      jp nz,@loop ; number is positive, nothing more to do
0B01B2 AF          0194*      xor a ; sign flag to zero
0B01B3 32 53 02 0B 0195*      ld (@sign),a ; store sign flag
0B01B7 23          0196*      inc hl ; skip '-'
0B01B8             0197*  
0B01B8             0198*  @loop:
0B01B8 7E          0199*      ld a, (hl)
0B01B9             0200*  
0B01B9             0201*  ; chcek for decimal point
0B01B9 FE 2E       0202*      cp '.' ; check for decimal point
0B01BB CA FC 01 0B 0203*      jp z,@fractional_start ; jump to fractional part
0B01BF             0204*  
0B01BF             0205*  ; process integer part
0B01BF D6 30       0206*      sub '0' ; normalise to 0
0B01C1 38 19       0207*      jr c, @integer_end ; return if < ascii '0'
0B01C3 FE 0A       0208*      cp 10 ; check if >= 10
0B01C5 30 15       0209*      jr nc, @integer_end ; return if >= 10
0B01C7 E5          0210*      push hl ; stack hl
0B01C8 D5          0211*      push de ; ld hl, de
0B01C9 E1          0212*      pop hl
0B01CA E5          0213*      push hl ; ld bc, hl
0B01CB C1          0214*      pop bc
0B01CC 29          0215*      add hl, hl ; x 2
0B01CD 29          0216*      add hl, hl ; x 4
0B01CE 09          0217*      add hl, bc ; x 5
0B01CF 29          0218*      add hl, hl ; x 10
0B01D0 01 00 00 00 0219*      ld bc, 0
0B01D4 4F          0220*      ld c, a ; ld bcu, a
0B01D5 09          0221*      add hl, bc ; add bcu to hl
0B01D6 E5          0222*      push hl ; ld de, hl
0B01D7 D1          0223*      pop de
0B01D8 E1          0224*      pop hl ; restore hl
0B01D9 23          0225*      inc hl
0B01DA 18 DC       0226*      jr @loop
0B01DC             0227*  
0B01DC             0228*  @integer_end:
0B01DC ED 53 4C 02 0229*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B01E1             0230*  
0B01E1             0231*  @end:
0B01E1 C1          0232*      pop bc ; send bc back how she came in
0B01E2 ED 5B 4B 02 0233*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B01E7 3A 53 02 0B 0234*      ld a, (@sign) ; get sign flag
0B01EB 3D          0235*      dec a ; check if negative
0B01EC F2 FA 01 0B 0236*      jp p,@pos ; positive number
0B01F0             0237*  
0B01F0             0238*  ; Negate de
0B01F0 E5          0239*      push hl ; save text pointer
0B01F1 21 00 00 00 0240*      ld hl, 0
0B01F5 AF          0241*      xor a ; clear carry
0B01F6 ED 52       0242*      sbc hl, de ; subtract DE from HL
0B01F8 EB          0243*      ex de, hl ; DE = 0-HL
0B01F9 E1          0244*      pop hl ; restore text pointer
0B01FA             0245*  
0B01FA             0246*  @pos:
0B01FA 37          0247*      scf ; we have a valid number so set carry
0B01FB C9          0248*      ret
0B01FC             0249*  
0B01FC             0250*  @fractional_start:
0B01FC DD E5       0251*      push ix                    ; preserve ix
0B01FE ED 53 4C 02 0252*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0203 06 03       0253*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B0205 11 00 00 00 0254*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B0209 DD 21 54 02 0255*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B020E 23          0256*      inc hl                     ; Skip decimal point
0B020F             0257*  
0B020F             0258*  @fractional_loop:
0B020F 7E          0259*      ld a, (hl)                 ; Load next character
0B0210 D6 30       0260*      sub '0'                    ; Normalize ASCII to decimal
0B0212 38 1C       0261*      jr c, @end_fraction        ; Exit if < '0'
0B0214 FE 0A       0262*      cp 10
0B0216 30 18       0263*      jr nc, @end_fraction       ; Exit if >= 10
0B0218             0264*  
0B0218             0265*      ; Multiply the current fractional accumulator by 10
0B0218 E5          0266*      push hl                    ; Save char pointer
0B0219 F5          0267*      push af                    ; Save the digit
0B021A EB          0268*      ex de, hl
0B021B E5          0269*      push hl
0B021C 29          0270*      add hl,hl ; * 2
0B021D 29          0271*      add hl,hl ; * 4
0B021E D1          0272*      pop de
0B021F 19          0273*      add hl,de ; * 5
0B0220 29          0274*      add hl,hl ; * 10
0B0221 11 00 00 00 0275*      ld de, 0                   ; Clear DEU
0B0225 F1          0276*      pop af                     ; Restore the current digit
0B0226 5F          0277*      ld e, a                    ; Load the digit into E
0B0227 19          0278*      add hl, de                 ; Add the digit to the accumulator
0B0228 EB          0279*      ex de, hl                  ; Result back to DE
0B0229 ED 32 03    0280*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B022C E1          0281*      pop hl                     ; Restore char pointer
0B022D 23          0282*      inc hl                     ; Move to the next character
0B022E 10 DF       0283*      djnz @fractional_loop      ; Loop if more digits to process
0B0230             0284*  
0B0230             0285*  @end_fraction:
0B0230             0286*  ; Final scaling based on number of fractional digits processed
0B0230 ED 53 50 02 0287*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B0235 2A 4F 02 0B 0288*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B0239             0289*  
0B0239 DD 17 00    0290*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B023C CD D9 08 0B 0291*      call udiv24                ; Perform 24-bit division to scale down
0B0240 7B          0292*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0241 32 4B 02 0B 0293*      ld (@result), a            ; Store fractional part in result buffer
0B0245 DD E1       0294*      pop ix                     ; Restore ix
0B0247 C3 E1 01 0B 0295*      jp @end                    ; Final sign check and flag setup
0B024B             0296*  
0B024B             0297*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B024F             0298*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0253 00          0299*  @sign: db 0                    ; Sign flag buffer
0B0254             0300*  
0B0254             0301*  powers_of_10:
0B0254 01 00 00    0302*      dl 1                       ; 10^0
0B0257 0A 00 00    0303*      dl 10                      ; 10^1
0B025A 64 00 00    0304*      dl 100                     ; 10^2
0B025D E8 03 00    0305*      dl 1000                    ; 10^3
0B0260 10 27 00    0306*      dl 10000                   ; 10^4
0B0263             0017   
0B0263             0018   ; API INCLUDES
0B0263             0019       include "functions.inc"
0B0263             0001*      MACRO printChar char
0B0263             0002*          LD A, char
0B0263             0003*          RST.LIL 10h
0B0263             0004*      ENDMACRO
0B0263             0005*  
0B0263             0006*  ; test the sign of HL
0B0263             0007*  ; inputs: HL obviously
0B0263             0008*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B0263             0009*  ; destroys: flags
0B0263             0010*      MACRO sign_hlu
0B0263             0011*          add hl,de
0B0263             0012*          or a
0B0263             0013*          sbc hl,de
0B0263             0014*      ENDMACRO
0B0263             0015*  
0B0263             0016*  ; Simulated call to subroutine at HL
0B0263             0017*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0B0263             0018*  ; outputs: whatever the subroutine does, including HL and BC
0B0263             0019*  ; destroys: only what the subroutine does, but always BC
0B0263             0020*      MACRO callHL
0B0263             0021*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0022*          push bc       ; which constitutes the return address
0B0263             0023*          jp   (hl)     ; Jump to the address in HL
0B0263             0024*      ENDMACRO
0B0263             0025*  
0B0263             0026*  ; Simulated call to subroutine at IX
0B0263             0027*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0B0263             0028*  ; outputs: whatever the subroutine does, including IX and BC
0B0263             0029*  ; destroys: only what the subroutine does, but always BC
0B0263             0030*      MACRO callIX
0B0263             0031*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0032*          push bc       ; which constitutes the return address
0B0263             0033*          jp   (ix)     ; Jump to the address in IX
0B0263             0034*      ENDMACRO
0B0263             0035*  
0B0263             0036*  ; Simulated call to soubroutinte at IY
0B0263             0037*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0B0263             0038*  ; outputs: whatever the subroutine does, including IY and BC
0B0263             0039*  ; destroys: only what the subroutine does, but always BC
0B0263             0040*      MACRO callIY
0B0263             0041*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0042*          push bc       ; which constitutes the return address
0B0263             0043*          jp   (iy)     ; Jump to the address in IY
0B0263             0044*      ENDMACRO
0B0263             0045*  
0B0263             0046*  ; put the value in HLU into the accumulator
0B0263             0047*  ; destroys: af
0B0263             0048*      MACRO HLU_TO_A
0B0263             0049*          push hl ; 4 cycles
0B0263             0050*          inc sp ; 1 cycle
0B0263             0051*          pop af  ; 4 cycles
0B0263             0052*          dec sp ; 1 cycle
0B0263             0053*                 ; 10 cycles total
0B0263             0054*      ENDMACRO
0B0263             0055*  
0B0263             0056*  A_TO_HLU:
0B0263             0057*      ; call is 7 cycles
0B0263 22 70 02 0B 0058*      ld (@scratch),hl ; 7 cycles
0B0267 32 72 02 0B 0059*      ld (@scratch+2),a ; 5 cycles
0B026B 2A 70 02 0B 0060*      ld hl,(@scratch) ; 7 cycles
0B026F C9          0061*      ret ; 6 cycles
0B0270             0062*          ; 25 cycles total
0B0270 00 00 00    0063*  @scratch: dl 0
0B0273             0064*  
0B0273             0065*      ; TODO: implement this
0B0273             0066*      ; MACRO A_TO_HLU
0B0273             0067*      ;     push.s af
0B0273             0068*      ;     inc sp
0B0273             0069*      ;     push.s hl
0B0273             0070*      ;     pop hl
0B0273             0071*      ;     inc sp
0B0273             0072*      ;     inc sp
0B0273             0073*      ; ENDMACRO
0B0273             0074*  
0B0273             0075*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0273             0076*  ; Print a zero-terminated string
0B0273             0077*  ; HL: Pointer to string
0B0273             0078*  printString:
0B0273 C5          0079*  	PUSH	BC
0B0274 01 00 00 00 0080*  	LD		BC,0
0B0278 3E 00       0081*  	LD 	 	A,0
0B027A 5B DF       0082*  	RST.LIL 18h
0B027C C1          0083*  	POP		BC
0B027D C9          0084*  	RET
0B027E             0085*  ; print a VDU sequence
0B027E             0086*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B027E             0087*  sendVDUsequence:
0B027E C5          0088*  	PUSH	BC
0B027F 01 00 00 00 0089*  	LD		BC, 0
0B0283 4E          0090*  	LD		C, (HL)
0B0284 5B DF       0091*  	RST.LIL	18h
0B0286 C1          0092*  	POP		BC
0B0287 C9          0093*  	RET
0B0288             0094*  ; Print Newline sequence to VDP
0B0288             0095*  printNewLine:
0B0288 F5          0096*      push af ; for some reason rst.lil 10h sets carry flag
0B0289 3E 0D       0097*  	LD	A, '\r'
0B028B 5B D7       0098*  	RST.LIL 10h
0B028D 3E 0A       0099*  	LD	A, '\n'
0B028F 5B D7       0100*  	RST.LIL 10h
0B0291 F1          0101*      pop af
0B0292 C9          0102*  	RET
0B0293             0103*  
0B0293             0104*  ; Print a 24-bit HEX number
0B0293             0105*  ; HLU: Number to print
0B0293             0106*  printHex24:
0B0293             0107*  	; PUSH	HL      ; 4 cycles
0B0293             0108*  	; LD		HL, 2   ; 4 cycles
0B0293             0109*  	; ADD		HL, SP  ; 1 cycle
0B0293             0110*  	; LD		A, (HL) ; 2 cycles
0B0293             0111*  	; POP		HL      ; 4 cycles
0B0293             0112*      ;                 ; 15 cycles total
0B0293 E5          0113*      push hl ; 4 cycles
0B0294 33          0114*      inc sp ; 1 cycle
0B0295 F1          0115*      pop af  ; 4 cycles
0B0296 3B          0116*      dec sp ; 1 cycle
0B0297             0117*              ; 10 cycles total
0B0297 CD A1 02 0B 0118*  	CALL	printHex8
0B029B             0119*  ; Print a 16-bit HEX number
0B029B             0120*  ; HL: Number to print
0B029B             0121*  printHex16:
0B029B 7C          0122*  	LD		A,H
0B029C CD A1 02 0B 0123*  	CALL	printHex8
0B02A0 7D          0124*  	LD		A,L
0B02A1             0125*  ; Print an 8-bit HEX number
0B02A1             0126*  ; A: Number to print
0B02A1             0127*  printHex8:
0B02A1 4F          0128*  	LD		C,A
0B02A2 1F          0129*  	RRA
0B02A3 1F          0130*  	RRA
0B02A4 1F          0131*  	RRA
0B02A5 1F          0132*  	RRA
0B02A6 CD AB 02 0B 0133*  	CALL	@F
0B02AA 79          0134*  	LD		A,C
0B02AB             0135*  @@:
0B02AB E6 0F       0136*  	AND		0Fh
0B02AD C6 90       0137*  	ADD		A,90h
0B02AF 27          0138*  	DAA
0B02B0 CE 40       0139*  	ADC		A,40h
0B02B2 27          0140*  	DAA
0B02B3 5B D7       0141*  	RST.LIL	10h
0B02B5 C9          0142*  	RET
0B02B6             0143*  
0B02B6             0144*  printHexA:
0B02B6 F5          0145*      push af
0B02B7 C5          0146*      push bc
0B02B8 CD A1 02 0B 0147*      call printHex8
0B02BC 3E 20       0148*      ld a,' '
0B02BE 5B D7       0149*      rst.lil 10h
0B02C0 C1          0150*      pop bc
0B02C1 F1          0151*      pop af
0B02C2 C9          0152*      ret
0B02C3             0153*  
0B02C3             0154*  printHexHL:
0B02C3 F5          0155*      push af
0B02C4 C5          0156*      push bc
0B02C5 CD 9B 02 0B 0157*      call printHex16
0B02C9 3E 20       0158*      ld a,' '
0B02CB 5B D7       0159*      rst.lil 10h
0B02CD C1          0160*      pop bc
0B02CE F1          0161*      pop af
0B02CF C9          0162*      ret
0B02D0             0163*  
0B02D0             0164*  printHexUHL:
0B02D0 F5          0165*      push af
0B02D1 C5          0166*      push bc
0B02D2 CD 93 02 0B 0167*      call printHex24
0B02D6 3E 20       0168*      ld a,' '
0B02D8 5B D7       0169*      rst.lil 10h
0B02DA C1          0170*      pop bc
0B02DB F1          0171*      pop af
0B02DC C9          0172*      ret
0B02DD             0173*  
0B02DD             0174*  printHexAUHL:
0B02DD F5          0175*      push af
0B02DE C5          0176*      push bc
0B02DF CD A1 02 0B 0177*      call printHex8
0B02E3 3E 2E       0178*      ld a,'.'
0B02E5 5B D7       0179*      rst.lil 10h
0B02E7 CD 93 02 0B 0180*      call printHex24
0B02EB 3E 20       0181*      ld a,' '
0B02ED 5B D7       0182*      rst.lil 10h
0B02EF C1          0183*      pop bc
0B02F0 F1          0184*      pop af
0B02F1 C9          0185*      ret
0B02F2             0186*  
0B02F2             0187*  printHexABHL:
0B02F2             0188*  ; preserve registers
0B02F2 C5          0189*      push bc ; b will be ok c will not
0B02F3 F5          0190*      push af ; will get totally destroyed
0B02F4             0191*  ; print a
0B02F4 CD A1 02 0B 0192*      call printHex8
0B02F8             0193*  ; print b
0B02F8 78          0194*      ld a,b
0B02F9 CD A1 02 0B 0195*      call printHex8
0B02FD             0196*  ; print hl
0B02FD CD 9B 02 0B 0197*      call printHex16
0B0301             0198*  ; restore registers
0B0301 F1          0199*      pop af
0B0302 C1          0200*      pop bc
0B0303 C9          0201*      ret
0B0304             0202*  
0B0304             0203*  printHexBHL:
0B0304             0204*  ; preserve registers
0B0304 C5          0205*      push bc ; b will be ok c will not
0B0305 F5          0206*      push af ; will get totally destroyed
0B0306             0207*  ; print b
0B0306 78          0208*      ld a,b
0B0307 CD A1 02 0B 0209*      call printHex8
0B030B             0210*  ; print hl
0B030B CD 9B 02 0B 0211*      call printHex16
0B030F             0212*  ; restore registers
0B030F F1          0213*      pop af
0B0310 C1          0214*      pop bc
0B0311 C9          0215*      ret
0B0312             0216*  
0B0312             0217*  printHexCDE:
0B0312             0218*  ; preserve registers
0B0312 C5          0219*      push bc ; b will be ok c will not
0B0313 F5          0220*      push af ; will get totally destroyed
0B0314             0221*  ; print c
0B0314 79          0222*      ld a,c
0B0315 CD A1 02 0B 0223*      call printHex8
0B0319             0224*  ; print de
0B0319 EB          0225*      ex de,hl
0B031A CD 9B 02 0B 0226*      call printHex16
0B031E EB          0227*      ex de,hl
0B031F             0228*  ; restore registers
0B031F F1          0229*      pop af
0B0320 C1          0230*      pop bc
0B0321 C9          0231*      ret
0B0322             0232*  
0B0322             0233*  ; Print a 0x HEX prefix
0B0322             0234*  DisplayHexPrefix:
0B0322 3E 30       0235*  	LD	A, '0'
0B0324 5B D7       0236*  	RST.LIL 10h
0B0326 3E 78       0237*  	LD	A, 'x'
0B0328 5B D7       0238*  	RST.LIL 10h
0B032A C9          0239*  	RET
0B032B             0240*  
0B032B             0241*      MACRO printDecBC
0B032B             0242*          push hl
0B032B             0243*          push bc
0B032B             0244*          pop hl
0B032B             0245*          call printDec
0B032B             0246*          pop hl
0B032B             0247*      ENDMACRO
0B032B             0248*  
0B032B             0249*      MACRO printDecDE
0B032B             0250*          push hl
0B032B             0251*          push de
0B032B             0252*          pop hl
0B032B             0253*          call printDec
0B032B             0254*          pop hl
0B032B             0255*      ENDMACRO
0B032B             0256*  
0B032B             0257*      MACRO printDecHL
0B032B             0258*          call printDec
0B032B             0259*      ENDMACRO
0B032B             0260*  
0B032B             0261*      MACRO printDecIX
0B032B             0262*          push hl
0B032B             0263*          push ix
0B032B             0264*          pop hl
0B032B             0265*          call printDec
0B032B             0266*          pop hl
0B032B             0267*      ENDMACRO
0B032B             0268*  
0B032B             0269*      MACRO printDecIY
0B032B             0270*          push hl
0B032B             0271*          push iy
0B032B             0272*          pop hl
0B032B             0273*          call printDec
0B032B             0274*          pop hl
0B032B             0275*      ENDMACRO
0B032B             0276*  
0B032B             0277*  
0B032B             0278*  ; Prints the right justified decimal value in HL without leading zeroes
0B032B             0279*  ; HL : Value to print
0B032B             0280*  ; preserves all registers and flags
0B032B             0281*  printDec:
0B032B             0282*  ; BEGIN MY CODE
0B032B             0283*  ; back up all the things
0B032B F5          0284*      push af
0B032C C5          0285*      push bc
0B032D D5          0286*      push de
0B032E E5          0287*      push hl
0B032F             0288*  ; END MY CODE
0B032F 11 57 03 0B 0289*  	LD	 DE, _printDecBuffer
0B0333 CD 67 03 0B 0290*  	CALL u24_to_ascii
0B0337             0291*  ; BEGIN MY CODE
0B0337             0292*  ; replace leading zeroes with spaces
0B0337 21 57 03 0B 0293*      LD	 HL, _printDecBuffer
0B033B 06 07       0294*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B033D             0295*  @loop:
0B033D 7E          0296*      LD	 A, (HL)
0B033E FE 30       0297*      CP	 '0'
0B0340 C2 4E 03 0B 0298*      JP	 NZ, @done
0B0344 3E 20       0299*      LD   A, ' '
0B0346 77          0300*      LD	 (HL), A
0B0347 23          0301*      INC	 HL
0B0348 CD 47 14 0B 0302*      CALL vdu_cursor_forward
0B034C 10 EF       0303*      DJNZ @loop
0B034E             0304*  @done:
0B034E             0305*  ; END MY CODE
0B034E             0306*  	; LD	 HL, _printDecBuffer
0B034E CD 73 02 0B 0307*  	CALL printString
0B0352             0308*  ; BEGIN MY CODE
0B0352             0309*  ; restore all the things
0B0352 E1          0310*      pop hl
0B0353 D1          0311*      pop de
0B0354 C1          0312*      pop bc
0B0355 F1          0313*      pop af
0B0356             0314*  ; END MY CODE
0B0356 C9          0315*  	RET
0B0357 00 00 00 00 0316*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0367             0317*  
0B0367             0318*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B0367             0319*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B0367             0320*  ; so it will allways be 8 characters length
0B0367             0321*  ; HL : Value to convert to string
0B0367             0322*  ; DE : pointer to buffer, at least 8 byte + 0
0B0367             0323*  u24_to_ascii:
0B0367 01 80 69 67 0324*  	LD	 BC,-10000000
0B036B CD 9E 03 0B 0325*  	CALL @one_digit
0B036F 01 C0 BD F0 0326*  	LD	 BC,-1000000
0B0373 CD 9E 03 0B 0327*  	CALL @one_digit
0B0377 01 60 79 FE 0328*  	LD	 BC,-100000
0B037B CD 9E 03 0B 0329*  	CALL @one_digit
0B037F 01 F0 D8 FF 0330*  	LD   BC,-10000
0B0383 CD 9E 03 0B 0331*  	CALL @one_digit
0B0387 01 18 FC FF 0332*  	LD   BC,-1000
0B038B CD 9E 03 0B 0333*  	CALL @one_digit
0B038F 01 9C FF FF 0334*  	LD   BC,-100
0B0393 CD 9E 03 0B 0335*  	CALL @one_digit
0B0397 0E F6       0336*  	LD   C,-10
0B0399 CD 9E 03 0B 0337*  	CALL @one_digit
0B039D 48          0338*  	LD   C,B
0B039E             0339*  @one_digit:
0B039E 3E 2F       0340*  	LD   A,'0'-1
0B03A0             0341*  @divide_me:
0B03A0 3C          0342*  	INC  A
0B03A1 09          0343*  	ADD  HL,BC
0B03A2 38 FC       0344*  	JR   C,@divide_me
0B03A4 ED 42       0345*  	SBC  HL,BC
0B03A6 12          0346*  	LD   (DE),A
0B03A7 13          0347*  	INC  DE
0B03A8 C9          0348*  	RET
0B03A9             0349*  
0B03A9             0350*  print_u24:
0B03A9 D5          0351*      push de
0B03AA E5          0352*      push hl
0B03AB 11 57 03 0B 0353*      ld de,_printDecBuffer
0B03AF CD 67 03 0B 0354*      call u24_to_ascii
0B03B3 21 57 03 0B 0355*      ld hl,_printDecBuffer
0B03B7 CD 73 02 0B 0356*      call printString
0B03BB 3E 20       0357*      ld a,' '
0B03BD 5B D7       0358*      rst.lil 10h
0B03BF E1          0359*      pop hl
0B03C0 D1          0360*      pop de
0B03C1 C9          0361*      ret
0B03C2             0362*  
0B03C2             0363*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B03C2             0364*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0B03C2             0365*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B03C2             0366*  u168_to_ascii:
0B03C2             0367*  ; add a leading space to make room for sign flag if needed
0B03C2 3E 20       0368*      ld a,' '
0B03C4 12          0369*      ld (de),a
0B03C5 13          0370*      inc de
0B03C6             0371*  ; Convert integer part
0B03C6 E5          0372*      push hl               ; Save HL (well need the fractional part later)
0B03C7 CD F7 09 0B 0373*      call div_hlu_256    ; Shift to get integer portion in HL
0B03CB 01 F0 D8 FF 0374*      ld   bc, -10000
0B03CF CD F2 03 0B 0375*      call @one_int
0B03D3 01 18 FC FF 0376*      ld   bc, -1000
0B03D7 CD F2 03 0B 0377*      call @one_int
0B03DB 01 9C FF FF 0378*      ld   bc, -100
0B03DF CD F2 03 0B 0379*      call @one_int
0B03E3 0E F6       0380*      ld   c, -10
0B03E5 CD F2 03 0B 0381*      call @one_int
0B03E9 48          0382*      ld   c, b
0B03EA CD F2 03 0B 0383*      call @one_int
0B03EE C3 FD 03 0B 0384*      jp   @frac            ; Jump to fractional part conversion
0B03F2             0385*  @one_int:
0B03F2 3E 2F       0386*      ld   a, '0' - 1       ; Start ASCII character at '0'
0B03F4             0387*  @divide_me:
0B03F4 3C          0388*      inc  a
0B03F5 09          0389*      add  hl, bc           ; Accumulate until overflow
0B03F6 38 FC       0390*      jr   c, @divide_me
0B03F8 ED 42       0391*      sbc  hl, bc           ; Remove excess after overflow
0B03FA 12          0392*      ld   (de), a          ; Store ASCII digit
0B03FB 13          0393*      inc  de
0B03FC C9          0394*      ret
0B03FD             0395*  ; Convert fractional part
0B03FD             0396*  @frac:
0B03FD 3E 2E       0397*      ld   a, '.'           ; Decimal point
0B03FF 12          0398*      ld   (de), a
0B0400 13          0399*      inc  de
0B0401 E1          0400*      pop  hl               ; Restore HL with original fraction
0B0402 06 03       0401*      ld   b, 3             ; Loop counter for 3 fractional digits
0B0404             0402*  @frac_loop:
0B0404 26 0A       0403*      ld   h, 10            ; Load multiplier for fractional part
0B0406 ED 6C       0404*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B0408 3E 30       0405*      ld   a, '0'
0B040A 84          0406*      add  a, h             ; Convert integer part to ASCII
0B040B 12          0407*      ld   (de), a
0B040C 13          0408*      inc  de
0B040D 10 F5       0409*      djnz @frac_loop       ; Repeat for each fractional digit
0B040F             0410*  ; Add null terminator
0B040F AF          0411*      xor  a                ; Null terminator
0B0410 12          0412*      ld   (de), a
0B0411 C9          0413*      ret
0B0412             0414*  
0B0412             0415*  print_u168:
0B0412 D5          0416*      push de
0B0413 E5          0417*      push hl
0B0414 11 57 03 0B 0418*      ld de,_printDecBuffer
0B0418 CD C2 03 0B 0419*      call u168_to_ascii
0B041C 21 57 03 0B 0420*      ld hl,_printDecBuffer
0B0420 CD 73 02 0B 0421*      call printString
0B0424 E1          0422*      pop hl
0B0425 D1          0423*      pop de
0B0426 C9          0424*      ret
0B0427             0425*  
0B0427             0426*  ; signed version of u168_to_ascii
0B0427             0427*  s168_to_ascii:
0B0427 D5          0428*      push de ; save starting address of buffer
0B0428 CD 49 07 0B 0429*      call abs_hlu
0B042C F5          0430*      push af ; save sign flag
0B042D CD C2 03 0B 0431*      call u168_to_ascii
0B0431 F1          0432*      pop af ; restore sign flag
0B0432 D1          0433*      pop de ; restore starting address of buffer
0B0433 F0          0434*      ret p ; hlu was positive so nothing to do
0B0434 3E 2D       0435*      ld a,'-'
0B0436 12          0436*      ld (de),a
0B0437 C9          0437*      ret
0B0438             0438*  
0B0438             0439*  print_s168:
0B0438 D5          0440*      push de
0B0439 E5          0441*      push hl
0B043A 11 57 03 0B 0442*      ld de,_printDecBuffer
0B043E CD 27 04 0B 0443*      call s168_to_ascii
0B0442 21 57 03 0B 0444*      ld hl,_printDecBuffer
0B0446 CD 73 02 0B 0445*      call printString
0B044A E1          0446*      pop hl
0B044B D1          0447*      pop de
0B044C C9          0448*      ret
0B044D             0449*  
0B044D             0450*  ; #### new functions added by Brandon R. Gates ####
0B044D             0451*  
0B044D             0452*  ; print the binary representation of the 8-bit value in a
0B044D             0453*  ; destroys a, hl, bc
0B044D             0454*  printBin8:
0B044D 06 08       0455*      ld b,8      ; loop counter for 8 bits
0B044F 21 6A 04 0B 0456*      ld hl,@cmd  ; set hl to the low byte of the output string
0B0453             0457*                  ; (which will be the high bit of the value in a)
0B0453             0458*  @loop:
0B0453 07          0459*      rlca ; put the next highest bit into carry
0B0454 38 04       0460*      jr c,@one
0B0456 36 30       0461*      ld (hl),'0'
0B0458 18 02       0462*      jr @next_bit
0B045A             0463*  @one:
0B045A 36 31       0464*      ld (hl),'1'
0B045C             0465*  @next_bit:
0B045C 23          0466*      inc hl
0B045D 10 F4       0467*      djnz @loop
0B045F             0468*  ; print it
0B045F 21 6A 04 0B 0469*  	ld hl,@cmd
0B0463 01 08 00 00 0470*  	ld bc,@end-@cmd
0B0467 5B DF       0471*  	rst.lil $18
0B0469 C9          0472*  	ret
0B046A             0473*  @cmd: ds 8 ; eight bytes for eight bits
0B0472             0474*  @end:
0B0472             0475*  
0B0472             0476*  ; print the binary representation of the 8-bit value in a
0B0472             0477*  ; in reverse order (lsb first)
0B0472             0478*  ; destroys a, hl, bc
0B0472             0479*  printBin8Rev:
0B0472 06 08       0480*      ld b,8      ; loop counter for 8 bits
0B0474 21 8F 04 0B 0481*      ld hl,@cmd  ; set hl to the low byte of the output string
0B0478             0482*                  ; (which will be the high bit of the value in a)
0B0478             0483*  @loop:
0B0478 0F          0484*      rrca ; put the next lowest bit into carry
0B0479 38 04       0485*      jr c,@one
0B047B 36 30       0486*      ld (hl),'0'
0B047D 18 02       0487*      jr @next_bit
0B047F             0488*  @one:
0B047F 36 31       0489*      ld (hl),'1'
0B0481             0490*  @next_bit:
0B0481 23          0491*      inc hl
0B0482 10 F4       0492*      djnz @loop
0B0484             0493*  ; print it
0B0484 21 8F 04 0B 0494*  	ld hl,@cmd
0B0488 01 08 00 00 0495*  	ld bc,@end-@cmd
0B048C 5B DF       0496*  	rst.lil $18
0B048E C9          0497*  	ret
0B048F             0498*  @cmd: ds 8 ; eight bytes for eight bits
0B0497             0499*  @end:
0B0497             0500*  
0B0497             0501*  ; print registers to screen in hexidecimal format
0B0497             0502*  ; inputs: none
0B0497             0503*  ; outputs: values of every register printed to screen
0B0497             0504*  ;    values of each register in global scratch memory
0B0497             0505*  ; destroys: nothing
0B0497             0506*  stepRegistersHex:
0B0497             0507*  ; store everything in scratch
0B0497 22 54 06 0B 0508*      ld (uhl),hl
0B049B ED 43 57 06 0509*      ld (ubc),bc
       0B          
0B04A0 ED 53 5A 06 0510*      ld (ude),de
       0B          
0B04A5 DD 22 5D 06 0511*      ld (uix),ix
       0B          
0B04AA FD 22 60 06 0512*      ld (uiy),iy
       0B          
0B04AF F5          0513*      push af ; fml
0B04B0 E1          0514*      pop hl  ; thanks, zilog
0B04B1 22 51 06 0B 0515*      ld (uaf),hl
0B04B5 F5          0516*      push af ; dammit
0B04B6             0517*  
0B04B6             0518*  ; home the cursor
0B04B6 CD 26 14 0B 0519*      call vdu_home_cursor
0B04BA             0520*  
0B04BA             0521*  ; print each register
0B04BA 21 D7 05 0B 0522*      ld hl,str_afu
0B04BE CD 73 02 0B 0523*      call printString
0B04C2 2A 51 06 0B 0524*      ld hl,(uaf)
0B04C6 CD 93 02 0B 0525*      call printHex24
0B04CA CD 88 02 0B 0526*      call printNewLine
0B04CE             0527*  
0B04CE 21 DC 05 0B 0528*      ld hl,str_hlu
0B04D2 CD 73 02 0B 0529*      call printString
0B04D6 2A 54 06 0B 0530*      ld hl,(uhl)
0B04DA CD 93 02 0B 0531*      call printHex24
0B04DE CD 88 02 0B 0532*      call printNewLine
0B04E2             0533*  
0B04E2 21 E1 05 0B 0534*      ld hl,str_bcu
0B04E6 CD 73 02 0B 0535*      call printString
0B04EA 2A 57 06 0B 0536*      ld hl,(ubc)
0B04EE CD 93 02 0B 0537*      call printHex24
0B04F2 CD 88 02 0B 0538*      call printNewLine
0B04F6             0539*  
0B04F6 21 E6 05 0B 0540*      ld hl,str_deu
0B04FA CD 73 02 0B 0541*      call printString
0B04FE 2A 5A 06 0B 0542*      ld hl,(ude)
0B0502 CD 93 02 0B 0543*      call printHex24
0B0506 CD 88 02 0B 0544*      call printNewLine
0B050A             0545*  
0B050A 21 EB 05 0B 0546*      ld hl,str_ixu
0B050E CD 73 02 0B 0547*      call printString
0B0512 2A 5D 06 0B 0548*      ld hl,(uix)
0B0516 CD 93 02 0B 0549*      call printHex24
0B051A CD 88 02 0B 0550*      call printNewLine
0B051E             0551*  
0B051E 21 F0 05 0B 0552*      ld hl,str_iyu
0B0522 CD 73 02 0B 0553*      call printString
0B0526 2A 60 06 0B 0554*      ld hl,(uiy)
0B052A CD 93 02 0B 0555*      call printHex24
0B052E CD 88 02 0B 0556*      call printNewLine
0B0532             0557*  
0B0532             0558*      ; call vsync
0B0532             0559*  
0B0532 CD 88 02 0B 0560*      call printNewLine
0B0536             0561*  
0B0536             0562*  ; check for right shift key and quit if pressed
0B0536             0563*  	MOSCALL mos_getkbmap
0B0536 3E 1E       0001*M 			LD	A, function
0B0538 5B CF       0002*M 			RST.L	08h
0B053A             0564*  @stayhere:
0B053A             0565*  ; 7 RightShift
0B053A DD CB 00 76 0566*      bit 6,(ix+0)
0B053E 20 02       0567*      jr nz,@RightShift
0B0540 18 F8       0568*      jr @stayhere
0B0542             0569*  @RightShift:
0B0542 DD CB 0E 86 0570*      res 0,(ix+14) ; debounce the key (hopefully)
0B0546 3E 80       0571*      ld a,%10000000
0B0548 CD 06 14 0B 0572*      call multiPurposeDelay
0B054C             0573*  
0B054C             0574*  ; restore everything
0B054C 2A 54 06 0B 0575*      ld hl, (uhl)
0B0550 ED 4B 57 06 0576*      ld bc, (ubc)
       0B          
0B0555 ED 5B 5A 06 0577*      ld de, (ude)
       0B          
0B055A DD 2A 5D 06 0578*      ld ix, (uix)
       0B          
0B055F FD 2A 60 06 0579*      ld iy, (uiy)
       0B          
0B0564 F1          0580*      pop af
0B0565             0581*  ; all done
0B0565 C9          0582*      ret
0B0566             0583*  
0B0566             0584*  ; print registers to screen in hexidecimal format
0B0566             0585*  ; inputs: none
0B0566             0586*  ; outputs: values of every register printed to screen
0B0566             0587*  ;    values of each register in global scratch memory
0B0566             0588*  ; destroys: nothing
0B0566             0589*  dumpRegistersHex:
0B0566             0590*  ; store everything in scratch
0B0566 22 54 06 0B 0591*      ld (uhl),hl
0B056A ED 43 57 06 0592*      ld (ubc),bc
       0B          
0B056F ED 53 5A 06 0593*      ld (ude),de
       0B          
0B0574 DD 22 5D 06 0594*      ld (uix),ix
       0B          
0B0579 FD 22 60 06 0595*      ld (uiy),iy
       0B          
0B057E F5          0596*      push af ; fml
0B057F E1          0597*      pop hl  ; thanks, zilog
0B0580 22 51 06 0B 0598*      ld (uaf),hl
0B0584 F5          0599*      push af ; dammit
0B0585             0600*  
0B0585             0601*  ; home the cursor
0B0585             0602*      ; call vdu_home_cursor
0B0585             0603*      ; call printNewLine
0B0585             0604*  
0B0585             0605*  ; print each register
0B0585 21 D7 05 0B 0606*      ld hl,str_afu
0B0589 CD 73 02 0B 0607*      call printString
0B058D 2A 51 06 0B 0608*      ld hl,(uaf)
0B0591 CD 93 02 0B 0609*      call printHex24
0B0595             0610*      ; call printNewLine
0B0595             0611*  
0B0595 21 E6 05 0B 0612*      ld hl,str_deu
0B0599 CD 73 02 0B 0613*      call printString
0B059D 2A 5A 06 0B 0614*      ld hl,(ude)
0B05A1 CD 93 02 0B 0615*      call printHex24
0B05A5             0616*      ; call printNewLine
0B05A5             0617*  
0B05A5 21 DC 05 0B 0618*      ld hl,str_hlu
0B05A9 CD 73 02 0B 0619*      call printString
0B05AD 2A 54 06 0B 0620*      ld hl,(uhl)
0B05B1 CD 93 02 0B 0621*      call printHex24
0B05B5             0622*      ; call printNewLine
0B05B5             0623*  
0B05B5             0624*      ; ld hl,str_bcu
0B05B5             0625*      ; call printString
0B05B5             0626*      ; ld hl,(ubc)
0B05B5             0627*      ; call printHex24
0B05B5             0628*      ; ; call printNewLine
0B05B5             0629*  
0B05B5             0630*      ; ld hl,str_deu
0B05B5             0631*      ; call printString
0B05B5             0632*      ; ld hl,(ude)
0B05B5             0633*      ; call printHex24
0B05B5             0634*      ; ; call printNewLine
0B05B5             0635*  
0B05B5             0636*      ; ld hl,str_ixu
0B05B5             0637*      ; call printString
0B05B5             0638*      ; ld hl,(uix)
0B05B5             0639*      ; call printHex24
0B05B5             0640*      ; ; call printNewLine
0B05B5             0641*  
0B05B5             0642*      ; ld hl,str_iyu
0B05B5             0643*      ; call printString
0B05B5             0644*      ; ld hl,(uiy)
0B05B5             0645*      ; call printHex24
0B05B5             0646*      ; ; call printNewLine
0B05B5             0647*  
0B05B5 CD BB 14 0B 0648*      call vdu_vblank
0B05B9             0649*  
0B05B9 CD 88 02 0B 0650*      call printNewLine
0B05BD             0651*  ; restore everything
0B05BD 2A 54 06 0B 0652*      ld hl, (uhl)
0B05C1 ED 4B 57 06 0653*      ld bc, (ubc)
       0B          
0B05C6 ED 5B 5A 06 0654*      ld de, (ude)
       0B          
0B05CB DD 2A 5D 06 0655*      ld ix, (uix)
       0B          
0B05D0 FD 2A 60 06 0656*      ld iy, (uiy)
       0B          
0B05D5 F1          0657*      pop af
0B05D6             0658*  ; all done
0B05D6 C9          0659*      ret
0B05D7             0660*  
0B05D7 20 61 66 3D 0661*  str_afu: db " af=",0
       00          
0B05DC 20 68 6C 3D 0662*  str_hlu: db " hl=",0
       00          
0B05E1 20 62 63 3D 0663*  str_bcu: db " bc=",0
       00          
0B05E6 20 64 65 3D 0664*  str_deu: db " de=",0
       00          
0B05EB 20 69 78 3D 0665*  str_ixu: db " ix=",0
       00          
0B05F0 20 69 79 3D 0666*  str_iyu: db " iy=",0
       00          
0B05F5             0667*  
0B05F5             0668*  ; print udeuhl to screen in hexidecimal format
0B05F5             0669*  ; inputs: none
0B05F5             0670*  ; outputs: concatenated hexidecimal udeuhl
0B05F5             0671*  ; destroys: nothing
0B05F5             0672*  dumpUDEUHLHex:
0B05F5             0673*  ; store everything in scratch
0B05F5 22 54 06 0B 0674*      ld (uhl),hl
0B05F9 ED 43 57 06 0675*      ld (ubc),bc
       0B          
0B05FE ED 53 5A 06 0676*      ld (ude),de
       0B          
0B0603 DD 22 5D 06 0677*      ld (uix),ix
       0B          
0B0608 FD 22 60 06 0678*      ld (uiy),iy
       0B          
0B060D F5          0679*      push af
0B060E             0680*  
0B060E             0681*  ; print each register
0B060E             0682*  
0B060E 21 48 06 0B 0683*      ld hl,str_udeuhl
0B0612 CD 73 02 0B 0684*      call printString
0B0616 2A 5A 06 0B 0685*      ld hl,(ude)
0B061A CD 93 02 0B 0686*      call printHex24
0B061E 3E 2E       0687*  	ld a,'.'	; print a dot to separate the values
0B0620 5B D7       0688*  	rst.lil 10h
0B0622 2A 54 06 0B 0689*      ld hl,(uhl)
0B0626 CD 93 02 0B 0690*      call printHex24
0B062A CD 88 02 0B 0691*      call printNewLine
0B062E             0692*  
0B062E             0693*  ; restore everything
0B062E 2A 54 06 0B 0694*      ld hl, (uhl)
0B0632 ED 4B 57 06 0695*      ld bc, (ubc)
       0B          
0B0637 ED 5B 5A 06 0696*      ld de, (ude)
       0B          
0B063C DD 2A 5D 06 0697*      ld ix, (uix)
       0B          
0B0641 FD 2A 60 06 0698*      ld iy, (uiy)
       0B          
0B0646 F1          0699*      pop af
0B0647             0700*  ; all done
0B0647 C9          0701*      ret
0B0648             0702*  
0B0648 75 64 65 2E 0703*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0B0651             0704*  
0B0651             0705*  ; global scratch memory for registers
0B0651 00 00 00    0706*  uaf: dl 0
0B0654 00 00 00    0707*  uhl: dl 0
0B0657 00 00 00    0708*  ubc: dl 0
0B065A 00 00 00    0709*  ude: dl 0
0B065D 00 00 00    0710*  uix: dl 0
0B0660 00 00 00    0711*  uiy: dl 0
0B0663 00 00 00    0712*  usp: dl 0
0B0666 00 00 00    0713*  upc: dl 0
0B0669             0714*  
0B0669             0715*  ; inputs: whatever is in the flags register
0B0669             0716*  ; outputs: binary representation of flags
0B0669             0717*  ;          with a header so we know which is what
0B0669             0718*  ; destroys: nothing
0B0669             0719*  ; preserves: everything
0B0669             0720*  dumpFlags:
0B0669             0721*  ; first we curse zilog for not giving direct access to flags
0B0669 F5          0722*      push af ; this is so we can send it back unharmed
0B066A F5          0723*      push af ; this is so we can pop it to hl
0B066B             0724*  ; store everything in scratch
0B066B 22 54 06 0B 0725*      ld (uhl),hl
0B066F ED 43 57 06 0726*      ld (ubc),bc
       0B          
0B0674 ED 53 5A 06 0727*      ld (ude),de
       0B          
0B0679 DD 22 5D 06 0728*      ld (uix),ix
       0B          
0B067E FD 22 60 06 0729*      ld (uiy),iy
       0B          
0B0683             0730*  ; next we print the header
0B0683 21 AF 06 0B 0731*      ld hl,@header
0B0687 CD 73 02 0B 0732*      call printString
0B068B E1          0733*      pop hl ; flags are now in l
0B068C 7D          0734*      ld a,l ; flags are now in a
0B068D CD 4D 04 0B 0735*      call printBin8
0B0691 CD 88 02 0B 0736*  	call printNewLine
0B0695             0737*  ; restore everything
0B0695 2A 54 06 0B 0738*      ld hl, (uhl)
0B0699 ED 4B 57 06 0739*      ld bc, (ubc)
       0B          
0B069E ED 5B 5A 06 0740*      ld de, (ude)
       0B          
0B06A3 DD 2A 5D 06 0741*      ld ix, (uix)
       0B          
0B06A8 FD 2A 60 06 0742*      ld iy, (uiy)
       0B          
0B06AD F1          0743*      pop af ; send her home the way she came
0B06AE C9          0744*      ret
0B06AF             0745*  ; Bit 7 (S): Sign flag
0B06AF             0746*  ; Bit 6 (Z): Zero flag
0B06AF             0747*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0B06AF             0748*  ; Bit 4 (H): Half Carry flag
0B06AF             0749*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0B06AF             0750*  ; Bit 2 (PV): Parity/Overflow flag
0B06AF             0751*  ; Bit 1 (N): Subtract flag
0B06AF             0752*  ; Bit 0 (C): Carry flag
0B06AF 53 5A 78 48 0753*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0B06BA             0754*  
0B06BA             0755*  ; set all the bits in the flag register
0B06BA             0756*  ; more of an academic exercise than anything useful
0B06BA             0757*  ; inputs; none
0B06BA             0758*  ; outputs; a=0,f=255
0B06BA             0759*  ; destroys: flags, hl
0B06BA             0760*  ; preserves: a, because why not
0B06BA             0761*  setAllFlags:
0B06BA 21 FF 00 00 0762*      ld hl,255
0B06BE 67          0763*      ld h,a ; four cycles to preserve a is cheap
0B06BF E5          0764*      push hl
0B06C0 F1          0765*      pop af
0B06C1 C9          0766*      ret
0B06C2             0767*  
0B06C2             0768*  ; reset all the bits in the flag register
0B06C2             0769*  ; unlike its inverse counterpart, this may actually be useful
0B06C2             0770*  ; inputs; none
0B06C2             0771*  ; outputs; a=0,f=0
0B06C2             0772*  ; destroys: flags, hl
0B06C2             0773*  ; preserves: a, because why not
0B06C2             0774*  resetAllFlags:
0B06C2 21 00 00 00 0775*      ld hl,0
0B06C6 67          0776*      ld h,a ; four cycles to preserve a is cheap
0B06C7 E5          0777*      push hl
0B06C8 F1          0778*      pop af
0B06C9 C9          0779*      ret
0B06CA             0780*  
0B06CA             0781*  ; wait until user presses a key
0B06CA             0782*  ; inputs: none
0B06CA             0783*  ; outputs: none
0B06CA             0784*  ; destroys: af,ix
0B06CA             0785*  waitKeypress:
0B06CA             0786*      MOSCALL mos_sysvars
0B06CA 3E 08       0001*M 			LD	A, function
0B06CC 5B CF       0002*M 			RST.L	08h
0B06CE AF          0787*      xor a ; zero out any prior keypresses
0B06CF DD 77 05    0788*      ld (ix+sysvar_keyascii),a
0B06D2             0789*  @loop:
0B06D2 DD 7E 05    0790*      ld a,(ix+sysvar_keyascii)
0B06D5 A7          0791*      and a
0B06D6 C0          0792*      ret nz
0B06D7 18 F9       0793*      jr @loop
0B06D9             0794*  
0B06D9             0795*  
0B06D9             0796*  ; print bytes from an address to the screen in hexidecimal format
0B06D9             0797*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B06D9             0798*  ; outputs: values of each byte printed to screen separated by spaces
0B06D9             0799*  ; destroys: nothing
0B06D9             0800*  dumpMemoryHex:
0B06D9             0801*  ; save registers to the stack
0B06D9 C5          0802*      push bc
0B06DA E5          0803*      push hl
0B06DB F5          0804*      push af
0B06DC             0805*  
0B06DC             0806*  ; print the address and separator
0B06DC CD 93 02 0B 0807*      call printHex24
0B06E0 3E 3A       0808*      ld a,':'
0B06E2 5B D7       0809*      rst.lil 10h
0B06E4 3E 20       0810*      ld a,' '
0B06E6 5B D7       0811*      rst.lil 10h
0B06E8             0812*  
0B06E8             0813*  ; set b to be our loop counter
0B06E8 F1          0814*      pop af
0B06E9 47          0815*      ld b,a
0B06EA E1          0816*      pop hl
0B06EB E5          0817*      push hl
0B06EC F5          0818*      push af
0B06ED             0819*  @loop:
0B06ED             0820*  ; print the byte
0B06ED 7E          0821*      ld a,(hl)
0B06EE CD A1 02 0B 0822*      call printHex8
0B06F2             0823*  ; print a space
0B06F2 3E 20       0824*      ld a,' '
0B06F4 5B D7       0825*      rst.lil 10h
0B06F6 23          0826*      inc hl
0B06F7 10 F4       0827*      djnz @loop
0B06F9             0828*      ; call printNewLine
0B06F9             0829*  
0B06F9             0830*  ; restore everything
0B06F9 F1          0831*      pop af
0B06FA E1          0832*      pop hl
0B06FB C1          0833*      pop bc
0B06FC             0834*  
0B06FC             0835*  ; all done
0B06FC C9          0836*      ret
0B06FD             0837*  
0B06FD             0838*  
0B06FD             0839*  ; print bytes from an address to the screen in binary format
0B06FD             0840*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B06FD             0841*  ; outputs: values of each byte printed to screen separated by spaces
0B06FD             0842*  ; destroys: nothing
0B06FD             0843*  dumpMemoryBin:
0B06FD             0844*  ; save all registers to the stack
0B06FD F5          0845*      push af
0B06FE C5          0846*      push bc
0B06FF D5          0847*      push de
0B0700 E5          0848*      push hl
0B0701 DD E5       0849*      push ix
0B0703 FD E5       0850*      push iy
0B0705             0851*  
0B0705             0852*  ; set b to be our loop counter
0B0705 47          0853*      ld b,a
0B0706             0854*  @loop:
0B0706             0855*  ; print the byte
0B0706 7E          0856*      ld a,(hl)
0B0707 E5          0857*      push hl
0B0708 C5          0858*      push bc
0B0709 CD 4D 04 0B 0859*      call printBin8
0B070D C1          0860*      pop bc
0B070E             0861*  ; print a space
0B070E 3E 20       0862*      ld a,' '
0B0710 5B D7       0863*      rst.lil 10h
0B0712 E1          0864*      pop hl
0B0713 23          0865*      inc hl
0B0714 10 F0       0866*      djnz @loop
0B0716 CD 88 02 0B 0867*      call printNewLine
0B071A             0868*  
0B071A             0869*  ; restore everything
0B071A FD E1       0870*      pop iy
0B071C DD E1       0871*      pop ix
0B071E E1          0872*      pop hl
0B071F D1          0873*      pop de
0B0720 C1          0874*      pop bc
0B0721 F1          0875*      pop af
0B0722             0876*  ; all done
0B0722 C9          0877*      ret
0B0723             0878*  
0B0723             0879*  ; print bytes from an address to the screen in binary format
0B0723             0880*  ; with the bits of each byte in reverse order (lsb first)
0B0723             0881*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B0723             0882*  ; outputs: values of each byte printed to screen separated by spaces
0B0723             0883*  ; destroys: nothing
0B0723             0884*  dumpMemoryBinRev:
0B0723             0885*  ; save all registers to the stack
0B0723 F5          0886*      push af
0B0724 C5          0887*      push bc
0B0725 D5          0888*      push de
0B0726 E5          0889*      push hl
0B0727 DD E5       0890*      push ix
0B0729 FD E5       0891*      push iy
0B072B             0892*  
0B072B             0893*  ; set b to be our loop counter
0B072B 47          0894*      ld b,a
0B072C             0895*  @loop:
0B072C             0896*  ; print the byte
0B072C 7E          0897*      ld a,(hl)
0B072D E5          0898*      push hl
0B072E C5          0899*      push bc
0B072F CD 72 04 0B 0900*      call printBin8Rev
0B0733 C1          0901*      pop bc
0B0734             0902*  ; print a space
0B0734 3E 20       0903*      ld a,' '
0B0736 5B D7       0904*      rst.lil 10h
0B0738 E1          0905*      pop hl
0B0739 23          0906*      inc hl
0B073A 10 F0       0907*      djnz @loop
0B073C CD 88 02 0B 0908*      call printNewLine
0B0740             0909*  
0B0740             0910*  ; restore everything
0B0740 FD E1       0911*      pop iy
0B0742 DD E1       0912*      pop ix
0B0744 E1          0913*      pop hl
0B0745 D1          0914*      pop de
0B0746 C1          0915*      pop bc
0B0747 F1          0916*      pop af
0B0748             0917*  ; all done
0B0748 C9          0918*      ret
0B0749             0020       include "maths.inc"
0B0749             0001*  ; absolute value of hlu
0B0749             0002*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B0749             0003*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0B0749             0004*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0B0749             0005*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0B0749             0006*  ; destroys: a
0B0749             0007*  abs_hlu:
0B0749 19          0008*      add hl,de
0B074A B7          0009*      or a
0B074B ED 52       0010*      sbc hl,de
0B074D FA 52 07 0B 0011*      jp m,@is_neg
0B0751 C9          0012*      ret         ; hlu is positive or zero so we're done
0B0752             0013*  @is_neg:
0B0752 F5          0014*      push af     ; otherwise, save current flags for return
0B0753 CD 59 07 0B 0015*      call neg_hlu ; negate hlu
0B0757 F1          0016*      pop af      ; get back flags
0B0758 C9          0017*      ret
0B0759             0018*  
0B0759             0019*  ; flip the sign of hlu
0B0759             0020*  ; inputs: hlu
0B0759             0021*  ; returns: 0-hlu, flags set appropriately for the result:
0B0759             0022*  ;         s1,z0,pv0,n1,c1 if result is negative
0B0759             0023*  ;         s0,z1,pv0,n1,c0 if result is zero
0B0759             0024*  ;         s0,z0,pv0,n1,c1 if result is positive
0B0759             0025*  ; destroys a
0B0759             0026*  neg_hlu:
0B0759 D5          0027*      push de     ; save de
0B075A EB          0028*      ex de,hl    ; put hl into de
0B075B 21 00 00 00 0029*      ld hl,0     ; clear hl
0B075F AF          0030*      xor a       ; clear carry
0B0760 ED 52       0031*      sbc hl,de   ; 0-hlu = -hlu
0B0762 D1          0032*      pop de      ; get de back
0B0763 C9          0033*      ret         ; easy peasy
0B0764             0034*  
0B0764             0035*  ;------------------------------------------------------------------------
0B0764             0036*  ; divide hlu by 2, inspired by above
0B0764             0037*  ;------------------------------------------------------------------------
0B0764             0038*  hlu_div2:
0B0764 22 F1 09 0B 0039*  	ld		(bitbuf1),hl
0B0768 21 F3 09 0B 0040*  	ld		hl,bitbuf1+2
0B076C CB 1E       0041*  	rr		(hl)
0B076E 2B          0042*  	dec		hl
0B076F CB 1E       0043*  	rr		(hl)
0B0771 2B          0044*  	dec		hl
0B0772 CB 1E       0045*  	rr		(hl)
0B0774 23          0046*  	inc		hl
0B0775 23          0047*  	inc		hl
0B0776 2A F1 09 0B 0048*      ld hl,(bitbuf1)
0B077A C9          0049*      ret
0B077B             0050*  
0B077B             0051*  ; this is my little hack to divide by 16
0B077B             0052*  hlu_div16:
0B077B AF          0053*      xor a
0B077C 29          0054*      add hl,hl
0B077D 17          0055*      rla
0B077E 29          0056*      add hl,hl
0B077F 17          0057*      rla
0B0780 29          0058*      add hl,hl
0B0781 17          0059*      rla
0B0782 29          0060*      add hl,hl
0B0783 17          0061*      rla
0B0784 22 91 07 0B 0062*      ld (@scratch),hl
0B0788 32 94 07 0B 0063*      ld (@scratch+3),a
0B078C 2A 92 07 0B 0064*      ld hl,(@scratch+1)
0B0790 C9          0065*      ret
0B0791             0066*  @scratch: ds 4
0B0795             0067*  
0B0795             0068*  
0B0795 00 00 00 00 0069*  add_bcd_arg1: db #00,#00,#00,#00
0B0799 00 00 00 00 0070*  add_bcd_arg2: db #00,#00,#00,#00
0B079D             0071*  
0B079D             0072*  ; set bcd values in a scratch memory address from registers bcde
0B079D             0073*  ; input: hl; scratch address,bcde; 8-place bcd number
0B079D             0074*  ; destroys ; hl
0B079D             0075*  set_bcd:
0B079D 73          0076*      ld (hl),e
0B079E 23          0077*      inc hl
0B079F 72          0078*      ld (hl),d
0B07A0 23          0079*      inc hl
0B07A1 71          0080*      ld (hl),c
0B07A2 23          0081*      inc hl
0B07A3 70          0082*      ld (hl),b
0B07A4 C9          0083*      ret
0B07A5             0084*  
0B07A5             0085*  ; load bcd values from a scratch memory address to bcde
0B07A5             0086*  ; input: hl; scratch address
0B07A5             0087*  ; output: bcde; 8-place bcd number
0B07A5             0088*  ; destroys: hl
0B07A5             0089*  get_bcd:
0B07A5 5E          0090*      ld e,(hl)
0B07A6 23          0091*      inc hl
0B07A7 56          0092*      ld d,(hl)
0B07A8 23          0093*      inc hl
0B07A9 4E          0094*      ld c,(hl)
0B07AA 23          0095*      inc hl
0B07AB 46          0096*      ld b,(hl)
0B07AC C9          0097*      ret
0B07AD             0098*  
0B07AD             0099*  ; BCD addition
0B07AD             0100*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B07AD             0101*  ;       a is the number of bytes holding each number (number of places/2)
0B07AD             0102*  ; outputs: (hl) + (de) --> (hl)
0B07AD             0103*  ; destroys: a,b,de,hl
0B07AD             0104*  add_bcd:
0B07AD 47          0105*      ld b,a ; loop counter
0B07AE AF          0106*      xor a ; reset a, clear carry flag
0B07AF             0107*  adcec:
0B07AF 1A          0108*      ld a,(de) ; addend to acc
0B07B0 8E          0109*      adc a,(hl) ; add (hl) to acc
0B07B1 27          0110*      daa ; adjust result to bcd
0B07B2 77          0111*      ld (hl),a ; store result
0B07B3 23          0112*      inc hl ; advance memory pointers
0B07B4 13          0113*      inc de
0B07B5 10 F8       0114*      djnz adcec ; loop until b == 0
0B07B7 C9          0115*      ret
0B07B8             0116*  
0B07B8             0117*  ; BCD subtraction
0B07B8             0118*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B07B8             0119*  ;       a is the number of bytes holding each number (number of places/2)
0B07B8             0120*  ; outputs: (hl) - (de) --> (hl)
0B07B8             0121*  ; destroys: a,b,de,hl
0B07B8             0122*  sub_bcd:
0B07B8 47          0123*      ld b,a ; loop counter
0B07B9 AF          0124*      xor a ; reset a,clear carry flag
0B07BA             0125*  subdec:
0B07BA 1A          0126*      ld a,(de) ; subtrahend to acc
0B07BB 9E          0127*      sbc a,(hl) ; subtract (hl) from acc
0B07BC 27          0128*      daa ; adjust result to bcd
0B07BD 77          0129*      ld (hl),a ; store result
0B07BE 23          0130*      inc hl ; advance memory pointers
0B07BF 13          0131*      inc de
0B07C0 10 F8       0132*      djnz subdec ; loop until b == 0
0B07C2 C9          0133*      ret
0B07C3             0134*  
0B07C3             0135*  ; http://www.z80.info/pseudo-random.txt
0B07C3             0136*  rand_8:
0B07C3 C5          0137*      push bc
0B07C4 3A D7 07 0B 0138*      ld a,(r_seed)
0B07C8 4F          0139*      ld c,a
0B07C9             0140*  
0B07C9 0F          0141*      rrca ; multiply by 32
0B07CA 0F          0142*      rrca
0B07CB 0F          0143*      rrca
0B07CC EE 1F       0144*      xor 0x1f
0B07CE             0145*  
0B07CE 81          0146*      add a,c
0B07CF DE FF       0147*      sbc a,255 ; carry
0B07D1             0148*  
0B07D1 32 D7 07 0B 0149*      ld (r_seed),a
0B07D5 C1          0150*      pop bc
0B07D6 C9          0151*      ret
0B07D7 50          0152*  r_seed: defb $50
0B07D8             0153*  
0B07D8             0154*  
0B07D8             0021   	INCLUDE	"arith24.inc"
0B07D8             0001*  arith24uaf: ds 6
0B07DE             0002*  arith24uhl: ds 6
0B07E4             0003*  arith24ubc: ds 6
0B07EA             0004*  arith24ude: ds 6
0B07F0             0005*  arith24uix: ds 6
0B07F6             0006*  arith24uiy: ds 6
0B07FC             0007*  arith24usp: ds 6
0B0802             0008*  arith24upc: ds 6
0B0808             0009*  
0B0808             0010*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0B0808             0011*  ; uses EZ80 MLT instruction for speed
0B0808             0012*  ; operation: UHL * A --> AUHL
0B0808             0013*  ; destroys: AF, HL
0B0808             0014*  umul24x8:
0B0808 D5          0015*  	push de ; preserve de
0B0809             0016*  ; low byte
0B0809 5D          0017*  	ld e,l
0B080A 57          0018*  	ld d,a
0B080B ED 5C       0019*  	mlt de
0B080D 6B          0020*  	ld l,e ; product low byte
0B080E 08          0021*  	ex af,af' ; save multiplier
0B080F 7A          0022*  	ld a,d ; carry
0B0810 08          0023*  	ex af,af' ; save carry, restore multiplier
0B0811             0024*  ; high byte
0B0811 5C          0025*  	ld e,h
0B0812 57          0026*  	ld d,a
0B0813 ED 5C       0027*  	mlt de
0B0815 08          0028*  	ex af,af' ; save multiplier, restore carry
0B0816 83          0029*  	add a,e ; add carry
0B0817 67          0030*  	ld h,a ; product middle byte
0B0818 7A          0031*  	ld a,d ; carry
0B0819 08          0032*  	ex af,af' ; save carry, restore multiplier
0B081A             0033*  ; upper byte
0B081A E5          0034*  	push hl
0B081B 33          0035*  	inc sp
0B081C D1          0036*  	pop de ; d = hlu
0B081D 3B          0037*  	dec sp
0B081E 5F          0038*  	ld e,a
0B081F ED 5C       0039*  	mlt de
0B0821 08          0040*  	ex af,af' ; restore carry
0B0822 8B          0041*  	adc a,e ; add carry
0B0823 22 34 08 0B 0042*      ld (@scratch),hl ; 7 cycles
0B0827 32 36 08 0B 0043*      ld (@scratch+2),a ; 5 cycles
0B082B 2A 34 08 0B 0044*      ld hl,(@scratch) ; 7 cycles
0B082F             0045*  ; highest byte
0B082F 3E 00       0046*  	ld a,0 ; preserve carry flag
0B0831 8A          0047*  	adc a,d ; product highest byte
0B0832 D1          0048*  	pop de ; restore de
0B0833 C9          0049*  	ret
0B0834             0050*  @scratch: ds 3
0B0837             0051*  
0B0837             0052*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0B0837             0053*  ; operation: UHL * UDE --> umul24x24out
0B0837             0054*  umul24x24:
0B0837 FD 21 8F 08 0055*  	ld iy,umul24x24out ; point to output buffer
       0B          
0B083C C5          0056*  	push bc
0B083D 01 00 00 00 0057*  	ld bc,0
0B0841 FD 0F 00    0058*  	ld (iy),bc
0B0844 FD 0F 03    0059*  	ld (iy+3),bc
0B0847 C1          0060*  	pop bc
0B0848             0061*  
0B0848             0062*  ; STEP 1: UHL * E
0B0848 7B          0063*  	ld a,e
0B0849 E5          0064*  	push hl
0B084A CD 08 08 0B 0065*  	call umul24x8
0B084E FD 2F 00    0066*  	ld (iy+0),hl
0B0851 FD 77 03    0067*  	ld (iy+3),a
0B0854             0068*  
0B0854             0069*  ; STEP 2: UHL * D
0B0854 E1          0070*  	pop hl
0B0855 E5          0071*  	push hl
0B0856 7A          0072*  	ld a,d
0B0857 CD 08 08 0B 0073*  	call umul24x8
0B085B CD 68 08 0B 0074*  	call @accumulate
0B085F             0075*  
0B085F             0076*  ; STEP 3: UHL * DEU
0B085F E1          0077*  	pop hl
0B0860 D5          0078*  	push de
0B0861 33          0079*  	inc sp
0B0862 F1          0080*  	pop af
0B0863 3B          0081*  	dec sp
0B0864 CD 08 08 0B 0082*  	call umul24x8
0B0868             0083*  
0B0868             0084*  @accumulate:
0B0868 FD 23       0085*  	inc iy
0B086A             0086*  ; highest byte of product to carry
0B086A FD 77 03    0087*  	ld (iy+3),a
0B086D             0088*  ; low byte of product
0B086D 7D          0089*  	ld a,l
0B086E FD 86 00    0090*  	add a,(iy+0)
0B0871 FD 77 00    0091*  	ld (iy+0),a
0B0874             0092*  ; high byte of product
0B0874 7C          0093*  	ld a,h
0B0875 FD 8E 01    0094*  	adc a,(iy+1)
0B0878 FD 77 01    0095*  	ld (iy+1),a
0B087B             0096*  ; uppper byte of product
0B087B E5          0097*  	push hl
0B087C 33          0098*  	inc sp
0B087D E1          0099*  	pop hl
0B087E 3B          0100*  	dec sp
0B087F 7C          0101*  	ld a,h
0B0880 FD 8E 02    0102*  	adc a,(iy+2)
0B0883 FD 77 02    0103*  	ld (iy+2),a
0B0886             0104*  ; carry
0B0886 3E 00       0105*  	ld a,0 ; preserve flags
0B0888 FD 8E 03    0106*  	adc a,(iy+3)
0B088B FD 77 03    0107*  	ld (iy+3),a
0B088E C9          0108*  	ret
0B088F             0109*  umul24x24out: ds 6 ; output buffer
0B0895             0110*  
0B0895             0111*  ; umul168:	UH.L = UH.L*UD.E (unsigned)
0B0895             0112*  umul168:
0B0895 CD 37 08 0B 0113*  	call umul24x24
0B0899 FD 27 FF    0114*  	ld hl,(iy-1)
0B089C C9          0115*  	ret
0B089D             0116*  
0B089D             0117*  ; smul168:	UH.L * UD.E --> UH.L (signed)
0B089D             0118*  smul168:
0B089D             0119*  ; make everything positive and store sign flags
0B089D CD 49 07 0B 0120*  	call abs_hlu
0B08A1 F5          0121*  	push af
0B08A2 EB          0122*  	ex de,hl
0B08A3 CD 49 07 0B 0123*  	call abs_hlu
0B08A7 EB          0124*  	ex de,hl
0B08A8 F5          0125*  	push af
0B08A9             0126*  ; do the division
0B08A9 CD 95 08 0B 0127*      call umul168 ; hl = product
0B08AD             0128*  ; adjust sign of result
0B08AD F1          0129*  	pop af ; sign de
0B08AE FA B9 08 0B 0130*  	jp m,@de_neg
0B08B2 F1          0131*  	pop af ; sign hl
0B08B3 F0          0132*  	ret p ; both positive, nothing to do
0B08B4             0133*  @hl_neg:
0B08B4 CD 59 07 0B 0134*      call neg_hlu ; de pos, hl neg, result is negative
0B08B8 C9          0135*      ret
0B08B9             0136*  @de_neg:
0B08B9 F1          0137*  	pop af
0B08BA F8          0138*  	ret m ; both negative, nothing to do
0B08BB CD 59 07 0B 0139*  	call neg_hlu ; result is negative
0B08BF C9          0140*  	ret
0B08C0             0141*  
0B08C0             0142*  ;------------------------------------------------------------------------
0B08C0             0143*  ;  arith24.inc
0B08C0             0144*  ;  24-bit ez80 arithmetic routines
0B08C0             0145*  ;  Copyright (c) Shawn Sijnstra 2024
0B08C0             0146*  ;  MIT license
0B08C0             0147*  ;
0B08C0             0148*  ;  This library was created as a tool to help make ez80
0B08C0             0149*  ;  24-bit native assembly routines for simple mathematical problems
0B08C0             0150*  ;  more widely available.
0B08C0             0151*  ;
0B08C0             0152*  ;------------------------------------------------------------------------
0B08C0             0153*  
0B08C0             0154*  ;------------------------------------------------------------------------
0B08C0             0155*  ; umul24:	HL = HL*DE (unsigned)
0B08C0             0156*  ; Preserves AF, BC, DE
0B08C0             0157*  ; Uses a fast multiply routine.
0B08C0             0158*  ;------------------------------------------------------------------------
0B08C0             0159*  umul24:
0B08C0 D5          0160*  	push	DE
0B08C1 C5          0161*  	push	BC
0B08C2 F5          0162*  	push	AF
0B08C3 E5          0163*  	push	HL
0B08C4 C1          0164*  	pop		BC
0B08C5 3E 18       0165*      ld	 	a, 24 ; No. of bits to process
0B08C7 21 00 00 00 0166*      ld	 	hl, 0 ; Result
0B08CB             0167*  umul24_lp:
0B08CB 29          0168*  	add	hl,hl
0B08CC EB          0169*  	ex	de,hl
0B08CD 29          0170*  	add	hl,hl
0B08CE EB          0171*  	ex	de,hl
0B08CF 30 01       0172*  	jr	nc,umul24_nc
0B08D1 09          0173*  	add	hl,bc
0B08D2             0174*  umul24_nc:
0B08D2 3D          0175*  	dec	a
0B08D3 20 F6       0176*  	jr	nz,umul24_lp
0B08D5 F1          0177*  	pop	af
0B08D6 C1          0178*  	pop	bc
0B08D7 D1          0179*  	pop	de
0B08D8 C9          0180*  	ret
0B08D9             0181*  
0B08D9             0182*  ;------------------------------------------------------------------------
0B08D9             0183*  ; udiv24
0B08D9             0184*  ; Unsigned 24-bit division
0B08D9             0185*  ; HLU / DEU --> DEU rem HLU
0B08D9             0186*  ; Uses AF BC DE HL
0B08D9             0187*  ; Uses Restoring Division algorithm
0B08D9             0188*  ;------------------------------------------------------------------------
0B08D9             0189*  
0B08D9             0190*  udiv24:
0B08D9 E5          0191*  	push	hl
0B08DA C1          0192*  	pop		bc	;move dividend to BCU
0B08DB 21 00 00 00 0193*  	ld		hl,0	;result
0B08DF A7          0194*  	and		a
0B08E0 ED 52       0195*  	sbc		hl,de	;test for div by 0
0B08E2 C8          0196*  	ret		z		;it's zero, carry flag is clear
0B08E3 19          0197*  	add		hl,de	;HL is 0 again
0B08E4 3E 18       0198*  	ld		a,24	;number of loops through.
0B08E6             0199*  udiv1:
0B08E6 C5          0200*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B08E7 E3          0201*  	ex		(sp),hl
0B08E8 37          0202*  	scf
0B08E9 ED 6A       0203*  	adc	hl,hl
0B08EB E3          0204*  	ex	(sp),hl
0B08EC C1          0205*  	pop	bc		;we now have bc = (bc * 2) + 1
0B08ED             0206*  
0B08ED ED 6A       0207*  	adc	hl,hl
0B08EF A7          0208*  	and	a		;is this the bug
0B08F0 ED 52       0209*  	sbc	hl,de
0B08F2 30 02       0210*  	jr	nc,udiv2
0B08F4 19          0211*  	add	hl,de
0B08F5             0212*  ;	dec	c
0B08F5 0B          0213*  	dec	bc
0B08F6             0214*  udiv2:
0B08F6 3D          0215*  	dec	a
0B08F7 20 ED       0216*  	jr	nz,udiv1
0B08F9 37          0217*  	scf		;flag used for div0 error
0B08FA C5          0218*  	push	bc
0B08FB D1          0219*  	pop		de	;remainder
0B08FC C9          0220*  	ret
0B08FD             0221*  
0B08FD             0222*  
0B08FD             0223*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0B08FD             0224*  ; perform unsigned division of 16.8 fixed place values
0B08FD             0225*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
0B08FD             0226*  udiv168:
0B08FD             0227*  ; back up divisor
0B08FD D5          0228*      push de
0B08FE             0229*  ; get the 16-bit integer part of the quotient
0B08FE CD D9 08 0B 0230*      call udiv24 ; de = quotient, hl = remainder
0B0902             0231*  ; load quotient to upper three bytes of output
0B0902 ED 53 31 09 0232*      ld (div168_out+1),de
       0B          
0B0907             0233*  @div256:
0B0907             0234*  ; divide divisor by 256
0B0907 EB          0235*      ex de,hl ; hl = quotient, de = remainder
0B0908 E1          0236*      pop hl ; hl = divisor (was de), de = remainder
0B0909 CD F7 09 0B 0237*      call div_hlu_256 ; hl = divisor / 256, de = remainder
0B090D EB          0238*      ex de,hl ; hl = remainder, de = divisor / 256
0B090E             0239*  ; skip fractional computation if remainder is zero
0B090E             0240*      sign_hlu
0B090E 19          0001*M         add hl,de
0B090F B7          0002*M         or a
0B0910 ED 52       0003*M         sbc hl,de
0B0912 20 03       0241*      jr nz,@div_frac
0B0914 AF          0242*      xor a
0B0915 18 05       0243*      jr @write_frac
0B0917             0244*  ; now divide the remainder by the shifted divisor
0B0917             0245*  @div_frac:
0B0917 CD D9 08 0B 0246*      call udiv24 ; de = quotient, hl = remainder
0B091B             0247*  ; load low byte of quotient to low byte of output
0B091B 7B          0248*      ld a,e
0B091C             0249*  @write_frac:
0B091C 32 30 09 0B 0250*      ld (div168_out),a
0B0920             0251*  ; load de with return value
0B0920 ED 5B 30 09 0252*      ld de,(div168_out)
       0B          
0B0925             0253*  ; load a with any overflow
0B0925 3A 33 09 0B 0254*      ld a,(div168_out+3)
0B0929 C9          0255*      ret ; ud.e is the 16.8 result
0B092A             0256*  @ude: ds 6
0B0930             0257*  div168_out: ds 4 ; the extra byte is for overflow
0B0934             0258*  
0B0934             0259*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0B0934             0260*  ; perform signed division of 16.8 fixed place values
0B0934             0261*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0B0934             0262*  sdiv168:
0B0934             0263*  ; make everything positive and store sign flags
0B0934 CD 49 07 0B 0264*  	call abs_hlu
0B0938 F5          0265*  	push af
0B0939 EB          0266*  	ex de,hl
0B093A CD 49 07 0B 0267*  	call abs_hlu
0B093E EB          0268*  	ex de,hl
0B093F F5          0269*  	push af
0B0940             0270*  ; do the division
0B0940 CD FD 08 0B 0271*      call udiv168 ; de = quotient, hl = remainder
0B0944             0272*  ; adjust sign of result
0B0944 F1          0273*  	pop af ; sign de
0B0945 FA 52 09 0B 0274*  	jp m,@de_neg
0B0949 F1          0275*  	pop af ; sign hl
0B094A F0          0276*  	ret p ; both positive, nothing to do
0B094B             0277*  @hl_neg:
0B094B EB          0278*      ex de,hl ; hl = quotient, de = remainder
0B094C CD 59 07 0B 0279*      call neg_hlu ; de pos, hl neg, result is negative
0B0950 EB          0280*      ex de,hl ; de = negated quotient, hl = remainder
0B0951 C9          0281*      ret
0B0952             0282*  @de_neg:
0B0952 F1          0283*  	pop af
0B0953 F8          0284*  	ret m ; both negative, nothing to do
0B0954 EB          0285*      ex de,hl ; hl = quotient, de = remainder
0B0955 CD 59 07 0B 0286*  	call neg_hlu ; result is negative
0B0959 EB          0287*      ex de,hl ; de = negated quotient, hl = remainder
0B095A C9          0288*  	ret
0B095B             0289*  
0B095B             0290*  ;------------------------------------------------------------------------
0B095B             0291*  ; neg24
0B095B             0292*  ; Returns: HLU = 0-HLU
0B095B             0293*  ; preserves all other registers
0B095B             0294*  ;------------------------------------------------------------------------
0B095B             0295*  neg24:
0B095B D5          0296*  	push	de
0B095C EB          0297*  	ex		de,hl
0B095D 21 00 00 00 0298*  	ld		hl,0
0B0961 B7          0299*  	or		a
0B0962 ED 52       0300*  	sbc		hl,de
0B0964 D1          0301*  	pop		de
0B0965 C9          0302*  	ret
0B0966             0303*  
0B0966             0304*  ;------------------------------------------------------------------------
0B0966             0305*  ; or_hlu_deu: 24 bit bitwise OR
0B0966             0306*  ; Returns: hlu = hlu OR deu
0B0966             0307*  ; preserves all other registers
0B0966             0308*  ;------------------------------------------------------------------------
0B0966             0309*  or_hlu_deu:
0B0966 22 F1 09 0B 0310*  	ld	(bitbuf1),hl
0B096A ED 53 F4 09 0311*  	ld	(bitbuf2),de
       0B          
0B096F D5          0312*  	push	de	;preserve DEU
0B0970 C5          0313*  	push	bc	;preserve BCU
0B0971 06 03       0314*  	ld		b,3
0B0973 21 F1 09 0B 0315*  	ld	hl,bitbuf1
0B0977 11 F1 09 0B 0316*  	ld	de,bitbuf1
0B097B             0317*  orloop_24:
0B097B 1A          0318*  	ld	a,(de)
0B097C B6          0319*  	or	(hl)
0B097D 12          0320*  	ld	(de),a
0B097E 13          0321*  	inc	de
0B097F 23          0322*  	inc	hl
0B0980 10 F9       0323*  	djnz	orloop_24
0B0982 2A F4 09 0B 0324*  	ld	hl,(bitbuf2)
0B0986 C1          0325*  	pop		bc	;restore BC
0B0987 D1          0326*  	pop		de	;restore DE
0B0988             0327*  
0B0988             0328*  ;------------------------------------------------------------------------
0B0988             0329*  ; and_hlu_deu: 24 bit bitwise AND
0B0988             0330*  ; Returns: hlu = hlu AND deu
0B0988             0331*  ; preserves all other registers
0B0988             0332*  ;------------------------------------------------------------------------
0B0988             0333*  and_hlu_deu:
0B0988 22 F1 09 0B 0334*  	ld	(bitbuf1),hl
0B098C ED 53 F4 09 0335*  	ld	(bitbuf2),de
       0B          
0B0991 D5          0336*  	push	de	;preserve DEU
0B0992 C5          0337*  	push	bc	;preserve BCU
0B0993 06 03       0338*  	ld		b,3
0B0995 21 F1 09 0B 0339*  	ld	hl,bitbuf1
0B0999 11 F1 09 0B 0340*  	ld	de,bitbuf1
0B099D             0341*  andloop_24:
0B099D 1A          0342*  	ld	a,(de)
0B099E A6          0343*  	and	(hl)
0B099F 12          0344*  	ld	(de),a
0B09A0 13          0345*  	inc	de
0B09A1 23          0346*  	inc	hl
0B09A2 10 F9       0347*  	djnz	andloop_24
0B09A4 2A F4 09 0B 0348*  	ld	hl,(bitbuf2)
0B09A8 C1          0349*  	pop		bc	;restore BC
0B09A9 D1          0350*  	pop		de	;restore DE
0B09AA             0351*  
0B09AA             0352*  ;------------------------------------------------------------------------
0B09AA             0353*  ; xor_hlu_deu: 24 bit bitwise XOR
0B09AA             0354*  ; Returns: hlu = hlu XOR deu
0B09AA             0355*  ; preserves all other registers
0B09AA             0356*  ;------------------------------------------------------------------------
0B09AA             0357*  xor_hlu_deu:
0B09AA 22 F1 09 0B 0358*  	ld	(bitbuf1),hl
0B09AE ED 53 F4 09 0359*  	ld	(bitbuf2),de
       0B          
0B09B3 D5          0360*  	push	de	;preserve DEU
0B09B4 C5          0361*  	push	bc	;preserve BCU
0B09B5 06 03       0362*  	ld		b,3
0B09B7 21 F1 09 0B 0363*  	ld	hl,bitbuf1
0B09BB 11 F1 09 0B 0364*  	ld	de,bitbuf1
0B09BF             0365*  xorloop_24:
0B09BF 1A          0366*  	ld	a,(de)
0B09C0 AE          0367*  	xor	(hl)
0B09C1 12          0368*  	ld	(de),a
0B09C2 13          0369*  	inc	de
0B09C3 23          0370*  	inc	hl
0B09C4 10 F9       0371*  	djnz	xorloop_24
0B09C6 2A F4 09 0B 0372*  	ld	hl,(bitbuf2)
0B09CA C1          0373*  	pop		bc	;restore BC
0B09CB D1          0374*  	pop		de	;restore DE
0B09CC             0375*  
0B09CC             0376*  ;------------------------------------------------------------------------
0B09CC             0377*  ; shl_hlu: 24 bit shift left hlu by deu positions
0B09CC             0378*  ; Returns: hlu = hlu << deu
0B09CC             0379*  ;		   de = 0
0B09CC             0380*  ; NOTE: only considers deu up to 16 bits.
0B09CC             0381*  ; preserves all other registers
0B09CC             0382*  ;------------------------------------------------------------------------
0B09CC             0383*  shl_hlu:
0B09CC 7A          0384*  	ld		a,d		;up to 16 bit.
0B09CD B3          0385*  	or		e
0B09CE C8          0386*  	ret		z		;we're done
0B09CF 29          0387*  	add		hl,hl	;shift HLU left
0B09D0 1B          0388*  	dec		de
0B09D1 18 F9       0389*  	jr		shl_hlu
0B09D3             0390*  
0B09D3             0391*  ;------------------------------------------------------------------------
0B09D3             0392*  ; shr_hlu: 24 bit shift right hlu by deu positions
0B09D3             0393*  ; Returns: hlu = hlu >> deu
0B09D3             0394*  ;		   de = 0
0B09D3             0395*  ; NOTE: only considers deu up to 16 bits.
0B09D3             0396*  ; preserves all other registers
0B09D3             0397*  ;------------------------------------------------------------------------
0B09D3             0398*  shr_hlu:
0B09D3 22 F1 09 0B 0399*  	ld		(bitbuf1),hl
0B09D7 21 F3 09 0B 0400*  	ld		hl,bitbuf1+2
0B09DB             0401*  shr_loop:
0B09DB 7A          0402*  	ld		a,d		;up to 16 bit.
0B09DC B3          0403*  	or		e
0B09DD 28 0D       0404*  	jr		z,shr_done		;we're done
0B09DF             0405*  ;carry is clear from or instruction
0B09DF CB 1E       0406*  	rr		(hl)
0B09E1 2B          0407*  	dec		hl
0B09E2 CB 1E       0408*  	rr		(hl)
0B09E4 2B          0409*  	dec		hl
0B09E5 CB 1E       0410*  	rr		(hl)
0B09E7 23          0411*  	inc		hl
0B09E8 23          0412*  	inc		hl
0B09E9 1B          0413*  	dec		de
0B09EA 18 EF       0414*  	jr		shr_loop
0B09EC             0415*  shr_done:
0B09EC 2A F1 09 0B 0416*  	ld		hl,(bitbuf1)	;collect result
0B09F0 C9          0417*  	ret
0B09F1             0418*  
0B09F1             0419*  ;------------------------------------------------------------------------
0B09F1             0420*  ; Scratch area for calculations
0B09F1             0421*  ;------------------------------------------------------------------------
0B09F1 00 00 00    0422*  bitbuf1:	dw24	0	;bit manipulation buffer 1
0B09F4 00 00 00    0423*  bitbuf2:	dw24	0	;bit manipulation buffer 2
0B09F7             0424*  
0B09F7             0425*  ; ========== FROM maths24.inc ==========
0B09F7             0426*  
0B09F7             0427*  ; hlu 1 byte right shift
0B09F7             0428*  ; returns: hlu / 256, fractional portion in a
0B09F7             0429*  ; destroys: af
0B09F7             0430*  div_hlu_256:
0B09F7 AF          0431*  	xor a
0B09F8 32 09 0A 0B 0432*  	ld (@buffer+3),a
0B09FC 7D          0433*  	ld a,l ; save the fractional portion
0B09FD 22 06 0A 0B 0434*  	ld (@buffer),hl
0B0A01 2A 07 0A 0B 0435*  	ld hl,(@buffer+1)
0B0A05 C9          0436*  	ret
0B0A06             0437*  @buffer: ds 4
0B0A0A             0438*  
0B0A0A             0439*  ; Expects  ADL mode
0B0A0A             0440*  ; Inputs:  UH.L
0B0A0A             0441*  ; Outputs: UH.L is the 16.8 square root
0B0A0A             0442*  ;          UD.E is the difference inputHL-DE^2
0B0A0A             0443*  ;          c flag reset
0B0A0A             0444*  sqrt168:
0B0A0A CD 14 0A 0B 0445*      call sqrt24
0B0A0E EB          0446*      ex de,hl
0B0A0F 29          0447*      add hl,hl
0B0A10 29          0448*      add hl,hl
0B0A11 29          0449*      add hl,hl
0B0A12 29          0450*      add hl,hl
0B0A13 C9          0451*      ret
0B0A14             0452*  
0B0A14             0453*  ; Expects  ADL mode
0B0A14             0454*  ; Inputs:  HL
0B0A14             0455*  ; Outputs: DE is the integer square root
0B0A14             0456*  ;          HL is the difference inputHL-DE^2
0B0A14             0457*  ;          c flag reset
0B0A14             0458*  sqrt24:
0B0A14 AF          0459*      xor a
0B0A15 45          0460*      ld b,l
0B0A16 C5          0461*      push bc
0B0A17 47          0462*      ld b,a
0B0A18 57          0463*      ld d,a
0B0A19 4F          0464*      ld c,a
0B0A1A 6F          0465*      ld l,a
0B0A1B 5F          0466*      ld e,a
0B0A1C             0467*  
0B0A1C             0468*      ;Iteration 1
0B0A1C 29          0469*      add hl,hl
0B0A1D CB 11       0470*      rl c
0B0A1F 29          0471*      add hl,hl
0B0A20 CB 11       0472*      rl c
0B0A22 91          0473*      sub c
0B0A23 30 04       0474*      jr nc,$+6
0B0A25 1C          0475*      inc e
0B0A26 1C          0476*      inc e
0B0A27 2F          0477*      cpl
0B0A28 4F          0478*      ld c,a
0B0A29             0479*  
0B0A29             0480*      ;Iteration 2
0B0A29 29          0481*      add hl,hl
0B0A2A CB 11       0482*      rl c
0B0A2C 29          0483*      add hl,hl
0B0A2D CB 11       0484*      rl c
0B0A2F CB 13       0485*      rl e
0B0A31 7B          0486*      ld a,e
0B0A32 91          0487*      sub c
0B0A33 30 04       0488*      jr nc,$+6
0B0A35 1C          0489*      inc e
0B0A36 1C          0490*      inc e
0B0A37 2F          0491*      cpl
0B0A38 4F          0492*      ld c,a
0B0A39             0493*  
0B0A39             0494*      ;Iteration 3
0B0A39 29          0495*      add hl,hl
0B0A3A CB 11       0496*      rl c
0B0A3C 29          0497*      add hl,hl
0B0A3D CB 11       0498*      rl c
0B0A3F CB 13       0499*      rl e
0B0A41 7B          0500*      ld a,e
0B0A42 91          0501*      sub c
0B0A43 30 04       0502*      jr nc,$+6
0B0A45 1C          0503*      inc e
0B0A46 1C          0504*      inc e
0B0A47 2F          0505*      cpl
0B0A48 4F          0506*      ld c,a
0B0A49             0507*  
0B0A49             0508*      ;Iteration 4
0B0A49 29          0509*      add hl,hl
0B0A4A CB 11       0510*      rl c
0B0A4C 29          0511*      add hl,hl
0B0A4D CB 11       0512*      rl c
0B0A4F CB 13       0513*      rl e
0B0A51 7B          0514*      ld a,e
0B0A52 91          0515*      sub c
0B0A53 30 04       0516*      jr nc,$+6
0B0A55 1C          0517*      inc e
0B0A56 1C          0518*      inc e
0B0A57 2F          0519*      cpl
0B0A58 4F          0520*      ld c,a
0B0A59             0521*  
0B0A59             0522*      ;Iteration 5
0B0A59 29          0523*      add hl,hl
0B0A5A CB 11       0524*      rl c
0B0A5C 29          0525*      add hl,hl
0B0A5D CB 11       0526*      rl c
0B0A5F CB 13       0527*      rl e
0B0A61 7B          0528*      ld a,e
0B0A62 91          0529*      sub c
0B0A63 30 04       0530*      jr nc,$+6
0B0A65 1C          0531*      inc e
0B0A66 1C          0532*      inc e
0B0A67 2F          0533*      cpl
0B0A68 4F          0534*      ld c,a
0B0A69             0535*  
0B0A69             0536*      ;Iteration 6
0B0A69 29          0537*      add hl,hl
0B0A6A CB 11       0538*      rl c
0B0A6C 29          0539*      add hl,hl
0B0A6D CB 11       0540*      rl c
0B0A6F CB 13       0541*      rl e
0B0A71 7B          0542*      ld a,e
0B0A72 91          0543*      sub c
0B0A73 30 04       0544*      jr nc,$+6
0B0A75 1C          0545*      inc e
0B0A76 1C          0546*      inc e
0B0A77 2F          0547*      cpl
0B0A78 4F          0548*      ld c,a
0B0A79             0549*  
0B0A79             0550*      ;Iteration 7
0B0A79 29          0551*      add hl,hl
0B0A7A CB 11       0552*      rl c
0B0A7C 29          0553*      add hl,hl
0B0A7D CB 11       0554*      rl c
0B0A7F CB 10       0555*      rl b
0B0A81 EB          0556*      ex de,hl
0B0A82 29          0557*      add hl,hl
0B0A83 E5          0558*      push hl
0B0A84 ED 42       0559*      sbc hl,bc
0B0A86 30 06       0560*      jr nc,$+8
0B0A88 7C          0561*      ld a,h
0B0A89 2F          0562*      cpl
0B0A8A 47          0563*      ld b,a
0B0A8B 7D          0564*      ld a,l
0B0A8C 2F          0565*      cpl
0B0A8D 4F          0566*      ld c,a
0B0A8E E1          0567*      pop hl
0B0A8F 30 02       0568*      jr nc,$+4
0B0A91 23          0569*      inc hl
0B0A92 23          0570*      inc hl
0B0A93 EB          0571*      ex de,hl
0B0A94             0572*  
0B0A94             0573*      ;Iteration 8
0B0A94 29          0574*      add hl,hl
0B0A95 69          0575*      ld l,c
0B0A96 60          0576*      ld h,b
0B0A97 ED 6A       0577*      adc hl,hl
0B0A99 ED 6A       0578*      adc hl,hl
0B0A9B EB          0579*      ex de,hl
0B0A9C 29          0580*      add hl,hl
0B0A9D ED 52       0581*      sbc hl,de
0B0A9F 19          0582*      add hl,de
0B0AA0 EB          0583*      ex de,hl
0B0AA1 30 04       0584*      jr nc,$+6
0B0AA3 ED 52       0585*      sbc hl,de
0B0AA5 13          0586*      inc de
0B0AA6 13          0587*      inc de
0B0AA7             0588*  
0B0AA7             0589*      ;Iteration 9
0B0AA7 F1          0590*      pop af
0B0AA8 17          0591*      rla
0B0AA9 ED 6A       0592*      adc hl,hl
0B0AAB 17          0593*      rla
0B0AAC ED 6A       0594*      adc hl,hl
0B0AAE EB          0595*      ex de,hl
0B0AAF 29          0596*      add hl,hl
0B0AB0 ED 52       0597*      sbc hl,de
0B0AB2 19          0598*      add hl,de
0B0AB3 EB          0599*      ex de,hl
0B0AB4 30 04       0600*      jr nc,$+6
0B0AB6 ED 52       0601*      sbc hl,de
0B0AB8 13          0602*      inc de
0B0AB9 13          0603*      inc de
0B0ABA             0604*  
0B0ABA             0605*      ;Iteration 10
0B0ABA 17          0606*      rla
0B0ABB ED 6A       0607*      adc hl,hl
0B0ABD 17          0608*      rla
0B0ABE ED 6A       0609*      adc hl,hl
0B0AC0 EB          0610*      ex de,hl
0B0AC1 29          0611*      add hl,hl
0B0AC2 ED 52       0612*      sbc hl,de
0B0AC4 19          0613*      add hl,de
0B0AC5 EB          0614*      ex de,hl
0B0AC6 30 04       0615*      jr nc,$+6
0B0AC8 ED 52       0616*      sbc hl,de
0B0ACA 13          0617*      inc de
0B0ACB 13          0618*      inc de
0B0ACC             0619*  
0B0ACC             0620*      ;Iteration 11
0B0ACC 17          0621*      rla
0B0ACD ED 6A       0622*      adc hl,hl
0B0ACF 17          0623*      rla
0B0AD0 ED 6A       0624*      adc hl,hl
0B0AD2 EB          0625*      ex de,hl
0B0AD3 29          0626*      add hl,hl
0B0AD4 ED 52       0627*      sbc hl,de
0B0AD6 19          0628*      add hl,de
0B0AD7 EB          0629*      ex de,hl
0B0AD8 30 04       0630*      jr nc,$+6
0B0ADA ED 52       0631*      sbc hl,de
0B0ADC 13          0632*      inc de
0B0ADD 13          0633*      inc de
0B0ADE             0634*  
0B0ADE             0635*      ;Iteration 11
0B0ADE 17          0636*      rla
0B0ADF ED 6A       0637*      adc hl,hl
0B0AE1 17          0638*      rla
0B0AE2 ED 6A       0639*      adc hl,hl
0B0AE4 EB          0640*      ex de,hl
0B0AE5 29          0641*      add hl,hl
0B0AE6 ED 52       0642*      sbc hl,de
0B0AE8 19          0643*      add hl,de
0B0AE9 EB          0644*      ex de,hl
0B0AEA 30 04       0645*      jr nc,$+6
0B0AEC ED 52       0646*      sbc hl,de
0B0AEE 13          0647*      inc de
0B0AEF 13          0648*      inc de
0B0AF0             0649*  
0B0AF0 CB 1A       0650*      rr d
0B0AF2 CB 1B       0651*      rr e
0B0AF4 C9          0652*      ret
0B0AF5             0022       include "trig24.inc"
0B0AF5             0001*  
0B0AF5             0002*  ; convert unsigned angles from a 360 to 255 degree circle
0B0AF5             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0B0AF5             0004*  ; outputs: uh.l is the angle255 in 16.8 fixed format
0B0AF5             0005*  ; destroys: TODO
0B0AF5             0006*  ; note: even though the inputs and outputs are 16.8 fixed format
0B0AF5             0007*  ;       precision is effectively limited to 8.8 fixed format
0B0AF5             0008*  deg_360_to_255:
0B0AF5             0009*  ; clear scratch buffer
0B0AF5 11 00 00 00 0010*  	ld de,0
0B0AF9 ED 53 25 0B 0011*  	ld (@scratch),de
       0B          
0B0AFE             0012*  ; divide uh.l by 360
0B0AFE 11 68 01 00 0013*  	ld de,360
0B0B02             0014*  ; get integer portion
0B0B02 CD D9 08 0B 0015*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
0B0B06 ED 53 2C 0B 0016*  	ld (@output+1),de ; shift result up one byte
       0B          
0B0B0B             0017*  ; get fractional portion
0B0B0B 22 26 0B 0B 0018*  	ld (@scratch+1),hl ; shift remainder up one byte
0B0B0F 2A 25 0B 0B 0019*  	ld hl,(@scratch)
0B0B13 11 68 01 00 0020*  	ld de,360
0B0B17 CD D9 08 0B 0021*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
0B0B1B 7B          0022*  	ld a,e ; lowest byte is all we need
0B0B1C 32 2B 0B 0B 0023*  	ld (@output),a
0B0B20             0024*  ; we want the low 3 bytes for 16.8 output
0B0B20 2A 2B 0B 0B 0025*  	ld hl,(@output)
0B0B24 C9          0026*  	ret
0B0B25             0027*  @scratch: ds 6 ; scratch buffer for shifting bytes
0B0B2B             0028*  @output: ds 6 ; scratch buffer to accumulate output
0B0B31             0029*  
0B0B31             0030*  ; 16.8 fixed inputs / outputs
0B0B31             0031*  ; takes: uh.l as angle in degrees 256
0B0B31             0032*  ;        ud.e as radius
0B0B31             0033*  ; returns ub.c as dx, ud.e as dy
0B0B31             0034*  ;        displacements from origin (0,0)
0B0B31             0035*  ; destroys: everything except indexes
0B0B31             0036*  polar_to_cartesian:
0B0B31             0037*  ; back up input parameters
0B0B31 22 DE 07 0B 0038*      ld (arith24uhl), hl
0B0B35 ED 53 EA 07 0039*      ld (arith24ude), de
       0B          
0B0B3A             0040*  ; compute dx = sin(uh.l) * ud.e
0B0B3A CD 69 0B 0B 0041*      call sin168
0B0B3E E5          0042*      push hl
0B0B3F C1          0043*      pop bc          ; ub.c = sin(uh.l)
0B0B40 ED 5B EA 07 0044*  	ld de, (arith24ude)   ; get radius back
       0B          
0B0B45 CD 9D 08 0B 0045*  	call smul168    ; uh.l = ub.c * ud.e = dx
0B0B49 E5          0046*      push hl         ; store dx for output
0B0B4A             0047*  ; compute dy = -cos(uh.l) * ud.e
0B0B4A 2A DE 07 0B 0048*      ld hl, (arith24uhl)
0B0B4E CD 64 0B 0B 0049*      call cos168
0B0B52 CD 59 07 0B 0050*  	call neg_hlu    ; invert dy for screen coords convention
0B0B56 E5          0051*      push hl
0B0B57 C1          0052*      pop bc          ; ub.c = -cos(uh.l)
0B0B58 ED 5B EA 07 0053*      ld de, (arith24ude)   ; get radius back
       0B          
0B0B5D CD 9D 08 0B 0054*      call smul168    ; uh.l = ub.c * ud.e = dy
0B0B61 EB          0055*      ex de, hl       ; de = dy for output
0B0B62 C1          0056*      pop bc          ; bc = dx for output
0B0B63             0057*  ; and out
0B0B63 C9          0058*      ret
0B0B64             0059*  
0B0B64             0060*  ; fixed 16.8 routine
0B0B64             0061*  ; cos(uh.l) --> uh.l
0B0B64             0062*  ; destroys: de
0B0B64             0063*  cos168:
0B0B64             0064*  ; for cos we simply increment the angle by 90 degrees
0B0B64             0065*  ; or 0x004000 in 16.8 degrees256
0B0B64             0066*  ; which makes it a sin problem
0B0B64 11 00 40 00 0067*      ld de,0x004000
0B0B68 19          0068*      add hl,de ; modulo 256 happens below
0B0B69             0069*  ; fall through to sin168
0B0B69             0070*  ; ---------------------
0B0B69             0071*  ; fixed 16.8 routine
0B0B69             0072*  ; sin(uh.l) --> uh.l
0B0B69             0073*  ; destroys: de
0B0B69             0074*  sin168:
0B0B69             0075*  ; h contains the integer portion of our angle
0B0B69             0076*  ; we multiply it by three to get our lookup table index
0B0B69 2E 03       0077*      ld l,3
0B0B6B ED 6C       0078*      mlt hl ; gosh that is handy
0B0B6D 11 00 00 00 0079*      ld de,0 ; clear deu
0B0B71 54          0080*      ld d,h ; copy hl to de
0B0B72 5D          0081*      ld e,l ; de contains our index
0B0B73 21 8F 0C 0B 0082*      ld hl,sin_lut_168 ; grab the lut address
0B0B77 19          0083*      add hl,de ; bump hl by the index
0B0B78 ED 27       0084*      ld hl,(hl) ; don't try this on a z80!
0B0B7A C9          0085*      ret ; and out
0B0B7B             0086*  
0B0B7B             0087*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0B7B             0088*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0B7B             0089*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0B7B             0090*  ;         also populates scratch locations dx168 and dy168
0B0B7B             0091*  ; destroys: a,hl,bc,de
0B0B7B             0092*  dxy168:
0B0B7B             0093*  ; compute dx = x1-x0
0B0B7B AF          0094*      xor a ; clear carry
0B0B7C DD E5       0095*      push ix ; move ix to hl via the stack
0B0B7E E1          0096*      pop hl ; hl = x1
0B0B7F ED 42       0097*      sbc hl,bc ; hl = dx
0B0B81 22 D6 0B 0B 0098*      ld (dx168),hl ; dx to scratch
0B0B85             0099*  ; compute dy = y1-y0
0B0B85 AF          0100*      xor a ; clear carry
0B0B86 FD E5       0101*      push iy ; move iy to hl via the stack
0B0B88 E1          0102*      pop hl ; hl = y1
0B0B89 ED 52       0103*      sbc hl,de ; hl = dy
0B0B8B 22 DC 0B 0B 0104*      ld (dy168),hl ; dy to scratch
0B0B8F             0105*  ; populate output registers and return
0B0B8F EB          0106*      ex de,hl        ; ud.e = dy
0B0B90 ED 4B D6 0B 0107*      ld bc,(dx168)   ; ub.c = dx
       0B          
0B0B95 C9          0108*      ret
0B0B96             0109*  
0B0B96             0110*  ; compute the euclidian distance between two cartesian coordinates
0B0B96             0111*  ; using the formula d = sqrt(dx^2+dy^2
0B0B96             0112*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0B96             0113*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0B96             0114*  ; output; uh.l is the 16.8 fixed format distance
0B0B96             0115*  ;       dx168/y are the 16.8 fixed format dx and dy
0B0B96             0116*  ; destroys: a,hl,bc,de
0B0B96             0117*  distance168:
0B0B96             0118*  ; compute dx = x1-x0
0B0B96 AF          0119*      xor a ; clear carry
0B0B97 DD E5       0120*      push ix ; move ix to hl via the stack
0B0B99 E1          0121*      pop hl ; hl = x1
0B0B9A ED 42       0122*      sbc hl,bc ; hl = dx
0B0B9C 22 D6 0B 0B 0123*      ld (dx168),hl ; dx to scratch
0B0BA0             0124*  ; ; test dx for overflow
0B0BA0             0125*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0BA0             0126*  ; 	ex de,hl
0B0BA0             0127*  ; 	sbc hl,de ; test for overflow
0B0BA0             0128*  ; 	push af ; carry indicates overflow
0B0BA0             0129*  ; compute dy = y1-y0
0B0BA0 AF          0130*      xor a ; clear carry
0B0BA1 FD E5       0131*      push iy ; move iy to hl via the stack
0B0BA3 E1          0132*      pop hl ; hl = y1
0B0BA4 ED 52       0133*      sbc hl,de ; hl = dy
0B0BA6 22 DC 0B 0B 0134*      ld (dy168),hl ; dy to scratch
0B0BAA             0135*  ; ; test dy for overflow
0B0BAA             0136*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0BAA             0137*  ; 	ex de,hl
0B0BAA             0138*  ; 	sbc hl,de ; test for overflow
0B0BAA             0139*  ; 	push af ; carry indicates overflow
0B0BAA             0140*  ; compute dy^2
0B0BAA 2A DC 0B 0B 0141*  	ld hl,(dy168)
0B0BAE CD 49 07 0B 0142*      call abs_hlu  ; make dy positive so we can use unsigned multiply
0B0BB2             0143*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0BB2 E5          0144*      push hl ; load hl/2 to bc via the stack
0B0BB3 C1          0145*      pop bc ; bc = dy/2
0B0BB4 EB          0146*      ex de,hl ; de = dy/2
0B0BB5 CD 95 08 0B 0147*      call umul168 ; uh.l = dy^2/2
0B0BB9 E5          0148*      push hl ; dy^2/2 to the stack
0B0BBA             0149*  ; compute dx^2
0B0BBA 2A D6 0B 0B 0150*      ld hl,(dx168) ; get back dx
0B0BBE CD 49 07 0B 0151*      call abs_hlu  ; make dx positive so we can use unsigned multiply
0B0BC2             0152*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0BC2 E5          0153*      push hl ; load hl/2 to bc via the stack
0B0BC3 C1          0154*      pop bc ; bc = dx/2
0B0BC4 EB          0155*      ex de,hl ; de = dx/2
0B0BC5 CD 95 08 0B 0156*      call umul168 ; uh.l = dx^2/2
0B0BC9             0157*  ; commpute dy^2+dx^2
0B0BC9 D1          0158*      pop de ; get back dx^2/2
0B0BCA 19          0159*      add hl,de ; hl = dx^2/2+dy^2/2
0B0BCB             0160*  ; compute sqrt(dx^2/2+dy^2/2)
0B0BCB CD 0A 0A 0B 0161*      call sqrt168 ; uh.l = distance/2
0B0BCF             0162*      ; add hl,hl ; hl = distance
0B0BCF             0163*  ; ; check for overflow
0B0BCF             0164*  ; 	pop af ; get back the overflow flags
0B0BCF             0165*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0BCF             0166*  ; 	ld b,a ; save the overflow flag
0B0BCF             0167*  ; 	pop af ; get back the overflow flags
0B0BCF             0168*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0BCF             0169*  ; 	add a,b ; if a != 0 then we had overflow
0B0BCF             0170*  ;     ret z ; no overflow we're done
0B0BCF             0171*  ; @overflow:
0B0BCF             0172*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
0B0BCF C9          0173*  	ret
0B0BD0             0174*  @scratch: ds 6
0B0BD6             0175*  dx168: ds 6
0B0BDC             0176*  dy168: ds 6
0B0BE2             0177*  
0B0BE2             0178*  ; atan2(ub.c,ud.e) --> uh.l
0B0BE2             0179*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0BE2             0180*  ;   whether inputs are integers or fractional doesn't matter
0B0BE2             0181*  ;   so long as the sign bit of the upper byte is correct
0B0BE2             0182*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0B0BE2             0183*  ; angles are COMPASS HEADINGS based on
0B0BE2             0184*  ; screen coordinate conventions,where the y axis is flipped
0B0BE2             0185*  ; #E0 315      0       45 #20
0B0BE2             0186*  ;        -x,-y | +x,-y
0B0BE2             0187*  ; #C0 270------+------ 90 #40
0B0BE2             0188*  ;        -x,+y | +x,+y
0B0BE2             0189*  ; #A0 225   180 #80   135 #60
0B0BE2             0190*  atan2_168game:
0B0BE2             0191*  ; get signs and make everything positive
0B0BE2             0192*  ; get abs(x) and store its original sign
0B0BE2 C5          0193*      push bc
0B0BE3 E1          0194*      pop hl
0B0BE4 CD 49 07 0B 0195*      call abs_hlu ; if x was negative this also sets the sign flag
0B0BE8 E5          0196*      push hl ; store abs(x)
0B0BE9 C1          0197*      pop bc ; bc = abs(x)
0B0BEA F5          0198*      push af ; store sign of x
0B0BEB             0199*  ; get abs(y) and store its original sign
0B0BEB EB          0200*      ex de,hl ; hl = y
0B0BEC CD 49 07 0B 0201*      call abs_hlu ; if y was negative this also sets the sign flag
0B0BF0 EB          0202*      ex de,hl ; de = abs(y)
0B0BF1 F5          0203*      push af ; store sign of y
0B0BF2             0204*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B0BF2             0205*  ; this ensures that our lookup value is between 0 and 1 inclusive
0B0BF2 AF          0206*      xor a ; clear the carry flag
0B0BF3 D5          0207*      push de
0B0BF4 E1          0208*      pop hl
0B0BF5 ED 42       0209*      sbc hl,bc
0B0BF7 F5          0210*      push af ; save sign of de - bc
0B0BF8 F2 01 0C 0B 0211*      jp p,@1 ; bc <= de, so we skip ahead
0B0BFC             0212*  ; otherwise we swap bc and de
0B0BFC C5          0213*      push bc
0B0BFD E1          0214*      pop hl
0B0BFE EB          0215*      ex de,hl
0B0BFF E5          0216*      push hl
0B0C00 C1          0217*      pop bc
0B0C01             0218*  @1:
0B0C01             0219*  ; now we're ready to snag our preliminary result
0B0C01 CD 6F 0C 0B 0220*      call atan_168game ; uh.l comes back with prelim result
0B0C05             0221*  ; now we adjust uh.l based on sign of de - bc
0B0C05 F1          0222*      pop af
0B0C06 F2 12 0C 0B 0223*      jp p,@2 ; bc <= de,so we skip ahead
0B0C0A EB          0224*      ex de,hl
0B0C0B 21 00 40 00 0225*      ld hl,0x004000 ; 90 degrees
0B0C0F AF          0226*      xor a ; clear the carry flag
0B0C10 ED 52       0227*      sbc hl,de ; subtract result from 90 degrees
0B0C12             0228*      ; ld de,0 ; prep to clear hlu
0B0C12             0229*      ; ld d,h
0B0C12             0230*      ; ld e,l
0B0C12             0231*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
0B0C12             0232*      ; fall through
0B0C12             0233*  @2:
0B0C12             0234*  ; now the fun part of adjusting the result
0B0C12             0235*  ; based on which quadrant (x,y) is in
0B0C12             0236*  ; #E0 315      0       45 #20
0B0C12             0237*  ;        -x,-y | +x,-y
0B0C12             0238*  ; #C0 270------+------ 90 #40
0B0C12             0239*  ;        -x,+y | +x,+y
0B0C12             0240*  ; #A0 225   180 #80   135 #60
0B0C12 F1          0241*      pop af ; sign of y
0B0C13 CA 50 0C 0B 0242*      jp z,@y_zero
0B0C17 F2 30 0C 0B 0243*      jp p,@y_pos
0B0C1B             0244*  ; y neg,check x
0B0C1B F1          0245*      pop af ; sign of x
0B0C1C CA 2A 0C 0B 0246*      jp z,@y_neg_x_zero
0B0C20 F2 2F 0C 0B 0247*      jp p,@y_neg_x_pos
0B0C24             0248*  ; y neg,x neg
0B0C24             0249*  ; angle is 270-360
0B0C24             0250*  ; negating the intermediate does the trick
0B0C24 CD 59 07 0B 0251*      call neg_hlu
0B0C28 18 31       0252*      jr @zero_hlu
0B0C2A             0253*  
0B0C2A             0254*  @y_neg_x_zero:
0B0C2A             0255*  ; y neg,x zero
0B0C2A             0256*  ; angle is 0
0B0C2A 21 00 00 00 0257*      ld hl,0
0B0C2E C9          0258*      ret
0B0C2F             0259*  @y_neg_x_pos:
0B0C2F             0260*  ; y neg,x pos
0B0C2F             0261*  ; angle is 0 to 90
0B0C2F             0262*  ; so we're good
0B0C2F C9          0263*      ret
0B0C30             0264*  
0B0C30             0265*  @y_pos:
0B0C30 F1          0266*      pop af ; sign of x
0B0C31 CA 40 0C 0B 0267*      jp z,@y_pos_x_zero
0B0C35 F2 45 0C 0B 0268*      jp p,@y_pos_x_pos
0B0C39             0269*  ; y pos,x neg
0B0C39             0270*  ; angle is 180-270
0B0C39             0271*  ; so we add 180 to intermediate
0B0C39 11 00 80 00 0272*      ld de,0x008000
0B0C3D 19          0273*      add hl,de
0B0C3E 18 1B       0274*      jr @zero_hlu
0B0C40             0275*  @y_pos_x_zero:
0B0C40             0276*  ; y pos,x zero
0B0C40             0277*  ; angle is 180
0B0C40 21 00 80 00 0278*      ld hl,0x008000
0B0C44 C9          0279*      ret
0B0C45             0280*  @y_pos_x_pos:
0B0C45             0281*  ; y pos,x pos
0B0C45             0282*  ; angle is 90-180
0B0C45             0283*  ; neg the intermediate and add 180 degrees
0B0C45 CD 59 07 0B 0284*      call neg_hlu
0B0C49 11 00 80 00 0285*      ld de,0x008000
0B0C4D 19          0286*      add hl,de
0B0C4E 18 0B       0287*      jr @zero_hlu
0B0C50             0288*  
0B0C50             0289*  @y_zero:
0B0C50 F1          0290*      pop af ; sign of x
0B0C51 FA 56 0C 0B 0291*      jp m,@y_zero_x_neg
0B0C55             0292*  ; y zero,x pos
0B0C55             0293*  ; angle is 90,nothing to do
0B0C55 C9          0294*      ret
0B0C56             0295*  @y_zero_x_neg:
0B0C56             0296*  ; y zero ,x neg
0B0C56             0297*  ; angle is 270
0B0C56 21 00 C0 00 0298*      ld hl,0x00C000
0B0C5A C9          0299*      ret
0B0C5B             0300*  @zero_hlu:
0B0C5B AF          0301*      xor a
0B0C5C 22 69 0C 0B 0302*      ld (@scratch),hl
0B0C60 32 6B 0C 0B 0303*      ld (@scratch+2),a
0B0C64 2A 69 0C 0B 0304*      ld hl,(@scratch)
0B0C68 C9          0305*      ret
0B0C69             0306*  @scratch: ds 6
0B0C6F             0307*  
0B0C6F             0308*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0C6F             0309*  ; output: uh.l is the 16.8 fixed format angle
0B0C6F             0310*  ; destroys: a,hl,bc,de
0B0C6F             0311*  ; the following note was written by github copilot:
0B0C6F             0312*  ; note: this routine is a bit of a hack
0B0C6F             0313*  ;      but it works
0B0C6F             0314*  ;      and it's fast
0B0C6F             0315*  ;      and it's small
0B0C6F             0316*  ;      and it's accurate
0B0C6F             0317*  ;      and it's easy to understand
0B0C6F             0318*  ;      and it's easy to modify
0B0C6F             0319*  ;      and it's easy to use
0B0C6F             0320*  ;      and it's easy to remember
0B0C6F             0321*  ;      and it's easy to love
0B0C6F             0322*  ;      and it's easy to hate
0B0C6F             0323*  ;      and it's easy to ignore
0B0C6F             0324*  ;      and it's easy to forget
0B0C6F             0325*  ;      and it's easy to remember
0B0C6F             0326*  ;      and it's easy to forget
0B0C6F             0327*  ;      and it's easy to remember
0B0C6F             0328*  ;      (ok the bot is stuck in a loop)
0B0C6F             0329*  ; REAL NOTE: only works for angles from 0 to 45 degrees
0B0C6F             0330*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0B0C6F             0331*  atan_168game:
0B0C6F             0332*  ; because we use compass headings instead of geometric angles
0B0C6F             0333*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0B0C6F             0334*  ; we can do faster unsigned division here because we know dx and dy are positive
0B0C6F CD FD 08 0B 0335*  	call udiv168 ; uh.l = dx/dy
0B0C73             0336*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0B0C73             0337*  ; ; test uh.l for 0
0B0C73             0338*  ;     add hl,de
0B0C73             0339*  ;     or a
0B0C73             0340*  ;     sbc hl,de
0B0C73             0341*  ;     jr z,@is_zero
0B0C73             0342*  ; ; test uh.l for 1
0B0C73             0343*  ;     xor a ; clear carry
0B0C73             0344*  ;     ex de,hl
0B0C73             0345*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0B0C73             0346*  ;     sbc hl,de
0B0C73             0347*  ;     jr z,@is_45
0B0C73             0348*  ; ; END TODO
0B0C73             0349*  
0B0C73             0350*  ; no special cases so we move on
0B0C73             0351*  ; l contains the fractional portion of tan(uh.l)
0B0C73             0352*  ; we multiply it by three to get our lookup table index
0B0C73 26 03       0353*      ld h,3
0B0C75 ED 6C       0354*      mlt hl ; gosh that is handy
0B0C77 11 00 00 00 0355*      ld de,0 ; clear deu
0B0C7B 54          0356*      ld d,h ; copy hl to de
0B0C7C 5D          0357*      ld e,l ; de contains our index
0B0C7D 21 8F 0F 0B 0358*      ld hl,atan_lut_168 ; grab the lut address
0B0C81 19          0359*      add hl,de ; bump hl by the index
0B0C82 ED 27       0360*      ld hl,(hl) ; don't try this on a z80!
0B0C84 C9          0361*      ret ; and out
0B0C85             0362*  @is_45:
0B0C85 21 00 20 00 0363*      ld hl,0x002000 ; 45 degrees decimal
0B0C89 C9          0364*      ret
0B0C8A             0365*  ; for the case tan(0)
0B0C8A             0366*  @is_zero:
0B0C8A 21 00 00 00 0367*      ld hl,0x000000
0B0C8E C9          0368*      ret
0B0C8F             0369*  
0B0C8F             0370*  
0B0C8F             0371*  sin_lut_168:
0B0C8F 00 00 00    0372*  	dl 0x000000 ; 0.000 00, 0.000
0B0C92 06 00 00    0373*  	dl 0x000006 ; 1.406 01, 0.025
0B0C95 0C 00 00    0374*  	dl 0x00000C ; 2.813 02, 0.049
0B0C98 12 00 00    0375*  	dl 0x000012 ; 4.219 03, 0.074
0B0C9B 19 00 00    0376*  	dl 0x000019 ; 5.625 04, 0.098
0B0C9E 1F 00 00    0377*  	dl 0x00001F ; 7.031 05, 0.122
0B0CA1 25 00 00    0378*  	dl 0x000025 ; 8.438 06, 0.147
0B0CA4 2B 00 00    0379*  	dl 0x00002B ; 9.844 07, 0.171
0B0CA7 31 00 00    0380*  	dl 0x000031 ; 11.250 08, 0.195
0B0CAA 38 00 00    0381*  	dl 0x000038 ; 12.656 09, 0.219
0B0CAD 3E 00 00    0382*  	dl 0x00003E ; 14.063 0A, 0.243
0B0CB0 44 00 00    0383*  	dl 0x000044 ; 15.469 0B, 0.267
0B0CB3 4A 00 00    0384*  	dl 0x00004A ; 16.875 0C, 0.290
0B0CB6 50 00 00    0385*  	dl 0x000050 ; 18.281 0D, 0.314
0B0CB9 56 00 00    0386*  	dl 0x000056 ; 19.688 0E, 0.337
0B0CBC 5C 00 00    0387*  	dl 0x00005C ; 21.094 0F, 0.360
0B0CBF 61 00 00    0388*  	dl 0x000061 ; 22.500 10, 0.383
0B0CC2 67 00 00    0389*  	dl 0x000067 ; 23.906 11, 0.405
0B0CC5 6D 00 00    0390*  	dl 0x00006D ; 25.313 12, 0.428
0B0CC8 73 00 00    0391*  	dl 0x000073 ; 26.719 13, 0.450
0B0CCB 78 00 00    0392*  	dl 0x000078 ; 28.125 14, 0.471
0B0CCE 7E 00 00    0393*  	dl 0x00007E ; 29.531 15, 0.493
0B0CD1 83 00 00    0394*  	dl 0x000083 ; 30.938 16, 0.514
0B0CD4 88 00 00    0395*  	dl 0x000088 ; 32.344 17, 0.535
0B0CD7 8E 00 00    0396*  	dl 0x00008E ; 33.750 18, 0.556
0B0CDA 93 00 00    0397*  	dl 0x000093 ; 35.156 19, 0.576
0B0CDD 98 00 00    0398*  	dl 0x000098 ; 36.563 1A, 0.596
0B0CE0 9D 00 00    0399*  	dl 0x00009D ; 37.969 1B, 0.615
0B0CE3 A2 00 00    0400*  	dl 0x0000A2 ; 39.375 1C, 0.634
0B0CE6 A7 00 00    0401*  	dl 0x0000A7 ; 40.781 1D, 0.653
0B0CE9 AB 00 00    0402*  	dl 0x0000AB ; 42.188 1E, 0.672
0B0CEC B0 00 00    0403*  	dl 0x0000B0 ; 43.594 1F, 0.690
0B0CEF B5 00 00    0404*  	dl 0x0000B5 ; 45.000 20, 0.707
0B0CF2 B9 00 00    0405*  	dl 0x0000B9 ; 46.406 21, 0.724
0B0CF5 BD 00 00    0406*  	dl 0x0000BD ; 47.813 22, 0.741
0B0CF8 C1 00 00    0407*  	dl 0x0000C1 ; 49.219 23, 0.757
0B0CFB C5 00 00    0408*  	dl 0x0000C5 ; 50.625 24, 0.773
0B0CFE C9 00 00    0409*  	dl 0x0000C9 ; 52.031 25, 0.788
0B0D01 CD 00 00    0410*  	dl 0x0000CD ; 53.438 26, 0.803
0B0D04 D1 00 00    0411*  	dl 0x0000D1 ; 54.844 27, 0.818
0B0D07 D4 00 00    0412*  	dl 0x0000D4 ; 56.250 28, 0.831
0B0D0A D8 00 00    0413*  	dl 0x0000D8 ; 57.656 29, 0.845
0B0D0D DB 00 00    0414*  	dl 0x0000DB ; 59.063 2A, 0.858
0B0D10 DE 00 00    0415*  	dl 0x0000DE ; 60.469 2B, 0.870
0B0D13 E1 00 00    0416*  	dl 0x0000E1 ; 61.875 2C, 0.882
0B0D16 E4 00 00    0417*  	dl 0x0000E4 ; 63.281 2D, 0.893
0B0D19 E7 00 00    0418*  	dl 0x0000E7 ; 64.688 2E, 0.904
0B0D1C EA 00 00    0419*  	dl 0x0000EA ; 66.094 2F, 0.914
0B0D1F EC 00 00    0420*  	dl 0x0000EC ; 67.500 30, 0.924
0B0D22 EE 00 00    0421*  	dl 0x0000EE ; 68.906 31, 0.933
0B0D25 F1 00 00    0422*  	dl 0x0000F1 ; 70.313 32, 0.942
0B0D28 F3 00 00    0423*  	dl 0x0000F3 ; 71.719 33, 0.950
0B0D2B F4 00 00    0424*  	dl 0x0000F4 ; 73.125 34, 0.957
0B0D2E F6 00 00    0425*  	dl 0x0000F6 ; 74.531 35, 0.964
0B0D31 F8 00 00    0426*  	dl 0x0000F8 ; 75.938 36, 0.970
0B0D34 F9 00 00    0427*  	dl 0x0000F9 ; 77.344 37, 0.976
0B0D37 FB 00 00    0428*  	dl 0x0000FB ; 78.750 38, 0.981
0B0D3A FC 00 00    0429*  	dl 0x0000FC ; 80.156 39, 0.985
0B0D3D FD 00 00    0430*  	dl 0x0000FD ; 81.563 3A, 0.989
0B0D40 FE 00 00    0431*  	dl 0x0000FE ; 82.969 3B, 0.992
0B0D43 FE 00 00    0432*  	dl 0x0000FE ; 84.375 3C, 0.995
0B0D46 FF 00 00    0433*  	dl 0x0000FF ; 85.781 3D, 0.997
0B0D49 FF 00 00    0434*  	dl 0x0000FF ; 87.188 3E, 0.999
0B0D4C FF 00 00    0435*  	dl 0x0000FF ; 88.594 3F, 1.000
0B0D4F 00 01 00    0436*  	dl 0x000100 ; 90.000 40, 1.000
0B0D52 FF 00 00    0437*  	dl 0x0000FF ; 91.406 41, 1.000
0B0D55 FF 00 00    0438*  	dl 0x0000FF ; 92.813 42, 0.999
0B0D58 FF 00 00    0439*  	dl 0x0000FF ; 94.219 43, 0.997
0B0D5B FE 00 00    0440*  	dl 0x0000FE ; 95.625 44, 0.995
0B0D5E FE 00 00    0441*  	dl 0x0000FE ; 97.031 45, 0.992
0B0D61 FD 00 00    0442*  	dl 0x0000FD ; 98.438 46, 0.989
0B0D64 FC 00 00    0443*  	dl 0x0000FC ; 99.844 47, 0.985
0B0D67 FB 00 00    0444*  	dl 0x0000FB ; 101.250 48, 0.981
0B0D6A F9 00 00    0445*  	dl 0x0000F9 ; 102.656 49, 0.976
0B0D6D F8 00 00    0446*  	dl 0x0000F8 ; 104.063 4A, 0.970
0B0D70 F6 00 00    0447*  	dl 0x0000F6 ; 105.469 4B, 0.964
0B0D73 F4 00 00    0448*  	dl 0x0000F4 ; 106.875 4C, 0.957
0B0D76 F3 00 00    0449*  	dl 0x0000F3 ; 108.281 4D, 0.950
0B0D79 F1 00 00    0450*  	dl 0x0000F1 ; 109.688 4E, 0.942
0B0D7C EE 00 00    0451*  	dl 0x0000EE ; 111.094 4F, 0.933
0B0D7F EC 00 00    0452*  	dl 0x0000EC ; 112.500 50, 0.924
0B0D82 EA 00 00    0453*  	dl 0x0000EA ; 113.906 51, 0.914
0B0D85 E7 00 00    0454*  	dl 0x0000E7 ; 115.313 52, 0.904
0B0D88 E4 00 00    0455*  	dl 0x0000E4 ; 116.719 53, 0.893
0B0D8B E1 00 00    0456*  	dl 0x0000E1 ; 118.125 54, 0.882
0B0D8E DE 00 00    0457*  	dl 0x0000DE ; 119.531 55, 0.870
0B0D91 DB 00 00    0458*  	dl 0x0000DB ; 120.938 56, 0.858
0B0D94 D8 00 00    0459*  	dl 0x0000D8 ; 122.344 57, 0.845
0B0D97 D4 00 00    0460*  	dl 0x0000D4 ; 123.750 58, 0.831
0B0D9A D1 00 00    0461*  	dl 0x0000D1 ; 125.156 59, 0.818
0B0D9D CD 00 00    0462*  	dl 0x0000CD ; 126.563 5A, 0.803
0B0DA0 C9 00 00    0463*  	dl 0x0000C9 ; 127.969 5B, 0.788
0B0DA3 C5 00 00    0464*  	dl 0x0000C5 ; 129.375 5C, 0.773
0B0DA6 C1 00 00    0465*  	dl 0x0000C1 ; 130.781 5D, 0.757
0B0DA9 BD 00 00    0466*  	dl 0x0000BD ; 132.188 5E, 0.741
0B0DAC B9 00 00    0467*  	dl 0x0000B9 ; 133.594 5F, 0.724
0B0DAF B5 00 00    0468*  	dl 0x0000B5 ; 135.000 60, 0.707
0B0DB2 B0 00 00    0469*  	dl 0x0000B0 ; 136.406 61, 0.690
0B0DB5 AB 00 00    0470*  	dl 0x0000AB ; 137.813 62, 0.672
0B0DB8 A7 00 00    0471*  	dl 0x0000A7 ; 139.219 63, 0.653
0B0DBB A2 00 00    0472*  	dl 0x0000A2 ; 140.625 64, 0.634
0B0DBE 9D 00 00    0473*  	dl 0x00009D ; 142.031 65, 0.615
0B0DC1 98 00 00    0474*  	dl 0x000098 ; 143.438 66, 0.596
0B0DC4 93 00 00    0475*  	dl 0x000093 ; 144.844 67, 0.576
0B0DC7 8E 00 00    0476*  	dl 0x00008E ; 146.250 68, 0.556
0B0DCA 88 00 00    0477*  	dl 0x000088 ; 147.656 69, 0.535
0B0DCD 83 00 00    0478*  	dl 0x000083 ; 149.063 6A, 0.514
0B0DD0 7E 00 00    0479*  	dl 0x00007E ; 150.469 6B, 0.493
0B0DD3 78 00 00    0480*  	dl 0x000078 ; 151.875 6C, 0.471
0B0DD6 73 00 00    0481*  	dl 0x000073 ; 153.281 6D, 0.450
0B0DD9 6D 00 00    0482*  	dl 0x00006D ; 154.688 6E, 0.428
0B0DDC 67 00 00    0483*  	dl 0x000067 ; 156.094 6F, 0.405
0B0DDF 61 00 00    0484*  	dl 0x000061 ; 157.500 70, 0.383
0B0DE2 5C 00 00    0485*  	dl 0x00005C ; 158.906 71, 0.360
0B0DE5 56 00 00    0486*  	dl 0x000056 ; 160.313 72, 0.337
0B0DE8 50 00 00    0487*  	dl 0x000050 ; 161.719 73, 0.314
0B0DEB 4A 00 00    0488*  	dl 0x00004A ; 163.125 74, 0.290
0B0DEE 44 00 00    0489*  	dl 0x000044 ; 164.531 75, 0.267
0B0DF1 3E 00 00    0490*  	dl 0x00003E ; 165.938 76, 0.243
0B0DF4 38 00 00    0491*  	dl 0x000038 ; 167.344 77, 0.219
0B0DF7 31 00 00    0492*  	dl 0x000031 ; 168.750 78, 0.195
0B0DFA 2B 00 00    0493*  	dl 0x00002B ; 170.156 79, 0.171
0B0DFD 25 00 00    0494*  	dl 0x000025 ; 171.563 7A, 0.147
0B0E00 1F 00 00    0495*  	dl 0x00001F ; 172.969 7B, 0.122
0B0E03 19 00 00    0496*  	dl 0x000019 ; 174.375 7C, 0.098
0B0E06 12 00 00    0497*  	dl 0x000012 ; 175.781 7D, 0.074
0B0E09 0C 00 00    0498*  	dl 0x00000C ; 177.188 7E, 0.049
0B0E0C 06 00 00    0499*  	dl 0x000006 ; 178.594 7F, 0.025
0B0E0F 00 00 00    0500*  	dl 0x000000 ; 180.000 80, 0.000
0B0E12 FA FF FF    0501*  	dl 0xFFFFFA ; 181.406 81, -0.025
0B0E15 F4 FF FF    0502*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0B0E18 EE FF FF    0503*  	dl 0xFFFFEE ; 184.219 83, -0.074
0B0E1B E7 FF FF    0504*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0B0E1E E1 FF FF    0505*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0B0E21 DB FF FF    0506*  	dl 0xFFFFDB ; 188.438 86, -0.147
0B0E24 D5 FF FF    0507*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0B0E27 CF FF FF    0508*  	dl 0xFFFFCF ; 191.250 88, -0.195
0B0E2A C8 FF FF    0509*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0B0E2D C2 FF FF    0510*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B0E30 BC FF FF    0511*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0B0E33 B6 FF FF    0512*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B0E36 B0 FF FF    0513*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B0E39 AA FF FF    0514*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0B0E3C A4 FF FF    0515*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B0E3F 9F FF FF    0516*  	dl 0xFFFF9F ; 202.500 90, -0.383
0B0E42 99 FF FF    0517*  	dl 0xFFFF99 ; 203.906 91, -0.405
0B0E45 93 FF FF    0518*  	dl 0xFFFF93 ; 205.313 92, -0.428
0B0E48 8D FF FF    0519*  	dl 0xFFFF8D ; 206.719 93, -0.450
0B0E4B 88 FF FF    0520*  	dl 0xFFFF88 ; 208.125 94, -0.471
0B0E4E 82 FF FF    0521*  	dl 0xFFFF82 ; 209.531 95, -0.493
0B0E51 7D FF FF    0522*  	dl 0xFFFF7D ; 210.938 96, -0.514
0B0E54 78 FF FF    0523*  	dl 0xFFFF78 ; 212.344 97, -0.535
0B0E57 72 FF FF    0524*  	dl 0xFFFF72 ; 213.750 98, -0.556
0B0E5A 6D FF FF    0525*  	dl 0xFFFF6D ; 215.156 99, -0.576
0B0E5D 68 FF FF    0526*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0B0E60 63 FF FF    0527*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0B0E63 5E FF FF    0528*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0B0E66 59 FF FF    0529*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0B0E69 55 FF FF    0530*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0B0E6C 50 FF FF    0531*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0B0E6F 4B FF FF    0532*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0B0E72 47 FF FF    0533*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0B0E75 43 FF FF    0534*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0B0E78 3F FF FF    0535*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0B0E7B 3B FF FF    0536*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0B0E7E 37 FF FF    0537*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0B0E81 33 FF FF    0538*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0B0E84 2F FF FF    0539*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0B0E87 2C FF FF    0540*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0B0E8A 28 FF FF    0541*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0B0E8D 25 FF FF    0542*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0B0E90 22 FF FF    0543*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0B0E93 1F FF FF    0544*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0B0E96 1C FF FF    0545*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0B0E99 19 FF FF    0546*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0B0E9C 16 FF FF    0547*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0B0E9F 14 FF FF    0548*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0B0EA2 12 FF FF    0549*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0B0EA5 0F FF FF    0550*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0B0EA8 0D FF FF    0551*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0B0EAB 0C FF FF    0552*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0B0EAE 0A FF FF    0553*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0B0EB1 08 FF FF    0554*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0B0EB4 07 FF FF    0555*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0B0EB7 05 FF FF    0556*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0B0EBA 04 FF FF    0557*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0B0EBD 03 FF FF    0558*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0B0EC0 02 FF FF    0559*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0B0EC3 02 FF FF    0560*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0B0EC6 01 FF FF    0561*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0B0EC9 01 FF FF    0562*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0B0ECC 01 FF FF    0563*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0B0ECF 00 FF FF    0564*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0B0ED2 01 FF FF    0565*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0B0ED5 01 FF FF    0566*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0B0ED8 01 FF FF    0567*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0B0EDB 02 FF FF    0568*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0B0EDE 02 FF FF    0569*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0B0EE1 03 FF FF    0570*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0B0EE4 04 FF FF    0571*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0B0EE7 05 FF FF    0572*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0B0EEA 07 FF FF    0573*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0B0EED 08 FF FF    0574*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0B0EF0 0A FF FF    0575*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0B0EF3 0C FF FF    0576*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0B0EF6 0D FF FF    0577*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0B0EF9 0F FF FF    0578*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0B0EFC 12 FF FF    0579*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0B0EFF 14 FF FF    0580*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0B0F02 16 FF FF    0581*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0B0F05 19 FF FF    0582*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0B0F08 1C FF FF    0583*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0B0F0B 1F FF FF    0584*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0B0F0E 22 FF FF    0585*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0B0F11 25 FF FF    0586*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0B0F14 28 FF FF    0587*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0B0F17 2C FF FF    0588*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0B0F1A 2F FF FF    0589*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0B0F1D 33 FF FF    0590*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0B0F20 37 FF FF    0591*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0B0F23 3B FF FF    0592*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0B0F26 3F FF FF    0593*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0B0F29 43 FF FF    0594*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0B0F2C 47 FF FF    0595*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0B0F2F 4B FF FF    0596*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0B0F32 50 FF FF    0597*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0B0F35 55 FF FF    0598*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0B0F38 59 FF FF    0599*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0B0F3B 5E FF FF    0600*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0B0F3E 63 FF FF    0601*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0B0F41 68 FF FF    0602*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0B0F44 6D FF FF    0603*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0B0F47 72 FF FF    0604*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0B0F4A 78 FF FF    0605*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0B0F4D 7D FF FF    0606*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0B0F50 82 FF FF    0607*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0B0F53 88 FF FF    0608*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0B0F56 8D FF FF    0609*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0B0F59 93 FF FF    0610*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0B0F5C 99 FF FF    0611*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0B0F5F 9F FF FF    0612*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0B0F62 A4 FF FF    0613*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B0F65 AA FF FF    0614*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0B0F68 B0 FF FF    0615*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B0F6B B6 FF FF    0616*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B0F6E BC FF FF    0617*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0B0F71 C2 FF FF    0618*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B0F74 C8 FF FF    0619*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B0F77 CF FF FF    0620*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0B0F7A D5 FF FF    0621*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B0F7D DB FF FF    0622*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0B0F80 E1 FF FF    0623*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B0F83 E7 FF FF    0624*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B0F86 EE FF FF    0625*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0B0F89 F4 FF FF    0626*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B0F8C FA FF FF    0627*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0B0F8F             0628*  
0B0F8F             0629*  atan_lut_168:
0B0F8F 00 00 00    0630*  	dl 0x000000 ; 000000, 0.000
0B0F92 28 00 00    0631*  	dl 0x000028 ; 000001, 0.224
0B0F95 51 00 00    0632*  	dl 0x000051 ; 000002, 0.448
0B0F98 7A 00 00    0633*  	dl 0x00007A ; 000003, 0.671
0B0F9B A2 00 00    0634*  	dl 0x0000A2 ; 000004, 0.895
0B0F9E CB 00 00    0635*  	dl 0x0000CB ; 000005, 1.119
0B0FA1 F4 00 00    0636*  	dl 0x0000F4 ; 000006, 1.343
0B0FA4 1D 01 00    0637*  	dl 0x00011D ; 000007, 1.566
0B0FA7 45 01 00    0638*  	dl 0x000145 ; 000008, 1.790
0B0FAA 6E 01 00    0639*  	dl 0x00016E ; 000009, 2.013
0B0FAD 97 01 00    0640*  	dl 0x000197 ; 00000A, 2.237
0B0FB0 BF 01 00    0641*  	dl 0x0001BF ; 00000B, 2.460
0B0FB3 E8 01 00    0642*  	dl 0x0001E8 ; 00000C, 2.684
0B0FB6 11 02 00    0643*  	dl 0x000211 ; 00000D, 2.907
0B0FB9 39 02 00    0644*  	dl 0x000239 ; 00000E, 3.130
0B0FBC 62 02 00    0645*  	dl 0x000262 ; 00000F, 3.353
0B0FBF 8B 02 00    0646*  	dl 0x00028B ; 000010, 3.576
0B0FC2 B3 02 00    0647*  	dl 0x0002B3 ; 000011, 3.799
0B0FC5 DC 02 00    0648*  	dl 0x0002DC ; 000012, 4.022
0B0FC8 04 03 00    0649*  	dl 0x000304 ; 000013, 4.245
0B0FCB 2D 03 00    0650*  	dl 0x00032D ; 000014, 4.467
0B0FCE 55 03 00    0651*  	dl 0x000355 ; 000015, 4.690
0B0FD1 7E 03 00    0652*  	dl 0x00037E ; 000016, 4.912
0B0FD4 A6 03 00    0653*  	dl 0x0003A6 ; 000017, 5.134
0B0FD7 CE 03 00    0654*  	dl 0x0003CE ; 000018, 5.356
0B0FDA F7 03 00    0655*  	dl 0x0003F7 ; 000019, 5.578
0B0FDD 1F 04 00    0656*  	dl 0x00041F ; 00001A, 5.799
0B0FE0 48 04 00    0657*  	dl 0x000448 ; 00001B, 6.021
0B0FE3 70 04 00    0658*  	dl 0x000470 ; 00001C, 6.242
0B0FE6 98 04 00    0659*  	dl 0x000498 ; 00001D, 6.463
0B0FE9 C0 04 00    0660*  	dl 0x0004C0 ; 00001E, 6.684
0B0FEC E8 04 00    0661*  	dl 0x0004E8 ; 00001F, 6.905
0B0FEF 11 05 00    0662*  	dl 0x000511 ; 000020, 7.125
0B0FF2 39 05 00    0663*  	dl 0x000539 ; 000021, 7.345
0B0FF5 61 05 00    0664*  	dl 0x000561 ; 000022, 7.565
0B0FF8 89 05 00    0665*  	dl 0x000589 ; 000023, 7.785
0B0FFB B1 05 00    0666*  	dl 0x0005B1 ; 000024, 8.005
0B0FFE D9 05 00    0667*  	dl 0x0005D9 ; 000025, 8.224
0B1001 01 06 00    0668*  	dl 0x000601 ; 000026, 8.443
0B1004 28 06 00    0669*  	dl 0x000628 ; 000027, 8.662
0B1007 50 06 00    0670*  	dl 0x000650 ; 000028, 8.881
0B100A 78 06 00    0671*  	dl 0x000678 ; 000029, 9.099
0B100D A0 06 00    0672*  	dl 0x0006A0 ; 00002A, 9.317
0B1010 C7 06 00    0673*  	dl 0x0006C7 ; 00002B, 9.535
0B1013 EF 06 00    0674*  	dl 0x0006EF ; 00002C, 9.752
0B1016 16 07 00    0675*  	dl 0x000716 ; 00002D, 9.970
0B1019 3E 07 00    0676*  	dl 0x00073E ; 00002E, 10.187
0B101C 65 07 00    0677*  	dl 0x000765 ; 00002F, 10.403
0B101F 8D 07 00    0678*  	dl 0x00078D ; 000030, 10.620
0B1022 B4 07 00    0679*  	dl 0x0007B4 ; 000031, 10.836
0B1025 DB 07 00    0680*  	dl 0x0007DB ; 000032, 11.051
0B1028 03 08 00    0681*  	dl 0x000803 ; 000033, 11.267
0B102B 2A 08 00    0682*  	dl 0x00082A ; 000034, 11.482
0B102E 51 08 00    0683*  	dl 0x000851 ; 000035, 11.697
0B1031 78 08 00    0684*  	dl 0x000878 ; 000036, 11.911
0B1034 9F 08 00    0685*  	dl 0x00089F ; 000037, 12.125
0B1037 C6 08 00    0686*  	dl 0x0008C6 ; 000038, 12.339
0B103A ED 08 00    0687*  	dl 0x0008ED ; 000039, 12.553
0B103D 13 09 00    0688*  	dl 0x000913 ; 00003A, 12.766
0B1040 3A 09 00    0689*  	dl 0x00093A ; 00003B, 12.978
0B1043 61 09 00    0690*  	dl 0x000961 ; 00003C, 13.191
0B1046 87 09 00    0691*  	dl 0x000987 ; 00003D, 13.403
0B1049 AE 09 00    0692*  	dl 0x0009AE ; 00003E, 13.614
0B104C D4 09 00    0693*  	dl 0x0009D4 ; 00003F, 13.825
0B104F FB 09 00    0694*  	dl 0x0009FB ; 000040, 14.036
0B1052 21 0A 00    0695*  	dl 0x000A21 ; 000041, 14.247
0B1055 47 0A 00    0696*  	dl 0x000A47 ; 000042, 14.457
0B1058 6D 0A 00    0697*  	dl 0x000A6D ; 000043, 14.666
0B105B 94 0A 00    0698*  	dl 0x000A94 ; 000044, 14.876
0B105E BA 0A 00    0699*  	dl 0x000ABA ; 000045, 15.085
0B1061 E0 0A 00    0700*  	dl 0x000AE0 ; 000046, 15.293
0B1064 05 0B 00    0701*  	dl 0x000B05 ; 000047, 15.501
0B1067 2B 0B 00    0702*  	dl 0x000B2B ; 000048, 15.709
0B106A 51 0B 00    0703*  	dl 0x000B51 ; 000049, 15.916
0B106D 77 0B 00    0704*  	dl 0x000B77 ; 00004A, 16.123
0B1070 9C 0B 00    0705*  	dl 0x000B9C ; 00004B, 16.329
0B1073 C2 0B 00    0706*  	dl 0x000BC2 ; 00004C, 16.535
0B1076 E7 0B 00    0707*  	dl 0x000BE7 ; 00004D, 16.740
0B1079 0C 0C 00    0708*  	dl 0x000C0C ; 00004E, 16.945
0B107C 32 0C 00    0709*  	dl 0x000C32 ; 00004F, 17.150
0B107F 57 0C 00    0710*  	dl 0x000C57 ; 000050, 17.354
0B1082 7C 0C 00    0711*  	dl 0x000C7C ; 000051, 17.558
0B1085 A1 0C 00    0712*  	dl 0x000CA1 ; 000052, 17.761
0B1088 C6 0C 00    0713*  	dl 0x000CC6 ; 000053, 17.964
0B108B EB 0C 00    0714*  	dl 0x000CEB ; 000054, 18.166
0B108E 0F 0D 00    0715*  	dl 0x000D0F ; 000055, 18.368
0B1091 34 0D 00    0716*  	dl 0x000D34 ; 000056, 18.569
0B1094 58 0D 00    0717*  	dl 0x000D58 ; 000057, 18.770
0B1097 7D 0D 00    0718*  	dl 0x000D7D ; 000058, 18.970
0B109A A1 0D 00    0719*  	dl 0x000DA1 ; 000059, 19.170
0B109D C6 0D 00    0720*  	dl 0x000DC6 ; 00005A, 19.370
0B10A0 EA 0D 00    0721*  	dl 0x000DEA ; 00005B, 19.569
0B10A3 0E 0E 00    0722*  	dl 0x000E0E ; 00005C, 19.767
0B10A6 32 0E 00    0723*  	dl 0x000E32 ; 00005D, 19.965
0B10A9 56 0E 00    0724*  	dl 0x000E56 ; 00005E, 20.163
0B10AC 7A 0E 00    0725*  	dl 0x000E7A ; 00005F, 20.360
0B10AF 9E 0E 00    0726*  	dl 0x000E9E ; 000060, 20.556
0B10B2 C1 0E 00    0727*  	dl 0x000EC1 ; 000061, 20.752
0B10B5 E5 0E 00    0728*  	dl 0x000EE5 ; 000062, 20.947
0B10B8 08 0F 00    0729*  	dl 0x000F08 ; 000063, 21.142
0B10BB 2C 0F 00    0730*  	dl 0x000F2C ; 000064, 21.337
0B10BE 4F 0F 00    0731*  	dl 0x000F4F ; 000065, 21.531
0B10C1 72 0F 00    0732*  	dl 0x000F72 ; 000066, 21.724
0B10C4 95 0F 00    0733*  	dl 0x000F95 ; 000067, 21.917
0B10C7 B8 0F 00    0734*  	dl 0x000FB8 ; 000068, 22.109
0B10CA DB 0F 00    0735*  	dl 0x000FDB ; 000069, 22.301
0B10CD FE 0F 00    0736*  	dl 0x000FFE ; 00006A, 22.493
0B10D0 21 10 00    0737*  	dl 0x001021 ; 00006B, 22.683
0B10D3 44 10 00    0738*  	dl 0x001044 ; 00006C, 22.874
0B10D6 66 10 00    0739*  	dl 0x001066 ; 00006D, 23.063
0B10D9 89 10 00    0740*  	dl 0x001089 ; 00006E, 23.253
0B10DC AB 10 00    0741*  	dl 0x0010AB ; 00006F, 23.441
0B10DF CD 10 00    0742*  	dl 0x0010CD ; 000070, 23.629
0B10E2 EF 10 00    0743*  	dl 0x0010EF ; 000071, 23.817
0B10E5 11 11 00    0744*  	dl 0x001111 ; 000072, 24.004
0B10E8 33 11 00    0745*  	dl 0x001133 ; 000073, 24.191
0B10EB 55 11 00    0746*  	dl 0x001155 ; 000074, 24.376
0B10EE 77 11 00    0747*  	dl 0x001177 ; 000075, 24.562
0B10F1 99 11 00    0748*  	dl 0x001199 ; 000076, 24.747
0B10F4 BA 11 00    0749*  	dl 0x0011BA ; 000077, 24.931
0B10F7 DC 11 00    0750*  	dl 0x0011DC ; 000078, 25.115
0B10FA FD 11 00    0751*  	dl 0x0011FD ; 000079, 25.298
0B10FD 1E 12 00    0752*  	dl 0x00121E ; 00007A, 25.481
0B1100 3F 12 00    0753*  	dl 0x00123F ; 00007B, 25.663
0B1103 60 12 00    0754*  	dl 0x001260 ; 00007C, 25.844
0B1106 81 12 00    0755*  	dl 0x001281 ; 00007D, 26.025
0B1109 A2 12 00    0756*  	dl 0x0012A2 ; 00007E, 26.206
0B110C C3 12 00    0757*  	dl 0x0012C3 ; 00007F, 26.386
0B110F E4 12 00    0758*  	dl 0x0012E4 ; 000080, 26.565
0B1112 04 13 00    0759*  	dl 0x001304 ; 000081, 26.744
0B1115 25 13 00    0760*  	dl 0x001325 ; 000082, 26.922
0B1118 45 13 00    0761*  	dl 0x001345 ; 000083, 27.100
0B111B 65 13 00    0762*  	dl 0x001365 ; 000084, 27.277
0B111E 85 13 00    0763*  	dl 0x001385 ; 000085, 27.453
0B1121 A5 13 00    0764*  	dl 0x0013A5 ; 000086, 27.629
0B1124 C5 13 00    0765*  	dl 0x0013C5 ; 000087, 27.805
0B1127 E5 13 00    0766*  	dl 0x0013E5 ; 000088, 27.979
0B112A 05 14 00    0767*  	dl 0x001405 ; 000089, 28.154
0B112D 24 14 00    0768*  	dl 0x001424 ; 00008A, 28.327
0B1130 44 14 00    0769*  	dl 0x001444 ; 00008B, 28.501
0B1133 63 14 00    0770*  	dl 0x001463 ; 00008C, 28.673
0B1136 83 14 00    0771*  	dl 0x001483 ; 00008D, 28.845
0B1139 A2 14 00    0772*  	dl 0x0014A2 ; 00008E, 29.017
0B113C C1 14 00    0773*  	dl 0x0014C1 ; 00008F, 29.187
0B113F E0 14 00    0774*  	dl 0x0014E0 ; 000090, 29.358
0B1142 FF 14 00    0775*  	dl 0x0014FF ; 000091, 29.527
0B1145 1E 15 00    0776*  	dl 0x00151E ; 000092, 29.697
0B1148 3C 15 00    0777*  	dl 0x00153C ; 000093, 29.865
0B114B 5B 15 00    0778*  	dl 0x00155B ; 000094, 30.033
0B114E 79 15 00    0779*  	dl 0x001579 ; 000095, 30.201
0B1151 98 15 00    0780*  	dl 0x001598 ; 000096, 30.368
0B1154 B6 15 00    0781*  	dl 0x0015B6 ; 000097, 30.534
0B1157 D4 15 00    0782*  	dl 0x0015D4 ; 000098, 30.700
0B115A F2 15 00    0783*  	dl 0x0015F2 ; 000099, 30.865
0B115D 10 16 00    0784*  	dl 0x001610 ; 00009A, 31.030
0B1160 2E 16 00    0785*  	dl 0x00162E ; 00009B, 31.194
0B1163 4C 16 00    0786*  	dl 0x00164C ; 00009C, 31.357
0B1166 6A 16 00    0787*  	dl 0x00166A ; 00009D, 31.520
0B1169 87 16 00    0788*  	dl 0x001687 ; 00009E, 31.682
0B116C A5 16 00    0789*  	dl 0x0016A5 ; 00009F, 31.844
0B116F C2 16 00    0790*  	dl 0x0016C2 ; 0000A0, 32.005
0B1172 DF 16 00    0791*  	dl 0x0016DF ; 0000A1, 32.166
0B1175 FC 16 00    0792*  	dl 0x0016FC ; 0000A2, 32.326
0B1178 19 17 00    0793*  	dl 0x001719 ; 0000A3, 32.486
0B117B 36 17 00    0794*  	dl 0x001736 ; 0000A4, 32.645
0B117E 53 17 00    0795*  	dl 0x001753 ; 0000A5, 32.803
0B1181 70 17 00    0796*  	dl 0x001770 ; 0000A6, 32.961
0B1184 8C 17 00    0797*  	dl 0x00178C ; 0000A7, 33.118
0B1187 A9 17 00    0798*  	dl 0x0017A9 ; 0000A8, 33.275
0B118A C5 17 00    0799*  	dl 0x0017C5 ; 0000A9, 33.431
0B118D E2 17 00    0800*  	dl 0x0017E2 ; 0000AA, 33.587
0B1190 FE 17 00    0801*  	dl 0x0017FE ; 0000AB, 33.742
0B1193 1A 18 00    0802*  	dl 0x00181A ; 0000AC, 33.896
0B1196 36 18 00    0803*  	dl 0x001836 ; 0000AD, 34.050
0B1199 52 18 00    0804*  	dl 0x001852 ; 0000AE, 34.203
0B119C 6E 18 00    0805*  	dl 0x00186E ; 0000AF, 34.356
0B119F 8A 18 00    0806*  	dl 0x00188A ; 0000B0, 34.509
0B11A2 A5 18 00    0807*  	dl 0x0018A5 ; 0000B1, 34.660
0B11A5 C1 18 00    0808*  	dl 0x0018C1 ; 0000B2, 34.811
0B11A8 DC 18 00    0809*  	dl 0x0018DC ; 0000B3, 34.962
0B11AB F7 18 00    0810*  	dl 0x0018F7 ; 0000B4, 35.112
0B11AE 13 19 00    0811*  	dl 0x001913 ; 0000B5, 35.262
0B11B1 2E 19 00    0812*  	dl 0x00192E ; 0000B6, 35.410
0B11B4 49 19 00    0813*  	dl 0x001949 ; 0000B7, 35.559
0B11B7 64 19 00    0814*  	dl 0x001964 ; 0000B8, 35.707
0B11BA 7F 19 00    0815*  	dl 0x00197F ; 0000B9, 35.854
0B11BD 99 19 00    0816*  	dl 0x001999 ; 0000BA, 36.001
0B11C0 B4 19 00    0817*  	dl 0x0019B4 ; 0000BB, 36.147
0B11C3 CE 19 00    0818*  	dl 0x0019CE ; 0000BC, 36.293
0B11C6 E9 19 00    0819*  	dl 0x0019E9 ; 0000BD, 36.438
0B11C9 03 1A 00    0820*  	dl 0x001A03 ; 0000BE, 36.582
0B11CC 1D 1A 00    0821*  	dl 0x001A1D ; 0000BF, 36.726
0B11CF 37 1A 00    0822*  	dl 0x001A37 ; 0000C0, 36.870
0B11D2 51 1A 00    0823*  	dl 0x001A51 ; 0000C1, 37.013
0B11D5 6B 1A 00    0824*  	dl 0x001A6B ; 0000C2, 37.155
0B11D8 85 1A 00    0825*  	dl 0x001A85 ; 0000C3, 37.297
0B11DB 9F 1A 00    0826*  	dl 0x001A9F ; 0000C4, 37.439
0B11DE B9 1A 00    0827*  	dl 0x001AB9 ; 0000C5, 37.579
0B11E1 D2 1A 00    0828*  	dl 0x001AD2 ; 0000C6, 37.720
0B11E4 EC 1A 00    0829*  	dl 0x001AEC ; 0000C7, 37.859
0B11E7 05 1B 00    0830*  	dl 0x001B05 ; 0000C8, 37.999
0B11EA 1E 1B 00    0831*  	dl 0x001B1E ; 0000C9, 38.137
0B11ED 37 1B 00    0832*  	dl 0x001B37 ; 0000CA, 38.276
0B11F0 50 1B 00    0833*  	dl 0x001B50 ; 0000CB, 38.413
0B11F3 69 1B 00    0834*  	dl 0x001B69 ; 0000CC, 38.550
0B11F6 82 1B 00    0835*  	dl 0x001B82 ; 0000CD, 38.687
0B11F9 9B 1B 00    0836*  	dl 0x001B9B ; 0000CE, 38.823
0B11FC B4 1B 00    0837*  	dl 0x001BB4 ; 0000CF, 38.959
0B11FF CC 1B 00    0838*  	dl 0x001BCC ; 0000D0, 39.094
0B1202 E5 1B 00    0839*  	dl 0x001BE5 ; 0000D1, 39.228
0B1205 FD 1B 00    0840*  	dl 0x001BFD ; 0000D2, 39.362
0B1208 16 1C 00    0841*  	dl 0x001C16 ; 0000D3, 39.496
0B120B 2E 1C 00    0842*  	dl 0x001C2E ; 0000D4, 39.629
0B120E 46 1C 00    0843*  	dl 0x001C46 ; 0000D5, 39.762
0B1211 5E 1C 00    0844*  	dl 0x001C5E ; 0000D6, 39.894
0B1214 76 1C 00    0845*  	dl 0x001C76 ; 0000D7, 40.025
0B1217 8E 1C 00    0846*  	dl 0x001C8E ; 0000D8, 40.156
0B121A A5 1C 00    0847*  	dl 0x001CA5 ; 0000D9, 40.286
0B121D BD 1C 00    0848*  	dl 0x001CBD ; 0000DA, 40.416
0B1220 D5 1C 00    0849*  	dl 0x001CD5 ; 0000DB, 40.546
0B1223 EC 1C 00    0850*  	dl 0x001CEC ; 0000DC, 40.675
0B1226 04 1D 00    0851*  	dl 0x001D04 ; 0000DD, 40.803
0B1229 1B 1D 00    0852*  	dl 0x001D1B ; 0000DE, 40.931
0B122C 32 1D 00    0853*  	dl 0x001D32 ; 0000DF, 41.059
0B122F 49 1D 00    0854*  	dl 0x001D49 ; 0000E0, 41.186
0B1232 60 1D 00    0855*  	dl 0x001D60 ; 0000E1, 41.312
0B1235 77 1D 00    0856*  	dl 0x001D77 ; 0000E2, 41.438
0B1238 8E 1D 00    0857*  	dl 0x001D8E ; 0000E3, 41.564
0B123B A5 1D 00    0858*  	dl 0x001DA5 ; 0000E4, 41.689
0B123E BB 1D 00    0859*  	dl 0x001DBB ; 0000E5, 41.814
0B1241 D2 1D 00    0860*  	dl 0x001DD2 ; 0000E6, 41.938
0B1244 E9 1D 00    0861*  	dl 0x001DE9 ; 0000E7, 42.061
0B1247 FF 1D 00    0862*  	dl 0x001DFF ; 0000E8, 42.184
0B124A 15 1E 00    0863*  	dl 0x001E15 ; 0000E9, 42.307
0B124D 2C 1E 00    0864*  	dl 0x001E2C ; 0000EA, 42.429
0B1250 42 1E 00    0865*  	dl 0x001E42 ; 0000EB, 42.551
0B1253 58 1E 00    0866*  	dl 0x001E58 ; 0000EC, 42.672
0B1256 6E 1E 00    0867*  	dl 0x001E6E ; 0000ED, 42.793
0B1259 84 1E 00    0868*  	dl 0x001E84 ; 0000EE, 42.913
0B125C 99 1E 00    0869*  	dl 0x001E99 ; 0000EF, 43.033
0B125F AF 1E 00    0870*  	dl 0x001EAF ; 0000F0, 43.152
0B1262 C5 1E 00    0871*  	dl 0x001EC5 ; 0000F1, 43.271
0B1265 DA 1E 00    0872*  	dl 0x001EDA ; 0000F2, 43.390
0B1268 F0 1E 00    0873*  	dl 0x001EF0 ; 0000F3, 43.508
0B126B 05 1F 00    0874*  	dl 0x001F05 ; 0000F4, 43.625
0B126E 1B 1F 00    0875*  	dl 0x001F1B ; 0000F5, 43.742
0B1271 30 1F 00    0876*  	dl 0x001F30 ; 0000F6, 43.859
0B1274 45 1F 00    0877*  	dl 0x001F45 ; 0000F7, 43.975
0B1277 5A 1F 00    0878*  	dl 0x001F5A ; 0000F8, 44.091
0B127A 6F 1F 00    0879*  	dl 0x001F6F ; 0000F9, 44.206
0B127D 84 1F 00    0880*  	dl 0x001F84 ; 0000FA, 44.321
0B1280 99 1F 00    0881*  	dl 0x001F99 ; 0000FB, 44.435
0B1283 AD 1F 00    0882*  	dl 0x001FAD ; 0000FC, 44.549
0B1286 C2 1F 00    0883*  	dl 0x001FC2 ; 0000FD, 44.662
0B1289 D7 1F 00    0884*  	dl 0x001FD7 ; 0000FE, 44.775
0B128C EB 1F 00    0885*  	dl 0x001FEB ; 0000FF, 44.888
0B128F 00 20 00    0886*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B1292             0023       include "files.inc"
0B1292             0001*  ; load to onboard 8k sram
0B1292             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0B1292             0024       include "timer.inc"
0B1292             0001*  ; Table 32. Timer Control Registers
0B1292             0002*  ; this constant is the base address of the timer control registers
0B1292             0003*  ; each timer takes three bytes:
0B1292             0004*  ;   0: control register
0B1292             0005*  ;   1: low byte of timer reset value
0B1292             0006*  ;   2: high byte of timer reset value
0B1292             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0B1292             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0B1292             0009*  TMR_CTL:     equ 80h
0B1292             0010*  
0B1292             0011*  ; Timer Control Register Bit Definitions
0B1292             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0B1292             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0B1292             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0B1292             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0B1292             0016*                              ; the TMRx_CTL register is read.
0B1292             0017*  
0B1292             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0B1292             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0B1292             0020*  
0B1292             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0B1292             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0B1292             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0B1292             0024*                              ; written to the counter when the end-of-count value is reached.
0B1292             0025*  
0B1292             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0B1292             0027*  CLK_DIV_256:  equ %00001100 ;
0B1292             0028*  CLK_DIV_64:   equ %00001000 ;
0B1292             0029*  CLK_DIV_16:   equ %00000100 ;
0B1292             0030*  CLK_DIV_4:    equ %00000000 ;
0B1292             0031*  
0B1292             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0B1292             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0B1292             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0B1292             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0B1292             0036*                              ; programmer must ensure that this bit is set to 1 each time
0B1292             0037*                              ; SINGLE-PASS mode is used.
0B1292             0038*  
0B1292             0039*  ; disable/enable the programmable reload timer
0B1292             0040*  PRT_EN_0:     equ %00000000 ;
0B1292             0041*  PRT_EN_1:     equ %00000001 ;
0B1292             0042*  
0B1292             0043*  ; Table 37. Timer Input Source Select Register
0B1292             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0B1292             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0B1292             0046*  ;   00: System clock / CLK_DIV
0B1292             0047*  ;   01: RTC / CLK_DIV
0B1292             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0B1292             0049*  ;   10: GPIO port B pin 1.
0B1292             0050*  ;   11: GPIO port B pin 1.
0B1292             0051*  TMR_ISS:   equ 92h ; register address
0B1292             0052*  
0B1292             0053*  ; Table 51. Real-Time Clock Control Register
0B1292             0054*  RTC_CTRL: equ EDh ; register address
0B1292             0055*  
0B1292             0056*  ; alarm interrupt disable/enable
0B1292             0057*  RTC_ALARM_0:    equ %00000000
0B1292             0058*  RTC_ALARM_1:    equ %10000000
0B1292             0059*  
0B1292             0060*  ; interrupt on alarm disable/enable
0B1292             0061*  RTC_INT_ENT_0:  equ %00000000
0B1292             0062*  RTC_INT_ENT_1:  equ %01000000
0B1292             0063*  
0B1292             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0B1292             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0B1292             0066*  
0B1292             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0B1292             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0B1292             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0B1292             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0B1292             0071*  
0B1292             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0B1292             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0B1292             0074*  
0B1292             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0B1292             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0B1292             0077*  
0B1292             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0B1292             0079*                                  ; RTC counter is enabled.
0B1292             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0B1292             0081*                                  ; RTC counter is disabled.
0B1292             0082*  
0B1292             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0B1292             0084*  
0B1292             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0B1292             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0B1292 00 00 00    0087*  prt_reload: dl 0x000000
0B1295             0088*  
0B1295             0089*  ; ; returns: a = 0 if running on hardware,1 if running on emulator
0B1295             0090*  ; ;          de = number PRT interrupts during test interval
0B1295             0091*  ; prt_calibrate:
0B1295             0092*  ;     call vdu_vblank
0B1295             0093*  ; ; set a MOS timer
0B1295             0094*  ;     ld hl,120*1 ; 1 second
0B1295             0095*  ;     ld iy,tmr_test
0B1295             0096*  ;     call tmr_set
0B1295             0097*  ; ; set a PRT timer
0B1295             0098*  ;     ; ld hl,prt_reload_hardware
0B1295             0099*  ;     ; ld hl,prt_reload_emulator
0B1295             0100*  ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
0B1295             0101*  ;     ld (prt_reload),hl
0B1295             0102*  ;     call prt_set
0B1295             0103*  ; @loop:
0B1295             0104*  ; ; check time remaining on MOS timer
0B1295             0105*  ;     call tmr_get
0B1295             0106*  ;     jp z,@done ; time expired,so quit
0B1295             0107*  ;     jp m,@done ; time past expiration (negative),so quit
0B1295             0108*  ;     jr @loop
0B1295             0109*  ; @done:
0B1295             0110*  ;     ld de,(prt_irq_counter)
0B1295             0111*  ;     ld bc,prt_reload_hardware ; default value for running on hardware
0B1295             0112*  ;     ld (prt_reload),bc
0B1295             0113*  ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0B1295             0114*  ;     xor a ; clear carry,zero is default value for running on hardware
0B1295             0115*  ;     ld (is_emulator),a
0B1295             0116*  ;     sbc hl,de
0B1295             0117*  ;     ld hl,on_hardware ; default message for running on hardware
0B1295             0118*  ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
0B1295             0119*  ;     ret m ; negative result means we're on hardware
0B1295             0120*  ;     inc a ; we're on emulator
0B1295             0121*  ;     ld (is_emulator),a
0B1295             0122*  ;     ld bc,prt_reload_emulator
0B1295             0123*  ;     ld (prt_reload),bc
0B1295             0124*  ;     ld hl,on_emulator
0B1295             0125*  ;     ret
0B1295             0126*  
0B1295             0127*  ; calibrating_timer: defb "Calibrating timer\r\n",0
0B1295             0128*  
0B1295             0129*  ; set PRT timer
0B1295             0130*  prt_set:
0B1295 21 00 00 00 0131*      ld hl,0
0B1299 22 E3 12 0B 0132*      ld (prt_irq_counter),hl
0B129D 2A 92 12 0B 0133*      ld hl,(prt_reload)
0B12A1 ED 29 84    0134*      out0 ($84),l
0B12A4 ED 21 85    0135*  	out0 ($85),h
0B12A7             0136*  ; disable timer
0B12A7 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0B12A9 ED 39 83    0138*  	out0 ($83),a
0B12AC             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0B12AC 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0B12AE ED 39 83    0141*  	out0 ($83),a
0B12B1 C9          0142*      ret
0B12B2             0143*  
0B12B2             0144*  ; ===============================================
0B12B2             0145*  ; PRT Timer Interrupt Handling
0B12B2             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0B12B2             0147*  ; -----------------------------------------------
0B12B2             0148*  prt_irq_init:
0B12B2             0149*      ; set up interrupt vector table 2
0B12B2 21 00 00 00 0150*  	ld hl,0
0B12B6 3A 0C 01 00 0151*  	ld a,($10c)
0B12BA 6F          0152*  	ld l,a
0B12BB 3A 0D 01 00 0153*  	ld a,($10d)
0B12BF 67          0154*  	ld h,a
0B12C0             0155*  
0B12C0             0156*  	; skip over CALL ($c3)
0B12C0 23          0157*  	inc hl
0B12C1             0158*  	; load address of jump into vector table 2 (in ram)
0B12C1 ED 27       0159*  	ld hl,(hl)
0B12C3             0160*  
0B12C3             0161*  	; write CALL prt_irq_handler to vector table 2
0B12C3 3E C3       0162*  	ld a,$c3
0B12C5 77          0163*  	ld (hl),a
0B12C6 23          0164*  	inc hl
0B12C7 11 CE 12 0B 0165*  	ld de,prt_irq_handler
0B12CB ED 1F       0166*  	ld (hl),de
0B12CD             0167*  
0B12CD C9          0168*      ret
0B12CE             0169*  
0B12CE             0170*  prt_irq_handler:
0B12CE F3          0171*  	di
0B12CF F5          0172*  	push af
0B12D0 E5          0173*      push hl
0B12D1 ED 38 83    0174*  	in0 a,($83)
0B12D4 2A E3 12 0B 0175*  	ld hl,(prt_irq_counter)
0B12D8 23          0176*  	inc hl
0B12D9 22 E3 12 0B 0177*  	ld (prt_irq_counter),hl
0B12DD E1          0178*      pop hl
0B12DE F1          0179*  	pop af
0B12DF FB          0180*  	ei
0B12E0 5B ED 4D    0181*  	reti.l
0B12E3             0182*  
0B12E3             0183*  prt_irq_counter:
0B12E3 00 00 00    0184*  	.dl 0
0B12E6             0185*  prt_irq_counter_saved:
0B12E6 00 00 00    0186*      .dl 0
0B12E9             0187*  
0B12E9             0188*  prt_loop_reset:
0B12E9 E5          0189*      push hl
0B12EA 21 00 00 00 0190*  	ld hl,0
0B12EE 22 E3 12 0B 0191*  	ld (prt_irq_counter),hl
0B12F2 22 54 13 0B 0192*      ld (prt_loop_counter),hl
0B12F6 22 57 13 0B 0193*      ld (prt_loops),hl
0B12FA CD 95 12 0B 0194*      call prt_set
0B12FE E1          0195*      pop hl
0B12FF C9          0196*      ret
0B1300             0197*  
0B1300             0198*  prt_loop_start:
0B1300 E5          0199*      push hl
0B1301 21 00 00 00 0200*  	ld hl,0
0B1305 22 E3 12 0B 0201*  	ld (prt_irq_counter),hl
0B1309 E1          0202*      pop hl
0B130A C9          0203*      ret
0B130B             0204*  
0B130B             0205*  prt_loop_stop:
0B130B E5          0206*      push hl
0B130C D5          0207*      push de
0B130D 2A E3 12 0B 0208*      ld hl,(prt_irq_counter)
0B1311 ED 5B 54 13 0209*      ld de,(prt_loop_counter)
       0B          
0B1316 19          0210*      add hl,de
0B1317 22 54 13 0B 0211*      ld (prt_loop_counter),hl
0B131B 21 00 00 00 0212*      ld hl,0
0B131F 22 E3 12 0B 0213*      ld (prt_irq_counter),hl
0B1323 2A 57 13 0B 0214*      ld hl,(prt_loops)
0B1327 23          0215*      inc hl
0B1328 22 57 13 0B 0216*      ld (prt_loops),hl
0B132C D1          0217*      pop de
0B132D E1          0218*      pop hl
0B132E C9          0219*      ret
0B132F             0220*  
0B132F             0221*  ; inputs: bc = y,x text coordinates to print
0B132F             0222*  prt_loop_print:
0B132F F5          0223*      push af
0B1330 E5          0224*      push hl
0B1331 C5          0225*      push bc
0B1332 D5          0226*      push de
0B1333 DD E5       0227*      push ix
0B1335 FD E5       0228*      push iy
0B1337 CD 4C 14 0B 0229*      call vdu_move_cursor
0B133B             0230*  
0B133B 2A 54 13 0B 0231*      ld hl,(prt_loop_counter)
0B133F CD 2B 03 0B 0232*      call printDec
0B1343             0233*  
0B1343 2A 57 13 0B 0234*      ld hl,(prt_loops)
0B1347 CD 2B 03 0B 0235*      call printDec
0B134B             0236*  
0B134B FD E1       0237*      pop iy
0B134D DD E1       0238*      pop ix
0B134F D1          0239*      pop de
0B1350 C1          0240*      pop bc
0B1351 E1          0241*      pop hl
0B1352 F1          0242*      pop af
0B1353 C9          0243*      ret
0B1354             0244*  
0B1354             0245*  prt_loop_counter:
0B1354 00 00 00    0246*      .dl 0
0B1357             0247*  prt_loops:
0B1357 00 00 00    0248*      .dl 0
0B135A             0249*  
0B135A             0250*  ; ===============================================
0B135A             0251*  ; Timer functions
0B135A             0252*  ; -----------------------------------------------
0B135A             0253*  ; set a countdown timer
0B135A             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B135A             0255*  ; returns: hl = current time
0B135A             0256*  tmr_set:
0B135A FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
0B135D             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
0B135D 3E 08       0001*M 			LD	A, function
0B135F 5B CF       0002*M 			RST.L	08h
0B1361 DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
0B1364 FD 2F 00    0260*      ld (iy+0),hl            ; set start time
0B1367 C9          0261*      ret
0B1368             0262*  
0B1368             0263*  ; gets time remaining on a countdown timer
0B1368             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1368             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B1368             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B1368             0267*  tmr_get:
0B1368             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
0B1368 3E 08       0001*M 			LD	A, function
0B136A 5B CF       0002*M 			RST.L	08h
0B136C DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
0B136F FD 27 00    0270*      ld hl,(iy+0)            ; get start time
0B1372 AF          0271*      xor a                   ; clear carry
0B1373 ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B1375 FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
0B1378 AF          0274*      xor a                   ; clear carry
0B1379 ED 5A       0275*      adc hl,de               ; hl = time remaining
0B137B             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B137B C9          0277*      ret
0B137C             0278*  
0B137C 00 00 00    0279*  timestamp_now: dl 0
0B137F 00 00 00    0280*  timestamp_old: dl 0
0B1382 00 00 00    0281*  timestamp_chg: dl 0
0B1385             0282*  
0B1385             0283*  ; update the global timestamp from the system clock
0B1385             0284*  ; inputs: none
0B1385             0285*  ; returns: hl = time elapsed in 1/120ths of a second
0B1385             0286*  ;          de = current time
0B1385             0287*  ;          ix = pointer to syvars table
0B1385             0288*  ; destroys: af,hl,de,ix
0B1385             0289*  timestamp_tick:
0B1385 ED 5B 7C 13 0290*      ld de,(timestamp_now)   ; get previous time
       0B          
0B138A ED 53 7F 13 0291*      ld (timestamp_old),de   ; save previous time
       0B          
0B138F             0292*      MOSCALL mos_sysvars     ; ix points to syvars table
0B138F 3E 08       0001*M 			LD	A, function
0B1391 5B CF       0002*M 			RST.L	08h
0B1393 DD 27 00    0293*      ld hl,(ix+sysvar_time)  ; get current time
0B1396 22 7C 13 0B 0294*      ld (timestamp_now),hl   ; save current time
0B139A AF          0295*      xor a                   ; clear carry
0B139B ED 52       0296*      sbc hl,de               ; hl = time elapsed
0B139D 22 82 13 0B 0297*      ld (timestamp_chg),hl   ; save elapsed time
0B13A1 C9          0298*      ret
0B13A2             0299*  
0B13A2             0300*  ; set a countdown timer
0B13A2             0301*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B13A2             0302*  ; requires: timestamp_tick to be called at least once before this function
0B13A2             0303*  ; returns: hl = current time
0B13A2             0304*  ; destroys: hl
0B13A2             0305*  timestamp_tmr_set:
0B13A2 FD 2F 03    0306*      ld (iy+3),hl            ; set time remaining
0B13A5 2A 7C 13 0B 0307*      ld hl,(timestamp_now)   ; get current timestamp
0B13A9 FD 2F 00    0308*      ld (iy+0),hl            ; set start time
0B13AC C9          0309*      ret
0B13AD             0310*  
0B13AD             0311*  ; gets time remaining on a countdown timer following the global timestamp
0B13AD             0312*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B13AD             0313*  ; requires: timestamp_tick to be called at least once before this function
0B13AD             0314*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B13AD             0315*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B13AD             0316*  ; destroys: af,hl,de
0B13AD             0317*  timestamp_tmr_get:
0B13AD ED 5B 7C 13 0318*      ld de,(timestamp_now)   ; get current timestamp
       0B          
0B13B2 FD 27 00    0319*      ld hl,(iy+0)            ; get start time
0B13B5 AF          0320*      xor a                   ; clear carry
0B13B6 ED 52       0321*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B13B8 FD 17 03    0322*      ld de,(iy+3)            ; get timer set value
0B13BB AF          0323*      xor a                   ; clear carry
0B13BC ED 5A       0324*      adc hl,de               ; hl = time remaining
0B13BE             0325*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B13BE C9          0326*      ret
0B13BF             0327*  
0B13BF             0328*  ; main loop timer functions
0B13BF             0329*  tmr_main_loop: ds 6 ; buffer to hold main loop timer
0B13C5             0330*  
0B13C5             0331*  ; set a countdown timer for the main loop using the timestamp timer
0B13C5             0332*  ; inputs: hl = time to set in 1/120ths of a second
0B13C5             0333*  ; returns: hl = current time
0B13C5             0334*  ; destroys: af,hl,de,ix,iy
0B13C5             0335*  tmr_main_loop_set:
0B13C5 FD 21 BF 13 0336*      ld iy,tmr_main_loop
       0B          
0B13CA FD 2F 03    0337*      ld (iy+3),hl ; set time remaining
0B13CD CD 85 13 0B 0338*      call timestamp_tick
0B13D1 2A 7C 13 0B 0339*      ld hl,(timestamp_now)   ; get current timestamp
0B13D5 FD 2F 00    0340*      ld (iy+0),hl ; set start time
0B13D8 C9          0341*      ret
0B13D9             0342*  
0B13D9             0343*  ; gets time remaining on the main loop countdown timer following the global timestamp
0B13D9             0344*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B13D9             0345*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B13D9             0346*  ; destroys: af,hl,de,ix,iy
0B13D9             0347*  tmr_main_loop_get:
0B13D9 CD 85 13 0B 0348*      call timestamp_tick
0B13DD FD 21 BF 13 0349*      ld iy,tmr_main_loop
       0B          
0B13E2 CD AD 13 0B 0350*      call timestamp_tmr_get
0B13E6 C9          0351*      ret
0B13E7             0352*  
0B13E7             0353*  ; set a stopwatch
0B13E7             0354*  ; returns: hl = start time
0B13E7             0355*  ; destroys: hl,ix
0B13E7             0356*  stopwatch_set:
0B13E7             0357*      MOSCALL mos_sysvars     ; ix points to syvars table
0B13E7 3E 08       0001*M 			LD	A, function
0B13E9 5B CF       0002*M 			RST.L	08h
0B13EB DD 27 00    0358*      ld hl,(ix+sysvar_time)  ; get current time
0B13EE 22 03 14 0B 0359*      ld (stopwatch_started),hl            ; set start time
0B13F2 C9          0360*      ret
0B13F3             0361*  
0B13F3             0362*  ; gets time elapsed on a stopwatch
0B13F3             0363*  ; returns: hl = time elapsed in 1/120ths of a second
0B13F3             0364*  ; destroys: af,hl,de,ix
0B13F3             0365*  stopwatch_get:
0B13F3             0366*      MOSCALL mos_sysvars     ; ix points to syvars table
0B13F3 3E 08       0001*M 			LD	A, function
0B13F5 5B CF       0002*M 			RST.L	08h
0B13F7 DD 27 00    0367*      ld hl,(ix+sysvar_time)  ; get current time
0B13FA ED 5B 03 14 0368*      ld de,(stopwatch_started)            ; get start time
       0B          
0B13FF AF          0369*      xor a                   ; clear carry
0B1400 ED 52       0370*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0B1402 C9          0371*      ret
0B1403             0372*  
0B1403             0373*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0B1406             0374*  
0B1406             0375*  ; ------------------
0B1406             0376*  ; delay routine
0B1406             0377*  ; Author: Richard Turrnidge
0B1406             0378*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0B1406             0379*  ; routine waits a fixed time,then returns
0B1406             0380*  ; arrive with A =  the delay byte. One bit to be set only.
0B1406             0381*  ; eg. ld A,00000100b
0B1406             0382*  
0B1406             0383*  multiPurposeDelay:
0B1406 F5          0384*      push af
0B1407 C5          0385*      push bc
0B1408 DD E5       0386*      push ix
0B140A 47          0387*      ld b,a
0B140B 3E 08       0388*      ld a,$08
0B140D 5B CF       0389*      RST.LIL	08h                 ; get IX pointer to sysvars
0B140F             0390*  
0B140F             0391*  waitLoop:
0B140F             0392*  
0B140F DD 7E 00    0393*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0B1412             0394*  
0B1412             0395*                                  ;   we check if bit set is same as last time we checked.
0B1412             0396*                                  ;   bit 0 - don't use
0B1412             0397*                                  ;   bit 1 - changes 64 times per second
0B1412             0398*                                  ;   bit 2 - changes 32 times per second
0B1412             0399*                                  ;   bit 3 - changes 16 times per second
0B1412             0400*  
0B1412             0401*                                  ;   bit 4 - changes 8 times per second
0B1412             0402*                                  ;   bit 5 - changes 4 times per second
0B1412             0403*                                  ;   bit 6 - changes 2 times per second
0B1412             0404*                                  ;   bit 7 - changes 1 times per second
0B1412 A0          0405*      and b
0B1413 4F          0406*      ld c,a
0B1414 3A 25 14 0B 0407*      ld a,(oldTimeStamp)
0B1418 B9          0408*      cp c                        ; is A same as last value?
0B1419 28 F4       0409*      jr z,waitLoop              ; loop here if it is
0B141B 79          0410*      ld a,c
0B141C 32 25 14 0B 0411*      ld (oldTimeStamp),a        ; set new value
0B1420             0412*  
0B1420 DD E1       0413*      pop ix
0B1422 C1          0414*      pop bc
0B1423 F1          0415*      pop af
0B1424 C9          0416*      ret
0B1425             0417*  
0B1425 00          0418*  oldTimeStamp:   .db 00h
0B1426             0025       include "vdu.inc"
0B1426             0001*  
0B1426             0002*  ; VDU 30: Home cursor
0B1426             0003*  vdu_home_cursor:
0B1426 3E 1E       0004*      ld a,30
0B1428 5B D7       0005*  	rst.lil $10
0B142A C9          0006*  	ret
0B142B             0007*  
0B142B             0008*  cursor_on:
0B142B 21 36 14 0B 0009*  	ld hl,@cmd
0B142F 01 03 00 00 0010*  	ld bc,@end-@cmd
0B1433 5B DF       0011*  	rst.lil $18
0B1435 C9          0012*  	ret
0B1436             0013*  @cmd:
0B1436 17 01 01    0014*  	db 23,1,1
0B1439             0015*  @end:
0B1439             0016*  
0B1439             0017*  cursor_off:
0B1439 21 44 14 0B 0018*  	ld hl,@cmd
0B143D 01 03 00 00 0019*  	ld bc,@end-@cmd
0B1441 5B DF       0020*  	rst.lil $18
0B1443 C9          0021*  	ret
0B1444             0022*  @cmd:
0B1444 17 01 00    0023*  	db 23,1,0
0B1447             0024*  @end:
0B1447             0025*  
0B1447             0026*  ; VDU 9: Move cursor forward one character
0B1447             0027*  vdu_cursor_forward:
0B1447 3E 09       0028*      ld a,9
0B1449 5B D7       0029*  	rst.lil $10
0B144B C9          0030*  	ret
0B144C             0031*  
0B144C             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0B144C             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
0B144C             0034*  vdu_move_cursor:
0B144C ED 43 5D 14 0035*      ld (@x0),bc
       0B          
0B1451 21 5C 14 0B 0036*  	ld hl,@cmd
0B1455 01 03 00 00 0037*  	ld bc,@end-@cmd
0B1459 5B DF       0038*  	rst.lil $18
0B145B C9          0039*  	ret
0B145C 1F          0040*  @cmd: 	db 31
0B145D 00          0041*  @x0:	db 0
0B145E 00          0042*  @y0: 	db 0
0B145F 00          0043*  @end: 	db 0 ; padding
0B1460             0044*  
0B1460             0045*  ; VDU 12: Clear text area (CLS)
0B1460             0046*  vdu_cls:
0B1460 3E 0C       0047*      ld a,12
0B1462 5B D7       0048*  	rst.lil $10
0B1464 C9          0049*  	ret
0B1465             0050*  
0B1465             0051*  vdu_flip:
0B1465 21 70 14 0B 0052*  	ld hl,@cmd
0B1469 01 03 00 00 0053*  	ld bc,@end-@cmd
0B146D 5B DF       0054*  	rst.lil $18
0B146F C9          0055*  	ret
0B1470 17 00 C3    0056*  @cmd: db 23,0,0xC3
0B1473             0057*  @end:
0B1473             0058*  
0B1473             0059*  ; VDU 16: Clear graphics area (CLG)
0B1473             0060*  vdu_clg:
0B1473 3E 10       0061*      ld a,16
0B1475 5B D7       0062*  	rst.lil $10
0B1477 C9          0063*  	ret
0B1478             0064*  
0B1478             0065*  ; COLOUR MODES
0B1478             0066*  ; Mode	Effect
0B1478             0067*  ; 0	Set on-screen pixel to target colour value
0B1478             0068*  ; 1	OR value with the on-screen pixel
0B1478             0069*  ; 2	AND value with the on-screen pixel
0B1478             0070*  ; 3	XOR value with the on-screen pixel
0B1478             0071*  ; 4	Invert the on-screen pixel
0B1478             0072*  ; 5	No operation
0B1478             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0B1478             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0B1478             0075*  
0B1478             0076*  ; VDU 17, colour: Define text colour (COLOUR)
0B1478             0077*  vdu_colour_text:
0B1478 32 88 14 0B 0078*  	ld (@arg),a
0B147C 21 87 14 0B 0079*  	ld hl,@cmd
0B1480 01 02 00 00 0080*  	ld bc,@end-@cmd
0B1484 5B DF       0081*  	rst.lil $18
0B1486 C9          0082*  	ret
0B1487 11          0083*  @cmd: db 17
0B1488 00          0084*  @arg: db 0
0B1489             0085*  @end:
0B1489             0086*  
0B1489             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0B1489             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0B1489             0089*  vdu_gcol:
0B1489 32 9E 14 0B 0090*  	ld (@mode),a
0B148D 79          0091*      ld a,c
0B148E 32 9F 14 0B 0092*      ld (@col),a
0B1492 21 9D 14 0B 0093*  	ld hl,@cmd
0B1496 01 03 00 00 0094*  	ld bc,@end-@cmd
0B149A 5B DF       0095*  	rst.lil $18
0B149C C9          0096*  	ret
0B149D 12          0097*  @cmd:  db 18
0B149E 00          0098*  @mode: db 0
0B149F 00          0099*  @col:  db 0
0B14A0             0100*  @end:
0B14A0             0101*  
0B14A0             0102*  
0B14A0             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
0B14A0             0104*  ; MIND THE LITTLE-ENDIANESS
0B14A0             0105*  ; inputs: c=left,b=bottom,e=right,d=top
0B14A0             0106*  ; outputs; nothing
0B14A0             0107*  ; destroys: a might make it out alive
0B14A0             0108*  vdu_set_txt_viewport:
0B14A0 ED 43 B6 14 0109*      ld (@lb),bc
       0B          
0B14A5 ED 53 B8 14 0110*  	ld (@rt),de
       0B          
0B14AA 21 B5 14 0B 0111*  	ld hl,@cmd
0B14AE 01 05 00 00 0112*  	ld bc,@end-@cmd
0B14B2 5B DF       0113*  	rst.lil $18
0B14B4 C9          0114*  	ret
0B14B5 1C          0115*  @cmd:   db 28 ; set text viewport command
0B14B6 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
0B14B8 00 00       0117*  @rt: 	dw 0x0000 ; set by de
0B14BA 00          0118*  @end:   db 0x00	  ; padding
0B14BB             0119*  
0B14BB             0120*  ; Wait for VBLANK interrupt
0B14BB             0121*  vdu_vblank:
0B14BB DD E5       0122*      PUSH 	IX
0B14BD             0123*  	MOSCALL	mos_sysvars
0B14BD 3E 08       0001*M 			LD	A, function
0B14BF 5B CF       0002*M 			RST.L	08h
0B14C1 DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
0B14C4             0125*  @wait:
0B14C4 DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
0B14C7 28 FB       0127*      JR	Z, @wait
0B14C9 DD E1       0128*      POP	IX
0B14CB C9          0129*      RET
0B14CC             0130*  
0B14CC             0131*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
0B14CC             0132*  ; NOTE: the order of the y-coordinate parameters are inverted
0B14CC             0133*  ; 	because we have turned off logical screen scaling
0B14CC             0134*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0B14CC             0135*  ; outputs; nothing
0B14CC             0136*  ; destroys: a might make it out alive
0B14CC             0137*  vdu_set_gfx_viewport:
0B14CC ED 43 EC 14 0138*      ld (@x0),bc
       0B          
0B14D1 FD 22 EE 14 0139*      ld (@y1),iy
       0B          
0B14D6 DD 22 F0 14 0140*  	ld (@x1),ix
       0B          
0B14DB ED 53 F2 14 0141*  	ld (@y0),de
       0B          
0B14E0 21 EB 14 0B 0142*  	ld hl,@cmd
0B14E4 01 09 00 00 0143*  	ld bc,@end-@cmd
0B14E8 5B DF       0144*  	rst.lil $18
0B14EA C9          0145*  	ret
0B14EB 18          0146*  @cmd:   db 24 ; set graphics viewport command
0B14EC 00 00       0147*  @x0: 	dw 0x0000 ; set by bc
0B14EE 00 00       0148*  @y1: 	dw 0x0000 ; set by iy
0B14F0 00 00       0149*  @x1: 	dw 0x0000 ; set by ix
0B14F2 00 00       0150*  @y0: 	dw 0x0000 ; set by de
0B14F4 00          0151*  @end:   db 0x00	  ; padding
0B14F5             0152*  
0B14F5             0153*  ; SCREEN MODES
0B14F5             0154*  ; ===============================
0B14F5             0155*  ; Mode  Horz  Vert  Cols  Refresh
0B14F5             0156*  ; ---   ----  ----  ----  -------
0B14F5             0157*  ; 11    320   240   2     60hz
0B14F5             0158*  ; 139   320   240   2     60hz
0B14F5             0159*  ; 23    512   384   2     60hz
0B14F5             0160*  ; 151   512   384   2     60hz
0B14F5             0161*  ; 6     640   240   2     60hz
0B14F5             0162*  ; 134   640   240   2     60hz
0B14F5             0163*  ; 2     640   480   2     60hz
0B14F5             0164*  ; 130   640   480   2     60hz
0B14F5             0165*  ; 17    800   600   2     60hz
0B14F5             0166*  ; 145   800   600   2     60hz
0B14F5             0167*  ; 18    1024  768   2     60hz
0B14F5             0168*  ; 146   1024  768   2     60hz
0B14F5             0169*  ; ---   ----  ----  ----  -------
0B14F5             0170*  ; 10    320   240   4     60hz
0B14F5             0171*  ; 138   320   240   4     60hz
0B14F5             0172*  ; 22    512   384   4     60hz
0B14F5             0173*  ; 150   512   384   4     60hz
0B14F5             0174*  ; 5     640   240   4     60hz
0B14F5             0175*  ; 133   640   240   4     60hz
0B14F5             0176*  ; 1     640   480   4     60hz
0B14F5             0177*  ; 129   640   480   4     60hz
0B14F5             0178*  ; 16    800   600   4     60hz
0B14F5             0179*  ; 19    1024  768   4     60hz
0B14F5             0180*  ; ---   ----  ----  ----  -------
0B14F5             0181*  ; 9     320   240   16    60hz
0B14F5             0182*  ; 137   320   240   16    60hz
0B14F5             0183*  ; 21    512   384   16    60hz
0B14F5             0184*  ; 149   512   384   16    60hz
0B14F5             0185*  ; 4     640   240   16    60hz
0B14F5             0186*  ; 132   640   240   16    60hz
0B14F5             0187*  ; 0     640   480   16    60hz
0B14F5             0188*  ; 7     n/a   n/a   16    60hz
0B14F5             0189*  ; ---   ----  ----  ----  -------
0B14F5             0190*  ; 8     320   240   64    60hz
0B14F5             0191*  ; 136   320   240   64    60hz
0B14F5             0192*  ; 20    512   384   64    60hz
0B14F5             0193*  ; 3     640   240   64    60hz
0B14F5             0194*  ; ---   ----  ----  ----  -------
0B14F5             0195*  vdu_set_screen_mode:
0B14F5 32 05 15 0B 0196*  	ld (@arg),a
0B14F9 21 04 15 0B 0197*  	ld hl,@cmd
0B14FD 01 02 00 00 0198*  	ld bc,@end-@cmd
0B1501 5B DF       0199*  	rst.lil $18
0B1503 C9          0200*  	ret
0B1504 16          0201*  @cmd: db 22 ; set screen mode
0B1505 00          0202*  @arg: db 0  ; screen mode parameter
0B1506             0203*  @end:
0B1506             0204*  
0B1506             0205*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0B1506             0206*  ; inputs: a is scaling mode, 1=on, 0=off
0B1506             0207*  ; note: default setting on boot is scaling ON
0B1506             0208*  vdu_set_scaling:
0B1506 32 18 15 0B 0209*  	ld (@arg),a
0B150A 21 15 15 0B 0210*  	ld hl,@cmd
0B150E 01 04 00 00 0211*  	ld bc,@end-@cmd
0B1512 5B DF       0212*  	rst.lil $18
0B1514 C9          0213*  	ret
0B1515 17 00 C0    0214*  @cmd: db 23,0,0xC0
0B1518 00          0215*  @arg: db 0  ; scaling on/off
0B1519             0216*  @end:
0B1519             0217*  
0B1519             0218*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0B1519             0219*  ; inputs: hl=bufferId
0B1519             0220*  vdu_buff_select:
0B1519 22 2B 15 0B 0221*  	ld (@bufferId),hl
0B151D 21 28 15 0B 0222*  	ld hl,@cmd
0B1521 01 05 00 00 0223*  	ld bc,@end-@cmd
0B1525 5B DF       0224*  	rst.lil $18
0B1527 C9          0225*  	ret
0B1528 17 1B 20    0226*  @cmd: db 23,27,0x20
0B152B 00 00       0227*  @bufferId: dw 0x0000
0B152D 00          0228*  @end: db 0x00 ; padding
0B152E             0229*  
0B152E             0230*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0B152E             0231*  ; inputs: a=format; bc=width; de=height
0B152E             0232*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0B152E             0233*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0B152E             0234*  ; 0 	RGBA8888 (4-bytes per pixel)
0B152E             0235*  ; 1 	RGBA2222 (1-bytes per pixel)
0B152E             0236*  ; 2 	Mono/Mask (1-bit per pixel)
0B152E             0237*  ; 3 	Reserved for internal use by VDP (native format)
0B152E             0238*  vdu_bmp_create:
0B152E ED 43 4A 15 0239*      ld (@width),bc
       0B          
0B1533 ED 53 4C 15 0240*      ld (@height),de
       0B          
0B1538 32 4E 15 0B 0241*      ld (@fmt),a
0B153C 21 47 15 0B 0242*  	ld hl,@cmd
0B1540 01 08 00 00 0243*  	ld bc,@end-@cmd
0B1544 5B DF       0244*  	rst.lil $18
0B1546 C9          0245*  	ret
0B1547 17 1B 21    0246*  @cmd:       db 23,27,0x21
0B154A 00 00       0247*  @width:     dw 0x0000
0B154C 00 00       0248*  @height:    dw 0x0000
0B154E 00          0249*  @fmt:       db 0x00
0B154F             0250*  @end:
0B154F             0251*  
0B154F             0252*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0B154F             0253*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0B154F             0254*  vdu_load_img_rgba2_to_8:
0B154F             0255*  ; backup the target buffer id and image dimensions
0B154F E5          0256*      push hl
0B1550 D5          0257*      push de
0B1551 C5          0258*      push bc
0B1552             0259*  ; load the rgba2 image to working buffer 65534
0B1552 21 FE FF 00 0260*      ld hl,65534 ; temporary working buffer id
0B1556 CD 59 16 0B 0261*  	call vdu_load_buffer_from_file
0B155A             0262*  ; restore the image dimensions and target buffer id
0B155A C1          0263*      pop bc
0B155B D1          0264*      pop de
0B155C E1          0265*      pop hl
0B155D             0266*  ; fall through to vdu_rgba2_to_8
0B155D             0267*  
0B155D             0268*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0B155D             0269*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0B155D             0270*  ; the "expand bitmap" command is:
0B155D             0271*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B155D             0272*  ; and then to reverse the byte order to fix endian-ness:
0B155D             0273*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B155D             0274*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B155D             0275*  ; VDU 23,27,&20,targetBufferID%;
0B155D             0276*  ; VDU 23,27,&21,width%;height%;0
0B155D             0277*  ; -------------------------------------------------------------------
0B155D             0278*  ; inputs: bc,de image width,height ; hl = targetBufferId
0B155D             0279*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0B155D             0280*  vdu_rgba2_to_8:
0B155D             0281*  ; load the image dimensions and buffer id parameters
0B155D ED 43 B9 15 0282*      ld (@width),bc
       0B          
0B1562 ED 53 BB 15 0283*      ld (@height),de
       0B          
0B1567 22 9E 15 0B 0284*      ld (@bufferId0),hl
0B156B 22 AB 15 0B 0285*      ld (@bufferId2),hl
0B156F 22 B4 15 0B 0286*      ld (@bufferId1),hl
0B1573             0287*  ; clean up bytes that got stomped on by the ID loads
0B1573 3E 48       0288*      ld a,0x48
0B1575 32 A0 15 0B 0289*      ld (@bufferId0+2),a
0B1579 3E 17       0290*      ld a,23
0B157B 32 B6 15 0B 0291*      ld (@bufferId1+2),a
0B157F 3E 18       0292*      ld a,24
0B1581 32 AD 15 0B 0293*      ld (@bufferId2+2),a
0B1585 AF          0294*      xor a
0B1586 32 BD 15 0B 0295*      ld (@height+2),a
0B158A             0296*  ; send the vdu command strings
0B158A 21 95 15 0B 0297*      ld hl,@beg
0B158E 01 29 00 00 0298*      ld bc,@end-@beg
0B1592 5B DF       0299*      rst.lil $18
0B1594 C9          0300*      ret
0B1595             0301*  @beg:
0B1595             0302*  ; Command 14: Consolidate blocks in a buffer
0B1595             0303*  ; VDU 23, 0, &A0, bufferId; 14
0B1595 17 00 A0    0304*      db 23,0,0xA0
0B1598 FE FF       0305*      dw 65534 ; workingBufferId
0B159A 0E          0306*      db 14 ; consolidate blocks
0B159B             0307*  ; the "expand bitmap" command is:
0B159B             0308*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B159B 17 00 A0    0309*      db 23,0,0xA0
0B159E 00 00       0310*  @bufferId0: dw 0x0000 ; targetBufferId
0B15A0 48          0311*      db 0x48 ; given as decimal command 72 in the docs
0B15A1 02          0312*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B15A2 FE FF       0313*      dw 65534 ; sourceBufferId
0B15A4 00 7F BF FF 0314*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B15A8             0315*  ; reverse the byte order to fix endian-ness:
0B15A8             0316*  ; Command 24: Reverse the order of data of blocks within a buffer
0B15A8             0317*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0B15A8             0318*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B15A8 17 00 A0    0319*      db 23,0,0xA0
0B15AB 00 00       0320*  @bufferId2:    dw 0x0000 ; targetBufferId
0B15AD 18          0321*      db 24 ; reverse byte order
0B15AE 04          0322*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B15AF 04 00       0323*      dw 4 ; size (4 bytes)
0B15B1             0324*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B15B1             0325*  ; VDU 23,27,&20,targetBufferID%;
0B15B1 17 1B 20    0326*      db 23,27,0x20 ; select bitmap
0B15B4 00 00       0327*  @bufferId1: dw 0x0000 ; targetBufferId
0B15B6             0328*  ; VDU 23,27,&21,width%;height%;0
0B15B6 17 1B 21    0329*      db 23,27,0x21 ; create bitmap from buffer
0B15B9 00 00       0330*  @width: dw 0x0000
0B15BB 00 00       0331*  @height: dw 0x0000
0B15BD 00          0332*      db 0x00 ; rgba8888 format
0B15BE             0333*  @end:
0B15BE             0334*  
0B15BE             0335*  ; scratch variables
0B15BE 00 00 00    0336*  bufferId0: dl 0x000000
0B15C1 00 00 00    0337*  bufferId1: dl 0x000000
0B15C4             0338*  
0B15C4             0339*  ; load a vdu buffer from local memory
0B15C4             0340*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B15C4             0341*  vdu_load_buffer:
0B15C4 ED 43 ED 15 0342*      ld (@length),bc
       0B          
0B15C9 D5          0343*      push de ; save data pointer
0B15CA             0344*  ; send the vdu command string
0B15CA 7D          0345*      ld a,l
0B15CB 32 EA 15 0B 0346*      ld (@bufferId),a
0B15CF 7C          0347*      ld a,h
0B15D0 32 EB 15 0B 0348*      ld (@bufferId+1),a
0B15D4 21 E7 15 0B 0349*      ld hl,@cmd
0B15D8 01 08 00 00 0350*      ld bc,@end-@cmd
0B15DC 5B DF       0351*      rst.lil $18
0B15DE             0352*  ; send the buffer data
0B15DE E1          0353*      pop hl ; pointer to data
0B15DF ED 4B ED 15 0354*      ld bc,(@length)
       0B          
0B15E4 5B DF       0355*      rst.lil $18 ; send it
0B15E6 C9          0356*      ret
0B15E7             0357*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B15E7 17 00 A0    0358*  @cmd:       db 23,0,0xA0
0B15EA 00 00       0359*  @bufferId:	dw 0x0000
0B15EC 00          0360*  		    db 0 ; load buffer
0B15ED 00 00       0361*  @length:	dw 0x0000
0B15EF 00          0362*  @end: db 0 ; padding
0B15F0             0363*  
0B15F0             0364*  ; clear a buffer
0B15F0             0365*  ; inputs: hl = bufferId
0B15F0             0366*  vdu_clear_buffer:
0B15F0 7D          0367*      ld a,l
0B15F1 32 08 16 0B 0368*      ld (@bufferId),a
0B15F5 7C          0369*      ld a,h
0B15F6 32 09 16 0B 0370*      ld (@bufferId+1),a
0B15FA 21 05 16 0B 0371*      ld hl,@cmd
0B15FE 01 06 00 00 0372*      ld bc,@end-@cmd
0B1602 5B DF       0373*      rst.lil $18
0B1604 C9          0374*      ret
0B1605 17 00 A0    0375*  @cmd:       db 23,0,0xA0
0B1608 00 00       0376*  @bufferId:	dw 0x0000
0B160A 02          0377*  		    db 2 ; clear buffer
0B160B             0378*  @end:
0B160B             0379*  
0B160B             0380*  vdu_clear_all_buffers:
0B160B             0381*  ; clear all buffers
0B160B 21 16 16 0B 0382*      ld hl,@beg
0B160F 01 06 00 00 0383*      ld bc,@end-@beg
0B1613 5B DF       0384*      rst.lil $18
0B1615 C9          0385*      ret
0B1616 17 00 A0    0386*  @beg: db 23,0,$A0
0B1619 FF FF       0387*        dw -1 ; clear all buffers
0B161B 02          0388*        db 2  ; command 2: clear a buffer
0B161C             0389*  @end:
0B161C             0390*  
0B161C             0391*  ; Command 14: Consolidate blocks in a buffer
0B161C             0392*  vdu_consolidate_buffer:
0B161C             0393*  ; set parameters for vdu call
0B161C 7D          0394*      ld a,l
0B161D 32 34 16 0B 0395*      ld (@bufferId),a
0B1621 7C          0396*      ld a,h
0B1622 32 35 16 0B 0397*      ld (@bufferId+1),a
0B1626 21 31 16 0B 0398*      ld hl,@beg
0B162A 01 06 00 00 0399*      ld bc,@end-@beg
0B162E 5B DF       0400*      rst.lil $18
0B1630 C9          0401*      ret
0B1631             0402*  ; VDU 23, 0, &A0, bufferId; 14
0B1631 17 00 A0    0403*  @beg: db 23,0,0xA0
0B1634 00 00       0404*  @bufferId: dw 0x0000
0B1636 0E          0405*             db 14
0B1637             0406*  @end:
0B1637             0407*  
0B1637             0408*  ; load an image file to a buffer and make it a bitmap
0B1637             0409*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0B1637             0410*  vdu_load_img:
0B1637             0411*  ; back up image type and dimension parameters
0B1637 22 BE 15 0B 0412*      ld (bufferId0),hl
0B163B F5          0413*      push af
0B163C C5          0414*  	push bc
0B163D D5          0415*  	push de
0B163E             0416*  ; load the image
0B163E CD 59 16 0B 0417*  	call vdu_load_buffer_from_file
0B1642             0418*  ; now make it a bitmap
0B1642 2A BE 15 0B 0419*      ld hl,(bufferId0)
0B1646 CD 1C 16 0B 0420*      call vdu_consolidate_buffer
0B164A 2A BE 15 0B 0421*      ld hl,(bufferId0)
0B164E CD 19 15 0B 0422*      call vdu_buff_select
0B1652 D1          0423*  	pop de ; image height
0B1653 C1          0424*  	pop bc ; image width
0B1654 F1          0425*  	pop af ; image type
0B1655 C3 2E 15 0B 0426*  	jp vdu_bmp_create ; will return to caller from there
0B1659             0427*  
0B1659             0428*  ; inputs: hl = bufferId; iy = pointer to filename
0B1659             0429*  vdu_load_buffer_from_file:
0B1659 22 BE 15 0B 0430*      ld (bufferId0),hl
0B165D             0431*  
0B165D             0432*  ; clear target buffer
0B165D CD F0 15 0B 0433*      call vdu_clear_buffer
0B1661             0434*  
0B1661             0435*  ; open the file in read mode
0B1661             0436*  ; Open a file
0B1661             0437*  ; HLU: Filename
0B1661             0438*  ;   C: Mode
0B1661             0439*  ; Returns:
0B1661             0440*  ;   A: Filehandle, or 0 if couldn't open
0B1661 FD E5       0441*  	push iy ; pointer to filename
0B1663 E1          0442*  	pop hl
0B1664 0E 01       0443*  	ld c,fa_read
0B1666             0444*      MOSCALL mos_fopen
0B1666 3E 0A       0001*M 			LD	A, function
0B1668 5B CF       0002*M 			RST.L	08h
0B166A 32 A5 16 0B 0445*      ld (@filehandle),a
0B166E             0446*  
0B166E             0447*  @read_file:
0B166E             0448*  ; Read a block of data from a file
0B166E             0449*  ;   C: Filehandle
0B166E             0450*  ; HLU: Pointer to where to write the data to
0B166E             0451*  ; DEU: Number of bytes to read
0B166E             0452*  ; Returns:
0B166E             0453*  ; DEU: Number of bytes read
0B166E 3A A5 16 0B 0454*      ld a,(@filehandle)
0B1672 4F          0455*      ld c,a
0B1673 21 00 E0 B7 0456*      ld hl,filedata
0B1677 11 00 20 00 0457*      ld de,8192 ; max we can read into onboard sram at one time
0B167B             0458*      MOSCALL mos_fread
0B167B 3E 1A       0001*M 			LD	A, function
0B167D 5B CF       0002*M 			RST.L	08h
0B167F             0459*  
0B167F             0460*  ; ; DEBUG: print chunk size
0B167F             0461*  ;     push de
0B167F             0462*  ;     pop hl
0B167F             0463*  ;     call printDec
0B167F             0464*  ;     call printNewLine
0B167F             0465*  
0B167F             0466*  ; test de for zero bytes read
0B167F 21 00 00 00 0467*      ld hl,0
0B1683 AF          0468*      xor a ; clear carry
0B1684 ED 52       0469*      sbc hl,de
0B1686 CA 9C 16 0B 0470*      jp z,@close_file
0B168A             0471*  
0B168A             0472*  ; load a vdu buffer from local memory
0B168A             0473*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B168A 2A BE 15 0B 0474*      ld hl,(bufferId0)
0B168E D5          0475*      push de ; chunksize
0B168F C1          0476*      pop bc
0B1690 11 00 E0 B7 0477*      ld de,filedata
0B1694 CD C4 15 0B 0478*      call vdu_load_buffer
0B1698             0479*  
0B1698             0480*  ; ; print progress breadcrumbs
0B1698             0481*  ;     ld a,'.'
0B1698             0482*  ;     rst.lil 10h
0B1698             0483*  
0B1698             0484*  ; read the next block
0B1698 C3 6E 16 0B 0485*      jp @read_file
0B169C             0486*  
0B169C             0487*  ; close the file
0B169C             0488*  @close_file:
0B169C 3A A5 16 0B 0489*      ld a,(@filehandle)
0B16A0             0490*      MOSCALL mos_fclose
0B16A0 3E 0B       0001*M 			LD	A, function
0B16A2 5B CF       0002*M 			RST.L	08h
0B16A4 C9          0491*      ret ; vdu_load_buffer_from_file
0B16A5             0492*  
0B16A5 00          0493*  @filehandle: db 0 ; file handle
0B16A6 00 00 00    0494*  @fil: dl 0 ; pointer to FIL struct
0B16A9             0495*  
0B16A9 00 00 00    0496*  @chunkpointer: dl 0 ; pointer to current chunk
0B16AC             0497*  
0B16AC             0498*  ; File information structure (FILINFO)
0B16AC             0499*  @filinfo:
0B16AC 00 00 00 00 0500*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B16B0 00 00       0501*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B16B2 00 00       0502*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B16B4 00          0503*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B16B5 00 00 00 00 0504*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0B16C2 00 00 00 00 0505*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B17C2             0026       ; include "vdu_fonts.inc"
0B17C2             0027       include "vdu_plot.inc"
0B17C2             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B17C2             0002*  ; PLOT code 	(Decimal) 	Effect
0B17C2             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0B17C2             0004*  plot_sl_both: equ 0x00
0B17C2             0005*  
0B17C2             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0B17C2             0007*  plot_sl_first: equ 0x08
0B17C2             0008*  
0B17C2             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0B17C2             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0B17C2             0011*  
0B17C2             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0B17C2             0013*  plot_sl_last: equ 0x20
0B17C2             0014*  
0B17C2             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0B17C2             0016*  plot_sl_none: equ 0x28
0B17C2             0017*  
0B17C2             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0B17C2             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0B17C2             0020*  
0B17C2             0021*  ; &40-&47 	64-71 	Point plot
0B17C2             0022*  plot_pt: equ 0x40
0B17C2             0023*  
0B17C2             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background 
0B17C2             0025*  plot_lf_lr_non_bg: equ 0x48
0B17C2             0026*  
0B17C2             0027*  ; &50-&57 	80-87 	Triangle fill
0B17C2             0028*  plot_tf: equ 0x50
0B17C2             0029*  
0B17C2             0030*  ; &58-&5F 	88-95 	Line fill right to background 
0B17C2             0031*  plot_lf_r_bg: equ 0x58
0B17C2             0032*  
0B17C2             0033*  ; &60-&67 	96-103 	Rectangle fill
0B17C2             0034*  plot_rf: equ 0x60
0B17C2             0035*  
0B17C2             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground 
0B17C2             0037*  plot_lf_lr_fg: equ 0x60
0B17C2             0038*  
0B17C2             0039*  ; &70-&77 	112-119 	Parallelogram fill
0B17C2             0040*  plot_pf: equ 0x70
0B17C2             0041*  
0B17C2             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground 
0B17C2             0043*  plot_lf_r_non_fg: equ 0x78
0B17C2             0044*  
0B17C2             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0B17C2             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0B17C2             0047*  
0B17C2             0048*  ; &90-&97 	144-151 	Circle outline
0B17C2             0049*  plot_co: equ 0x90
0B17C2             0050*  
0B17C2             0051*  ; &98-&9F 	152-159 	Circle fill
0B17C2             0052*  plot_cf: equ 0x98
0B17C2             0053*  
0B17C2             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0B17C2             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0B17C2             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0B17C2             0057*  
0B17C2             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0B17C2             0059*  plot_rcm: equ 0xB8
0B17C2             0060*  
0B17C2             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0B17C2             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0B17C2             0063*  ; &D0-&D7 	208-215 	Not defined
0B17C2             0064*  ; &D8-&DF 	216-223 	Not defined
0B17C2             0065*  ; &E0-&E7 	224-231 	Not defined
0B17C2             0066*  
0B17C2             0067*  ; &E8-&EF 	232-239 	Bitmap plot 
0B17C2             0068*  plot_bmp: equ 0xE8
0B17C2             0069*  
0B17C2             0070*  ; &F0-&F7 	240-247 	Not defined
0B17C2             0071*  ; &F8-&FF 	248-255 	Not defined
0B17C2             0072*  
0B17C2             0073*  ;  Support added in Agon Console8 VDP 2.1.0  Support added in
0B17C2             0074*  ; Agon Console8 VDP 2.2.0
0B17C2             0075*  
0B17C2             0076*  ; Within each group of eight plot codes, the effects are as follows:
0B17C2             0077*  ; Plot code 	Effect
0B17C2             0078*  ; 0 	Move relative
0B17C2             0079*  mv_rel: equ 0
0B17C2             0080*  
0B17C2             0081*  ; 1 	Plot relative in current foreground colour
0B17C2             0082*  dr_rel_fg: equ 1
0B17C2             0083*  
0B17C2             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0B17C2             0085*  ; 3 	Plot relative in current background colour
0B17C2             0086*  dr_rel_bg: equ 3
0B17C2             0087*  
0B17C2             0088*  ; 4 	Move absolute
0B17C2             0089*  mv_abs: equ 4
0B17C2             0090*  
0B17C2             0091*  ; 5 	Plot absolute in current foreground colour
0B17C2             0092*  dr_abs_fg: equ 5
0B17C2             0093*  
0B17C2             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0B17C2             0095*  ; 7 	Plot absolute in current background colour
0B17C2             0096*  dr_abs_bg: equ 7
0B17C2             0097*  
0B17C2             0098*  ; Codes 0-3 use the position data provided as part of the command
0B17C2             0099*  ; as a relative position, adding the position given to the current
0B17C2             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0B17C2             0101*  ; as part of the command as an absolute position, setting the current
0B17C2             0102*  ; graphical cursor position to the position given.
0B17C2             0103*  
0B17C2             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0B17C2             0105*  ; current pixel colour. These operations cannot currently be supported
0B17C2             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0B17C2             0107*  ; supported. Support for these codes may be added in a future version
0B17C2             0108*  ; of the VDP firmware.
0B17C2             0109*  
0B17C2             0110*  ; 16 colour palette constants
0B17C2             0111*  c_black: equ 0
0B17C2             0112*  c_red_dk: equ 1
0B17C2             0113*  c_green_dk: equ 2
0B17C2             0114*  c_yellow_dk: equ 3
0B17C2             0115*  c_blue_dk: equ 4
0B17C2             0116*  c_magenta_dk: equ 5
0B17C2             0117*  c_cyan_dk: equ 6
0B17C2             0118*  c_grey: equ 7
0B17C2             0119*  c_grey_dk: equ 8
0B17C2             0120*  c_red: equ 9
0B17C2             0121*  c_green: equ 10
0B17C2             0122*  c_yellow: equ 11
0B17C2             0123*  c_blue: equ 12
0B17C2             0124*  c_magenta: equ 13
0B17C2             0125*  c_cyan: equ 14
0B17C2             0126*  c_white: equ 15
0B17C2             0127*  
0B17C2             0128*  ; VDU 25, mode, x; y;: PLOT command
0B17C2             0129*  ; inputs: a=mode, bc=x0, de=y0
0B17C2             0130*  vdu_plot:
0B17C2 32 DC 17 0B 0131*      ld (@mode),a
0B17C6 ED 43 DD 17 0132*      ld (@x0),bc
       0B          
0B17CB ED 53 DF 17 0133*      ld (@y0),de
       0B          
0B17D0 21 DB 17 0B 0134*  	ld hl,@cmd
0B17D4 01 06 00 00 0135*  	ld bc,@end-@cmd
0B17D8 5B DF       0136*  	rst.lil $18
0B17DA C9          0137*  	ret
0B17DB 19          0138*  @cmd:   db 25
0B17DC 00          0139*  @mode:  db 0
0B17DD 00 00       0140*  @x0: 	dw 0
0B17DF 00 00       0141*  @y0: 	dw 0
0B17E1 00          0142*  @end:   db 0 ; extra byte to soak up deu
0B17E2             0143*  
0B17E2             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B17E2             0145*  ; &E8-&EF 	232-239 	Bitmap plot 
0B17E2             0146*  ; VDU 25, mode, x; y;: PLOT command
0B17E2             0147*  ; inputs: bc=x0, de=y0
0B17E2             0148*  ; prerequisites: vdu_buff_select
0B17E2             0149*  vdu_plot_bmp:
0B17E2 ED 43 F9 17 0150*      ld (@x0),bc
       0B          
0B17E7 ED 53 FB 17 0151*      ld (@y0),de
       0B          
0B17EC 21 F7 17 0B 0152*  	ld hl,@cmd
0B17F0 01 06 00 00 0153*  	ld bc,@end-@cmd
0B17F4 5B DF       0154*  	rst.lil $18
0B17F6 C9          0155*  	ret
0B17F7 19          0156*  @cmd:   db 25
0B17F8 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B17F9 00 00       0158*  @x0: 	dw 0x0000
0B17FB 00 00       0159*  @y0: 	dw 0x0000
0B17FD 00          0160*  @end:   db 0x00 ; padding
0B17FE             0161*  
0B17FE             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B17FE             0163*  ; &E8-&EF 	232-239 	Bitmap plot 
0B17FE             0164*  ; VDU 25, mode, x; y;: PLOT command
0B17FE             0165*  ; inputs: bc=x0, de=y0
0B17FE             0166*  ; USING 16.8 FIXED POINT COORDINATES
0B17FE             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
0B17FE             0168*  ;   the fractional portiion of the inputs are truncated
0B17FE             0169*  ;   leaving only the 16-bit integer portion
0B17FE             0170*  ; prerequisites: vdu_buff_select
0B17FE             0171*  vdu_plot_bmp168:
0B17FE             0172*  ; populate in the reverse of normal to keep the
0B17FE             0173*  ; inputs from stomping on each other
0B17FE ED 53 1C 18 0174*      ld (@y0-1),de
       0B          
0B1803 ED 43 1A 18 0175*      ld (@x0-1),bc
       0B          
0B1808 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
0B180A 32 1A 18 0B 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B180E 21 19 18 0B 0178*  	ld hl,@cmd
0B1812 01 06 00 00 0179*  	ld bc,@end-@cmd
0B1816 5B DF       0180*  	rst.lil $18
0B1818 C9          0181*  	ret
0B1819 19          0182*  @cmd:   db 25
0B181A ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B181B 00 00       0184*  @x0: 	dw 0x0000
0B181D 00 00       0185*  @y0: 	dw 0x0000
0B181F             0186*  @end:  ; no padding required b/c we shifted de right
0B181F             0187*  
0B181F             0188*  ; draw a filled rectangle
0B181F             0189*  vdu_plot_rf:
0B181F ED 43 46 18 0190*      ld (@x0),bc
       0B          
0B1824 ED 53 48 18 0191*      ld (@y0),de
       0B          
0B1829 DD 22 4C 18 0192*      ld (@x1),ix
       0B          
0B182E FD 22 4E 18 0193*      ld (@y1),iy
       0B          
0B1833 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
0B1835 32 4A 18 0B 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B1839 21 44 18 0B 0196*  	ld hl,@cmd0
0B183D 01 0C 00 00 0197*  	ld bc,@end-@cmd0
0B1841 5B DF       0198*  	rst.lil $18
0B1843 C9          0199*      ret
0B1844 19          0200*  @cmd0:  db 25 ; plot
0B1845 04          0201*  @arg0:  db plot_sl_both+mv_abs
0B1846 00 00       0202*  @x0:    dw 0x0000
0B1848 00 00       0203*  @y0:    dw 0x0000
0B184A 19          0204*  @cmd1:  db 25 ; plot
0B184B 65          0205*  @arg1:  db plot_rf+dr_abs_fg
0B184C 00 00       0206*  @x1:    dw 0x0000
0B184E 00 00       0207*  @y1:    dw 0x0000
0B1850 00          0208*  @end:   db 0x00 ; padding
0B1851             0209*  
0B1851             0210*  ; draw a filled circle
0B1851             0211*  vdu_plot_cf:
0B1851 ED 43 78 18 0212*      ld (@x0),bc
       0B          
0B1856 ED 53 7A 18 0213*      ld (@y0),de
       0B          
0B185B DD 22 7E 18 0214*      ld (@x1),ix
       0B          
0B1860 FD 22 80 18 0215*      ld (@y1),iy
       0B          
0B1865 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
0B1867 32 7C 18 0B 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B186B 21 76 18 0B 0218*  	ld hl,@cmd0
0B186F 01 0C 00 00 0219*  	ld bc,@end-@cmd0
0B1873 5B DF       0220*  	rst.lil $18
0B1875 C9          0221*      ret
0B1876 19          0222*  @cmd0:  db 25 ; plot
0B1877 04          0223*  @arg0:  db plot_sl_both+mv_abs
0B1878 00 00       0224*  @x0:    dw 0x0000
0B187A 00 00       0225*  @y0:    dw 0x0000
0B187C 19          0226*  @cmd1:  db 25 ; plot
0B187D 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
0B187E 00 00       0228*  @x1:    dw 0x0000
0B1880 00 00       0229*  @y1:    dw 0x0000
0B1882 00          0230*  @end:   db 0x00 ; padding
0B1883             0231*  
0B1883             0232*  ; VDU 25, mode, x; y;: PLOT command
0B1883             0233*  ; inputs: a=mode, ix=x0, iy=y0
0B1883             0234*  plot:
0B1883 32 9D 18 0B 0235*      ld (@mode),a
0B1887 DD 22 9E 18 0236*      ld (@x0),ix
       0B          
0B188C FD 22 A0 18 0237*      ld (@y0),iy
       0B          
0B1891 21 9C 18 0B 0238*  	ld hl,@cmd
0B1895 01 06 00 00 0239*  	ld bc,@end-@cmd
0B1899 5B DF       0240*  	rst.lil $18
0B189B C9          0241*  	ret
0B189C 19          0242*  @cmd:   db 25
0B189D 00          0243*  @mode:  db 0
0B189E 00 00       0244*  @x0: 	dw 0
0B18A0 00 00       0245*  @y0: 	dw 0
0B18A2 00          0246*  @end:   db 0 ; padding
0B18A3             0247*  
0B18A3             0248*  ; VDU 5: Write text at graphics cursor
0B18A3             0249*  ; inputs: hl = pointer to text, ix=x0, iy=y0
0B18A3             0250*  ; prerequisites: gcol foreground set, VDU 5 set
0B18A3             0251*  plot_text:
0B18A3 E5          0252*      push hl ; save text pointer
0B18A4             0253*  ; move graphics cursor to x0, y0
0B18A4 3E 44       0254*      ld a,plot_pt+mv_abs
0B18A6 CD 83 18 0B 0255*      call plot
0B18AA             0256*  ; write text
0B18AA E1          0257*      pop hl ; restore text pointer
0B18AB CD 73 02 0B 0258*      call printString
0B18AF C9          0259*      ret
0B18B0             0028   
0B18B0             0029   ; SHAWN'S INCLUDES
0B18B0             0030   	INCLUDE	"strings24.asm"
0B18B0             0001*  ;------------------------------------------------------------------------
0B18B0             0002*  ;  strings24.asm
0B18B0             0003*  ;
0B18B0             0004*  ; 24-bit native ez80 strings routines for numerical processing
0B18B0             0005*  ;  Copyright (c) Shawn Sijnstra 2024
0B18B0             0006*  ;  MIT license
0B18B0             0007*  ;------------------------------------------------------------------------
0B18B0             0008*  
0B18B0             0009*  ;Print signed value in HLU in decimal with leading 0s removed
0B18B0             0010*  ; and postpended with a minus sign if was negative
0B18B0             0011*  ; Uses HLU, DEU, BCU
0B18B0             0012*  print_HLU_s24:
0B18B0 CD 49 07 0B 0013*  	call abs_hlu
0B18B4 F5          0014*  	push af ; save the sign and zero flags
0B18B5 CD C0 18 0B 0015*  	call print_HLU_u24
0B18B9 F1          0016*  	pop af
0B18BA F0          0017*  	ret p ; HLU was positive so nothig more to do
0B18BB 3E 2D       0018*  	ld a,'-'
0B18BD 5B D7       0019*  	rst.lil 10h
0B18BF C9          0020*  	ret
0B18C0             0021*  
0B18C0             0022*  ;------------------------------------------------------------------------
0B18C0             0023*  ;Full print and buffer routine so you can adjust behaviour
0B18C0             0024*  ; Double-Dabble AKA shift-and-add-3 algorithm
0B18C0             0025*  ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
0B18C0             0026*  ;Print value in HLU in decimal with leading 0s removed
0B18C0             0027*  ; Uses HLU, DEU, BCU
0B18C0             0028*  ;------------------------------------------------------------------------
0B18C0             0029*  
0B18C0             0030*  print_HLU_u24:
0B18C0 22 9D 19 0B 0031*  	ld	(hex_temp),hl
0B18C4 06 08       0032*  	ld	b,8	;8 digits max here with 24 bit unsigned
0B18C6 11 A0 19 0B 0033*  	ld	de,outbuf
0B18CA D5          0034*  	push	de
0B18CB 21 07 00 00 0035*  	ld	hl,7
0B18CF 19          0036*  	add	hl,de
0B18D0 E5          0037*  	push	hl
0B18D1 D1          0038*  	pop	de	;copy HLU to DEU
0B18D2 AF          0039*  	xor	a
0B18D3             0040*  _pde_u_zerobuf:
0B18D3 77          0041*  	ld	(hl),a	;zero out the output
0B18D4 2B          0042*  	dec	hl
0B18D5 10 FC       0043*  	djnz	_pde_u_zerobuf
0B18D7             0044*  
0B18D7 0E 18       0045*  	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
0B18D9             0046*  _bcd_Convert:
0B18D9             0047*  
0B18D9 21 9D 19 0B 0048*  	ld hl,hex_temp
0B18DD             0049*  ;
0B18DD CB 26       0050*  	sla (hl)
0B18DF 23          0051*  	inc hl
0B18E0 CB 16       0052*  	rl (hl)
0B18E2 23          0053*  	inc hl
0B18E3 CB 16       0054*  	rl (hl)		;24 bits rolled right
0B18E5             0055*  
0B18E5             0056*  
0B18E5 06 08       0057*          ld	b,8	;8 digits max for 24 bit decimal output
0B18E7 D5          0058*  	push	de
0B18E8 E1          0059*  	pop	hl
0B18E9             0060*  
0B18E9             0061*  _bcd_Add3:
0B18E9 7E          0062*  	ld	a,(hl)
0B18EA 8F          0063*  	adc	a
0B18EB 27          0064*          daa		;this is add 3 after shifting left; i.e. add 6.
0B18EC FE 10       0065*  	cp	10h	;did we roll over nibble?
0B18EE 3F          0066*  	ccf
0B18EF CB A7       0067*  	res	4,a
0B18F1             0068*  
0B18F1 77          0069*          ld (hl),a
0B18F2 2B          0070*  	dec	hl
0B18F3 10 F4       0071*          djnz	_bcd_Add3	;loop for decimal digits
0B18F5 0D          0072*          dec c
0B18F6 20 E1       0073*          jr nz, _bcd_Convert	;loop around
0B18F8             0074*  
0B18F8             0075*  
0B18F8 E1          0076*  	pop	hl
0B18F9 E5          0077*  	push	hl
0B18FA 06 07       0078*          ld	b,8-1		;one less than total in case output is '0'
0B18FC             0079*  _pde_u_make_ascii:
0B18FC 7E          0080*  	ld	a,(hl)
0B18FD B7          0081*  	or	a
0B18FE 20 05       0082*  	jr	nz,_pde_u_make_ascii2
0B1900 36 20       0083*  	ld	(hl),' '
0B1902 23          0084*  	inc	hl
0B1903 10 F7       0085*  	djnz	_pde_u_make_ascii
0B1905             0086*  _pde_u_make_ascii2:
0B1905 04          0087*  	inc	b
0B1906             0088*  _pde_u_make_ascii3:
0B1906 7E          0089*  	ld	a,(hl)
0B1907 F6 30       0090*  	or	30h
0B1909 77          0091*  	ld	(hl),a
0B190A 23          0092*  	inc	hl
0B190B 10 F9       0093*  	djnz	_pde_u_make_ascii3
0B190D             0094*  
0B190D E1          0095*  	pop	hl
0B190E 06 08       0096*  	ld	b,8
0B1910             0097*  _pde_u_final_out:
0B1910 7E          0098*  	ld	a,(hl)
0B1911 23          0099*  	inc	hl
0B1912 FE 20       0100*  	cp	' '
0B1914 28 02       0101*  	jr	z,_pde_u_final_out_strip
0B1916 5B D7       0102*  	rst.lil	10h
0B1918             0103*  _pde_u_final_out_strip:
0B1918 10 F6       0104*  	djnz	_pde_u_final_out
0B191A C9          0105*  	ret
0B191B             0106*  
0B191B             0107*  ;------------------------------------------------------------------------
0B191B             0108*  ; is_digit
0B191B             0109*  ; C flag set if A is a digit
0B191B             0110*  ; preserves all registers
0B191B             0111*  ;------------------------------------------------------------------------
0B191B             0112*  is_digit:
0B191B FE 30       0113*  	cp	'0'
0B191D 3F          0114*  	ccf
0B191E D0          0115*  	ret	nc	;less that '0'
0B191F FE 3A       0116*  	cp	'9' + 1
0B1921 C9          0117*  	ret
0B1922             0118*  
0B1922             0119*  
0B1922             0120*  ;------------------------------------------------------------------------
0B1922             0121*  ; char2hex
0B1922             0122*  ; Input: ASCII nibble in A
0B1922             0123*  ; Returns: if valid nibble value in A; else 0FFh in A
0B1922             0124*  ;------------------------------------------------------------------------
0B1922             0125*  char2hex:
0B1922 FE 30       0126*  	CP	'0'
0B1924 38 1D       0127*  	JR	C, char_not_hex
0B1926 FE 3A       0128*  	CP	'9' + 1
0B1928 30 03       0129*  	JR	NC, char_not_09
0B192A D6 30       0130*  	sub	'0'
0B192C C9          0131*  	ret
0B192D             0132*  
0B192D             0133*  char_not_09:
0B192D             0134*  	; char is not 0 to 9. Try upper case
0B192D FE 41       0135*  	CP	'A'
0B192F 38 12       0136*  	JR	C, char_not_hex
0B1931 FE 47       0137*  	CP	'F' + 1
0B1933 30 03       0138*  	JR	NC, char_not_AF
0B1935 D6 37       0139*  	sub	'A'-10
0B1937 C9          0140*  	ret
0B1938             0141*  
0B1938             0142*  char_not_AF:
0B1938             0143*  	; char is not upper case A-F. Try lower
0B1938 FE 61       0144*  	CP	'a'
0B193A 38 07       0145*  	JR	C, char_not_hex
0B193C FE 67       0146*  	CP	'f' + 1
0B193E 30 03       0147*  	JR	NC, char_not_hex
0B1940 D6 57       0148*  	sub	'a' - 10
0B1942 C9          0149*  	RET
0B1943             0150*  
0B1943             0151*  char_not_hex:
0B1943 3E FF       0152*   	ld	a,0FFh	;return -1 for not a valid hex digit
0B1945 C9          0153*  	RET
0B1946             0154*  
0B1946             0155*  ;------------------------------------------------------------------------
0B1946             0156*  ;  newline
0B1946             0157*  ;  Output CR+LF; all registers preserved
0B1946             0158*  ;------------------------------------------------------------------------
0B1946             0159*  newline:
0B1946 F5          0160*         push   AF
0B1947 3E 0D       0161*         LD     A, 13
0B1949 5B D7       0162*         RST.LIL    10h
0B194B 3E 0A       0163*         LD     A, 10
0B194D 5B D7       0164*         RST.LIL    10h
0B194F F1          0165*         POP    AF
0B1950 C9          0166*         RET
0B1951             0167*  
0B1951             0168*  ;------------------------------------------------------------------------
0B1951             0169*  ;  put_nibble
0B1951             0170*  ;  Output a single hex nibble in A
0B1951             0171*  ;  All registers preserved
0B1951             0172*  ;------------------------------------------------------------------------
0B1951             0173*  put_nibble:
0B1951 F5          0174*  	push   AF
0B1952 C6 90       0175*  	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
0B1954 27          0176*  	daa
0B1955 CE 40       0177*  	adc    a,040h
0B1957 27          0178*  	daa
0B1958 5B D7       0179*  	RST.LIL    10h	;output character in A
0B195A F1          0180*  	pop    AF
0B195B C9          0181*  	ret
0B195C             0182*  
0B195C             0183*  ;------------------------------------------------------------------------
0B195C             0184*  ;  print_A
0B195C             0185*  ;  Output the 8-bit hex number A
0B195C             0186*  ;  All registers preserved
0B195C             0187*  ;------------------------------------------------------------------------
0B195C             0188*  print_A:
0B195C F5          0189*  	push 	AF
0B195D F5          0190*  	push 	AF	;save for second nibble
0B195E 0F          0191*  	rrca
0B195F 0F          0192*  	rrca
0B1960 0F          0193*  	rrca
0B1961 0F          0194*  	rrca
0B1962 E6 0F       0195*  	and	0Fh	;first nibble
0B1964 CD 51 19 0B 0196*  	call	put_nibble
0B1968 F1          0197*  	pop 	AF
0B1969 E6 0F       0198*  	and	0Fh	;second nibble
0B196B CD 51 19 0B 0199*  	call	put_nibble
0B196F F1          0200*  	pop 	AF
0B1970 C9          0201*  	ret
0B1971             0202*  
0B1971             0203*  ;------------------------------------------------------------------------
0B1971             0204*  ;  print_HLU_hex
0B1971             0205*  ;  Output the 24-bit hex number HLU; other registers preserved
0B1971             0206*  ;------------------------------------------------------------------------
0B1971             0207*  print_HLU_hex:
0B1971 F5          0208*         push   AF
0B1972 22 9D 19 0B 0209*         ld     (hex_temp),hl
0B1976 3A 9F 19 0B 0210*         ld     a,(hex_temp+2)
0B197A CD 5C 19 0B 0211*         call   print_A
0B197E 3A 9E 19 0B 0212*         ld     a,(hex_temp+1)
0B1982 CD 5C 19 0B 0213*         call   print_A
0B1986 3A 9D 19 0B 0214*         ld     a,(hex_temp)
0B198A CD 5C 19 0B 0215*         call   print_A
0B198E F1          0216*         POP    AF
0B198F C9          0217*         RET
0B1990             0218*  
0B1990             0219*  ;------------------------------------------------------------------------
0B1990             0220*  ;  puts
0B1990             0221*  ;  Output a zero-terminated string whose address is in HL; all
0B1990             0222*  ;  registers preserved.
0B1990             0223*  ;------------------------------------------------------------------------
0B1990             0224*  puts:
0B1990 F5          0225*         push   AF
0B1991 C5          0226*         push   BC
0B1992 01 00 00 00 0227*         ld     BC, 0                ; Set to 0, so length ignored...
0B1996 3E 00       0228*         ld     A, 0                 ; Use character in A as delimiter
0B1998 5B DF       0229*         RST.LIL    18h                  ; This calls a RST in the eZ80 address space
0B199A C1          0230*         pop    BC
0B199B F1          0231*         pop    AF
0B199C C9          0232*         ret
0B199D             0233*  
0B199D             0234*  ;------------------------------------------------------------------------
0B199D             0235*  ; Data area
0B199D             0236*  ; Storage for 24 bit conversion
0B199D             0237*  ;------------------------------------------------------------------------
0B199D             0238*  hex_temp:
0B199D 00 00 00    0239*         dw24     0      ;3 bytes for HL used for both hex and decimal temp
0B19A0             0240*  
0B19A0             0241*  outbuf:
0B19A0 31 36 37 37 0242*  	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
0B19A9             0031   
0B19A9             0032   ; APPLICATION INCLUDES
0B19A9 55 73 61 67 0033   str_usage: ASCIZ "Usage: scratch <args>\r\n"
       65 3A 20 73 
       63 72 61 74 
       63 68 20 3C 
       61 72 67 73 
       3E 0D 0A 00 
0B19C1 45 72 72 6F 0034   str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B19CA 53 75 63 63 0035   str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B19D5             0036   
0B19D5             0037   ; This is a scratch moslet for testing new features
0B19D5             0038   ; Parameters:
0B19D5             0039   ;
0B19D5             0040   
0B19D5             0041   ; ========= BOILERPLATE MAIN LOOP =========
0B19D5             0042   ; The main routine
0B19D5             0043   ; IXU: argv - pointer to array of parameters
0B19D5             0044   ;   C: argc - number of parameters
0B19D5             0045   ; Returns:
0B19D5             0046   ;  HL: Error code, or 0 if OK
0B19D5             0047   
0B19D5             0048   min_args: equ 2
0B19D5             0049   
0B19D5             0050   _main:
0B19D5 79          0051       ld a,c              ; how many arguments?
0B19D6 FE 02       0052       cp min_args         ; not enough?
0B19D8 30 1A       0053       jr nc,main          ; if enough, go to main loop
0B19DA 21 A9 19 0B 0054       ld hl,str_usage     ; if not enough, print usage
0B19DE CD 73 02 0B 0055       call printString
0B19E2             0056                           ; fall through to _main_end_error
0B19E2             0057   
0B19E2             0058   _main_end_error:
0B19E2 21 C1 19 0B 0059       ld hl,str_error     ; print error message
0B19E6 CD 73 02 0B 0060       call printString
0B19EA 21 13 00 00 0061       ld hl,19            ; return error code 19
0B19EE C9          0062       ret
0B19EF             0063   
0B19EF             0064   _main_end_ok:
0B19EF             0065       ; ld hl,str_success   ; print success message
0B19EF             0066       ; call printString
0B19EF 21 00 00 00 0067       ld hl,0             ; return 0 for success
0B19F3 C9          0068       ret
0B19F4             0069   
0B19F4             0070   ; ========= BEGIN CUSTOM MAIN LOOP =========
0B19F4             0071   main:
0B19F4 0D          0072       dec c               ; decrement the argument count to skip the program name
0B19F5             0073   
0B19F5 C3 2C 1A 0B 0074       jp test_smul168
0B19F9             0075   
0B19F9             0076   test_sdiv168:
0B19F9 CD 52 1B 0B 0077       call get_arg_s168 ; get the dividend
0B19FD D5          0078       push de
0B19FE EB          0079       ex de,hl
0B19FF CD 38 04 0B 0080       call print_s168
0B1A03             0081   
0B1A03 CD 52 1B 0B 0082       call get_arg_s168 ; get the divisor
0B1A07 EB          0083       ex de,hl
0B1A08 CD 38 04 0B 0084       call print_s168
0B1A0C CD 88 02 0B 0085       call printNewLine
0B1A10 EB          0086       ex de,hl ; de = divisor
0B1A11 E1          0087       pop hl ; hl = dividend
0B1A12             0088   
0B1A12 CD 34 09 0B 0089       call sdiv168 ; de = quotient, hl = remainder
0B1A16 EB          0090       ex de,hl ; hl = quotient, de = remainder
0B1A17 CD 38 04 0B 0091       call print_s168
0B1A1B EB          0092       ex de,hl ; de = quotient, hl = remainder
0B1A1C CD 38 04 0B 0093       call print_s168
0B1A20 CD 88 02 0B 0094       call printNewLine
0B1A24 CD 88 02 0B 0095       call printNewLine
0B1A28             0096   
0B1A28 C3 EF 19 0B 0097       jp _main_end_ok
0B1A2C             0098   
0B1A2C             0099   test_smul168:
0B1A2C CD 52 1B 0B 0100       call get_arg_s168 ; get the dividend
0B1A30 D5          0101       push de
0B1A31 EB          0102       ex de,hl
0B1A32 CD 38 04 0B 0103       call print_s168
0B1A36             0104   
0B1A36 CD 52 1B 0B 0105       call get_arg_s168 ; get the divisor
0B1A3A EB          0106       ex de,hl
0B1A3B CD 38 04 0B 0107       call print_s168
0B1A3F CD 88 02 0B 0108       call printNewLine
0B1A43 EB          0109       ex de,hl ; de = divisor
0B1A44 E1          0110       pop hl ; hl = dividend
0B1A45             0111   
0B1A45 CD 9D 08 0B 0112       call smul168 ; hl = product
0B1A49 CD 38 04 0B 0113       call print_s168
0B1A4D CD 88 02 0B 0114       call printNewLine
0B1A51 CD 88 02 0B 0115       call printNewLine
0B1A55             0116   
0B1A55 C3 EF 19 0B 0117       jp _main_end_ok
0B1A59             0118   
0B1A59             0119   test_udiv168:
0B1A59 CD 52 1B 0B 0120       call get_arg_s168 ; get the dividend
0B1A5D D5          0121       push de
0B1A5E EB          0122       ex de,hl
0B1A5F CD 38 04 0B 0123       call print_s168
0B1A63             0124   
0B1A63 CD 52 1B 0B 0125       call get_arg_s168 ; get the divisor
0B1A67 EB          0126       ex de,hl
0B1A68 CD 38 04 0B 0127       call print_s168
0B1A6C CD 88 02 0B 0128       call printNewLine
0B1A70 EB          0129       ex de,hl ; de = divisor
0B1A71 E1          0130       pop hl ; hl = dividend
0B1A72             0131   
0B1A72 CD FD 08 0B 0132       call udiv168 ; de = quotient, hl = remainder
0B1A76 EB          0133       ex de,hl ; hl = quotient, de = remainder
0B1A77 CD 38 04 0B 0134       call print_s168
0B1A7B EB          0135       ex de,hl ; de = quotient, hl = remainder
0B1A7C CD 38 04 0B 0136       call print_s168
0B1A80 CD 88 02 0B 0137       call printNewLine
0B1A84             0138   
0B1A84 C3 EF 19 0B 0139       jp _main_end_ok
0B1A88             0140   
0B1A88             0141   test_udiv24:
0B1A88             0142   ; get dividend
0B1A88 CD 5D 1B 0B 0143       call get_arg_s24
0B1A8C D5          0144       push de
0B1A8D EB          0145       ex de,hl
0B1A8E CD A9 03 0B 0146       call print_u24
0B1A92             0147   ; get divisor
0B1A92 CD 5D 1B 0B 0148       call get_arg_s24
0B1A96 EB          0149       ex de,hl
0B1A97 CD A9 03 0B 0150       call print_u24
0B1A9B EB          0151       ex de,hl
0B1A9C CD 88 02 0B 0152       call printNewLine
0B1AA0 E1          0153       pop hl
0B1AA1             0154   
0B1AA1             0155   ; do the division
0B1AA1 CD D9 08 0B 0156       call udiv24 ; de = quotient, hl = remainder
0B1AA5 EB          0157       ex de,hl ; hl = quotient, de = remainder
0B1AA6 CD 66 05 0B 0158       call dumpRegistersHex
0B1AAA CD A9 03 0B 0159       call print_u24
0B1AAE EB          0160       ex de,hl ; de = quotient, hl = remainder
0B1AAF CD A9 03 0B 0161       call print_u24
0B1AB3             0162   
0B1AB3 C3 EF 19 0B 0163       jp _main_end_ok
0B1AB7             0164   @scratch: ds 4
0B1ABB             0165   
0B1ABB             0166   test_umul168:
0B1ABB CD 52 1B 0B 0167       call get_arg_s168
0B1ABF D5          0168       push de
0B1AC0 EB          0169       ex de,hl
0B1AC1 CD 38 04 0B 0170       call print_s168
0B1AC5             0171   
0B1AC5 CD 52 1B 0B 0172       call get_arg_s168
0B1AC9 D5          0173       push de
0B1ACA EB          0174       ex de,hl
0B1ACB CD 38 04 0B 0175       call print_s168
0B1ACF             0176   
0B1ACF E1          0177       pop hl
0B1AD0 D1          0178       pop de
0B1AD1 CD 95 08 0B 0179       call umul168
0B1AD5 CD 38 04 0B 0180       call print_s168
0B1AD9 CD 88 02 0B 0181       call printNewLine
0B1ADD CD 88 02 0B 0182       call printNewLine
0B1AE1             0183   
0B1AE1 C3 EF 19 0B 0184       jp _main_end_ok
0B1AE5             0185   
0B1AE5             0186   test_umul24x24:
0B1AE5 CD 5D 1B 0B 0187       call get_arg_s24
0B1AE9 D5          0188       push de
0B1AEA CD 5D 1B 0B 0189       call get_arg_s24
0B1AEE E1          0190       pop hl
0B1AEF             0191   
0B1AEF             0192       ; call dumpRegistersHex
0B1AEF CD 37 08 0B 0193       call umul24x24
0B1AF3             0194   
0B1AF3 2A 92 08 0B 0195       ld hl,(umul24x24out+3)
0B1AF7 CD D0 02 0B 0196       call printHexUHL
0B1AFB             0197   
0B1AFB 2A 8F 08 0B 0198       ld hl,(umul24x24out+0)
0B1AFF CD D0 02 0B 0199       call printHexUHL
0B1B03 CD 88 02 0B 0200       call printNewLine
0B1B07             0201   
0B1B07 C3 EF 19 0B 0202       jp _main_end_ok
0B1B0B             0203   
0B1B0B             0204   test_umul24x8:
0B1B0B             0205   ; 24-bit argument to BHL
0B1B0B CD 5D 1B 0B 0206       call get_arg_s24
0B1B0F EB          0207       ex de,hl
0B1B10             0208       HLU_TO_A
0B1B10 E5          0001M          push hl ; 4 cycles
0B1B11 33          0002M          inc sp ; 1 cycle
0B1B12 F1          0003M          pop af  ; 4 cycles
0B1B13 3B          0004M          dec sp ; 1 cycle
0B1B14             0005M                 ; 10 cycles total
0B1B14 47          0209       ld b,a ; b = high 8-bits
0B1B15 E5          0210       push hl ; store low 16-bits, b will be fine
0B1B16             0211   
0B1B16             0212   ; 8-bit argument to A TODO: write an 8-bit argument parser for performance
0B1B16 CD 5D 1B 0B 0213       call get_arg_s24
0B1B1A 7B          0214       ld a,e ; 8-bit argument
0B1B1B E1          0215       pop hl ; bhl is the 24-bit argument
0B1B1C             0216   
0B1B1C             0217   ; do the multiplication
0B1B1C CD 08 08 0B 0218       call umul24x8
0B1B20 CD F2 02 0B 0219       call printHexABHL
0B1B24 CD 88 02 0B 0220       call printNewLine
0B1B28 C3 EF 19 0B 0221       jp _main_end_ok
0B1B2C             0222   
0B1B2C             0223   test_scratch:
0B1B2C CD 5D 1B 0B 0224       call get_arg_s24
0B1B30 EB          0225       ex de,hl
0B1B31             0226       HLU_TO_A
0B1B31 E5          0001M          push hl ; 4 cycles
0B1B32 33          0002M          inc sp ; 1 cycle
0B1B33 F1          0003M          pop af  ; 4 cycles
0B1B34 3B          0004M          dec sp ; 1 cycle
0B1B35             0005M                 ; 10 cycles total
0B1B35             0227       ; call dumpRegistersHex
0B1B35 CD 88 02 0B 0228       call printNewLine
0B1B39 C3 EF 19 0B 0229       jp _main_end_ok
0B1B3D             0230   
0B1B3D             0231   test_deg_360_to_255:
0B1B3D CD 52 1B 0B 0232       call get_arg_s168 ; argument value to de
0B1B41 EB          0233       ex de,hl             ; argument to hl for function call
0B1B42 CD F5 0A 0B 0234       call deg_360_to_255
0B1B46             0235       ; call dumpRegistersHex
0B1B46 CD 38 04 0B 0236       call print_s168
0B1B4A CD 88 02 0B 0237       call printNewLine
0B1B4E C3 EF 19 0B 0238       jp _main_end_ok
0B1B52             0239   
0B1B52             0240   ; ========== HELPER FUNCTIONS ==========
0B1B52             0241   ; get the next argument after ix as a signed 16.8 fixed point number
0B1B52             0242   ; inputs: ix = pointer to the argument string
0B1B52             0243   ; outputs: ude = signed 16.8 fixed point number
0B1B52             0244   ; destroys: a, d, e, h, l, f
0B1B52             0245   get_arg_s168:
0B1B52 ED 32 03    0246       lea ix,ix+3 ; point to the next argument
0B1B55 DD 27 00    0247       ld hl,(ix)  ; get the argument string
0B1B58 CD 94 01 0B 0248       call asc_to_s168 ; convert the string to a number
0B1B5C C9          0249       ret ; return with the value in DE
0B1B5D             0250   
0B1B5D             0251   ; Inputs: ix = pointer to the argument string
0B1B5D             0252   ; Outputs: ude = signed 24-bit integer
0B1B5D             0253   ; Destroys: a, d, e, h, l, f
0B1B5D             0254   get_arg_s24:
0B1B5D ED 32 03    0255       lea ix,ix+3 ; point to the next argument
0B1B60 DD 27 00    0256       ld hl,(ix)  ; get the argument string
0B1B63 CD 45 01 0B 0257       call asc_to_s24 ; convert the string to a number
0B1B67 C9          0258       ret ; return with the value in DE
0B1B68             0259   
0B1B68             0260   get_plot_coords:
0B1B68             0261   ; get the move coordinates
0B1B68 ED 32 03    0262       lea ix,ix+3 ; pointer to next argument address
0B1B6B DD 27 00    0263       ld hl,(ix)  ; pointer to the x coordinate string
0B1B6E CD 94 01 0B 0264       call asc_to_s168 ; de = x coordinate
0B1B72 D5          0265       push de
0B1B73 C1          0266       pop bc ; bc = x coordinate
0B1B74 ED 32 03    0267       lea ix,ix+3 ; pointer to next argument address
0B1B77 DD 27 00    0268       ld hl,(ix)  ; pointer to the y coordinate string
0B1B7A CD 94 01 0B 0269       call asc_to_s168 ; de = y coordinate
0B1B7E C9          0270       ret
0B1B7F             0271   
0B1B7F             0272   ; match the next argument after ix to the dispatch table at iy
0B1B7F             0273   ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B1B7F             0274   ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B1B7F             0275   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B1B7F             0276   ;          ON MATCH: iy=dispatch address, a=0 and zero flag se
0B1B7F             0277   ; destroys: a, hl, de, ix, iy, flags
0B1B7F             0278   match_next:
0B1B7F ED 32 03    0279       lea ix,ix+3         ; point to the next argument
0B1B82             0280   @loop:
0B1B82 FD 27 00    0281       ld hl,(iy)          ; pointer argument dispatch record
0B1B85             0282       sign_hlu            ; check for list terminator
0B1B85 19          0001M          add hl,de
0B1B86 B7          0002M          or a
0B1B87 ED 52       0003M          sbc hl,de
0B1B89 CA A1 1B 0B 0283       jp z,@no_match      ; if a=0, return error
0B1B8D 23          0284       inc hl              ; skip over jp instruction
0B1B8E 23          0285       inc hl
0B1B8F DD 17 00    0286       ld de,(ix)          ; pointer to the argument string
0B1B92 CD A7 1B 0B 0287       call str_equal      ; compare the argument to the dispatch table entry
0B1B96 CA A3 1B 0B 0288       jp z,@match         ; if equal, return success
0B1B9A ED 33 03    0289       lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B1B9D C3 82 1B 0B 0290       jp @loop            ; and loop
0B1BA1             0291   @no_match:
0B1BA1 3C          0292       inc a               ; no match so return a=1 and zero flag reset
0B1BA2 C9          0293       ret
0B1BA3             0294   @match:
0B1BA3 FD 37 00    0295       ld iy,(iy)          ; get the function pointer
0B1BA6 C9          0296       ret                 ; return a=0 and zero flag set
0B1BA7             0297   
0B1BA7             0298   ; compare two zero-terminated strings for equality, case-sensitive
0B1BA7             0299   ; hl: pointer to first string, de: pointer to second string
0B1BA7             0300   ; returns: z if equal, nz if not equal
0B1BA7             0301   ; destroys: a, hl, de
0B1BA7             0302   str_equal:
0B1BA7 1A          0303       ld a,(de)           ; get the first character
0B1BA8 BE          0304       cp (hl)             ; compare to the second character
0B1BA9 C0          0305       ret nz              ; if not equal, return
0B1BAA B7          0306       or a
0B1BAB C8          0307       ret z               ; if equal and zero, return
0B1BAC 23          0308       inc hl              ; next character
0B1BAD 13          0309       inc de
0B1BAE C3 A7 1B 0B 0310       jp str_equal        ; loop until end of string
0B1BB2             0311   
0B1BB2             0312   ; print the parameter string pointed to by ix
0B1BB2             0313   ; destroys: a, hl
0B1BB2             0314   print_param:
0B1BB2 DD 27 00    0315       ld hl,(ix)          ; get the parameter pointer
0B1BB5 CD 73 02 0B 0316       call printString    ; print the parameter string
0B1BB9 3E 20       0317       ld a,' '            ; print a space separator
0B1BBB 5B D7       0318       rst.lil $10
0B1BBD C9          0319       ret
0B1BBE             0320   
0B1BBE             0321   ; print the parameters
0B1BBE             0322   ; inputs: b = number of parameters, ix = pointer to the parameters
0B1BBE             0323   ; destroys: a, hl, bc
0B1BBE             0324   print_params:
0B1BBE 41          0325       ld b,c              ; loop counter = number of parameters
0B1BBF DD E5       0326       push ix             ; save the pointer to the parameters
0B1BC1             0327   @loop:
0B1BC1 C5          0328       push bc             ; save the loop counter
0B1BC2 CD B2 1B 0B 0329       call print_param    ; print the parameter
0B1BC6 ED 32 03    0330       lea ix,ix+3         ; next parameter pointer
0B1BC9 C1          0331       pop bc              ; get back the loop counter
0B1BCA 10 F5       0332       djnz @loop          ; loop until done
0B1BCC DD E1       0333       pop ix              ; restore the pointer to the parameters
0B1BCE C9          0334       ret
0B1BCF             0335   
0B1BCF             0336   debug_print:
0B1BCF CD 88 02 0B 0337       call printNewLine   ; DEBUG
0B1BD3 CD 69 06 0B 0338       call dumpFlags      ; DEBUG
0B1BD7 CD B2 1B 0B 0339       call print_param    ; DEBUG
0B1BDB CD 88 02 0B 0340       call printNewLine   ; DEBUG
0B1BDF CD 88 02 0B 0341       call printNewLine   ; DEBUG
0B1BE3 C9          0342       ret
