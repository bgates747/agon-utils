PC     Output      Line
040000             0001   ;
040000             0002   ; Title:	test
040000             0003   ; Author:	Brandon Gates
040000             0004   ; Created:	29/10/2024
040000             0005   
040000             0006       ASSUME	ADL = 1
040000             0007       INCLUDE "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  ; 09/04/2024:   Adapter to ez80asm
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ;FFOBJID	.STRUCT
040000             0196*  ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ;	id:		DS	2	; Hosting volume mount ID
040000             0198*  ;	attr:		DS	1	; Object attribute;
040000             0199*  ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ;
040000             0204*  ; File object structure (FIL)
040000             0205*  ;
040000             0206*  ;FIL .STRUCT
040000             0207*  ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ;	flag:		DS	1	; File status flags
040000             0209*  ;	err:		DS	1	; Abort flag (error code)
040000             0210*  ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  ;DIR .STRUCT
040000             0220*  ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*  ;	dptr:		DS	4	; Current read/write offset
040000             0222*  ;	clust:		DS	4	; Current cluster
040000             0223*  ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ;
040000             0229*  ; File information structure (FILINFO)
040000             0230*  ;
040000             0231*  ;FILINFO .STRUCT
040000             0232*  ;	fsize:		DS 	4	; File size
040000             0233*  ;	fdate:		DS	2	; Modified date;
040000             0234*  ;	ftime:		DS	2	; Modified time
040000             0235*  ;	fattrib:	DS	1	; File attribute
040000             0236*  ;	altname:	DS	13	; Alternative file name
040000             0237*  ;	fname:		DS	256	; Primary file name
040000             0238*  ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  			MACRO	MOSCALL function
040000             0246*  			LD	A, function
040000             0247*  			RST.L	08h
040000             0248*  			ENDMACRO
040000             0008       ORG 0x0B0000 ; Is a moslet
0B0000             0009   
0B0000             0010       MACRO PROGNAME
0B0000             0011       ASCIZ "scratch.bin"
0B0000             0012       ENDMACRO
0B0000             0013   
0B0000             0014   ; STANDARD MOSLET INCLUDES
0B0000             0015       include "init.inc"
0B0000             0001*  ;
0B0000             0002*  ; Title:	Copy - Initialisation Code
0B0000             0003*  ; Author:	Dean Belfield, Lennart Benschop
0B0000             0004*  ; Created:	06/11/2022
0B0000             0005*  ; Last Updated:	26/12/2022
0B0000             0006*  ;
0B0000             0007*  ; Modinfo:
0B0000             0008*  ; 17/12/2022:	Added parameter processing
0B0000             0009*  ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
0B0000             0010*  ; Changed:      08/04/2924 adapt to ez80asm
0B0000             0011*  
0B0000             0012*  
0B0000             0013*  argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B0000             0014*  
0B0000             0015*  ;
0B0000             0016*  ; Start in ADL mode
0B0000             0017*  ;
0B0000 C3 45 00 0B 0018*  			JP	_start			; Jump to start
0B0004             0019*  ;
0B0004             0020*  ; The header stuff is from byte 64 onwards
0B0004             0021*  ;
0B0004             0022*  
0B0004             0023*  _exec_name:
0B0004             0024*  			PROGNAME			; The executable name, only used in argv
0B0004 73 63 72 61 0001*M     ASCIZ "scratch.bin"
       74 63 68 2E 
       62 69 6E 00 
0B0010             0025*  
0B0010 FF FF FF FF 0026*  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B0040             0027*  
0B0040 4D 4F 53    0028*  			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0029*  			DB	00h			; MOS header version 0
0B0044 01          0030*  			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0031*  ;
0B0045             0032*  ; And the code follows on immediately after the header
0B0045             0033*  ;
0B0045 F5          0034*  _start:			PUSH	AF			; Preserve the registers
0B0046 C5          0035*  			PUSH	BC
0B0047 D5          0036*  			PUSH	DE
0B0048 DD E5       0037*  			PUSH	IX
0B004A FD E5       0038*  			PUSH	IY
0B004C ED 6E       0039*  			LD	A, MB			; Save MB
0B004E F5          0040*  			PUSH 	AF
0B004F AF          0041*  			XOR 	A
0B0050 ED 6D       0042*  			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0043*  
0B0052 DD 21 B9 00 0044*  			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B0057 DD E5       0045*  			PUSH	IX
0B0059 CD 70 00 0B 0046*  			CALL	_parse_params		; Parse the parameters
0B005D DD E1       0047*  			POP	IX			; IX: argv
0B005F 06 00       0048*  			LD	B, 0			;  C: argc
0B0061 CD 81 19 0B 0049*  			CALL	_main			; Start user code
0B0065             0050*  
0B0065 F1          0051*  			POP 	AF
0B0066 ED 6D       0052*  			LD	MB, A
0B0068 FD E1       0053*  			POP	IY			; Restore registers
0B006A DD E1       0054*  			POP	IX
0B006C D1          0055*  			POP	DE
0B006D C1          0056*  			POP	BC
0B006E F1          0057*  			POP	AF
0B006F C9          0058*  			RET
0B0070             0059*  
0B0070             0060*  ; Parse the parameter string into a C array
0B0070             0061*  ; Parameters
0B0070             0062*  ; - HL: Address of parameter string
0B0070             0063*  ; - IX: Address for array pointer storage
0B0070             0064*  ; Returns:
0B0070             0065*  ; -  C: Number of parameters parsed
0B0070             0066*  ;
0B0070 01 04 00 0B 0067*  _parse_params:		LD	BC, _exec_name
0B0074 DD 0F 00    0068*  			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0077 ED 32 03    0069*  			LEA     IX, IX+3
0B007A CD B2 00 0B 0070*  			CALL	_skip_spaces		; Skip HL past any leading spaces
0B007E             0071*  ;
0B007E 01 01 00 00 0072*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0082 06 0F       0073*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0084             0074*  ;
0B0084             0075*  _parse_params_1:
0B0084 C5          0076*  			PUSH	BC			; Stack ARGC
0B0085 E5          0077*  			PUSH	HL			; Stack start address of token
0B0086 CD A3 00 0B 0078*  			CALL	_get_token		; Get the next token
0B008A 79          0079*  			LD	A, C			; A: Length of the token in characters
0B008B D1          0080*  			POP	DE			; Start address of token (was in HL)
0B008C C1          0081*  			POP	BC			; ARGC
0B008D B7          0082*  			OR	A			; Check for A=0 (no token found) OR at end of string
0B008E C8          0083*  			RET	Z
0B008F             0084*  ;
0B008F DD 1F 00    0085*  			LD	(IX+0), DE		; Store the pointer to the token
0B0092 E5          0086*  			PUSH	HL			; DE=HL
0B0093 D1          0087*  			POP	DE
0B0094 CD B2 00 0B 0088*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0098 AF          0089*  			XOR	A
0B0099 12          0090*  			LD	(DE), A			; Zero-terminate the token
0B009A ED 32 03    0091*  			LEA  	IX, IX+3			; Advance to next pointer position
0B009D 0C          0092*  			INC	C			; Increment ARGC
0B009E 79          0093*  			LD	A, C			; Check for C >= A
0B009F B8          0094*  			CP	B
0B00A0 38 E2       0095*  			JR	C, _parse_params_1	; And loop
0B00A2 C9          0096*  			RET
0B00A3             0097*  
0B00A3             0098*  ; Get the next token
0B00A3             0099*  ; Parameters:
0B00A3             0100*  ; - HL: Address of parameter string
0B00A3             0101*  ; Returns:
0B00A3             0102*  ; - HL: Address of first character after token
0B00A3             0103*  ; -  C: Length of token (in characters)
0B00A3             0104*  ;
0B00A3 0E 00       0105*  _get_token:		LD	C, 0			; Initialise length
0B00A5 7E          0106*  @@:			LD	A, (HL)			; Get the character from the parameter string
0B00A6 B7          0107*  			OR	A			; Exit if 0 (end of parameter string in MOS)
0B00A7 C8          0108*  			RET 	Z
0B00A8 FE 0D       0109*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AA C8          0110*  			RET	Z
0B00AB FE 20       0111*  			CP	' '			; Exit if space (end of token)
0B00AD C8          0112*  			RET	Z
0B00AE 23          0113*  			INC	HL			; Advance to next character
0B00AF 0C          0114*  			INC 	C			; Increment length
0B00B0 18 F3       0115*  			JR	@B
0B00B2             0116*  
0B00B2             0117*  ; Skip spaces in the parameter string
0B00B2             0118*  ; Parameters:
0B00B2             0119*  ; - HL: Address of parameter string
0B00B2             0120*  ; Returns:
0B00B2             0121*  ; - HL: Address of next none-space character
0B00B2             0122*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00B2             0123*  ;
0B00B2 7E          0124*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B3 FE 20       0125*  			CP	' '			; Exit if not space
0B00B5 C0          0126*  			RET	NZ
0B00B6 23          0127*  			INC	HL			; Advance to next character
0B00B7 18 F9       0128*  			JR	_skip_spaces		; Increment length
0B00B9             0129*  
0B00B9             0130*  ; Storage for the argv array pointers
0B00B9             0131*  ;
0B00B9 00 00 00 00 0132*  argv_ptrs:		BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B00E9             0016       include "parse.inc"
0B00E9             0001*  ;
0B00E9             0002*  ; Title:	Number Parsing Functions
0B00E9             0003*  ; Author:	Dean Belfield
0B00E9             0004*  ; Created:	15/11/2022
0B00E9             0005*  ; Last Updated:	15/11/2022
0B00E9             0006*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B00E9             0007*  ; Modinfo:
0B00E9             0008*  ; 2024/04/08    Adapt for ez80asm
0B00E9             0009*  
0B00E9             0010*  ; Read a number and convert to binary
0B00E9             0011*  ; If prefixed with &, will read as hex, otherwise decimal
0B00E9             0012*  ;   Inputs: HL: Pointer in string buffer
0B00E9             0013*  ;  Outputs: HL: Updated text pointer
0B00E9             0014*  ;           DE: Value
0B00E9             0015*  ;            A: Terminator (spaces skipped)
0B00E9             0016*  ;            F: Carry set if valid number, otherwise reset
0B00E9             0017*  ; Destroys: A,D,E,H,L,F
0B00E9             0018*  ;
0B00E9 11 00 00 00 0019*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B00ED CD B2 00 0B 0020*  			CALL		_skip_spaces		; Skip whitespace
0B00F1 7E          0021*  			LD		A, (HL)			; Read first character
0B00F2 B7          0022*  			OR		A			; Check for end of string
0B00F3 C8          0023*  			RET		Z			; Return with no carry if not
0B00F4 C5          0024*  			PUSH		BC			; Preserve BC
0B00F5 FE 26       0025*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B00F7 20 23       0026*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B00F9 23          0027*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B00FA             0028*  ;
0B00FA 7E          0029*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B00FB CD 3D 01 0B 0030*  			CALL   	 	UPPRC			; Convert to uppercase
0B00FF D6 30       0031*  			SUB		'0'			; Normalise to 0
0B0101 38 37       0032*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0103 FE 0A       0033*  			CP 		10			; Check if >= 10
0B0105 38 06       0034*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0107 D6 07       0035*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0109 FE 10       0036*  			CP 		16			; Check for > F
0B010B 30 2D       0037*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B010D             0038*  ;
0B010D E5          0039*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B010E D5          0040*  			PUSH		DE			; LD HL, DE
0B010F E1          0041*  			POP		HL
0B0110 29          0042*  			ADD		HL, HL
0B0111 29          0043*  			ADD		HL, HL
0B0112 29          0044*  			ADD		HL, HL
0B0113 29          0045*  			ADD		HL, HL
0B0114 E5          0046*  			PUSH		HL			; LD DE, HL
0B0115 D1          0047*  			POP		DE
0B0116 E1          0048*  			POP		HL			; Restore HL
0B0117 B3          0049*  			OR      	E			; OR the new digit in to the least significant nibble
0B0118 5F          0050*  			LD      	E, A
0B0119             0051*  ;
0B0119 23          0052*  			INC		HL			; Onto the next character
0B011A 18 DE       0053*  			JR      	ASC_TO_NUMBER1		; And loop
0B011C             0054*  ;
0B011C 7E          0055*  ASC_TO_NUMBER3:		LD		A, (HL)
0B011D D6 30       0056*  			SUB		'0'			; Normalise to 0
0B011F 38 19       0057*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0121 FE 0A       0058*  			CP		10			; Check if >= 10
0B0123 30 15       0059*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0125             0060*  ;
0B0125 E5          0061*  			PUSH		HL			; Stack HL
0B0126 D5          0062*  			PUSH		DE			; LD HL, DE
0B0127 E1          0063*  			POP		HL
0B0128 E5          0064*  			PUSH		HL			; LD BC, HL
0B0129 C1          0065*  			POP		BC
0B012A 29          0066*  			ADD		HL, HL 			; x 2
0B012B 29          0067*  			ADD		HL, HL 			; x 4
0B012C 09          0068*  			ADD		HL, BC 			; x 5
0B012D 29          0069*  			ADD		HL, HL 			; x 10
0B012E 01 00 00 00 0070*  			LD		BC, 0
0B0132 4F          0071*  			LD 		C, A			; LD BCU, A
0B0133 09          0072*  			ADD		HL, BC			; Add BCU to HL
0B0134 E5          0073*  			PUSH		HL			; LD DE, HL
0B0135 D1          0074*  			POP		DE
0B0136 E1          0075*  			POP		HL			; Restore HL
0B0137             0076*  ;
0B0137 23          0077*  			INC		HL
0B0138 18 E2       0078*  			JR		ASC_TO_NUMBER3
0B013A C1          0079*  ASC_TO_NUMBER4:		POP		BC
0B013B 37          0080*  			SCF					; We have a valid number so set carry
0B013C C9          0081*  			RET
0B013D             0082*  
0B013D             0083*  
0B013D             0084*  ; Convert a character to upper case
0B013D             0085*  ;  A: Character to convert
0B013D             0086*  ;
0B013D E6 7F       0087*  UPPRC:  		AND     	7FH
0B013F FE 60       0088*  			CP      	'`'
0B0141 D8          0089*  			RET     	C
0B0142 E6 5F       0090*  			AND     	5FH			; Convert to upper case
0B0144 C9          0091*  			RET
0B0145             0092*  
0B0145             0093*  
0B0145             0094*  ;------------------------------------------------------------------------
0B0145             0095*  ; Read a number and convert to binary (decimal only)
0B0145             0096*  ; Inputs: hl: Pointer in string buffer
0B0145             0097*  ; Outputs: hl: Updated text pointer
0B0145             0098*  ;         de: Value
0B0145             0099*  ;         a: Terminator (spaces skipped)
0B0145             0100*  ;         f: Carry set if valid number, otherwise reset
0B0145             0101*  ; Destroys: a, d, e, h, l, f
0B0145             0102*  ;------------------------------------------------------------------------
0B0145             0103*  asc_to_sint:
0B0145 3E 01       0104*      ld a,1 ; set sign flag
0B0147 32 97 01 0B 0105*      ld (@sign),a ; store sign flag
0B014B             0106*  
0B014B 11 00 00 00 0107*      ld de, 0 ; initialise de
0B014F CD B2 00 0B 0108*      call _skip_spaces ; skip whitespace
0B0153             0109*  
0B0153 7E          0110*      ld a, (hl) ; read first character
0B0154 B7          0111*      or a ; check for end of string
0B0155 C8          0112*      ret z ; return with no carry if not
0B0156             0113*  
0B0156 C5          0114*      push bc ; preserve bc
0B0157             0115*  
0B0157 FE 2D       0116*      cp '-' ; check for negative number
0B0159 C2 63 01 0B 0117*      jp nz,@loop ; number is positive, nothing more to do
0B015D AF          0118*      xor a ; sign flag to zero
0B015E 32 97 01 0B 0119*      ld (@sign),a ; store sign flag
0B0162 23          0120*      inc hl ; skip '-'
0B0163             0121*  
0B0163             0122*  @loop:
0B0163 7E          0123*      ld a, (hl)
0B0164 D6 30       0124*      sub '0' ; normalise to 0
0B0166 38 19       0125*      jr c, @integer_end ; return if < ascii '0'
0B0168 FE 0A       0126*      cp 10 ; check if >= 10
0B016A 30 15       0127*      jr nc, @integer_end ; return if >= 10
0B016C E5          0128*      push hl ; stack hl
0B016D D5          0129*      push de ; ld hl, de
0B016E E1          0130*      pop hl
0B016F E5          0131*      push hl ; ld bc, hl
0B0170 C1          0132*      pop bc
0B0171 29          0133*      add hl, hl ; x 2
0B0172 29          0134*      add hl, hl ; x 4
0B0173 09          0135*      add hl, bc ; x 5
0B0174 29          0136*      add hl, hl ; x 10
0B0175 01 00 00 00 0137*      ld bc, 0
0B0179 4F          0138*      ld c, a ; ld bcu, a
0B017A 09          0139*      add hl, bc ; add bcu to hl
0B017B E5          0140*      push hl ; ld de, hl
0B017C D1          0141*      pop de
0B017D E1          0142*      pop hl ; restore hl
0B017E 23          0143*      inc hl
0B017F 18 E2       0144*      jr @loop
0B0181             0145*  
0B0181             0146*  @integer_end:
0B0181 C1          0147*      pop bc ; send bc back how she came in
0B0182 3A 97 01 0B 0148*      ld a, (@sign) ; get sign flag
0B0186 3D          0149*      dec a ; check if negative
0B0187 F2 95 01 0B 0150*      jp p,@pos ; positive number
0B018B             0151*  
0B018B             0152*  ; Negate de
0B018B E5          0153*      push hl ; save text pointer
0B018C 21 00 00 00 0154*      ld hl, 0
0B0190 AF          0155*      xor a ; clear carry
0B0191 ED 52       0156*      sbc hl, de ; subtract DE from HL
0B0193 EB          0157*      ex de, hl ; DE = 0-HL
0B0194 E1          0158*      pop hl ; restore text pointer
0B0195             0159*  
0B0195             0160*  @pos:
0B0195 37          0161*      scf ; we have a valid number so set carry
0B0196 C9          0162*      ret
0B0197             0163*  
0B0197 00          0164*  @sign: db 0 ; sign flag buffer
0B0198             0165*  
0B0198             0166*  
0B0198             0167*  ;------------------------------------------------------------------------
0B0198             0168*  ; Read a number and convert to binary (decimal only)
0B0198             0169*  ; Inputs: hl: Pointer in string buffer
0B0198             0170*  ; Outputs: hl: Updated text pointer
0B0198             0171*  ;         de: Value
0B0198             0172*  ;         a: Terminator (spaces skipped)
0B0198             0173*  ;         f: Carry set if valid number, otherwise reset
0B0198             0174*  ; Destroys: a, d, e, h, l, f
0B0198             0175*  ;------------------------------------------------------------------------
0B0198             0176*  asc_to_s168:
0B0198 3E 01       0177*      ld a,1 ; set sign flag
0B019A 32 57 02 0B 0178*      ld (@sign),a ; store sign flag
0B019E             0179*  
0B019E 11 00 00 00 0180*      ld de, 0 ; initialise de
0B01A2 ED 53 4F 02 0181*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B01A7 ED 53 53 02 0182*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B01AC             0183*  
0B01AC CD B2 00 0B 0184*      call _skip_spaces ; skip whitespace
0B01B0             0185*  
0B01B0 7E          0186*      ld a, (hl) ; read first character
0B01B1 B7          0187*      or a ; check for end of string
0B01B2 C8          0188*      ret z ; return with no carry if not
0B01B3             0189*  
0B01B3 C5          0190*      push bc ; preserve bc
0B01B4             0191*  
0B01B4 FE 2D       0192*      cp '-' ; check for negative number
0B01B6 C2 C0 01 0B 0193*      jp nz,@loop ; number is positive, nothing more to do
0B01BA AF          0194*      xor a ; sign flag to zero
0B01BB 32 57 02 0B 0195*      ld (@sign),a ; store sign flag
0B01BF 23          0196*      inc hl ; skip '-'
0B01C0             0197*  
0B01C0             0198*  @loop:
0B01C0 7E          0199*      ld a, (hl)
0B01C1             0200*  
0B01C1             0201*  ; chcek for decimal point
0B01C1 FE 2E       0202*      cp '.' ; check for decimal point
0B01C3 CA 04 02 0B 0203*      jp z,@fractional_start ; jump to fractional part
0B01C7             0204*  
0B01C7             0205*  ; process integer part
0B01C7 D6 30       0206*      sub '0' ; normalise to 0
0B01C9 38 19       0207*      jr c, @integer_end ; return if < ascii '0'
0B01CB FE 0A       0208*      cp 10 ; check if >= 10
0B01CD 30 15       0209*      jr nc, @integer_end ; return if >= 10
0B01CF E5          0210*      push hl ; stack hl
0B01D0 D5          0211*      push de ; ld hl, de
0B01D1 E1          0212*      pop hl
0B01D2 E5          0213*      push hl ; ld bc, hl
0B01D3 C1          0214*      pop bc
0B01D4 29          0215*      add hl, hl ; x 2
0B01D5 29          0216*      add hl, hl ; x 4
0B01D6 09          0217*      add hl, bc ; x 5
0B01D7 29          0218*      add hl, hl ; x 10
0B01D8 01 00 00 00 0219*      ld bc, 0
0B01DC 4F          0220*      ld c, a ; ld bcu, a
0B01DD 09          0221*      add hl, bc ; add bcu to hl
0B01DE E5          0222*      push hl ; ld de, hl
0B01DF D1          0223*      pop de
0B01E0 E1          0224*      pop hl ; restore hl
0B01E1 23          0225*      inc hl
0B01E2 18 DC       0226*      jr @loop
0B01E4             0227*  
0B01E4             0228*  @integer_end:
0B01E4 ED 53 50 02 0229*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B01E9             0230*  
0B01E9             0231*  @end:
0B01E9 C1          0232*      pop bc ; send bc back how she came in
0B01EA ED 5B 4F 02 0233*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B01EF 3A 57 02 0B 0234*      ld a, (@sign) ; get sign flag
0B01F3 3D          0235*      dec a ; check if negative
0B01F4 F2 02 02 0B 0236*      jp p,@pos ; positive number
0B01F8             0237*  
0B01F8             0238*  ; Negate de
0B01F8 E5          0239*      push hl ; save text pointer
0B01F9 21 00 00 00 0240*      ld hl, 0
0B01FD AF          0241*      xor a ; clear carry
0B01FE ED 52       0242*      sbc hl, de ; subtract DE from HL
0B0200 EB          0243*      ex de, hl ; DE = 0-HL
0B0201 E1          0244*      pop hl ; restore text pointer
0B0202             0245*  
0B0202             0246*  @pos:
0B0202 37          0247*      scf ; we have a valid number so set carry
0B0203 C9          0248*      ret
0B0204             0249*  
0B0204             0250*  @fractional_start:
0B0204 ED 53 50 02 0251*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0209 06 03       0252*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B020B 11 00 00 00 0253*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B020F DD 21 58 02 0254*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B0214 23          0255*      inc hl                     ; Skip decimal point
0B0215             0256*  
0B0215             0257*  @fractional_loop:
0B0215 7E          0258*      ld a, (hl)                 ; Load next character
0B0216 D6 30       0259*      sub '0'                    ; Normalize ASCII to decimal
0B0218 38 1C       0260*      jr c, @end_fraction        ; Exit if < '0'
0B021A FE 0A       0261*      cp 10
0B021C 30 18       0262*      jr nc, @end_fraction       ; Exit if >= 10
0B021E             0263*  
0B021E             0264*      ; Multiply the current fractional accumulator by 10
0B021E E5          0265*      push hl                    ; Save char pointer
0B021F F5          0266*      push af                    ; Save the digit
0B0220 EB          0267*      ex de, hl
0B0221 E5          0268*      push hl
0B0222 29          0269*      add hl,hl ; * 2
0B0223 29          0270*      add hl,hl ; * 4
0B0224 D1          0271*      pop de
0B0225 19          0272*      add hl,de ; * 5
0B0226 29          0273*      add hl,hl ; * 10
0B0227 11 00 00 00 0274*      ld de, 0                   ; Clear DEU
0B022B F1          0275*      pop af                     ; Restore the current digit
0B022C 5F          0276*      ld e, a                    ; Load the digit into E
0B022D 19          0277*      add hl, de                 ; Add the digit to the accumulator
0B022E EB          0278*      ex de, hl                  ; Result back to DE
0B022F ED 32 03    0279*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B0232 E1          0280*      pop hl                     ; Restore char pointer
0B0233 23          0281*      inc hl                     ; Move to the next character
0B0234 10 DF       0282*      djnz @fractional_loop      ; Loop if more digits to process
0B0236             0283*  
0B0236             0284*  @end_fraction:
0B0236             0285*  ; Final scaling based on number of fractional digits processed
0B0236 ED 53 54 02 0286*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B023B 2A 53 02 0B 0287*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B023F             0288*  
0B023F DD 17 00    0289*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B0242 CD 61 0E 0B 0290*      call udiv24                ; Perform 24-bit division to scale down
0B0246 7B          0291*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0247 32 4F 02 0B 0292*      ld (@result), a            ; Store fractional part in result buffer
0B024B C3 E9 01 0B 0293*      jp @end                    ; Final sign check and flag setup
0B024F             0294*  
0B024F             0295*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B0253             0296*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0257 00          0297*  @sign: db 0                    ; Sign flag buffer
0B0258             0298*  
0B0258             0299*  powers_of_10:
0B0258 01 00 00    0300*      dl 1                       ; 10^0
0B025B 0A 00 00    0301*      dl 10                      ; 10^1
0B025E 64 00 00    0302*      dl 100                     ; 10^2
0B0261 E8 03 00    0303*      dl 1000                    ; 10^3
0B0264 10 27 00    0304*      dl 10000                   ; 10^4
0B0267             0017   
0B0267             0018   ; API INCLUDES
0B0267             0019       include "functions.inc"
0B0267             0001*      MACRO printChar char
0B0267             0002*          LD A, char
0B0267             0003*          RST.LIL 10h
0B0267             0004*      ENDMACRO
0B0267             0005*  
0B0267             0006*  ; test the sign of HL
0B0267             0007*  ; inputs: HL obviously
0B0267             0008*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B0267             0009*  ; destroys: flags
0B0267             0010*      MACRO signHL
0B0267             0011*          add hl,de
0B0267             0012*          or a
0B0267             0013*          sbc hl,de
0B0267             0014*      ENDMACRO
0B0267             0015*  
0B0267             0016*  ; Simulated call to subroutine at HL
0B0267             0017*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0B0267             0018*  ; outputs: whatever the subroutine does, including HL and BC
0B0267             0019*  ; destroys: only what the subroutine does, but always BC
0B0267             0020*      MACRO callHL
0B0267             0021*          ld bc,$+7     ; Address of first instruction after the jump
0B0267             0022*          push bc       ; which constitutes the return address
0B0267             0023*          jp   (hl)     ; Jump to the address in HL
0B0267             0024*      ENDMACRO
0B0267             0025*  
0B0267             0026*  ; Simulated call to subroutine at IX
0B0267             0027*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0B0267             0028*  ; outputs: whatever the subroutine does, including IX and BC
0B0267             0029*  ; destroys: only what the subroutine does, but always BC
0B0267             0030*      MACRO callIX
0B0267             0031*          ld bc,$+7     ; Address of first instruction after the jump
0B0267             0032*          push bc       ; which constitutes the return address
0B0267             0033*          jp   (ix)     ; Jump to the address in IX
0B0267             0034*      ENDMACRO
0B0267             0035*  
0B0267             0036*  ; Simulated call to soubroutinte at IY
0B0267             0037*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0B0267             0038*  ; outputs: whatever the subroutine does, including IY and BC
0B0267             0039*  ; destroys: only what the subroutine does, but always BC
0B0267             0040*      MACRO callIY
0B0267             0041*          ld bc,$+7     ; Address of first instruction after the jump
0B0267             0042*          push bc       ; which constitutes the return address
0B0267             0043*          jp   (iy)     ; Jump to the address in IY
0B0267             0044*      ENDMACRO
0B0267             0045*  
0B0267             0046*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0267             0047*  ; Print a zero-terminated string
0B0267             0048*  ; HL: Pointer to string
0B0267             0049*  printString:
0B0267 C5          0050*  	PUSH	BC
0B0268 01 00 00 00 0051*  	LD		BC,0
0B026C 3E 00       0052*  	LD 	 	A,0
0B026E 5B DF       0053*  	RST.LIL 18h
0B0270 C1          0054*  	POP		BC
0B0271 C9          0055*  	RET
0B0272             0056*  ; print a VDU sequence
0B0272             0057*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B0272             0058*  sendVDUsequence:
0B0272 C5          0059*  	PUSH	BC
0B0273 01 00 00 00 0060*  	LD		BC, 0
0B0277 4E          0061*  	LD		C, (HL)
0B0278 5B DF       0062*  	RST.LIL	18h
0B027A C1          0063*  	POP		BC
0B027B C9          0064*  	RET
0B027C             0065*  ; Print Newline sequence to VDP
0B027C             0066*  printNewLine:
0B027C F5          0067*      push af ; for some reason rst.lil 10h sets carry flag
0B027D 3E 0D       0068*  	LD	A, '\r'
0B027F 5B D7       0069*  	RST.LIL 10h
0B0281 3E 0A       0070*  	LD	A, '\n'
0B0283 5B D7       0071*  	RST.LIL 10h
0B0285 F1          0072*      pop af
0B0286 C9          0073*  	RET
0B0287             0074*  ; Print a 24-bit HEX number
0B0287             0075*  ; HLU: Number to print
0B0287             0076*  printHex24:
0B0287 E5          0077*  	PUSH	HL
0B0288 21 02 00 00 0078*  	LD		HL, 2
0B028C 39          0079*  	ADD		HL, SP
0B028D 7E          0080*  	LD		A, (HL)
0B028E E1          0081*  	POP		HL
0B028F CD 99 02 0B 0082*  	CALL	printHex8
0B0293             0083*  ; Print a 16-bit HEX number
0B0293             0084*  ; HL: Number to print
0B0293             0085*  printHex16:
0B0293 7C          0086*  	LD		A,H
0B0294 CD 99 02 0B 0087*  	CALL	printHex8
0B0298 7D          0088*  	LD		A,L
0B0299             0089*  ; Print an 8-bit HEX number
0B0299             0090*  ; A: Number to print
0B0299             0091*  printHex8:
0B0299 4F          0092*  	LD		C,A
0B029A 1F          0093*  	RRA
0B029B 1F          0094*  	RRA
0B029C 1F          0095*  	RRA
0B029D 1F          0096*  	RRA
0B029E CD A3 02 0B 0097*  	CALL	@F
0B02A2 79          0098*  	LD		A,C
0B02A3             0099*  @@:
0B02A3 E6 0F       0100*  	AND		0Fh
0B02A5 C6 90       0101*  	ADD		A,90h
0B02A7 27          0102*  	DAA
0B02A8 CE 40       0103*  	ADC		A,40h
0B02AA 27          0104*  	DAA
0B02AB 5B D7       0105*  	RST.LIL	10h
0B02AD C9          0106*  	RET
0B02AE             0107*  
0B02AE             0108*  ; Print a 0x HEX prefix
0B02AE             0109*  DisplayHexPrefix:
0B02AE 3E 30       0110*  	LD	A, '0'
0B02B0 5B D7       0111*  	RST.LIL 10h
0B02B2 3E 78       0112*  	LD	A, 'x'
0B02B4 5B D7       0113*  	RST.LIL 10h
0B02B6 C9          0114*  	RET
0B02B7             0115*  
0B02B7             0116*      MACRO printDecBC
0B02B7             0117*          push hl
0B02B7             0118*          push bc
0B02B7             0119*          pop hl
0B02B7             0120*          call printDec
0B02B7             0121*          pop hl
0B02B7             0122*      ENDMACRO
0B02B7             0123*  
0B02B7             0124*      MACRO printDecDE
0B02B7             0125*          push hl
0B02B7             0126*          push de
0B02B7             0127*          pop hl
0B02B7             0128*          call printDec
0B02B7             0129*          pop hl
0B02B7             0130*      ENDMACRO
0B02B7             0131*  
0B02B7             0132*      MACRO printDecHL
0B02B7             0133*          call printDec
0B02B7             0134*      ENDMACRO
0B02B7             0135*  
0B02B7             0136*      MACRO printDecIX
0B02B7             0137*          push hl
0B02B7             0138*          push ix
0B02B7             0139*          pop hl
0B02B7             0140*          call printDec
0B02B7             0141*          pop hl
0B02B7             0142*      ENDMACRO
0B02B7             0143*  
0B02B7             0144*      MACRO printDecIY
0B02B7             0145*          push hl
0B02B7             0146*          push iy
0B02B7             0147*          pop hl
0B02B7             0148*          call printDec
0B02B7             0149*          pop hl
0B02B7             0150*      ENDMACRO
0B02B7             0151*  
0B02B7             0152*  ; Prints the right justified decimal value in HL without leading zeroes
0B02B7             0153*  ; HL : Value to print
0B02B7             0154*  ; preserves all registers and flags
0B02B7             0155*  printDecFrac:
0B02B7             0156*  ; back up all the things
0B02B7 F5          0157*      push af
0B02B8 C5          0158*      push bc
0B02B9 D5          0159*      push de
0B02BA E5          0160*      push hl
0B02BB 11 DF 02 0B 0161*  	LD	 DE, _printDecFracBuffer
0B02BF CD 1F 03 0B 0162*  	CALL u24_to_ascii
0B02C3             0163*  ; replace leading zeroes with spaces
0B02C3 21 DF 02 0B 0164*      LD	 HL, _printDecFracBuffer
0B02C7 06 07       0165*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B02C9             0166*  @loop:
0B02C9 7E          0167*      LD	 A, (HL)
0B02CA FE 30       0168*      CP	 '0'
0B02CC C2 D6 02 0B 0169*      JP	 NZ, @done
0B02D0 3E 20       0170*      LD   A, ' '
0B02D2 77          0171*      LD	 (HL), A
0B02D3 23          0172*      INC	 HL
0B02D4 10 F3       0173*      DJNZ @loop
0B02D6             0174*  @done:
0B02D6 CD 67 02 0B 0175*  	CALL printString
0B02DA             0176*  ; restore all the things
0B02DA E1          0177*      pop hl
0B02DB D1          0178*      pop de
0B02DC C1          0179*      pop bc
0B02DD F1          0180*      pop af
0B02DE             0181*  ; END MY CODE
0B02DE C9          0182*  	RET
0B02DF 00 00 00 00 0183*  _printDecFracBuffer: blkb 11,0 ; 11 bytes full of zeroes
       00 00 00 00 
       00 00 00    
0B02EA             0184*  
0B02EA             0185*  
0B02EA             0186*  ; Prints the right justified decimal value in HL without leading zeroes
0B02EA             0187*  ; HL : Value to print
0B02EA             0188*  ; preserves all registers and flags
0B02EA             0189*  printDec:
0B02EA             0190*  ; BEGIN MY CODE
0B02EA             0191*  ; back up all the things
0B02EA F5          0192*      push af
0B02EB C5          0193*      push bc
0B02EC D5          0194*      push de
0B02ED E5          0195*      push hl
0B02EE             0196*  ; END MY CODE
0B02EE 11 16 03 0B 0197*  	LD	 DE, _printDecBuffer
0B02F2 CD 1F 03 0B 0198*  	CALL u24_to_ascii
0B02F6             0199*  ; BEGIN MY CODE
0B02F6             0200*  ; replace leading zeroes with spaces
0B02F6 21 16 03 0B 0201*      LD	 HL, _printDecBuffer
0B02FA 06 07       0202*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B02FC             0203*  @loop:
0B02FC 7E          0204*      LD	 A, (HL)
0B02FD FE 30       0205*      CP	 '0'
0B02FF C2 0D 03 0B 0206*      JP	 NZ, @done
0B0303 3E 20       0207*      LD   A, ' '
0B0305 77          0208*      LD	 (HL), A
0B0306 23          0209*      INC	 HL
0B0307 CD A3 08 0B 0210*      CALL vdu_cursor_forward
0B030B 10 EF       0211*      DJNZ @loop
0B030D             0212*  @done:
0B030D             0213*  ; END MY CODE
0B030D             0214*  	; LD	 HL, _printDecBuffer
0B030D CD 67 02 0B 0215*  	CALL printString
0B0311             0216*  ; BEGIN MY CODE
0B0311             0217*  ; restore all the things
0B0311 E1          0218*      pop hl
0B0312 D1          0219*      pop de
0B0313 C1          0220*      pop bc
0B0314 F1          0221*      pop af
0B0315             0222*  ; END MY CODE
0B0315 C9          0223*  	RET
0B0316 00 00 00 00 0224*  _printDecBuffer: blkb 9,0 ; nine bytes full of zeroes
       00 00 00 00 
       00          
0B031F             0225*  
0B031F             0226*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B031F             0227*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B031F             0228*  ; so it will allways be 8 characters length
0B031F             0229*  ; HL : Value to convert to string
0B031F             0230*  ; DE : pointer to buffer, at least 8 byte + 0
0B031F             0231*  u24_to_ascii:
0B031F 01 80 69 67 0232*  	LD	 BC,-10000000
0B0323 CD 56 03 0B 0233*  	CALL @one_digit
0B0327 01 C0 BD F0 0234*  	LD	 BC,-1000000
0B032B CD 56 03 0B 0235*  	CALL @one_digit
0B032F 01 60 79 FE 0236*  	LD	 BC,-100000
0B0333 CD 56 03 0B 0237*  	CALL @one_digit
0B0337 01 F0 D8 FF 0238*  	LD   BC,-10000
0B033B CD 56 03 0B 0239*  	CALL @one_digit
0B033F 01 18 FC FF 0240*  	LD   BC,-1000
0B0343 CD 56 03 0B 0241*  	CALL @one_digit
0B0347 01 9C FF FF 0242*  	LD   BC,-100
0B034B CD 56 03 0B 0243*  	CALL @one_digit
0B034F 0E F6       0244*  	LD   C,-10
0B0351 CD 56 03 0B 0245*  	CALL @one_digit
0B0355 48          0246*  	LD   C,B
0B0356             0247*  @one_digit:
0B0356 3E 2F       0248*  	LD   A,'0'-1
0B0358             0249*  @divide_me:
0B0358 3C          0250*  	INC  A
0B0359 09          0251*  	ADD  HL,BC
0B035A 38 FC       0252*  	JR   C,@divide_me
0B035C ED 42       0253*  	SBC  HL,BC
0B035E 12          0254*  	LD   (DE),A
0B035F 13          0255*  	INC  DE
0B0360 C9          0256*  	RET
0B0361             0257*  
0B0361             0258*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B0361             0259*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0B0361             0260*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B0361             0261*  u168_to_ascii:
0B0361             0262*  ; add a leading space to make room for sign flag if needed
0B0361 3E 20       0263*      ld a,' '
0B0363 12          0264*      ld (de),a
0B0364 13          0265*      inc de
0B0365             0266*  ; Convert integer part
0B0365 E5          0267*      push hl               ; Save HL (well need the fractional part later)
0B0366 CD 35 0E 0B 0268*      call shift_hlu_r1b    ; Shift to get integer portion in HL
0B036A 01 F0 D8 FF 0269*      ld   bc, -10000
0B036E CD 91 03 0B 0270*      call @one_int
0B0372 01 18 FC FF 0271*      ld   bc, -1000
0B0376 CD 91 03 0B 0272*      call @one_int
0B037A 01 9C FF FF 0273*      ld   bc, -100
0B037E CD 91 03 0B 0274*      call @one_int
0B0382 0E F6       0275*      ld   c, -10
0B0384 CD 91 03 0B 0276*      call @one_int
0B0388 48          0277*      ld   c, b
0B0389 CD 91 03 0B 0278*      call @one_int
0B038D C3 9C 03 0B 0279*      jp   @frac            ; Jump to fractional part conversion
0B0391             0280*  @one_int:
0B0391 3E 2F       0281*      ld   a, '0' - 1       ; Start ASCII character at '0'
0B0393             0282*  @divide_me:
0B0393 3C          0283*      inc  a
0B0394 09          0284*      add  hl, bc           ; Accumulate until overflow
0B0395 38 FC       0285*      jr   c, @divide_me
0B0397 ED 42       0286*      sbc  hl, bc           ; Remove excess after overflow
0B0399 12          0287*      ld   (de), a          ; Store ASCII digit
0B039A 13          0288*      inc  de
0B039B C9          0289*      ret
0B039C             0290*  ; Convert fractional part
0B039C             0291*  @frac:
0B039C 3E 2E       0292*      ld   a, '.'           ; Decimal point
0B039E 12          0293*      ld   (de), a
0B039F 13          0294*      inc  de
0B03A0 E1          0295*      pop  hl               ; Restore HL with original fraction
0B03A1 06 03       0296*      ld   b, 3             ; Loop counter for 3 fractional digits
0B03A3             0297*  @frac_loop:
0B03A3 26 0A       0298*      ld   h, 10            ; Load multiplier for fractional part
0B03A5 ED 6C       0299*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B03A7 3E 30       0300*      ld   a, '0'
0B03A9 84          0301*      add  a, h             ; Convert integer part to ASCII
0B03AA 12          0302*      ld   (de), a
0B03AB 13          0303*      inc  de
0B03AC 10 F5       0304*      djnz @frac_loop       ; Repeat for each fractional digit
0B03AE             0305*  ; Add null terminator
0B03AE AF          0306*      xor  a                ; Null terminator
0B03AF 12          0307*      ld   (de), a
0B03B0 C9          0308*      ret
0B03B1             0309*  
0B03B1             0310*  ; signed version of u168_to_ascii
0B03B1             0311*  s168_to_ascii:
0B03B1 D5          0312*      push de ; save starting address of buffer
0B03B2 CD 7C 18 0B 0313*      call abs_hlu
0B03B6 F5          0314*      push af ; save sign flag
0B03B7 CD 61 03 0B 0315*      call u168_to_ascii
0B03BB F1          0316*      pop af ; restore sign flag
0B03BC D1          0317*      pop de ; restore starting address of buffer
0B03BD F0          0318*      ret p ; hlu was positive so nothing to do
0B03BE 3E 2D       0319*      ld a,'-'
0B03C0 12          0320*      ld (de),a
0B03C1 C9          0321*      ret
0B03C2             0322*  
0B03C2             0323*  ; #### new functions added by Brandon R. Gates ####
0B03C2             0324*  
0B03C2             0325*  ; print the binary representation of the 8-bit value in a
0B03C2             0326*  ; destroys a, hl, bc
0B03C2             0327*  printBin8:
0B03C2 06 08       0328*      ld b,8      ; loop counter for 8 bits
0B03C4 21 DF 03 0B 0329*      ld hl,@cmd  ; set hl to the low byte of the output string
0B03C8             0330*                  ; (which will be the high bit of the value in a)
0B03C8             0331*  @loop:
0B03C8 07          0332*      rlca ; put the next highest bit into carry
0B03C9 38 04       0333*      jr c,@one
0B03CB 36 30       0334*      ld (hl),'0'
0B03CD 18 02       0335*      jr @next_bit
0B03CF             0336*  @one:
0B03CF 36 31       0337*      ld (hl),'1'
0B03D1             0338*  @next_bit:
0B03D1 23          0339*      inc hl
0B03D2 10 F4       0340*      djnz @loop
0B03D4             0341*  ; print it
0B03D4 21 DF 03 0B 0342*  	ld hl,@cmd
0B03D8 01 08 00 00 0343*  	ld bc,@end-@cmd
0B03DC 5B DF       0344*  	rst.lil $18
0B03DE C9          0345*  	ret
0B03DF             0346*  @cmd: ds 8 ; eight bytes for eight bits
0B03E7             0347*  @end:
0B03E7             0348*  
0B03E7             0349*  ; print the binary representation of the 8-bit value in a
0B03E7             0350*  ; in reverse order (lsb first)
0B03E7             0351*  ; destroys a, hl, bc
0B03E7             0352*  printBin8Rev:
0B03E7 06 08       0353*      ld b,8      ; loop counter for 8 bits
0B03E9 21 04 04 0B 0354*      ld hl,@cmd  ; set hl to the low byte of the output string
0B03ED             0355*                  ; (which will be the high bit of the value in a)
0B03ED             0356*  @loop:
0B03ED 0F          0357*      rrca ; put the next lowest bit into carry
0B03EE 38 04       0358*      jr c,@one
0B03F0 36 30       0359*      ld (hl),'0'
0B03F2 18 02       0360*      jr @next_bit
0B03F4             0361*  @one:
0B03F4 36 31       0362*      ld (hl),'1'
0B03F6             0363*  @next_bit:
0B03F6 23          0364*      inc hl
0B03F7 10 F4       0365*      djnz @loop
0B03F9             0366*  ; print it
0B03F9 21 04 04 0B 0367*  	ld hl,@cmd
0B03FD 01 08 00 00 0368*  	ld bc,@end-@cmd
0B0401 5B DF       0369*  	rst.lil $18
0B0403 C9          0370*  	ret
0B0404             0371*  @cmd: ds 8 ; eight bytes for eight bits
0B040C             0372*  @end:
0B040C             0373*  
0B040C             0374*  ; print registers to screen in hexidecimal format
0B040C             0375*  ; inputs: none
0B040C             0376*  ; outputs: values of every register printed to screen
0B040C             0377*  ;    values of each register in global scratch memory
0B040C             0378*  ; destroys: nothing
0B040C             0379*  stepRegistersHex:
0B040C             0380*  ; store everything in scratch
0B040C 22 F9 05 0B 0381*      ld (uhl),hl
0B0410 ED 43 FC 05 0382*      ld (ubc),bc
       0B          
0B0415 ED 53 FF 05 0383*      ld (ude),de
       0B          
0B041A DD 22 02 06 0384*      ld (uix),ix
       0B          
0B041F FD 22 05 06 0385*      ld (uiy),iy
       0B          
0B0424 F5          0386*      push af ; fml
0B0425 E1          0387*      pop hl  ; thanks, zilog
0B0426 22 F6 05 0B 0388*      ld (uaf),hl
0B042A F5          0389*      push af ; dammit
0B042B             0390*  
0B042B             0391*  ; home the cursor
0B042B CD 82 08 0B 0392*      call vdu_home_cursor
0B042F             0393*  
0B042F             0394*  ; print each register
0B042F 21 7C 05 0B 0395*      ld hl,str_afu
0B0433 CD 67 02 0B 0396*      call printString
0B0437 2A F6 05 0B 0397*      ld hl,(uaf)
0B043B CD 87 02 0B 0398*      call printHex24
0B043F CD 7C 02 0B 0399*      call printNewLine
0B0443             0400*  
0B0443 21 81 05 0B 0401*      ld hl,str_hlu
0B0447 CD 67 02 0B 0402*      call printString
0B044B 2A F9 05 0B 0403*      ld hl,(uhl)
0B044F CD 87 02 0B 0404*      call printHex24
0B0453 CD 7C 02 0B 0405*      call printNewLine
0B0457             0406*  
0B0457 21 86 05 0B 0407*      ld hl,str_bcu
0B045B CD 67 02 0B 0408*      call printString
0B045F 2A FC 05 0B 0409*      ld hl,(ubc)
0B0463 CD 87 02 0B 0410*      call printHex24
0B0467 CD 7C 02 0B 0411*      call printNewLine
0B046B             0412*  
0B046B 21 8B 05 0B 0413*      ld hl,str_deu
0B046F CD 67 02 0B 0414*      call printString
0B0473 2A FF 05 0B 0415*      ld hl,(ude)
0B0477 CD 87 02 0B 0416*      call printHex24
0B047B CD 7C 02 0B 0417*      call printNewLine
0B047F             0418*  
0B047F 21 90 05 0B 0419*      ld hl,str_ixu
0B0483 CD 67 02 0B 0420*      call printString
0B0487 2A 02 06 0B 0421*      ld hl,(uix)
0B048B CD 87 02 0B 0422*      call printHex24
0B048F CD 7C 02 0B 0423*      call printNewLine
0B0493             0424*  
0B0493 21 95 05 0B 0425*      ld hl,str_iyu
0B0497 CD 67 02 0B 0426*      call printString
0B049B 2A 05 06 0B 0427*      ld hl,(uiy)
0B049F CD 87 02 0B 0428*      call printHex24
0B04A3 CD 7C 02 0B 0429*      call printNewLine
0B04A7             0430*  
0B04A7             0431*      ; call vsync
0B04A7             0432*  
0B04A7 CD 7C 02 0B 0433*      call printNewLine
0B04AB             0434*  
0B04AB             0435*  ; check for right shift key and quit if pressed
0B04AB             0436*  	MOSCALL mos_getkbmap
0B04AB 3E 1E       0001*M 			LD	A, function
0B04AD 5B CF       0002*M 			RST.L	08h
0B04AF             0437*  @stayhere:
0B04AF             0438*  ; 7 RightShift
0B04AF DD CB 00 76 0439*      bit 6,(ix+0)
0B04B3 20 02       0440*      jr nz,@RightShift
0B04B5 18 F8       0441*      jr @stayhere
0B04B7             0442*  @RightShift:
0B04B7 DD CB 0E 86 0443*      res 0,(ix+14) ; debounce the key (hopefully)
0B04BB 3E 80       0444*      ld a,%10000000
0B04BD CD 62 08 0B 0445*      call multiPurposeDelay
0B04C1             0446*  
0B04C1             0447*  ; restore everything
0B04C1 2A F9 05 0B 0448*      ld hl, (uhl)
0B04C5 ED 4B FC 05 0449*      ld bc, (ubc)
       0B          
0B04CA ED 5B FF 05 0450*      ld de, (ude)
       0B          
0B04CF DD 2A 02 06 0451*      ld ix, (uix)
       0B          
0B04D4 FD 2A 05 06 0452*      ld iy, (uiy)
       0B          
0B04D9 F1          0453*      pop af
0B04DA             0454*  ; all done
0B04DA C9          0455*      ret
0B04DB             0456*  
0B04DB             0457*  ; print registers to screen in hexidecimal format
0B04DB             0458*  ; inputs: none
0B04DB             0459*  ; outputs: values of every register printed to screen
0B04DB             0460*  ;    values of each register in global scratch memory
0B04DB             0461*  ; destroys: nothing
0B04DB             0462*  dumpRegistersHex:
0B04DB             0463*  ; store everything in scratch
0B04DB 22 F9 05 0B 0464*      ld (uhl),hl
0B04DF ED 43 FC 05 0465*      ld (ubc),bc
       0B          
0B04E4 ED 53 FF 05 0466*      ld (ude),de
       0B          
0B04E9 DD 22 02 06 0467*      ld (uix),ix
       0B          
0B04EE FD 22 05 06 0468*      ld (uiy),iy
       0B          
0B04F3 F5          0469*      push af ; fml
0B04F4 E1          0470*      pop hl  ; thanks, zilog
0B04F5 22 F6 05 0B 0471*      ld (uaf),hl
0B04F9 F5          0472*      push af ; dammit
0B04FA             0473*  
0B04FA             0474*  ; home the cursor
0B04FA             0475*      ; call vdu_home_cursor
0B04FA             0476*      ; call printNewLine
0B04FA             0477*  
0B04FA             0478*  ; print each register
0B04FA 21 7C 05 0B 0479*      ld hl,str_afu
0B04FE CD 67 02 0B 0480*      call printString
0B0502 2A F6 05 0B 0481*      ld hl,(uaf)
0B0506 CD 87 02 0B 0482*      call printHex24
0B050A             0483*      ; call printNewLine
0B050A             0484*  
0B050A 21 81 05 0B 0485*      ld hl,str_hlu
0B050E CD 67 02 0B 0486*      call printString
0B0512 2A F9 05 0B 0487*      ld hl,(uhl)
0B0516 CD 87 02 0B 0488*      call printHex24
0B051A             0489*      ; call printNewLine
0B051A             0490*  
0B051A 21 86 05 0B 0491*      ld hl,str_bcu
0B051E CD 67 02 0B 0492*      call printString
0B0522 2A FC 05 0B 0493*      ld hl,(ubc)
0B0526 CD 87 02 0B 0494*      call printHex24
0B052A             0495*      ; call printNewLine
0B052A             0496*  
0B052A 21 8B 05 0B 0497*      ld hl,str_deu
0B052E CD 67 02 0B 0498*      call printString
0B0532 2A FF 05 0B 0499*      ld hl,(ude)
0B0536 CD 87 02 0B 0500*      call printHex24
0B053A             0501*      ; call printNewLine
0B053A             0502*  
0B053A 21 90 05 0B 0503*      ld hl,str_ixu
0B053E CD 67 02 0B 0504*      call printString
0B0542 2A 02 06 0B 0505*      ld hl,(uix)
0B0546 CD 87 02 0B 0506*      call printHex24
0B054A             0507*      ; call printNewLine
0B054A             0508*  
0B054A 21 95 05 0B 0509*      ld hl,str_iyu
0B054E CD 67 02 0B 0510*      call printString
0B0552 2A 05 06 0B 0511*      ld hl,(uiy)
0B0556 CD 87 02 0B 0512*      call printHex24
0B055A             0513*      ; call printNewLine
0B055A             0514*  
0B055A CD 17 09 0B 0515*      call vdu_vblank
0B055E             0516*  
0B055E CD 7C 02 0B 0517*      call printNewLine
0B0562             0518*  ; restore everything
0B0562 2A F9 05 0B 0519*      ld hl, (uhl)
0B0566 ED 4B FC 05 0520*      ld bc, (ubc)
       0B          
0B056B ED 5B FF 05 0521*      ld de, (ude)
       0B          
0B0570 DD 2A 02 06 0522*      ld ix, (uix)
       0B          
0B0575 FD 2A 05 06 0523*      ld iy, (uiy)
       0B          
0B057A F1          0524*      pop af
0B057B             0525*  ; all done
0B057B C9          0526*      ret
0B057C             0527*  
0B057C 20 61 66 3D 0528*  str_afu: db " af=",0
       00          
0B0581 20 68 6C 3D 0529*  str_hlu: db " hl=",0
       00          
0B0586 20 62 63 3D 0530*  str_bcu: db " bc=",0
       00          
0B058B 20 64 65 3D 0531*  str_deu: db " de=",0
       00          
0B0590 20 69 78 3D 0532*  str_ixu: db " ix=",0
       00          
0B0595 20 69 79 3D 0533*  str_iyu: db " iy=",0
       00          
0B059A             0534*  
0B059A             0535*  ; print udeuhl to screen in hexidecimal format
0B059A             0536*  ; inputs: none
0B059A             0537*  ; outputs: concatenated hexidecimal udeuhl
0B059A             0538*  ; destroys: nothing
0B059A             0539*  dumpUDEUHLHex:
0B059A             0540*  ; store everything in scratch
0B059A 22 F9 05 0B 0541*      ld (uhl),hl
0B059E ED 43 FC 05 0542*      ld (ubc),bc
       0B          
0B05A3 ED 53 FF 05 0543*      ld (ude),de
       0B          
0B05A8 DD 22 02 06 0544*      ld (uix),ix
       0B          
0B05AD FD 22 05 06 0545*      ld (uiy),iy
       0B          
0B05B2 F5          0546*      push af
0B05B3             0547*  
0B05B3             0548*  ; print each register
0B05B3             0549*  
0B05B3 21 ED 05 0B 0550*      ld hl,str_udeuhl
0B05B7 CD 67 02 0B 0551*      call printString
0B05BB 2A FF 05 0B 0552*      ld hl,(ude)
0B05BF CD 87 02 0B 0553*      call printHex24
0B05C3 3E 2E       0554*  	ld a,'.'	; print a dot to separate the values
0B05C5 5B D7       0555*  	rst.lil 10h
0B05C7 2A F9 05 0B 0556*      ld hl,(uhl)
0B05CB CD 87 02 0B 0557*      call printHex24
0B05CF CD 7C 02 0B 0558*      call printNewLine
0B05D3             0559*  
0B05D3             0560*  ; restore everything
0B05D3 2A F9 05 0B 0561*      ld hl, (uhl)
0B05D7 ED 4B FC 05 0562*      ld bc, (ubc)
       0B          
0B05DC ED 5B FF 05 0563*      ld de, (ude)
       0B          
0B05E1 DD 2A 02 06 0564*      ld ix, (uix)
       0B          
0B05E6 FD 2A 05 06 0565*      ld iy, (uiy)
       0B          
0B05EB F1          0566*      pop af
0B05EC             0567*  ; all done
0B05EC C9          0568*      ret
0B05ED             0569*  
0B05ED 75 64 65 2E 0570*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0B05F6             0571*  
0B05F6             0572*  ; global scratch memory for registers
0B05F6 00 00 00    0573*  uaf: dl 0
0B05F9 00 00 00    0574*  uhl: dl 0
0B05FC 00 00 00    0575*  ubc: dl 0
0B05FF 00 00 00    0576*  ude: dl 0
0B0602 00 00 00    0577*  uix: dl 0
0B0605 00 00 00    0578*  uiy: dl 0
0B0608 00 00 00    0579*  usp: dl 0
0B060B 00 00 00    0580*  upc: dl 0
0B060E             0581*  
0B060E             0582*  ; inputs: whatever is in the flags register
0B060E             0583*  ; outputs: binary representation of flags
0B060E             0584*  ;          with a header so we know which is what
0B060E             0585*  ; destroys: nothing
0B060E             0586*  ; preserves: everything
0B060E             0587*  dumpFlags:
0B060E             0588*  ; first we curse zilog for not giving direct access to flags
0B060E F5          0589*      push af ; this is so we can send it back unharmed
0B060F F5          0590*      push af ; this is so we can pop it to hl
0B0610             0591*  ; store everything in scratch
0B0610 22 F9 05 0B 0592*      ld (uhl),hl
0B0614 ED 43 FC 05 0593*      ld (ubc),bc
       0B          
0B0619 ED 53 FF 05 0594*      ld (ude),de
       0B          
0B061E DD 22 02 06 0595*      ld (uix),ix
       0B          
0B0623 FD 22 05 06 0596*      ld (uiy),iy
       0B          
0B0628             0597*  ; next we print the header
0B0628 21 54 06 0B 0598*      ld hl,@header
0B062C CD 67 02 0B 0599*      call printString
0B0630 E1          0600*      pop hl ; flags are now in l
0B0631 7D          0601*      ld a,l ; flags are now in a
0B0632 CD C2 03 0B 0602*      call printBin8
0B0636 CD 7C 02 0B 0603*  	call printNewLine
0B063A             0604*  ; restore everything
0B063A 2A F9 05 0B 0605*      ld hl, (uhl)
0B063E ED 4B FC 05 0606*      ld bc, (ubc)
       0B          
0B0643 ED 5B FF 05 0607*      ld de, (ude)
       0B          
0B0648 DD 2A 02 06 0608*      ld ix, (uix)
       0B          
0B064D FD 2A 05 06 0609*      ld iy, (uiy)
       0B          
0B0652 F1          0610*      pop af ; send her home the way she came
0B0653 C9          0611*      ret
0B0654             0612*  ; Bit 7 (S): Sign flag
0B0654             0613*  ; Bit 6 (Z): Zero flag
0B0654             0614*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0B0654             0615*  ; Bit 4 (H): Half Carry flag
0B0654             0616*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0B0654             0617*  ; Bit 2 (PV): Parity/Overflow flag
0B0654             0618*  ; Bit 1 (N): Subtract flag
0B0654             0619*  ; Bit 0 (C): Carry flag
0B0654 53 5A 78 48 0620*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0B065F             0621*  
0B065F             0622*  ; set all the bits in the flag register
0B065F             0623*  ; more of an academic exercise than anything useful
0B065F             0624*  ; inputs; none
0B065F             0625*  ; outputs; a=0,f=255
0B065F             0626*  ; destroys: flags, hl
0B065F             0627*  ; preserves: a, because why not
0B065F             0628*  setAllFlags:
0B065F 21 FF 00 00 0629*      ld hl,255
0B0663 67          0630*      ld h,a ; four cycles to preserve a is cheap
0B0664 E5          0631*      push hl
0B0665 F1          0632*      pop af
0B0666 C9          0633*      ret
0B0667             0634*  
0B0667             0635*  ; reset all the bits in the flag register
0B0667             0636*  ; unlike its inverse counterpart, this may actually be useful
0B0667             0637*  ; inputs; none
0B0667             0638*  ; outputs; a=0,f=0
0B0667             0639*  ; destroys: flags, hl
0B0667             0640*  ; preserves: a, because why not
0B0667             0641*  resetAllFlags:
0B0667 21 00 00 00 0642*      ld hl,0
0B066B 67          0643*      ld h,a ; four cycles to preserve a is cheap
0B066C E5          0644*      push hl
0B066D F1          0645*      pop af
0B066E C9          0646*      ret
0B066F             0647*  
0B066F             0648*  ; wait until user presses a key
0B066F             0649*  ; inputs: none
0B066F             0650*  ; outputs: none
0B066F             0651*  ; destroys: af,ix
0B066F             0652*  waitKeypress:
0B066F             0653*      MOSCALL mos_sysvars
0B066F 3E 08       0001*M 			LD	A, function
0B0671 5B CF       0002*M 			RST.L	08h
0B0673 AF          0654*      xor a ; zero out any prior keypresses
0B0674 DD 77 05    0655*      ld (ix+sysvar_keyascii),a
0B0677             0656*  @loop:
0B0677 DD 7E 05    0657*      ld a,(ix+sysvar_keyascii)
0B067A A7          0658*      and a
0B067B C0          0659*      ret nz
0B067C 18 F9       0660*      jr @loop
0B067E             0661*  
0B067E             0662*  
0B067E             0663*  ; print bytes from an address to the screen in hexidecimal format
0B067E             0664*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B067E             0665*  ; outputs: values of each byte printed to screen separated by spaces
0B067E             0666*  ; destroys: nothing
0B067E             0667*  dumpMemoryHex:
0B067E             0668*  ; save registers to the stack
0B067E C5          0669*      push bc
0B067F E5          0670*      push hl
0B0680 F5          0671*      push af
0B0681             0672*  
0B0681             0673*  ; print the address and separator
0B0681 CD 87 02 0B 0674*      call printHex24
0B0685 3E 3A       0675*      ld a,':'
0B0687 5B D7       0676*      rst.lil 10h
0B0689 3E 20       0677*      ld a,' '
0B068B 5B D7       0678*      rst.lil 10h
0B068D             0679*  
0B068D             0680*  ; set b to be our loop counter
0B068D F1          0681*      pop af
0B068E 47          0682*      ld b,a
0B068F E1          0683*      pop hl
0B0690 E5          0684*      push hl
0B0691 F5          0685*      push af
0B0692             0686*  @loop:
0B0692             0687*  ; print the byte
0B0692 7E          0688*      ld a,(hl)
0B0693 CD 99 02 0B 0689*      call printHex8
0B0697             0690*  ; print a space
0B0697 3E 20       0691*      ld a,' '
0B0699 5B D7       0692*      rst.lil 10h
0B069B 23          0693*      inc hl
0B069C 10 F4       0694*      djnz @loop
0B069E             0695*      ; call printNewLine
0B069E             0696*  
0B069E             0697*  ; restore everything
0B069E F1          0698*      pop af
0B069F E1          0699*      pop hl
0B06A0 C1          0700*      pop bc
0B06A1             0701*  
0B06A1             0702*  ; all done
0B06A1 C9          0703*      ret
0B06A2             0704*  
0B06A2             0705*  
0B06A2             0706*  ; print bytes from an address to the screen in binary format
0B06A2             0707*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B06A2             0708*  ; outputs: values of each byte printed to screen separated by spaces
0B06A2             0709*  ; destroys: nothing
0B06A2             0710*  dumpMemoryBin:
0B06A2             0711*  ; save all registers to the stack
0B06A2 F5          0712*      push af
0B06A3 C5          0713*      push bc
0B06A4 D5          0714*      push de
0B06A5 E5          0715*      push hl
0B06A6 DD E5       0716*      push ix
0B06A8 FD E5       0717*      push iy
0B06AA             0718*  
0B06AA             0719*  ; set b to be our loop counter
0B06AA 47          0720*      ld b,a
0B06AB             0721*  @loop:
0B06AB             0722*  ; print the byte
0B06AB 7E          0723*      ld a,(hl)
0B06AC E5          0724*      push hl
0B06AD C5          0725*      push bc
0B06AE CD C2 03 0B 0726*      call printBin8
0B06B2 C1          0727*      pop bc
0B06B3             0728*  ; print a space
0B06B3 3E 20       0729*      ld a,' '
0B06B5 5B D7       0730*      rst.lil 10h
0B06B7 E1          0731*      pop hl
0B06B8 23          0732*      inc hl
0B06B9 10 F0       0733*      djnz @loop
0B06BB CD 7C 02 0B 0734*      call printNewLine
0B06BF             0735*  
0B06BF             0736*  ; restore everything
0B06BF FD E1       0737*      pop iy
0B06C1 DD E1       0738*      pop ix
0B06C3 E1          0739*      pop hl
0B06C4 D1          0740*      pop de
0B06C5 C1          0741*      pop bc
0B06C6 F1          0742*      pop af
0B06C7             0743*  ; all done
0B06C7 C9          0744*      ret
0B06C8             0745*  
0B06C8             0746*  ; print bytes from an address to the screen in binary format
0B06C8             0747*  ; with the bits of each byte in reverse order (lsb first)
0B06C8             0748*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B06C8             0749*  ; outputs: values of each byte printed to screen separated by spaces
0B06C8             0750*  ; destroys: nothing
0B06C8             0751*  dumpMemoryBinRev:
0B06C8             0752*  ; save all registers to the stack
0B06C8 F5          0753*      push af
0B06C9 C5          0754*      push bc
0B06CA D5          0755*      push de
0B06CB E5          0756*      push hl
0B06CC DD E5       0757*      push ix
0B06CE FD E5       0758*      push iy
0B06D0             0759*  
0B06D0             0760*  ; set b to be our loop counter
0B06D0 47          0761*      ld b,a
0B06D1             0762*  @loop:
0B06D1             0763*  ; print the byte
0B06D1 7E          0764*      ld a,(hl)
0B06D2 E5          0765*      push hl
0B06D3 C5          0766*      push bc
0B06D4 CD E7 03 0B 0767*      call printBin8Rev
0B06D8 C1          0768*      pop bc
0B06D9             0769*  ; print a space
0B06D9 3E 20       0770*      ld a,' '
0B06DB 5B D7       0771*      rst.lil 10h
0B06DD E1          0772*      pop hl
0B06DE 23          0773*      inc hl
0B06DF 10 F0       0774*      djnz @loop
0B06E1 CD 7C 02 0B 0775*      call printNewLine
0B06E5             0776*  
0B06E5             0777*  ; restore everything
0B06E5 FD E1       0778*      pop iy
0B06E7 DD E1       0779*      pop ix
0B06E9 E1          0780*      pop hl
0B06EA D1          0781*      pop de
0B06EB C1          0782*      pop bc
0B06EC F1          0783*      pop af
0B06ED             0784*  ; all done
0B06ED C9          0785*      ret
0B06EE             0020       include "files.inc"
0B06EE             0001*  ; load to onboard 8k sram
0B06EE             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0B06EE             0021       include "timer.inc"
0B06EE             0001*  ; Table 32. Timer Control Registers
0B06EE             0002*  ; this constant is the base address of the timer control registers
0B06EE             0003*  ; each timer takes three bytes:
0B06EE             0004*  ;   0: control register
0B06EE             0005*  ;   1: low byte of timer reset value
0B06EE             0006*  ;   2: high byte of timer reset value
0B06EE             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0B06EE             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0B06EE             0009*  TMR_CTL:     equ 80h
0B06EE             0010*  
0B06EE             0011*  ; Timer Control Register Bit Definitions
0B06EE             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0B06EE             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0B06EE             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0B06EE             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0B06EE             0016*                              ; the TMRx_CTL register is read.
0B06EE             0017*  
0B06EE             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0B06EE             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0B06EE             0020*  
0B06EE             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0B06EE             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0B06EE             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0B06EE             0024*                              ; written to the counter when the end-of-count value is reached.
0B06EE             0025*  
0B06EE             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0B06EE             0027*  CLK_DIV_256:  equ %00001100 ;
0B06EE             0028*  CLK_DIV_64:   equ %00001000 ;
0B06EE             0029*  CLK_DIV_16:   equ %00000100 ;
0B06EE             0030*  CLK_DIV_4:    equ %00000000 ;
0B06EE             0031*  
0B06EE             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0B06EE             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0B06EE             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0B06EE             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0B06EE             0036*                              ; programmer must ensure that this bit is set to 1 each time
0B06EE             0037*                              ; SINGLE-PASS mode is used.
0B06EE             0038*  
0B06EE             0039*  ; disable/enable the programmable reload timer
0B06EE             0040*  PRT_EN_0:     equ %00000000 ;
0B06EE             0041*  PRT_EN_1:     equ %00000001 ;
0B06EE             0042*  
0B06EE             0043*  ; Table 37. Timer Input Source Select Register
0B06EE             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0B06EE             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0B06EE             0046*  ;   00: System clock / CLK_DIV
0B06EE             0047*  ;   01: RTC / CLK_DIV
0B06EE             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0B06EE             0049*  ;   10: GPIO port B pin 1.
0B06EE             0050*  ;   11: GPIO port B pin 1.
0B06EE             0051*  TMR_ISS:   equ 92h ; register address
0B06EE             0052*  
0B06EE             0053*  ; Table 51. Real-Time Clock Control Register
0B06EE             0054*  RTC_CTRL: equ EDh ; register address
0B06EE             0055*  
0B06EE             0056*  ; alarm interrupt disable/enable
0B06EE             0057*  RTC_ALARM_0:    equ %00000000
0B06EE             0058*  RTC_ALARM_1:    equ %10000000
0B06EE             0059*  
0B06EE             0060*  ; interrupt on alarm disable/enable
0B06EE             0061*  RTC_INT_ENT_0:  equ %00000000
0B06EE             0062*  RTC_INT_ENT_1:  equ %01000000
0B06EE             0063*  
0B06EE             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0B06EE             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0B06EE             0066*  
0B06EE             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0B06EE             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0B06EE             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0B06EE             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0B06EE             0071*  
0B06EE             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0B06EE             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0B06EE             0074*  
0B06EE             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0B06EE             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0B06EE             0077*  
0B06EE             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0B06EE             0079*                                  ; RTC counter is enabled.
0B06EE             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0B06EE             0081*                                  ; RTC counter is disabled.
0B06EE             0082*  
0B06EE             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0B06EE             0084*  
0B06EE             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0B06EE             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0B06EE 00 00 00    0087*  prt_reload: dl 0x000000
0B06F1             0088*  
0B06F1             0089*  ; ; returns: a = 0 if running on hardware,1 if running on emulator
0B06F1             0090*  ; ;          de = number PRT interrupts during test interval
0B06F1             0091*  ; prt_calibrate:
0B06F1             0092*  ;     call vdu_vblank
0B06F1             0093*  ; ; set a MOS timer
0B06F1             0094*  ;     ld hl,120*1 ; 1 second
0B06F1             0095*  ;     ld iy,tmr_test
0B06F1             0096*  ;     call tmr_set
0B06F1             0097*  ; ; set a PRT timer
0B06F1             0098*  ;     ; ld hl,prt_reload_hardware
0B06F1             0099*  ;     ; ld hl,prt_reload_emulator
0B06F1             0100*  ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
0B06F1             0101*  ;     ld (prt_reload),hl
0B06F1             0102*  ;     call prt_set
0B06F1             0103*  ; @loop:
0B06F1             0104*  ; ; check time remaining on MOS timer
0B06F1             0105*  ;     call tmr_get
0B06F1             0106*  ;     jp z,@done ; time expired,so quit
0B06F1             0107*  ;     jp m,@done ; time past expiration (negative),so quit
0B06F1             0108*  ;     jr @loop
0B06F1             0109*  ; @done:
0B06F1             0110*  ;     ld de,(prt_irq_counter)
0B06F1             0111*  ;     ld bc,prt_reload_hardware ; default value for running on hardware
0B06F1             0112*  ;     ld (prt_reload),bc
0B06F1             0113*  ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0B06F1             0114*  ;     xor a ; clear carry,zero is default value for running on hardware
0B06F1             0115*  ;     ld (is_emulator),a
0B06F1             0116*  ;     sbc hl,de
0B06F1             0117*  ;     ld hl,on_hardware ; default message for running on hardware
0B06F1             0118*  ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
0B06F1             0119*  ;     ret m ; negative result means we're on hardware
0B06F1             0120*  ;     inc a ; we're on emulator
0B06F1             0121*  ;     ld (is_emulator),a
0B06F1             0122*  ;     ld bc,prt_reload_emulator
0B06F1             0123*  ;     ld (prt_reload),bc
0B06F1             0124*  ;     ld hl,on_emulator
0B06F1             0125*  ;     ret
0B06F1             0126*  
0B06F1             0127*  ; calibrating_timer: defb "Calibrating timer\r\n",0
0B06F1             0128*  
0B06F1             0129*  ; set PRT timer
0B06F1             0130*  prt_set:
0B06F1 21 00 00 00 0131*      ld hl,0
0B06F5 22 3F 07 0B 0132*      ld (prt_irq_counter),hl
0B06F9 2A EE 06 0B 0133*      ld hl,(prt_reload)
0B06FD ED 29 84    0134*      out0 ($84),l
0B0700 ED 21 85    0135*  	out0 ($85),h
0B0703             0136*  ; disable timer
0B0703 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0B0705 ED 39 83    0138*  	out0 ($83),a
0B0708             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0B0708 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0B070A ED 39 83    0141*  	out0 ($83),a
0B070D C9          0142*      ret
0B070E             0143*  
0B070E             0144*  ; ===============================================
0B070E             0145*  ; PRT Timer Interrupt Handling
0B070E             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0B070E             0147*  ; -----------------------------------------------
0B070E             0148*  prt_irq_init:
0B070E             0149*      ; set up interrupt vector table 2
0B070E 21 00 00 00 0150*  	ld hl,0
0B0712 3A 0C 01 00 0151*  	ld a,($10c)
0B0716 6F          0152*  	ld l,a
0B0717 3A 0D 01 00 0153*  	ld a,($10d)
0B071B 67          0154*  	ld h,a
0B071C             0155*  
0B071C             0156*  	; skip over CALL ($c3)
0B071C 23          0157*  	inc hl
0B071D             0158*  	; load address of jump into vector table 2 (in ram)
0B071D ED 27       0159*  	ld hl,(hl)
0B071F             0160*  
0B071F             0161*  	; write CALL prt_irq_handler to vector table 2
0B071F 3E C3       0162*  	ld a,$c3
0B0721 77          0163*  	ld (hl),a
0B0722 23          0164*  	inc hl
0B0723 11 2A 07 0B 0165*  	ld de,prt_irq_handler
0B0727 ED 1F       0166*  	ld (hl),de
0B0729             0167*  
0B0729 C9          0168*      ret
0B072A             0169*  
0B072A             0170*  prt_irq_handler:
0B072A F3          0171*  	di
0B072B F5          0172*  	push af
0B072C E5          0173*      push hl
0B072D ED 38 83    0174*  	in0 a,($83)
0B0730 2A 3F 07 0B 0175*  	ld hl,(prt_irq_counter)
0B0734 23          0176*  	inc hl
0B0735 22 3F 07 0B 0177*  	ld (prt_irq_counter),hl
0B0739 E1          0178*      pop hl
0B073A F1          0179*  	pop af
0B073B FB          0180*  	ei
0B073C 5B ED 4D    0181*  	reti.l
0B073F             0182*  
0B073F             0183*  prt_irq_counter:
0B073F 00 00 00    0184*  	.dl 0
0B0742             0185*  prt_irq_counter_saved:
0B0742 00 00 00    0186*      .dl 0
0B0745             0187*  
0B0745             0188*  prt_loop_reset:
0B0745 E5          0189*      push hl
0B0746 21 00 00 00 0190*  	ld hl,0
0B074A 22 3F 07 0B 0191*  	ld (prt_irq_counter),hl
0B074E 22 B0 07 0B 0192*      ld (prt_loop_counter),hl
0B0752 22 B3 07 0B 0193*      ld (prt_loops),hl
0B0756 CD F1 06 0B 0194*      call prt_set
0B075A E1          0195*      pop hl
0B075B C9          0196*      ret
0B075C             0197*  
0B075C             0198*  prt_loop_start:
0B075C E5          0199*      push hl
0B075D 21 00 00 00 0200*  	ld hl,0
0B0761 22 3F 07 0B 0201*  	ld (prt_irq_counter),hl
0B0765 E1          0202*      pop hl
0B0766 C9          0203*      ret
0B0767             0204*  
0B0767             0205*  prt_loop_stop:
0B0767 E5          0206*      push hl
0B0768 D5          0207*      push de
0B0769 2A 3F 07 0B 0208*      ld hl,(prt_irq_counter)
0B076D ED 5B B0 07 0209*      ld de,(prt_loop_counter)
       0B          
0B0772 19          0210*      add hl,de
0B0773 22 B0 07 0B 0211*      ld (prt_loop_counter),hl
0B0777 21 00 00 00 0212*      ld hl,0
0B077B 22 3F 07 0B 0213*      ld (prt_irq_counter),hl
0B077F 2A B3 07 0B 0214*      ld hl,(prt_loops)
0B0783 23          0215*      inc hl
0B0784 22 B3 07 0B 0216*      ld (prt_loops),hl
0B0788 D1          0217*      pop de
0B0789 E1          0218*      pop hl
0B078A C9          0219*      ret
0B078B             0220*  
0B078B             0221*  ; inputs: bc = y,x text coordinates to print
0B078B             0222*  prt_loop_print:
0B078B F5          0223*      push af
0B078C E5          0224*      push hl
0B078D C5          0225*      push bc
0B078E D5          0226*      push de
0B078F DD E5       0227*      push ix
0B0791 FD E5       0228*      push iy
0B0793 CD A8 08 0B 0229*      call vdu_move_cursor
0B0797             0230*  
0B0797 2A B0 07 0B 0231*      ld hl,(prt_loop_counter)
0B079B CD EA 02 0B 0232*      call printDec
0B079F             0233*  
0B079F 2A B3 07 0B 0234*      ld hl,(prt_loops)
0B07A3 CD EA 02 0B 0235*      call printDec
0B07A7             0236*  
0B07A7 FD E1       0237*      pop iy
0B07A9 DD E1       0238*      pop ix
0B07AB D1          0239*      pop de
0B07AC C1          0240*      pop bc
0B07AD E1          0241*      pop hl
0B07AE F1          0242*      pop af
0B07AF C9          0243*      ret
0B07B0             0244*  
0B07B0             0245*  prt_loop_counter:
0B07B0 00 00 00    0246*      .dl 0
0B07B3             0247*  prt_loops:
0B07B3 00 00 00    0248*      .dl 0
0B07B6             0249*  
0B07B6             0250*  ; ===============================================
0B07B6             0251*  ; Timer functions
0B07B6             0252*  ; -----------------------------------------------
0B07B6             0253*  ; set a countdown timer
0B07B6             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B07B6             0255*  ; returns: hl = current time
0B07B6             0256*  tmr_set:
0B07B6 FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
0B07B9             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
0B07B9 3E 08       0001*M 			LD	A, function
0B07BB 5B CF       0002*M 			RST.L	08h
0B07BD DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
0B07C0 FD 2F 00    0260*      ld (iy+0),hl            ; set start time
0B07C3 C9          0261*      ret
0B07C4             0262*  
0B07C4             0263*  ; gets time remaining on a countdown timer
0B07C4             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B07C4             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B07C4             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B07C4             0267*  tmr_get:
0B07C4             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
0B07C4 3E 08       0001*M 			LD	A, function
0B07C6 5B CF       0002*M 			RST.L	08h
0B07C8 DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
0B07CB FD 27 00    0270*      ld hl,(iy+0)            ; get start time
0B07CE AF          0271*      xor a                   ; clear carry
0B07CF ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B07D1 FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
0B07D4 AF          0274*      xor a                   ; clear carry
0B07D5 ED 5A       0275*      adc hl,de               ; hl = time remaining
0B07D7             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B07D7 C9          0277*      ret
0B07D8             0278*  
0B07D8 00 00 00    0279*  timestamp_now: dl 0
0B07DB 00 00 00    0280*  timestamp_old: dl 0
0B07DE 00 00 00    0281*  timestamp_chg: dl 0
0B07E1             0282*  
0B07E1             0283*  ; update the global timestamp from the system clock
0B07E1             0284*  ; inputs: none
0B07E1             0285*  ; returns: hl = time elapsed in 1/120ths of a second
0B07E1             0286*  ;          de = current time
0B07E1             0287*  ;          ix = pointer to syvars table
0B07E1             0288*  ; destroys: af,hl,de,ix
0B07E1             0289*  timestamp_tick:
0B07E1 ED 5B D8 07 0290*      ld de,(timestamp_now)   ; get previous time
       0B          
0B07E6 ED 53 DB 07 0291*      ld (timestamp_old),de   ; save previous time
       0B          
0B07EB             0292*      MOSCALL mos_sysvars     ; ix points to syvars table
0B07EB 3E 08       0001*M 			LD	A, function
0B07ED 5B CF       0002*M 			RST.L	08h
0B07EF DD 27 00    0293*      ld hl,(ix+sysvar_time)  ; get current time
0B07F2 22 D8 07 0B 0294*      ld (timestamp_now),hl   ; save current time
0B07F6 AF          0295*      xor a                   ; clear carry
0B07F7 ED 52       0296*      sbc hl,de               ; hl = time elapsed
0B07F9 22 DE 07 0B 0297*      ld (timestamp_chg),hl   ; save elapsed time
0B07FD C9          0298*      ret
0B07FE             0299*  
0B07FE             0300*  ; set a countdown timer
0B07FE             0301*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B07FE             0302*  ; requires: timestamp_tick to be called at least once before this function
0B07FE             0303*  ; returns: hl = current time
0B07FE             0304*  ; destroys: hl
0B07FE             0305*  timestamp_tmr_set:
0B07FE FD 2F 03    0306*      ld (iy+3),hl            ; set time remaining
0B0801 2A D8 07 0B 0307*      ld hl,(timestamp_now)   ; get current timestamp
0B0805 FD 2F 00    0308*      ld (iy+0),hl            ; set start time
0B0808 C9          0309*      ret
0B0809             0310*  
0B0809             0311*  ; gets time remaining on a countdown timer following the global timestamp
0B0809             0312*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B0809             0313*  ; requires: timestamp_tick to be called at least once before this function
0B0809             0314*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B0809             0315*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B0809             0316*  ; destroys: af,hl,de
0B0809             0317*  timestamp_tmr_get:
0B0809 ED 5B D8 07 0318*      ld de,(timestamp_now)   ; get current timestamp
       0B          
0B080E FD 27 00    0319*      ld hl,(iy+0)            ; get start time
0B0811 AF          0320*      xor a                   ; clear carry
0B0812 ED 52       0321*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B0814 FD 17 03    0322*      ld de,(iy+3)            ; get timer set value
0B0817 AF          0323*      xor a                   ; clear carry
0B0818 ED 5A       0324*      adc hl,de               ; hl = time remaining
0B081A             0325*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B081A C9          0326*      ret
0B081B             0327*  
0B081B             0328*  ; main loop timer functions
0B081B             0329*  tmr_main_loop: ds 6 ; buffer to hold main loop timer
0B0821             0330*  
0B0821             0331*  ; set a countdown timer for the main loop using the timestamp timer
0B0821             0332*  ; inputs: hl = time to set in 1/120ths of a second
0B0821             0333*  ; returns: hl = current time
0B0821             0334*  ; destroys: af,hl,de,ix,iy
0B0821             0335*  tmr_main_loop_set:
0B0821 FD 21 1B 08 0336*      ld iy,tmr_main_loop
       0B          
0B0826 FD 2F 03    0337*      ld (iy+3),hl ; set time remaining
0B0829 CD E1 07 0B 0338*      call timestamp_tick
0B082D 2A D8 07 0B 0339*      ld hl,(timestamp_now)   ; get current timestamp
0B0831 FD 2F 00    0340*      ld (iy+0),hl ; set start time
0B0834 C9          0341*      ret
0B0835             0342*  
0B0835             0343*  ; gets time remaining on the main loop countdown timer following the global timestamp
0B0835             0344*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B0835             0345*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B0835             0346*  ; destroys: af,hl,de,ix,iy
0B0835             0347*  tmr_main_loop_get:
0B0835 CD E1 07 0B 0348*      call timestamp_tick
0B0839 FD 21 1B 08 0349*      ld iy,tmr_main_loop
       0B          
0B083E CD 09 08 0B 0350*      call timestamp_tmr_get
0B0842 C9          0351*      ret
0B0843             0352*  
0B0843             0353*  ; set a stopwatch
0B0843             0354*  ; returns: hl = start time
0B0843             0355*  ; destroys: hl,ix
0B0843             0356*  stopwatch_set:
0B0843             0357*      MOSCALL mos_sysvars     ; ix points to syvars table
0B0843 3E 08       0001*M 			LD	A, function
0B0845 5B CF       0002*M 			RST.L	08h
0B0847 DD 27 00    0358*      ld hl,(ix+sysvar_time)  ; get current time
0B084A 22 5F 08 0B 0359*      ld (stopwatch_started),hl            ; set start time
0B084E C9          0360*      ret
0B084F             0361*  
0B084F             0362*  ; gets time elapsed on a stopwatch
0B084F             0363*  ; returns: hl = time elapsed in 1/120ths of a second
0B084F             0364*  ; destroys: af,hl,de,ix
0B084F             0365*  stopwatch_get:
0B084F             0366*      MOSCALL mos_sysvars     ; ix points to syvars table
0B084F 3E 08       0001*M 			LD	A, function
0B0851 5B CF       0002*M 			RST.L	08h
0B0853 DD 27 00    0367*      ld hl,(ix+sysvar_time)  ; get current time
0B0856 ED 5B 5F 08 0368*      ld de,(stopwatch_started)            ; get start time
       0B          
0B085B AF          0369*      xor a                   ; clear carry
0B085C ED 52       0370*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0B085E C9          0371*      ret
0B085F             0372*  
0B085F             0373*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0B0862             0374*  
0B0862             0375*  ; ------------------
0B0862             0376*  ; delay routine
0B0862             0377*  ; Author: Richard Turrnidge
0B0862             0378*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0B0862             0379*  ; routine waits a fixed time,then returns
0B0862             0380*  ; arrive with A =  the delay byte. One bit to be set only.
0B0862             0381*  ; eg. ld A,00000100b
0B0862             0382*  
0B0862             0383*  multiPurposeDelay:
0B0862 F5          0384*      push af
0B0863 C5          0385*      push bc
0B0864 DD E5       0386*      push ix
0B0866 47          0387*      ld b,a
0B0867 3E 08       0388*      ld a,$08
0B0869 5B CF       0389*      RST.LIL	08h                 ; get IX pointer to sysvars
0B086B             0390*  
0B086B             0391*  waitLoop:
0B086B             0392*  
0B086B DD 7E 00    0393*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0B086E             0394*  
0B086E             0395*                                  ;   we check if bit set is same as last time we checked.
0B086E             0396*                                  ;   bit 0 - don't use
0B086E             0397*                                  ;   bit 1 - changes 64 times per second
0B086E             0398*                                  ;   bit 2 - changes 32 times per second
0B086E             0399*                                  ;   bit 3 - changes 16 times per second
0B086E             0400*  
0B086E             0401*                                  ;   bit 4 - changes 8 times per second
0B086E             0402*                                  ;   bit 5 - changes 4 times per second
0B086E             0403*                                  ;   bit 6 - changes 2 times per second
0B086E             0404*                                  ;   bit 7 - changes 1 times per second
0B086E A0          0405*      and b
0B086F 4F          0406*      ld c,a
0B0870 3A 81 08 0B 0407*      ld a,(oldTimeStamp)
0B0874 B9          0408*      cp c                        ; is A same as last value?
0B0875 28 F4       0409*      jr z,waitLoop              ; loop here if it is
0B0877 79          0410*      ld a,c
0B0878 32 81 08 0B 0411*      ld (oldTimeStamp),a        ; set new value
0B087C             0412*  
0B087C DD E1       0413*      pop ix
0B087E C1          0414*      pop bc
0B087F F1          0415*      pop af
0B0880 C9          0416*      ret
0B0881             0417*  
0B0881 00          0418*  oldTimeStamp:   .db 00h
0B0882             0022       include "vdu.inc"
0B0882             0001*  
0B0882             0002*  ; VDU 30: Home cursor
0B0882             0003*  vdu_home_cursor:
0B0882 3E 1E       0004*      ld a,30
0B0884 5B D7       0005*  	rst.lil $10
0B0886 C9          0006*  	ret
0B0887             0007*  
0B0887             0008*  cursor_on:
0B0887 21 92 08 0B 0009*  	ld hl,@cmd
0B088B 01 03 00 00 0010*  	ld bc,@end-@cmd
0B088F 5B DF       0011*  	rst.lil $18
0B0891 C9          0012*  	ret
0B0892             0013*  @cmd:
0B0892 17 01 01    0014*  	db 23,1,1
0B0895             0015*  @end:
0B0895             0016*  
0B0895             0017*  cursor_off:
0B0895 21 A0 08 0B 0018*  	ld hl,@cmd
0B0899 01 03 00 00 0019*  	ld bc,@end-@cmd
0B089D 5B DF       0020*  	rst.lil $18
0B089F C9          0021*  	ret
0B08A0             0022*  @cmd:
0B08A0 17 01 00    0023*  	db 23,1,0
0B08A3             0024*  @end:
0B08A3             0025*  
0B08A3             0026*  ; VDU 9: Move cursor forward one character
0B08A3             0027*  vdu_cursor_forward:
0B08A3 3E 09       0028*      ld a,9
0B08A5 5B D7       0029*  	rst.lil $10
0B08A7 C9          0030*  	ret
0B08A8             0031*  
0B08A8             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0B08A8             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
0B08A8             0034*  vdu_move_cursor:
0B08A8 ED 43 B9 08 0035*      ld (@x0),bc
       0B          
0B08AD 21 B8 08 0B 0036*  	ld hl,@cmd
0B08B1 01 03 00 00 0037*  	ld bc,@end-@cmd
0B08B5 5B DF       0038*  	rst.lil $18
0B08B7 C9          0039*  	ret
0B08B8 1F          0040*  @cmd: 	db 31
0B08B9 00          0041*  @x0:	db 0
0B08BA 00          0042*  @y0: 	db 0
0B08BB 00          0043*  @end: 	db 0 ; padding
0B08BC             0044*  
0B08BC             0045*  ; VDU 12: Clear text area (CLS)
0B08BC             0046*  vdu_cls:
0B08BC 3E 0C       0047*      ld a,12
0B08BE 5B D7       0048*  	rst.lil $10
0B08C0 C9          0049*  	ret
0B08C1             0050*  
0B08C1             0051*  vdu_flip:
0B08C1 21 CC 08 0B 0052*  	ld hl,@cmd
0B08C5 01 03 00 00 0053*  	ld bc,@end-@cmd
0B08C9 5B DF       0054*  	rst.lil $18
0B08CB C9          0055*  	ret
0B08CC 17 00 C3    0056*  @cmd: db 23,0,0xC3
0B08CF             0057*  @end:
0B08CF             0058*  
0B08CF             0059*  ; VDU 16: Clear graphics area (CLG)
0B08CF             0060*  vdu_clg:
0B08CF 3E 10       0061*      ld a,16
0B08D1 5B D7       0062*  	rst.lil $10
0B08D3 C9          0063*  	ret
0B08D4             0064*  
0B08D4             0065*  ; COLOUR MODES
0B08D4             0066*  ; Mode	Effect
0B08D4             0067*  ; 0	Set on-screen pixel to target colour value
0B08D4             0068*  ; 1	OR value with the on-screen pixel
0B08D4             0069*  ; 2	AND value with the on-screen pixel
0B08D4             0070*  ; 3	XOR value with the on-screen pixel
0B08D4             0071*  ; 4	Invert the on-screen pixel
0B08D4             0072*  ; 5	No operation
0B08D4             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0B08D4             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0B08D4             0075*  
0B08D4             0076*  ; VDU 17, colour: Define text colour (COLOUR)
0B08D4             0077*  vdu_colour_text:
0B08D4 32 E4 08 0B 0078*  	ld (@arg),a
0B08D8 21 E3 08 0B 0079*  	ld hl,@cmd
0B08DC 01 02 00 00 0080*  	ld bc,@end-@cmd
0B08E0 5B DF       0081*  	rst.lil $18
0B08E2 C9          0082*  	ret
0B08E3 11          0083*  @cmd: db 17
0B08E4 00          0084*  @arg: db 0
0B08E5             0085*  @end:
0B08E5             0086*  
0B08E5             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0B08E5             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0B08E5             0089*  vdu_gcol:
0B08E5 32 FA 08 0B 0090*  	ld (@mode),a
0B08E9 79          0091*      ld a,c
0B08EA 32 FB 08 0B 0092*      ld (@col),a
0B08EE 21 F9 08 0B 0093*  	ld hl,@cmd
0B08F2 01 03 00 00 0094*  	ld bc,@end-@cmd
0B08F6 5B DF       0095*  	rst.lil $18
0B08F8 C9          0096*  	ret
0B08F9 12          0097*  @cmd:  db 18
0B08FA 00          0098*  @mode: db 0
0B08FB 00          0099*  @col:  db 0
0B08FC             0100*  @end:
0B08FC             0101*  
0B08FC             0102*  
0B08FC             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
0B08FC             0104*  ; MIND THE LITTLE-ENDIANESS
0B08FC             0105*  ; inputs: c=left,b=bottom,e=right,d=top
0B08FC             0106*  ; outputs; nothing
0B08FC             0107*  ; destroys: a might make it out alive
0B08FC             0108*  vdu_set_txt_viewport:
0B08FC ED 43 12 09 0109*      ld (@lb),bc
       0B          
0B0901 ED 53 14 09 0110*  	ld (@rt),de
       0B          
0B0906 21 11 09 0B 0111*  	ld hl,@cmd
0B090A 01 05 00 00 0112*  	ld bc,@end-@cmd
0B090E 5B DF       0113*  	rst.lil $18
0B0910 C9          0114*  	ret
0B0911 1C          0115*  @cmd:   db 28 ; set text viewport command
0B0912 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
0B0914 00 00       0117*  @rt: 	dw 0x0000 ; set by de
0B0916 00          0118*  @end:   db 0x00	  ; padding
0B0917             0119*  
0B0917             0120*  ; Wait for VBLANK interrupt
0B0917             0121*  vdu_vblank:
0B0917 DD E5       0122*      PUSH 	IX
0B0919             0123*  	MOSCALL	mos_sysvars
0B0919 3E 08       0001*M 			LD	A, function
0B091B 5B CF       0002*M 			RST.L	08h
0B091D DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
0B0920             0125*  @wait:
0B0920 DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
0B0923 28 FB       0127*      JR	Z, @wait
0B0925 DD E1       0128*      POP	IX
0B0927 C9          0129*      RET
0B0928             0130*  
0B0928             0131*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
0B0928             0132*  ; NOTE: the order of the y-coordinate parameters are inverted
0B0928             0133*  ; 	because we have turned off logical screen scaling
0B0928             0134*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0B0928             0135*  ; outputs; nothing
0B0928             0136*  ; destroys: a might make it out alive
0B0928             0137*  vdu_set_gfx_viewport:
0B0928 ED 43 48 09 0138*      ld (@x0),bc
       0B          
0B092D FD 22 4A 09 0139*      ld (@y1),iy
       0B          
0B0932 DD 22 4C 09 0140*  	ld (@x1),ix
       0B          
0B0937 ED 53 4E 09 0141*  	ld (@y0),de
       0B          
0B093C 21 47 09 0B 0142*  	ld hl,@cmd
0B0940 01 09 00 00 0143*  	ld bc,@end-@cmd
0B0944 5B DF       0144*  	rst.lil $18
0B0946 C9          0145*  	ret
0B0947 18          0146*  @cmd:   db 24 ; set graphics viewport command
0B0948 00 00       0147*  @x0: 	dw 0x0000 ; set by bc
0B094A 00 00       0148*  @y1: 	dw 0x0000 ; set by iy
0B094C 00 00       0149*  @x1: 	dw 0x0000 ; set by ix
0B094E 00 00       0150*  @y0: 	dw 0x0000 ; set by de
0B0950 00          0151*  @end:   db 0x00	  ; padding
0B0951             0152*  
0B0951             0153*  ; SCREEN MODES
0B0951             0154*  ; ===============================
0B0951             0155*  ; Mode  Horz  Vert  Cols  Refresh
0B0951             0156*  ; ---   ----  ----  ----  -------
0B0951             0157*  ; 11    320   240   2     60hz
0B0951             0158*  ; 139   320   240   2     60hz
0B0951             0159*  ; 23    512   384   2     60hz
0B0951             0160*  ; 151   512   384   2     60hz
0B0951             0161*  ; 6     640   240   2     60hz
0B0951             0162*  ; 134   640   240   2     60hz
0B0951             0163*  ; 2     640   480   2     60hz
0B0951             0164*  ; 130   640   480   2     60hz
0B0951             0165*  ; 17    800   600   2     60hz
0B0951             0166*  ; 145   800   600   2     60hz
0B0951             0167*  ; 18    1024  768   2     60hz
0B0951             0168*  ; 146   1024  768   2     60hz
0B0951             0169*  ; ---   ----  ----  ----  -------
0B0951             0170*  ; 10    320   240   4     60hz
0B0951             0171*  ; 138   320   240   4     60hz
0B0951             0172*  ; 22    512   384   4     60hz
0B0951             0173*  ; 150   512   384   4     60hz
0B0951             0174*  ; 5     640   240   4     60hz
0B0951             0175*  ; 133   640   240   4     60hz
0B0951             0176*  ; 1     640   480   4     60hz
0B0951             0177*  ; 129   640   480   4     60hz
0B0951             0178*  ; 16    800   600   4     60hz
0B0951             0179*  ; 19    1024  768   4     60hz
0B0951             0180*  ; ---   ----  ----  ----  -------
0B0951             0181*  ; 9     320   240   16    60hz
0B0951             0182*  ; 137   320   240   16    60hz
0B0951             0183*  ; 21    512   384   16    60hz
0B0951             0184*  ; 149   512   384   16    60hz
0B0951             0185*  ; 4     640   240   16    60hz
0B0951             0186*  ; 132   640   240   16    60hz
0B0951             0187*  ; 0     640   480   16    60hz
0B0951             0188*  ; 7     n/a   n/a   16    60hz
0B0951             0189*  ; ---   ----  ----  ----  -------
0B0951             0190*  ; 8     320   240   64    60hz
0B0951             0191*  ; 136   320   240   64    60hz
0B0951             0192*  ; 20    512   384   64    60hz
0B0951             0193*  ; 3     640   240   64    60hz
0B0951             0194*  ; ---   ----  ----  ----  -------
0B0951             0195*  vdu_set_screen_mode:
0B0951 32 61 09 0B 0196*  	ld (@arg),a
0B0955 21 60 09 0B 0197*  	ld hl,@cmd
0B0959 01 02 00 00 0198*  	ld bc,@end-@cmd
0B095D 5B DF       0199*  	rst.lil $18
0B095F C9          0200*  	ret
0B0960 16          0201*  @cmd: db 22 ; set screen mode
0B0961 00          0202*  @arg: db 0  ; screen mode parameter
0B0962             0203*  @end:
0B0962             0204*  
0B0962             0205*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0B0962             0206*  ; inputs: a is scaling mode, 1=on, 0=off
0B0962             0207*  ; note: default setting on boot is scaling ON
0B0962             0208*  vdu_set_scaling:
0B0962 32 74 09 0B 0209*  	ld (@arg),a
0B0966 21 71 09 0B 0210*  	ld hl,@cmd
0B096A 01 04 00 00 0211*  	ld bc,@end-@cmd
0B096E 5B DF       0212*  	rst.lil $18
0B0970 C9          0213*  	ret
0B0971 17 00 C0    0214*  @cmd: db 23,0,0xC0
0B0974 00          0215*  @arg: db 0  ; scaling on/off
0B0975             0216*  @end:
0B0975             0217*  
0B0975             0218*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0B0975             0219*  ; inputs: hl=bufferId
0B0975             0220*  vdu_buff_select:
0B0975 22 87 09 0B 0221*  	ld (@bufferId),hl
0B0979 21 84 09 0B 0222*  	ld hl,@cmd
0B097D 01 05 00 00 0223*  	ld bc,@end-@cmd
0B0981 5B DF       0224*  	rst.lil $18
0B0983 C9          0225*  	ret
0B0984 17 1B 20    0226*  @cmd: db 23,27,0x20
0B0987 00 00       0227*  @bufferId: dw 0x0000
0B0989 00          0228*  @end: db 0x00 ; padding
0B098A             0229*  
0B098A             0230*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0B098A             0231*  ; inputs: a=format; bc=width; de=height
0B098A             0232*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0B098A             0233*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0B098A             0234*  ; 0 	RGBA8888 (4-bytes per pixel)
0B098A             0235*  ; 1 	RGBA2222 (1-bytes per pixel)
0B098A             0236*  ; 2 	Mono/Mask (1-bit per pixel)
0B098A             0237*  ; 3 	Reserved for internal use by VDP (native format)
0B098A             0238*  vdu_bmp_create:
0B098A ED 43 A6 09 0239*      ld (@width),bc
       0B          
0B098F ED 53 A8 09 0240*      ld (@height),de
       0B          
0B0994 32 AA 09 0B 0241*      ld (@fmt),a
0B0998 21 A3 09 0B 0242*  	ld hl,@cmd
0B099C 01 08 00 00 0243*  	ld bc,@end-@cmd
0B09A0 5B DF       0244*  	rst.lil $18
0B09A2 C9          0245*  	ret
0B09A3 17 1B 21    0246*  @cmd:       db 23,27,0x21
0B09A6 00 00       0247*  @width:     dw 0x0000
0B09A8 00 00       0248*  @height:    dw 0x0000
0B09AA 00          0249*  @fmt:       db 0x00
0B09AB             0250*  @end:
0B09AB             0251*  
0B09AB             0252*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0B09AB             0253*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0B09AB             0254*  vdu_load_img_rgba2_to_8:
0B09AB             0255*  ; backup the target buffer id and image dimensions
0B09AB E5          0256*      push hl
0B09AC D5          0257*      push de
0B09AD C5          0258*      push bc
0B09AE             0259*  ; load the rgba2 image to working buffer 65534
0B09AE 21 FE FF 00 0260*      ld hl,65534 ; temporary working buffer id
0B09B2 CD B5 0A 0B 0261*  	call vdu_load_buffer_from_file
0B09B6             0262*  ; restore the image dimensions and target buffer id
0B09B6 C1          0263*      pop bc
0B09B7 D1          0264*      pop de
0B09B8 E1          0265*      pop hl
0B09B9             0266*  ; fall through to vdu_rgba2_to_8
0B09B9             0267*  
0B09B9             0268*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0B09B9             0269*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0B09B9             0270*  ; the "expand bitmap" command is:
0B09B9             0271*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B09B9             0272*  ; and then to reverse the byte order to fix endian-ness:
0B09B9             0273*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B09B9             0274*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B09B9             0275*  ; VDU 23,27,&20,targetBufferID%;
0B09B9             0276*  ; VDU 23,27,&21,width%;height%;0
0B09B9             0277*  ; -------------------------------------------------------------------
0B09B9             0278*  ; inputs: bc,de image width,height ; hl = targetBufferId
0B09B9             0279*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0B09B9             0280*  vdu_rgba2_to_8:
0B09B9             0281*  ; load the image dimensions and buffer id parameters
0B09B9 ED 43 15 0A 0282*      ld (@width),bc
       0B          
0B09BE ED 53 17 0A 0283*      ld (@height),de
       0B          
0B09C3 22 FA 09 0B 0284*      ld (@bufferId0),hl
0B09C7 22 07 0A 0B 0285*      ld (@bufferId2),hl
0B09CB 22 10 0A 0B 0286*      ld (@bufferId1),hl
0B09CF             0287*  ; clean up bytes that got stomped on by the ID loads
0B09CF 3E 48       0288*      ld a,0x48
0B09D1 32 FC 09 0B 0289*      ld (@bufferId0+2),a
0B09D5 3E 17       0290*      ld a,23
0B09D7 32 12 0A 0B 0291*      ld (@bufferId1+2),a
0B09DB 3E 18       0292*      ld a,24
0B09DD 32 09 0A 0B 0293*      ld (@bufferId2+2),a
0B09E1 AF          0294*      xor a
0B09E2 32 19 0A 0B 0295*      ld (@height+2),a
0B09E6             0296*  ; send the vdu command strings
0B09E6 21 F1 09 0B 0297*      ld hl,@beg
0B09EA 01 29 00 00 0298*      ld bc,@end-@beg
0B09EE 5B DF       0299*      rst.lil $18
0B09F0 C9          0300*      ret
0B09F1             0301*  @beg:
0B09F1             0302*  ; Command 14: Consolidate blocks in a buffer
0B09F1             0303*  ; VDU 23, 0, &A0, bufferId; 14
0B09F1 17 00 A0    0304*      db 23,0,0xA0
0B09F4 FE FF       0305*      dw 65534 ; workingBufferId
0B09F6 0E          0306*      db 14 ; consolidate blocks
0B09F7             0307*  ; the "expand bitmap" command is:
0B09F7             0308*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B09F7 17 00 A0    0309*      db 23,0,0xA0
0B09FA 00 00       0310*  @bufferId0: dw 0x0000 ; targetBufferId
0B09FC 48          0311*      db 0x48 ; given as decimal command 72 in the docs
0B09FD 02          0312*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B09FE FE FF       0313*      dw 65534 ; sourceBufferId
0B0A00 00 7F BF FF 0314*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B0A04             0315*  ; reverse the byte order to fix endian-ness:
0B0A04             0316*  ; Command 24: Reverse the order of data of blocks within a buffer
0B0A04             0317*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0B0A04             0318*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B0A04 17 00 A0    0319*      db 23,0,0xA0
0B0A07 00 00       0320*  @bufferId2:    dw 0x0000 ; targetBufferId
0B0A09 18          0321*      db 24 ; reverse byte order
0B0A0A 04          0322*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B0A0B 04 00       0323*      dw 4 ; size (4 bytes)
0B0A0D             0324*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B0A0D             0325*  ; VDU 23,27,&20,targetBufferID%;
0B0A0D 17 1B 20    0326*      db 23,27,0x20 ; select bitmap
0B0A10 00 00       0327*  @bufferId1: dw 0x0000 ; targetBufferId
0B0A12             0328*  ; VDU 23,27,&21,width%;height%;0
0B0A12 17 1B 21    0329*      db 23,27,0x21 ; create bitmap from buffer
0B0A15 00 00       0330*  @width: dw 0x0000
0B0A17 00 00       0331*  @height: dw 0x0000
0B0A19 00          0332*      db 0x00 ; rgba8888 format
0B0A1A             0333*  @end:
0B0A1A             0334*  
0B0A1A             0335*  ; scratch variables
0B0A1A 00 00 00    0336*  bufferId0: dl 0x000000
0B0A1D 00 00 00    0337*  bufferId1: dl 0x000000
0B0A20             0338*  
0B0A20             0339*  ; load a vdu buffer from local memory
0B0A20             0340*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B0A20             0341*  vdu_load_buffer:
0B0A20 ED 43 49 0A 0342*      ld (@length),bc
       0B          
0B0A25 D5          0343*      push de ; save data pointer
0B0A26             0344*  ; send the vdu command string
0B0A26 7D          0345*      ld a,l
0B0A27 32 46 0A 0B 0346*      ld (@bufferId),a
0B0A2B 7C          0347*      ld a,h
0B0A2C 32 47 0A 0B 0348*      ld (@bufferId+1),a
0B0A30 21 43 0A 0B 0349*      ld hl,@cmd
0B0A34 01 08 00 00 0350*      ld bc,@end-@cmd
0B0A38 5B DF       0351*      rst.lil $18
0B0A3A             0352*  ; send the buffer data
0B0A3A E1          0353*      pop hl ; pointer to data
0B0A3B ED 4B 49 0A 0354*      ld bc,(@length)
       0B          
0B0A40 5B DF       0355*      rst.lil $18 ; send it
0B0A42 C9          0356*      ret
0B0A43             0357*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B0A43 17 00 A0    0358*  @cmd:       db 23,0,0xA0
0B0A46 00 00       0359*  @bufferId:	dw 0x0000
0B0A48 00          0360*  		    db 0 ; load buffer
0B0A49 00 00       0361*  @length:	dw 0x0000
0B0A4B 00          0362*  @end: db 0 ; padding
0B0A4C             0363*  
0B0A4C             0364*  ; clear a buffer
0B0A4C             0365*  ; inputs: hl = bufferId
0B0A4C             0366*  vdu_clear_buffer:
0B0A4C 7D          0367*      ld a,l
0B0A4D 32 64 0A 0B 0368*      ld (@bufferId),a
0B0A51 7C          0369*      ld a,h
0B0A52 32 65 0A 0B 0370*      ld (@bufferId+1),a
0B0A56 21 61 0A 0B 0371*      ld hl,@cmd
0B0A5A 01 06 00 00 0372*      ld bc,@end-@cmd
0B0A5E 5B DF       0373*      rst.lil $18
0B0A60 C9          0374*      ret
0B0A61 17 00 A0    0375*  @cmd:       db 23,0,0xA0
0B0A64 00 00       0376*  @bufferId:	dw 0x0000
0B0A66 02          0377*  		    db 2 ; clear buffer
0B0A67             0378*  @end:
0B0A67             0379*  
0B0A67             0380*  vdu_clear_all_buffers:
0B0A67             0381*  ; clear all buffers
0B0A67 21 72 0A 0B 0382*      ld hl,@beg
0B0A6B 01 06 00 00 0383*      ld bc,@end-@beg
0B0A6F 5B DF       0384*      rst.lil $18
0B0A71 C9          0385*      ret
0B0A72 17 00 A0    0386*  @beg: db 23,0,$A0
0B0A75 FF FF       0387*        dw -1 ; clear all buffers
0B0A77 02          0388*        db 2  ; command 2: clear a buffer
0B0A78             0389*  @end:
0B0A78             0390*  
0B0A78             0391*  ; Command 14: Consolidate blocks in a buffer
0B0A78             0392*  vdu_consolidate_buffer:
0B0A78             0393*  ; set parameters for vdu call
0B0A78 7D          0394*      ld a,l
0B0A79 32 90 0A 0B 0395*      ld (@bufferId),a
0B0A7D 7C          0396*      ld a,h
0B0A7E 32 91 0A 0B 0397*      ld (@bufferId+1),a
0B0A82 21 8D 0A 0B 0398*      ld hl,@beg
0B0A86 01 06 00 00 0399*      ld bc,@end-@beg
0B0A8A 5B DF       0400*      rst.lil $18
0B0A8C C9          0401*      ret
0B0A8D             0402*  ; VDU 23, 0, &A0, bufferId; 14
0B0A8D 17 00 A0    0403*  @beg: db 23,0,0xA0
0B0A90 00 00       0404*  @bufferId: dw 0x0000
0B0A92 0E          0405*             db 14
0B0A93             0406*  @end:
0B0A93             0407*  
0B0A93             0408*  ; load an image file to a buffer and make it a bitmap
0B0A93             0409*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0B0A93             0410*  vdu_load_img:
0B0A93             0411*  ; back up image type and dimension parameters
0B0A93 22 1A 0A 0B 0412*      ld (bufferId0),hl
0B0A97 F5          0413*      push af
0B0A98 C5          0414*  	push bc
0B0A99 D5          0415*  	push de
0B0A9A             0416*  ; load the image
0B0A9A CD B5 0A 0B 0417*  	call vdu_load_buffer_from_file
0B0A9E             0418*  ; now make it a bitmap
0B0A9E 2A 1A 0A 0B 0419*      ld hl,(bufferId0)
0B0AA2 CD 78 0A 0B 0420*      call vdu_consolidate_buffer
0B0AA6 2A 1A 0A 0B 0421*      ld hl,(bufferId0)
0B0AAA CD 75 09 0B 0422*      call vdu_buff_select
0B0AAE D1          0423*  	pop de ; image height
0B0AAF C1          0424*  	pop bc ; image width
0B0AB0 F1          0425*  	pop af ; image type
0B0AB1 C3 8A 09 0B 0426*  	jp vdu_bmp_create ; will return to caller from there
0B0AB5             0427*  
0B0AB5             0428*  ; inputs: hl = bufferId; iy = pointer to filename
0B0AB5             0429*  vdu_load_buffer_from_file:
0B0AB5 22 1A 0A 0B 0430*      ld (bufferId0),hl
0B0AB9             0431*  
0B0AB9             0432*  ; clear target buffer
0B0AB9 CD 4C 0A 0B 0433*      call vdu_clear_buffer
0B0ABD             0434*  
0B0ABD             0435*  ; open the file in read mode
0B0ABD             0436*  ; Open a file
0B0ABD             0437*  ; HLU: Filename
0B0ABD             0438*  ;   C: Mode
0B0ABD             0439*  ; Returns:
0B0ABD             0440*  ;   A: Filehandle, or 0 if couldn't open
0B0ABD FD E5       0441*  	push iy ; pointer to filename
0B0ABF E1          0442*  	pop hl
0B0AC0 0E 01       0443*  	ld c,fa_read
0B0AC2             0444*      MOSCALL mos_fopen
0B0AC2 3E 0A       0001*M 			LD	A, function
0B0AC4 5B CF       0002*M 			RST.L	08h
0B0AC6 32 01 0B 0B 0445*      ld (@filehandle),a
0B0ACA             0446*  
0B0ACA             0447*  @read_file:
0B0ACA             0448*  ; Read a block of data from a file
0B0ACA             0449*  ;   C: Filehandle
0B0ACA             0450*  ; HLU: Pointer to where to write the data to
0B0ACA             0451*  ; DEU: Number of bytes to read
0B0ACA             0452*  ; Returns:
0B0ACA             0453*  ; DEU: Number of bytes read
0B0ACA 3A 01 0B 0B 0454*      ld a,(@filehandle)
0B0ACE 4F          0455*      ld c,a
0B0ACF 21 00 E0 B7 0456*      ld hl,filedata
0B0AD3 11 00 20 00 0457*      ld de,8192 ; max we can read into onboard sram at one time
0B0AD7             0458*      MOSCALL mos_fread
0B0AD7 3E 1A       0001*M 			LD	A, function
0B0AD9 5B CF       0002*M 			RST.L	08h
0B0ADB             0459*  
0B0ADB             0460*  ; ; DEBUG: print chunk size
0B0ADB             0461*  ;     push de
0B0ADB             0462*  ;     pop hl
0B0ADB             0463*  ;     call printDec
0B0ADB             0464*  ;     call printNewLine
0B0ADB             0465*  
0B0ADB             0466*  ; test de for zero bytes read
0B0ADB 21 00 00 00 0467*      ld hl,0
0B0ADF AF          0468*      xor a ; clear carry
0B0AE0 ED 52       0469*      sbc hl,de
0B0AE2 CA F8 0A 0B 0470*      jp z,@close_file
0B0AE6             0471*  
0B0AE6             0472*  ; load a vdu buffer from local memory
0B0AE6             0473*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B0AE6 2A 1A 0A 0B 0474*      ld hl,(bufferId0)
0B0AEA D5          0475*      push de ; chunksize
0B0AEB C1          0476*      pop bc
0B0AEC 11 00 E0 B7 0477*      ld de,filedata
0B0AF0 CD 20 0A 0B 0478*      call vdu_load_buffer
0B0AF4             0479*  
0B0AF4             0480*  ; ; print progress breadcrumbs
0B0AF4             0481*  ;     ld a,'.'
0B0AF4             0482*  ;     rst.lil 10h
0B0AF4             0483*  
0B0AF4             0484*  ; read the next block
0B0AF4 C3 CA 0A 0B 0485*      jp @read_file
0B0AF8             0486*  
0B0AF8             0487*  ; close the file
0B0AF8             0488*  @close_file:
0B0AF8 3A 01 0B 0B 0489*      ld a,(@filehandle)
0B0AFC             0490*      MOSCALL mos_fclose
0B0AFC 3E 0B       0001*M 			LD	A, function
0B0AFE 5B CF       0002*M 			RST.L	08h
0B0B00 C9          0491*      ret ; vdu_load_buffer_from_file
0B0B01             0492*  
0B0B01 00          0493*  @filehandle: db 0 ; file handle
0B0B02 00 00 00    0494*  @fil: dl 0 ; pointer to FIL struct
0B0B05             0495*  
0B0B05 00 00 00    0496*  @chunkpointer: dl 0 ; pointer to current chunk
0B0B08             0497*  
0B0B08             0498*  ; File information structure (FILINFO)
0B0B08             0499*  @filinfo:
0B0B08 00 00 00 00 0500*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B0B0C 00 00       0501*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B0B0E 00 00       0502*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B0B10 00          0503*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B0B11 00 00 00 00 0504*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0B0B1E 00 00 00 00 0505*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0C1E             0023       ; include "vdu_fonts.inc"
0B0C1E             0024       include "vdu_plot.inc"
0B0C1E             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0C1E             0002*  ; PLOT code 	(Decimal) 	Effect
0B0C1E             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0B0C1E             0004*  plot_sl_both: equ 0x00
0B0C1E             0005*  
0B0C1E             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0B0C1E             0007*  plot_sl_first: equ 0x08
0B0C1E             0008*  
0B0C1E             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0B0C1E             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0B0C1E             0011*  
0B0C1E             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0B0C1E             0013*  plot_sl_last: equ 0x20
0B0C1E             0014*  
0B0C1E             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0B0C1E             0016*  plot_sl_none: equ 0x28
0B0C1E             0017*  
0B0C1E             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0B0C1E             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0B0C1E             0020*  
0B0C1E             0021*  ; &40-&47 	64-71 	Point plot
0B0C1E             0022*  plot_pt: equ 0x40
0B0C1E             0023*  
0B0C1E             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background 
0B0C1E             0025*  plot_lf_lr_non_bg: equ 0x48
0B0C1E             0026*  
0B0C1E             0027*  ; &50-&57 	80-87 	Triangle fill
0B0C1E             0028*  plot_tf: equ 0x50
0B0C1E             0029*  
0B0C1E             0030*  ; &58-&5F 	88-95 	Line fill right to background 
0B0C1E             0031*  plot_lf_r_bg: equ 0x58
0B0C1E             0032*  
0B0C1E             0033*  ; &60-&67 	96-103 	Rectangle fill
0B0C1E             0034*  plot_rf: equ 0x60
0B0C1E             0035*  
0B0C1E             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground 
0B0C1E             0037*  plot_lf_lr_fg: equ 0x60
0B0C1E             0038*  
0B0C1E             0039*  ; &70-&77 	112-119 	Parallelogram fill
0B0C1E             0040*  plot_pf: equ 0x70
0B0C1E             0041*  
0B0C1E             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground 
0B0C1E             0043*  plot_lf_r_non_fg: equ 0x78
0B0C1E             0044*  
0B0C1E             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0B0C1E             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0B0C1E             0047*  
0B0C1E             0048*  ; &90-&97 	144-151 	Circle outline
0B0C1E             0049*  plot_co: equ 0x90
0B0C1E             0050*  
0B0C1E             0051*  ; &98-&9F 	152-159 	Circle fill
0B0C1E             0052*  plot_cf: equ 0x98
0B0C1E             0053*  
0B0C1E             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0B0C1E             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0B0C1E             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0B0C1E             0057*  
0B0C1E             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0B0C1E             0059*  plot_rcm: equ 0xB8
0B0C1E             0060*  
0B0C1E             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0B0C1E             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0B0C1E             0063*  ; &D0-&D7 	208-215 	Not defined
0B0C1E             0064*  ; &D8-&DF 	216-223 	Not defined
0B0C1E             0065*  ; &E0-&E7 	224-231 	Not defined
0B0C1E             0066*  
0B0C1E             0067*  ; &E8-&EF 	232-239 	Bitmap plot 
0B0C1E             0068*  plot_bmp: equ 0xE8
0B0C1E             0069*  
0B0C1E             0070*  ; &F0-&F7 	240-247 	Not defined
0B0C1E             0071*  ; &F8-&FF 	248-255 	Not defined
0B0C1E             0072*  
0B0C1E             0073*  ;  Support added in Agon Console8 VDP 2.1.0  Support added in
0B0C1E             0074*  ; Agon Console8 VDP 2.2.0
0B0C1E             0075*  
0B0C1E             0076*  ; Within each group of eight plot codes, the effects are as follows:
0B0C1E             0077*  ; Plot code 	Effect
0B0C1E             0078*  ; 0 	Move relative
0B0C1E             0079*  mv_rel: equ 0
0B0C1E             0080*  
0B0C1E             0081*  ; 1 	Plot relative in current foreground colour
0B0C1E             0082*  dr_rel_fg: equ 1
0B0C1E             0083*  
0B0C1E             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0B0C1E             0085*  ; 3 	Plot relative in current background colour
0B0C1E             0086*  dr_rel_bg: equ 3
0B0C1E             0087*  
0B0C1E             0088*  ; 4 	Move absolute
0B0C1E             0089*  mv_abs: equ 4
0B0C1E             0090*  
0B0C1E             0091*  ; 5 	Plot absolute in current foreground colour
0B0C1E             0092*  dr_abs_fg: equ 5
0B0C1E             0093*  
0B0C1E             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0B0C1E             0095*  ; 7 	Plot absolute in current background colour
0B0C1E             0096*  dr_abs_bg: equ 7
0B0C1E             0097*  
0B0C1E             0098*  ; Codes 0-3 use the position data provided as part of the command
0B0C1E             0099*  ; as a relative position, adding the position given to the current
0B0C1E             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0B0C1E             0101*  ; as part of the command as an absolute position, setting the current
0B0C1E             0102*  ; graphical cursor position to the position given.
0B0C1E             0103*  
0B0C1E             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0B0C1E             0105*  ; current pixel colour. These operations cannot currently be supported
0B0C1E             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0B0C1E             0107*  ; supported. Support for these codes may be added in a future version
0B0C1E             0108*  ; of the VDP firmware.
0B0C1E             0109*  
0B0C1E             0110*  ; 16 colour palette constants
0B0C1E             0111*  c_black: equ 0
0B0C1E             0112*  c_red_dk: equ 1
0B0C1E             0113*  c_green_dk: equ 2
0B0C1E             0114*  c_yellow_dk: equ 3
0B0C1E             0115*  c_blue_dk: equ 4
0B0C1E             0116*  c_magenta_dk: equ 5
0B0C1E             0117*  c_cyan_dk: equ 6
0B0C1E             0118*  c_grey: equ 7
0B0C1E             0119*  c_grey_dk: equ 8
0B0C1E             0120*  c_red: equ 9
0B0C1E             0121*  c_green: equ 10
0B0C1E             0122*  c_yellow: equ 11
0B0C1E             0123*  c_blue: equ 12
0B0C1E             0124*  c_magenta: equ 13
0B0C1E             0125*  c_cyan: equ 14
0B0C1E             0126*  c_white: equ 15
0B0C1E             0127*  
0B0C1E             0128*  ; VDU 25, mode, x; y;: PLOT command
0B0C1E             0129*  ; inputs: a=mode, bc=x0, de=y0
0B0C1E             0130*  vdu_plot:
0B0C1E 32 38 0C 0B 0131*      ld (@mode),a
0B0C22 ED 43 39 0C 0132*      ld (@x0),bc
       0B          
0B0C27 ED 53 3B 0C 0133*      ld (@y0),de
       0B          
0B0C2C 21 37 0C 0B 0134*  	ld hl,@cmd
0B0C30 01 06 00 00 0135*  	ld bc,@end-@cmd
0B0C34 5B DF       0136*  	rst.lil $18
0B0C36 C9          0137*  	ret
0B0C37 19          0138*  @cmd:   db 25
0B0C38 00          0139*  @mode:  db 0
0B0C39 00 00       0140*  @x0: 	dw 0
0B0C3B 00 00       0141*  @y0: 	dw 0
0B0C3D 00          0142*  @end:   db 0 ; extra byte to soak up deu
0B0C3E             0143*  
0B0C3E             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0C3E             0145*  ; &E8-&EF 	232-239 	Bitmap plot 
0B0C3E             0146*  ; VDU 25, mode, x; y;: PLOT command
0B0C3E             0147*  ; inputs: bc=x0, de=y0
0B0C3E             0148*  ; prerequisites: vdu_buff_select
0B0C3E             0149*  vdu_plot_bmp:
0B0C3E ED 43 55 0C 0150*      ld (@x0),bc
       0B          
0B0C43 ED 53 57 0C 0151*      ld (@y0),de
       0B          
0B0C48 21 53 0C 0B 0152*  	ld hl,@cmd
0B0C4C 01 06 00 00 0153*  	ld bc,@end-@cmd
0B0C50 5B DF       0154*  	rst.lil $18
0B0C52 C9          0155*  	ret
0B0C53 19          0156*  @cmd:   db 25
0B0C54 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B0C55 00 00       0158*  @x0: 	dw 0x0000
0B0C57 00 00       0159*  @y0: 	dw 0x0000
0B0C59 00          0160*  @end:   db 0x00 ; padding
0B0C5A             0161*  
0B0C5A             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0C5A             0163*  ; &E8-&EF 	232-239 	Bitmap plot 
0B0C5A             0164*  ; VDU 25, mode, x; y;: PLOT command
0B0C5A             0165*  ; inputs: bc=x0, de=y0
0B0C5A             0166*  ; USING 16.8 FIXED POINT COORDINATES
0B0C5A             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
0B0C5A             0168*  ;   the fractional portiion of the inputs are truncated
0B0C5A             0169*  ;   leaving only the 16-bit integer portion
0B0C5A             0170*  ; prerequisites: vdu_buff_select
0B0C5A             0171*  vdu_plot_bmp168:
0B0C5A             0172*  ; populate in the reverse of normal to keep the
0B0C5A             0173*  ; inputs from stomping on each other
0B0C5A ED 53 78 0C 0174*      ld (@y0-1),de
       0B          
0B0C5F ED 43 76 0C 0175*      ld (@x0-1),bc
       0B          
0B0C64 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
0B0C66 32 76 0C 0B 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B0C6A 21 75 0C 0B 0178*  	ld hl,@cmd
0B0C6E 01 06 00 00 0179*  	ld bc,@end-@cmd
0B0C72 5B DF       0180*  	rst.lil $18
0B0C74 C9          0181*  	ret
0B0C75 19          0182*  @cmd:   db 25
0B0C76 ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B0C77 00 00       0184*  @x0: 	dw 0x0000
0B0C79 00 00       0185*  @y0: 	dw 0x0000
0B0C7B             0186*  @end:  ; no padding required b/c we shifted de right
0B0C7B             0187*  
0B0C7B             0188*  ; draw a filled rectangle
0B0C7B             0189*  vdu_plot_rf:
0B0C7B ED 43 A2 0C 0190*      ld (@x0),bc
       0B          
0B0C80 ED 53 A4 0C 0191*      ld (@y0),de
       0B          
0B0C85 DD 22 A8 0C 0192*      ld (@x1),ix
       0B          
0B0C8A FD 22 AA 0C 0193*      ld (@y1),iy
       0B          
0B0C8F 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
0B0C91 32 A6 0C 0B 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B0C95 21 A0 0C 0B 0196*  	ld hl,@cmd0
0B0C99 01 0C 00 00 0197*  	ld bc,@end-@cmd0
0B0C9D 5B DF       0198*  	rst.lil $18
0B0C9F C9          0199*      ret
0B0CA0 19          0200*  @cmd0:  db 25 ; plot
0B0CA1 04          0201*  @arg0:  db plot_sl_both+mv_abs
0B0CA2 00 00       0202*  @x0:    dw 0x0000
0B0CA4 00 00       0203*  @y0:    dw 0x0000
0B0CA6 19          0204*  @cmd1:  db 25 ; plot
0B0CA7 65          0205*  @arg1:  db plot_rf+dr_abs_fg
0B0CA8 00 00       0206*  @x1:    dw 0x0000
0B0CAA 00 00       0207*  @y1:    dw 0x0000
0B0CAC 00          0208*  @end:   db 0x00 ; padding
0B0CAD             0209*  
0B0CAD             0210*  ; draw a filled circle
0B0CAD             0211*  vdu_plot_cf:
0B0CAD ED 43 D4 0C 0212*      ld (@x0),bc
       0B          
0B0CB2 ED 53 D6 0C 0213*      ld (@y0),de
       0B          
0B0CB7 DD 22 DA 0C 0214*      ld (@x1),ix
       0B          
0B0CBC FD 22 DC 0C 0215*      ld (@y1),iy
       0B          
0B0CC1 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
0B0CC3 32 D8 0C 0B 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B0CC7 21 D2 0C 0B 0218*  	ld hl,@cmd0
0B0CCB 01 0C 00 00 0219*  	ld bc,@end-@cmd0
0B0CCF 5B DF       0220*  	rst.lil $18
0B0CD1 C9          0221*      ret
0B0CD2 19          0222*  @cmd0:  db 25 ; plot
0B0CD3 04          0223*  @arg0:  db plot_sl_both+mv_abs
0B0CD4 00 00       0224*  @x0:    dw 0x0000
0B0CD6 00 00       0225*  @y0:    dw 0x0000
0B0CD8 19          0226*  @cmd1:  db 25 ; plot
0B0CD9 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
0B0CDA 00 00       0228*  @x1:    dw 0x0000
0B0CDC 00 00       0229*  @y1:    dw 0x0000
0B0CDE 00          0230*  @end:   db 0x00 ; padding
0B0CDF             0231*  
0B0CDF             0232*  ; VDU 25, mode, x; y;: PLOT command
0B0CDF             0233*  ; inputs: a=mode, ix=x0, iy=y0
0B0CDF             0234*  plot:
0B0CDF 32 F9 0C 0B 0235*      ld (@mode),a
0B0CE3 DD 22 FA 0C 0236*      ld (@x0),ix
       0B          
0B0CE8 FD 22 FC 0C 0237*      ld (@y0),iy
       0B          
0B0CED 21 F8 0C 0B 0238*  	ld hl,@cmd
0B0CF1 01 06 00 00 0239*  	ld bc,@end-@cmd
0B0CF5 5B DF       0240*  	rst.lil $18
0B0CF7 C9          0241*  	ret
0B0CF8 19          0242*  @cmd:   db 25
0B0CF9 00          0243*  @mode:  db 0
0B0CFA 00 00       0244*  @x0: 	dw 0
0B0CFC 00 00       0245*  @y0: 	dw 0
0B0CFE 00          0246*  @end:   db 0 ; padding
0B0CFF             0247*  
0B0CFF             0248*  ; VDU 5: Write text at graphics cursor
0B0CFF             0249*  ; inputs: hl = pointer to text, ix=x0, iy=y0
0B0CFF             0250*  ; prerequisites: gcol foreground set, VDU 5 set
0B0CFF             0251*  plot_text:
0B0CFF E5          0252*      push hl ; save text pointer
0B0D00             0253*  ; move graphics cursor to x0, y0
0B0D00 3E 44       0254*      ld a,plot_pt+mv_abs
0B0D02 CD DF 0C 0B 0255*      call plot
0B0D06             0256*  ; write text
0B0D06 E1          0257*      pop hl ; restore text pointer
0B0D07 CD 67 02 0B 0258*      call printString
0B0D0B C9          0259*      ret
0B0D0C             0025   
0B0D0C             0026   ; SHAWN'S INCLUDES
0B0D0C             0027   	INCLUDE	"strings24.asm"
0B0D0C             0001*  ;------------------------------------------------------------------------
0B0D0C             0002*  ;  strings24.asm
0B0D0C             0003*  ;
0B0D0C             0004*  ; 24-bit native ez80 strings routines for numerical processing
0B0D0C             0005*  ;  Copyright (c) Shawn Sijnstra 2024
0B0D0C             0006*  ;  MIT license
0B0D0C             0007*  ;------------------------------------------------------------------------
0B0D0C             0008*  
0B0D0C             0009*  ;Print signed value in HLU in decimal with leading 0s removed
0B0D0C             0010*  ; and postpended with a minus sign if was negative
0B0D0C             0011*  ; Uses HLU, DEU, BCU
0B0D0C             0012*  print_HLU_s24:
0B0D0C CD 7C 18 0B 0013*  	call abs_hlu
0B0D10 F5          0014*  	push af ; save the sign and zero flags
0B0D11 CD 1C 0D 0B 0015*  	call print_HLU_u24
0B0D15 F1          0016*  	pop af
0B0D16 F0          0017*  	ret p ; HLU was positive so nothig more to do
0B0D17 3E 2D       0018*  	ld a,'-'
0B0D19 5B D7       0019*  	rst.lil 10h
0B0D1B C9          0020*  	ret
0B0D1C             0021*  
0B0D1C             0022*  ;------------------------------------------------------------------------
0B0D1C             0023*  ;Full print and buffer routine so you can adjust behaviour
0B0D1C             0024*  ; Double-Dabble AKA shift-and-add-3 algorithm
0B0D1C             0025*  ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
0B0D1C             0026*  ;Print value in HLU in decimal with leading 0s removed
0B0D1C             0027*  ; Uses HLU, DEU, BCU
0B0D1C             0028*  ;------------------------------------------------------------------------
0B0D1C             0029*  
0B0D1C             0030*  print_HLU_u24:
0B0D1C 22 F9 0D 0B 0031*  	ld	(hex_temp),hl
0B0D20 06 08       0032*  	ld	b,8	;8 digits max here with 24 bit unsigned
0B0D22 11 FC 0D 0B 0033*  	ld	de,outbuf
0B0D26 D5          0034*  	push	de
0B0D27 21 07 00 00 0035*  	ld	hl,7
0B0D2B 19          0036*  	add	hl,de
0B0D2C E5          0037*  	push	hl
0B0D2D D1          0038*  	pop	de	;copy HLU to DEU
0B0D2E AF          0039*  	xor	a
0B0D2F             0040*  _pde_u_zerobuf:
0B0D2F 77          0041*  	ld	(hl),a	;zero out the output
0B0D30 2B          0042*  	dec	hl
0B0D31 10 FC       0043*  	djnz	_pde_u_zerobuf
0B0D33             0044*  
0B0D33 0E 18       0045*  	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
0B0D35             0046*  _bcd_Convert:
0B0D35             0047*  
0B0D35 21 F9 0D 0B 0048*  	ld hl,hex_temp
0B0D39             0049*  ;
0B0D39 CB 26       0050*  	sla (hl)
0B0D3B 23          0051*  	inc hl
0B0D3C CB 16       0052*  	rl (hl)
0B0D3E 23          0053*  	inc hl
0B0D3F CB 16       0054*  	rl (hl)		;24 bits rolled right
0B0D41             0055*  
0B0D41             0056*  
0B0D41 06 08       0057*          ld	b,8	;8 digits max for 24 bit decimal output
0B0D43 D5          0058*  	push	de
0B0D44 E1          0059*  	pop	hl
0B0D45             0060*  
0B0D45             0061*  _bcd_Add3:
0B0D45 7E          0062*  	ld	a,(hl)
0B0D46 8F          0063*  	adc	a
0B0D47 27          0064*          daa		;this is add 3 after shifting left; i.e. add 6.
0B0D48 FE 10       0065*  	cp	10h	;did we roll over nibble?
0B0D4A 3F          0066*  	ccf
0B0D4B CB A7       0067*  	res	4,a
0B0D4D             0068*  
0B0D4D 77          0069*          ld (hl),a
0B0D4E 2B          0070*  	dec	hl
0B0D4F 10 F4       0071*          djnz	_bcd_Add3	;loop for decimal digits
0B0D51 0D          0072*          dec c
0B0D52 20 E1       0073*          jr nz, _bcd_Convert	;loop around
0B0D54             0074*  
0B0D54             0075*  
0B0D54 E1          0076*  	pop	hl
0B0D55 E5          0077*  	push	hl
0B0D56 06 07       0078*          ld	b,8-1		;one less than total in case output is '0'
0B0D58             0079*  _pde_u_make_ascii:
0B0D58 7E          0080*  	ld	a,(hl)
0B0D59 B7          0081*  	or	a
0B0D5A 20 05       0082*  	jr	nz,_pde_u_make_ascii2
0B0D5C 36 20       0083*  	ld	(hl),' '
0B0D5E 23          0084*  	inc	hl
0B0D5F 10 F7       0085*  	djnz	_pde_u_make_ascii
0B0D61             0086*  _pde_u_make_ascii2:
0B0D61 04          0087*  	inc	b
0B0D62             0088*  _pde_u_make_ascii3:
0B0D62 7E          0089*  	ld	a,(hl)
0B0D63 F6 30       0090*  	or	30h
0B0D65 77          0091*  	ld	(hl),a
0B0D66 23          0092*  	inc	hl
0B0D67 10 F9       0093*  	djnz	_pde_u_make_ascii3
0B0D69             0094*  
0B0D69 E1          0095*  	pop	hl
0B0D6A 06 08       0096*  	ld	b,8
0B0D6C             0097*  _pde_u_final_out:
0B0D6C 7E          0098*  	ld	a,(hl)
0B0D6D 23          0099*  	inc	hl
0B0D6E FE 20       0100*  	cp	' '
0B0D70 28 02       0101*  	jr	z,_pde_u_final_out_strip
0B0D72 5B D7       0102*  	rst.lil	10h
0B0D74             0103*  _pde_u_final_out_strip:
0B0D74 10 F6       0104*  	djnz	_pde_u_final_out
0B0D76 C9          0105*  	ret
0B0D77             0106*  
0B0D77             0107*  ;------------------------------------------------------------------------
0B0D77             0108*  ; is_digit
0B0D77             0109*  ; C flag set if A is a digit
0B0D77             0110*  ; preserves all registers
0B0D77             0111*  ;------------------------------------------------------------------------
0B0D77             0112*  is_digit:
0B0D77 FE 30       0113*  	cp	'0'
0B0D79 3F          0114*  	ccf
0B0D7A D0          0115*  	ret	nc	;less that '0'
0B0D7B FE 3A       0116*  	cp	'9' + 1
0B0D7D C9          0117*  	ret
0B0D7E             0118*  
0B0D7E             0119*  
0B0D7E             0120*  ;------------------------------------------------------------------------
0B0D7E             0121*  ; char2hex
0B0D7E             0122*  ; Input: ASCII nibble in A
0B0D7E             0123*  ; Returns: if valid nibble value in A; else 0FFh in A
0B0D7E             0124*  ;------------------------------------------------------------------------
0B0D7E             0125*  char2hex:
0B0D7E FE 30       0126*  	CP	'0'
0B0D80 38 1D       0127*  	JR	C, char_not_hex
0B0D82 FE 3A       0128*  	CP	'9' + 1
0B0D84 30 03       0129*  	JR	NC, char_not_09
0B0D86 D6 30       0130*  	sub	'0'
0B0D88 C9          0131*  	ret
0B0D89             0132*  
0B0D89             0133*  char_not_09:
0B0D89             0134*  	; char is not 0 to 9. Try upper case
0B0D89 FE 41       0135*  	CP	'A'
0B0D8B 38 12       0136*  	JR	C, char_not_hex
0B0D8D FE 47       0137*  	CP	'F' + 1
0B0D8F 30 03       0138*  	JR	NC, char_not_AF
0B0D91 D6 37       0139*  	sub	'A'-10
0B0D93 C9          0140*  	ret
0B0D94             0141*  
0B0D94             0142*  char_not_AF:
0B0D94             0143*  	; char is not upper case A-F. Try lower
0B0D94 FE 61       0144*  	CP	'a'
0B0D96 38 07       0145*  	JR	C, char_not_hex
0B0D98 FE 67       0146*  	CP	'f' + 1
0B0D9A 30 03       0147*  	JR	NC, char_not_hex
0B0D9C D6 57       0148*  	sub	'a' - 10
0B0D9E C9          0149*  	RET
0B0D9F             0150*  
0B0D9F             0151*  char_not_hex:
0B0D9F 3E FF       0152*   	ld	a,0FFh	;return -1 for not a valid hex digit
0B0DA1 C9          0153*  	RET
0B0DA2             0154*  
0B0DA2             0155*  ;------------------------------------------------------------------------
0B0DA2             0156*  ;  newline
0B0DA2             0157*  ;  Output CR+LF; all registers preserved
0B0DA2             0158*  ;------------------------------------------------------------------------
0B0DA2             0159*  newline:
0B0DA2 F5          0160*         push   AF
0B0DA3 3E 0D       0161*         LD     A, 13
0B0DA5 5B D7       0162*         RST.LIL    10h
0B0DA7 3E 0A       0163*         LD     A, 10
0B0DA9 5B D7       0164*         RST.LIL    10h
0B0DAB F1          0165*         POP    AF
0B0DAC C9          0166*         RET
0B0DAD             0167*  
0B0DAD             0168*  ;------------------------------------------------------------------------
0B0DAD             0169*  ;  put_nibble
0B0DAD             0170*  ;  Output a single hex nibble in A
0B0DAD             0171*  ;  All registers preserved
0B0DAD             0172*  ;------------------------------------------------------------------------
0B0DAD             0173*  put_nibble:
0B0DAD F5          0174*  	push   AF
0B0DAE C6 90       0175*  	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
0B0DB0 27          0176*  	daa
0B0DB1 CE 40       0177*  	adc    a,040h
0B0DB3 27          0178*  	daa
0B0DB4 5B D7       0179*  	RST.LIL    10h	;output character in A
0B0DB6 F1          0180*  	pop    AF
0B0DB7 C9          0181*  	ret
0B0DB8             0182*  
0B0DB8             0183*  ;------------------------------------------------------------------------
0B0DB8             0184*  ;  print_A
0B0DB8             0185*  ;  Output the 8-bit hex number A
0B0DB8             0186*  ;  All registers preserved
0B0DB8             0187*  ;------------------------------------------------------------------------
0B0DB8             0188*  print_A:
0B0DB8 F5          0189*  	push 	AF
0B0DB9 F5          0190*  	push 	AF	;save for second nibble
0B0DBA 0F          0191*  	rrca
0B0DBB 0F          0192*  	rrca
0B0DBC 0F          0193*  	rrca
0B0DBD 0F          0194*  	rrca
0B0DBE E6 0F       0195*  	and	0Fh	;first nibble
0B0DC0 CD AD 0D 0B 0196*  	call	put_nibble
0B0DC4 F1          0197*  	pop 	AF
0B0DC5 E6 0F       0198*  	and	0Fh	;second nibble
0B0DC7 CD AD 0D 0B 0199*  	call	put_nibble
0B0DCB F1          0200*  	pop 	AF
0B0DCC C9          0201*  	ret
0B0DCD             0202*  
0B0DCD             0203*  ;------------------------------------------------------------------------
0B0DCD             0204*  ;  print_HLU_hex
0B0DCD             0205*  ;  Output the 24-bit hex number HLU; other registers preserved
0B0DCD             0206*  ;------------------------------------------------------------------------
0B0DCD             0207*  print_HLU_hex:
0B0DCD F5          0208*         push   AF
0B0DCE 22 F9 0D 0B 0209*         ld     (hex_temp),hl
0B0DD2 3A FB 0D 0B 0210*         ld     a,(hex_temp+2)
0B0DD6 CD B8 0D 0B 0211*         call   print_A
0B0DDA 3A FA 0D 0B 0212*         ld     a,(hex_temp+1)
0B0DDE CD B8 0D 0B 0213*         call   print_A
0B0DE2 3A F9 0D 0B 0214*         ld     a,(hex_temp)
0B0DE6 CD B8 0D 0B 0215*         call   print_A
0B0DEA F1          0216*         POP    AF
0B0DEB C9          0217*         RET
0B0DEC             0218*  
0B0DEC             0219*  ;------------------------------------------------------------------------
0B0DEC             0220*  ;  puts
0B0DEC             0221*  ;  Output a zero-terminated string whose address is in HL; all
0B0DEC             0222*  ;  registers preserved.
0B0DEC             0223*  ;------------------------------------------------------------------------
0B0DEC             0224*  puts:
0B0DEC F5          0225*         push   AF
0B0DED C5          0226*         push   BC
0B0DEE 01 00 00 00 0227*         ld     BC, 0                ; Set to 0, so length ignored...
0B0DF2 3E 00       0228*         ld     A, 0                 ; Use character in A as delimiter
0B0DF4 5B DF       0229*         RST.LIL    18h                  ; This calls a RST in the eZ80 address space
0B0DF6 C1          0230*         pop    BC
0B0DF7 F1          0231*         pop    AF
0B0DF8 C9          0232*         ret
0B0DF9             0233*  
0B0DF9             0234*  ;------------------------------------------------------------------------
0B0DF9             0235*  ; Data area
0B0DF9             0236*  ; Storage for 24 bit conversion
0B0DF9             0237*  ;------------------------------------------------------------------------
0B0DF9             0238*  hex_temp:
0B0DF9 00 00 00    0239*         dw24     0      ;3 bytes for HL used for both hex and decimal temp
0B0DFC             0240*  
0B0DFC             0241*  outbuf:
0B0DFC 31 36 37 37 0242*  	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
0B0E05             0028   	INCLUDE	"arith24.asm"
0B0E05             0001*  
0B0E05             0002*  arith24uaf: ds 6
0B0E0B             0003*  arith24uhl: ds 6
0B0E11             0004*  arith24ubc: ds 6
0B0E17             0005*  arith24ude: ds 6
0B0E1D             0006*  arith24uix: ds 6
0B0E23             0007*  arith24uiy: ds 6
0B0E29             0008*  arith24usp: ds 6
0B0E2F             0009*  arith24upc: ds 6
0B0E35             0010*  
0B0E35             0011*  ; hlu 1 byte right shift
0B0E35             0012*  ; returns: hlu / 256, fractional portion in a
0B0E35             0013*  ; destroys: af
0B0E35             0014*  shift_hlu_r1b:
0B0E35 AF          0015*  	xor a
0B0E36 32 47 0E 0B 0016*  	ld (@buffer+3),a
0B0E3A 7D          0017*  	ld a,l ; save the fractional portion
0B0E3B 22 44 0E 0B 0018*  	ld (@buffer),hl
0B0E3F 2A 45 0E 0B 0019*  	ld hl,(@buffer+1)
0B0E43 C9          0020*  	ret
0B0E44             0021*  @buffer: ds 4
0B0E48             0022*  
0B0E48             0023*  ;------------------------------------------------------------------------
0B0E48             0024*  ;  arith24.asm
0B0E48             0025*  ;  24-bit ez80 arithmetic routines
0B0E48             0026*  ;  Copyright (c) Shawn Sijnstra 2024
0B0E48             0027*  ;  MIT license
0B0E48             0028*  ;
0B0E48             0029*  ;  This library was created as a tool to help make ez80
0B0E48             0030*  ;  24-bit native assembly routines for simple mathematical problems
0B0E48             0031*  ;  more widely available.
0B0E48             0032*  ;
0B0E48             0033*  ;------------------------------------------------------------------------
0B0E48             0034*  
0B0E48             0035*  ;------------------------------------------------------------------------
0B0E48             0036*  ; umul24:	HL = HL*DE (unsigned)
0B0E48             0037*  ; Preserves AF, BC, DE
0B0E48             0038*  ; Uses a fast multiply routine.
0B0E48             0039*  ;------------------------------------------------------------------------
0B0E48             0040*  umul24:
0B0E48 D5          0041*  	push	DE
0B0E49 C5          0042*  	push	BC
0B0E4A F5          0043*  	push	AF
0B0E4B E5          0044*  	push	HL
0B0E4C C1          0045*  	pop		BC
0B0E4D 3E 18       0046*      ld	 	a, 24 ; No. of bits to process
0B0E4F 21 00 00 00 0047*      ld	 	hl, 0 ; Result
0B0E53             0048*  umul24_lp:
0B0E53 29          0049*  	add	hl,hl
0B0E54 EB          0050*  	ex	de,hl
0B0E55 29          0051*  	add	hl,hl
0B0E56 EB          0052*  	ex	de,hl
0B0E57 30 01       0053*  	jr	nc,umul24_nc
0B0E59 09          0054*  	add	hl,bc
0B0E5A             0055*  umul24_nc:
0B0E5A 3D          0056*  	dec	a
0B0E5B 20 F6       0057*  	jr	nz,umul24_lp
0B0E5D F1          0058*  	pop	af
0B0E5E C1          0059*  	pop	bc
0B0E5F D1          0060*  	pop	de
0B0E60 C9          0061*  	ret
0B0E61             0062*  
0B0E61             0063*  
0B0E61             0064*  ;------------------------------------------------------------------------
0B0E61             0065*  ; udiv24
0B0E61             0066*  ; Unsigned 24-bit division
0B0E61             0067*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0B0E61             0068*  ;
0B0E61             0069*  ; Uses AF BC DE HL
0B0E61             0070*  ; Uses Restoring Division algorithm
0B0E61             0071*  ;------------------------------------------------------------------------
0B0E61             0072*  
0B0E61             0073*  udiv24:
0B0E61 E5          0074*  	push	hl
0B0E62 C1          0075*  	pop		bc	;move dividend to BCU
0B0E63 21 00 00 00 0076*  	ld		hl,0	;result
0B0E67 A7          0077*  	and		a
0B0E68 ED 52       0078*  	sbc		hl,de	;test for div by 0
0B0E6A C8          0079*  	ret		z		;it's zero, carry flag is clear
0B0E6B 19          0080*  	add		hl,de	;HL is 0 again
0B0E6C 3E 18       0081*  	ld		a,24	;number of loops through.
0B0E6E             0082*  udiv1:
0B0E6E C5          0083*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B0E6F E3          0084*  	ex		(sp),hl
0B0E70 37          0085*  	scf
0B0E71 ED 6A       0086*  	adc	hl,hl
0B0E73 E3          0087*  	ex	(sp),hl
0B0E74 C1          0088*  	pop	bc		;we now have bc = (bc * 2) + 1
0B0E75             0089*  
0B0E75 ED 6A       0090*  	adc	hl,hl
0B0E77 A7          0091*  	and	a		;is this the bug
0B0E78 ED 52       0092*  	sbc	hl,de
0B0E7A 30 02       0093*  	jr	nc,udiv2
0B0E7C 19          0094*  	add	hl,de
0B0E7D             0095*  ;	dec	c
0B0E7D 0B          0096*  	dec	bc
0B0E7E             0097*  udiv2:
0B0E7E 3D          0098*  	dec	a
0B0E7F 20 ED       0099*  	jr	nz,udiv1
0B0E81 37          0100*  	scf		;flag used for div0 error
0B0E82 C5          0101*  	push	bc
0B0E83 D1          0102*  	pop		de	;remainder
0B0E84 C9          0103*  	ret
0B0E85             0104*  
0B0E85             0105*  
0B0E85             0106*  
0B0E85             0107*  ;------------------------------------------------------------------------
0B0E85             0108*  ; neg24
0B0E85             0109*  ; Returns: HLU = 0-HLU
0B0E85             0110*  ; preserves all other registers
0B0E85             0111*  ;------------------------------------------------------------------------
0B0E85             0112*  neg24:
0B0E85 D5          0113*  	push	de
0B0E86 EB          0114*  	ex		de,hl
0B0E87 21 00 00 00 0115*  	ld		hl,0
0B0E8B B7          0116*  	or		a
0B0E8C ED 52       0117*  	sbc		hl,de
0B0E8E D1          0118*  	pop		de
0B0E8F C9          0119*  	ret
0B0E90             0120*  
0B0E90             0121*  ;------------------------------------------------------------------------
0B0E90             0122*  ; or_hlu_deu: 24 bit bitwise OR
0B0E90             0123*  ; Returns: hlu = hlu OR deu
0B0E90             0124*  ; preserves all other registers
0B0E90             0125*  ;------------------------------------------------------------------------
0B0E90             0126*  or_hlu_deu:
0B0E90 22 1B 0F 0B 0127*  	ld	(bitbuf1),hl
0B0E94 ED 53 1E 0F 0128*  	ld	(bitbuf2),de
       0B          
0B0E99 D5          0129*  	push	de	;preserve DEU
0B0E9A C5          0130*  	push	bc	;preserve BCU
0B0E9B 06 03       0131*  	ld		b,3
0B0E9D 21 1B 0F 0B 0132*  	ld	hl,bitbuf1
0B0EA1 11 1B 0F 0B 0133*  	ld	de,bitbuf1
0B0EA5             0134*  orloop_24:
0B0EA5 1A          0135*  	ld	a,(de)
0B0EA6 B6          0136*  	or	(hl)
0B0EA7 12          0137*  	ld	(de),a
0B0EA8 13          0138*  	inc	de
0B0EA9 23          0139*  	inc	hl
0B0EAA 10 F9       0140*  	djnz	orloop_24
0B0EAC 2A 1E 0F 0B 0141*  	ld	hl,(bitbuf2)
0B0EB0 C1          0142*  	pop		bc	;restore BC
0B0EB1 D1          0143*  	pop		de	;restore DE
0B0EB2             0144*  
0B0EB2             0145*  ;------------------------------------------------------------------------
0B0EB2             0146*  ; and_hlu_deu: 24 bit bitwise AND
0B0EB2             0147*  ; Returns: hlu = hlu AND deu
0B0EB2             0148*  ; preserves all other registers
0B0EB2             0149*  ;------------------------------------------------------------------------
0B0EB2             0150*  and_hlu_deu:
0B0EB2 22 1B 0F 0B 0151*  	ld	(bitbuf1),hl
0B0EB6 ED 53 1E 0F 0152*  	ld	(bitbuf2),de
       0B          
0B0EBB D5          0153*  	push	de	;preserve DEU
0B0EBC C5          0154*  	push	bc	;preserve BCU
0B0EBD 06 03       0155*  	ld		b,3
0B0EBF 21 1B 0F 0B 0156*  	ld	hl,bitbuf1
0B0EC3 11 1B 0F 0B 0157*  	ld	de,bitbuf1
0B0EC7             0158*  andloop_24:
0B0EC7 1A          0159*  	ld	a,(de)
0B0EC8 A6          0160*  	and	(hl)
0B0EC9 12          0161*  	ld	(de),a
0B0ECA 13          0162*  	inc	de
0B0ECB 23          0163*  	inc	hl
0B0ECC 10 F9       0164*  	djnz	andloop_24
0B0ECE 2A 1E 0F 0B 0165*  	ld	hl,(bitbuf2)
0B0ED2 C1          0166*  	pop		bc	;restore BC
0B0ED3 D1          0167*  	pop		de	;restore DE
0B0ED4             0168*  
0B0ED4             0169*  ;------------------------------------------------------------------------
0B0ED4             0170*  ; xor_hlu_deu: 24 bit bitwise XOR
0B0ED4             0171*  ; Returns: hlu = hlu XOR deu
0B0ED4             0172*  ; preserves all other registers
0B0ED4             0173*  ;------------------------------------------------------------------------
0B0ED4             0174*  xor_hlu_deu:
0B0ED4 22 1B 0F 0B 0175*  	ld	(bitbuf1),hl
0B0ED8 ED 53 1E 0F 0176*  	ld	(bitbuf2),de
       0B          
0B0EDD D5          0177*  	push	de	;preserve DEU
0B0EDE C5          0178*  	push	bc	;preserve BCU
0B0EDF 06 03       0179*  	ld		b,3
0B0EE1 21 1B 0F 0B 0180*  	ld	hl,bitbuf1
0B0EE5 11 1B 0F 0B 0181*  	ld	de,bitbuf1
0B0EE9             0182*  xorloop_24:
0B0EE9 1A          0183*  	ld	a,(de)
0B0EEA AE          0184*  	xor	(hl)
0B0EEB 12          0185*  	ld	(de),a
0B0EEC 13          0186*  	inc	de
0B0EED 23          0187*  	inc	hl
0B0EEE 10 F9       0188*  	djnz	xorloop_24
0B0EF0 2A 1E 0F 0B 0189*  	ld	hl,(bitbuf2)
0B0EF4 C1          0190*  	pop		bc	;restore BC
0B0EF5 D1          0191*  	pop		de	;restore DE
0B0EF6             0192*  
0B0EF6             0193*  ;------------------------------------------------------------------------
0B0EF6             0194*  ; shl_hlu: 24 bit shift left hlu by deu positions
0B0EF6             0195*  ; Returns: hlu = hlu << deu
0B0EF6             0196*  ;		   de = 0
0B0EF6             0197*  ; NOTE: only considers deu up to 16 bits.
0B0EF6             0198*  ; preserves all other registers
0B0EF6             0199*  ;------------------------------------------------------------------------
0B0EF6             0200*  shl_hlu:
0B0EF6 7A          0201*  	ld		a,d		;up to 16 bit.
0B0EF7 B3          0202*  	or		e
0B0EF8 C8          0203*  	ret		z		;we're done
0B0EF9 29          0204*  	add		hl,hl	;shift HLU left
0B0EFA 1B          0205*  	dec		de
0B0EFB 18 F9       0206*  	jr		shl_hlu
0B0EFD             0207*  
0B0EFD             0208*  ;------------------------------------------------------------------------
0B0EFD             0209*  ; shr_hlu: 24 bit shift right hlu by deu positions
0B0EFD             0210*  ; Returns: hlu = hlu >> deu
0B0EFD             0211*  ;		   de = 0
0B0EFD             0212*  ; NOTE: only considers deu up to 16 bits.
0B0EFD             0213*  ; preserves all other registers
0B0EFD             0214*  ;------------------------------------------------------------------------
0B0EFD             0215*  shr_hlu:
0B0EFD 22 1B 0F 0B 0216*  	ld		(bitbuf1),hl
0B0F01 21 1D 0F 0B 0217*  	ld		hl,bitbuf1+2
0B0F05             0218*  shr_loop:
0B0F05 7A          0219*  	ld		a,d		;up to 16 bit.
0B0F06 B3          0220*  	or		e
0B0F07 28 0D       0221*  	jr		z,shr_done		;we're done
0B0F09             0222*  ;carry is clear from or instruction
0B0F09 CB 1E       0223*  	rr		(hl)
0B0F0B 2B          0224*  	dec		hl
0B0F0C CB 1E       0225*  	rr		(hl)
0B0F0E 2B          0226*  	dec		hl
0B0F0F CB 1E       0227*  	rr		(hl)
0B0F11 23          0228*  	inc		hl
0B0F12 23          0229*  	inc		hl
0B0F13 1B          0230*  	dec		de
0B0F14 18 EF       0231*  	jr		shr_loop
0B0F16             0232*  shr_done:
0B0F16 2A 1B 0F 0B 0233*  	ld		hl,(bitbuf1)	;collect result
0B0F1A C9          0234*  	ret
0B0F1B             0235*  
0B0F1B             0236*  ;------------------------------------------------------------------------
0B0F1B             0237*  ; Scratch area for calculations
0B0F1B             0238*  ;------------------------------------------------------------------------
0B0F1B 00 00 00    0239*  bitbuf1:	dw24	0	;bit manipulation buffer 1
0B0F1E 00 00 00    0240*  bitbuf2:	dw24	0	;bit manipulation buffer 2
0B0F21             0241*  
0B0F21             0242*  ; ========== FROM maths24.inc ==========
0B0F21             0243*  
0B0F21             0244*  ; http://www.z80.info/pseudo-random.txt
0B0F21             0245*  rand_8:
0B0F21 C5          0246*      push bc
0B0F22 3A 35 0F 0B 0247*      ld a,(r_seed)
0B0F26 4F          0248*      ld c,a
0B0F27             0249*  
0B0F27 0F          0250*      rrca ; multiply by 32
0B0F28 0F          0251*      rrca
0B0F29 0F          0252*      rrca
0B0F2A EE 1F       0253*      xor 0x1f
0B0F2C             0254*  
0B0F2C 81          0255*      add a,c
0B0F2D DE FF       0256*      sbc a,255 ; carry
0B0F2F             0257*  
0B0F2F 32 35 0F 0B 0258*      ld (r_seed),a
0B0F33 C1          0259*      pop bc
0B0F34 C9          0260*      ret
0B0F35 50          0261*  r_seed: defb $50
0B0F36             0262*  
0B0F36             0263*  ; tests the sign of 24-bit register hlu
0B0F36             0264*  ; returns: a in [-1,0,1]
0B0F36             0265*  ;   sign and zero flags as expected
0B0F36             0266*  ;   hl is untouched
0B0F36             0267*  ; GPT-4 wrote most of this. the or l was inspired. it did bit 7,a instead of h
0B0F36             0268*  ; and it left the zero flag set after ld a,1,which i fixed by anding it
0B0F36             0269*  get_sign_hlu:
0B0F36             0270*      ; Load the upper byte of HLU into A
0B0F36 E5          0271*      push hl
0B0F37 DD 21 00 00 0272*      ld ix,0
       00          
0B0F3C DD 39       0273*      add ix,sp
0B0F3E DD 7E 02    0274*      ld a,(ix+2)
0B0F41 E1          0275*      pop hl
0B0F42             0276*  
0B0F42 B5          0277*      or l                ; OR with the low byte to check if HL is zero
0B0F43 C8          0278*      ret z               ; Return if HL is zero
0B0F44             0279*  
0B0F44 3E FF       0280*      ld a,-1             ; Send A back as -1 if the sign flag is set
0B0F46 CB 7C       0281*      bit 7,h            ; Test the sign bit (7th bit) of the high byte
0B0F48 C0          0282*      ret nz              ; If set,HL is negative,return with the sign flag set
0B0F49             0283*  
0B0F49 3E 01       0284*      ld a,1             ; Otherwise,HL is positive
0B0F4B A7          0285*      and a               ; Reset the zero flag
0B0F4C C9          0286*      ret                 ; Return with A set to 1
0B0F4D             0287*  
0B0F4D             0288*  ; convert unsigned angles from a 360 to 255 degree circle
0B0F4D             0289*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0B0F4D             0290*  ; outputs: uh.l is the angle255 in 16.8 fixed format
0B0F4D             0291*  ; destroys: TODO
0B0F4D             0292*  ; note: even though the inputs and outputs are 16.8 fixed format
0B0F4D             0293*  ;       precision is effectively limited to 8.8 fixed format
0B0F4D             0294*  deg_360_to_255:
0B0F4D             0295*  ; clear scratch buffer
0B0F4D 11 00 00 00 0296*  	ld de,0
0B0F51 ED 53 7D 0F 0297*  	ld (@scratch),de
       0B          
0B0F56             0298*  ; divide uh.l by 360
0B0F56 11 68 01 00 0299*  	ld de,360
0B0F5A             0300*  ; get integer portion
0B0F5A CD 61 0E 0B 0301*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
0B0F5E ED 53 84 0F 0302*  	ld (@output+1),de ; shift result up one byte
       0B          
0B0F63             0303*  ; get fractional portion
0B0F63 22 7E 0F 0B 0304*  	ld (@scratch+1),hl ; shift remainder up one byte
0B0F67 2A 7D 0F 0B 0305*  	ld hl,(@scratch)
0B0F6B 11 68 01 00 0306*  	ld de,360
0B0F6F CD 61 0E 0B 0307*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
0B0F73 7B          0308*  	ld a,e ; lowest byte is all we need
0B0F74 32 83 0F 0B 0309*  	ld (@output),a
0B0F78             0310*  ; we want the low 3 bytes for 16.8 output
0B0F78 2A 83 0F 0B 0311*  	ld hl,(@output)
0B0F7C C9          0312*  	ret
0B0F7D             0313*  @scratch: ds 6 ; scratch buffer for shifting bytes
0B0F83             0314*  @output: ds 6 ; scratch buffer to accumulate output
0B0F89             0315*  
0B0F89             0316*  ; 16.8 fixed inputs / outputs
0B0F89             0317*  ; takes: uh.l as angle in degrees 256
0B0F89             0318*  ;        ud.e as radius
0B0F89             0319*  ; returns ub.c as dx, ud.e as dy
0B0F89             0320*  ;        displacements from origin (0,0)
0B0F89             0321*  ; destroys: everything except indexes
0B0F89             0322*  polar_to_cartesian:
0B0F89             0323*  ; back up input parameters
0B0F89 22 0B 0E 0B 0324*      ld (arith24uhl), hl
0B0F8D ED 53 17 0E 0325*      ld (arith24ude), de
       0B          
0B0F92             0326*  ; compute dx = sin(uh.l) * ud.e
0B0F92 CD C1 0F 0B 0327*      call sin168
0B0F96 E5          0328*      push hl
0B0F97 C1          0329*      pop bc          ; ub.c = sin(uh.l)
0B0F98 ED 5B 17 0E 0330*  	ld de, (arith24ude)   ; get radius back
       0B          
0B0F9D CD 1A 19 0B 0331*  	call smul168    ; uh.l = ub.c * ud.e = dx
0B0FA1 E5          0332*      push hl         ; store dx for output
0B0FA2             0333*  ; compute dy = -cos(uh.l) * ud.e
0B0FA2 2A 0B 0E 0B 0334*      ld hl, (arith24uhl)
0B0FA6 CD BC 0F 0B 0335*      call cos168
0B0FAA CD 8C 18 0B 0336*  	call neg_hlu    ; invert dy for screen coords convention
0B0FAE E5          0337*      push hl
0B0FAF C1          0338*      pop bc          ; ub.c = -cos(uh.l)
0B0FB0 ED 5B 17 0E 0339*      ld de, (arith24ude)   ; get radius back
       0B          
0B0FB5 CD 1A 19 0B 0340*      call smul168    ; uh.l = ub.c * ud.e = dy
0B0FB9 EB          0341*      ex de, hl       ; de = dy for output
0B0FBA C1          0342*      pop bc          ; bc = dx for output
0B0FBB             0343*  ; and out
0B0FBB C9          0344*      ret
0B0FBC             0345*  
0B0FBC             0346*  ; fixed 16.8 routine
0B0FBC             0347*  ; cos(uh.l) --> uh.l
0B0FBC             0348*  ; destroys: de
0B0FBC             0349*  cos168:
0B0FBC             0350*  ; for cos we simply increment the angle by 90 degrees
0B0FBC             0351*  ; or 0x004000 in 16.8 degrees256
0B0FBC             0352*  ; which makes it a sin problem
0B0FBC 11 00 40 00 0353*      ld de,0x004000
0B0FC0 19          0354*      add hl,de ; modulo 256 happens below
0B0FC1             0355*  ; fall through to sin168
0B0FC1             0356*  ; ---------------------
0B0FC1             0357*  ; fixed 16.8 routine
0B0FC1             0358*  ; sin(uh.l) --> uh.l
0B0FC1             0359*  ; destroys: de
0B0FC1             0360*  sin168:
0B0FC1             0361*  ; h contains the integer portion of our angle
0B0FC1             0362*  ; we multiply it by three to get our lookup table index
0B0FC1 2E 03       0363*      ld l,3
0B0FC3 ED 6C       0364*      mlt hl ; gosh that is handy
0B0FC5 11 00 00 00 0365*      ld de,0 ; clear deu
0B0FC9 54          0366*      ld d,h ; copy hl to de
0B0FCA 5D          0367*      ld e,l ; de contains our index
0B0FCB 21 D2 11 0B 0368*      ld hl,sin_lut_168 ; grab the lut address
0B0FCF 19          0369*      add hl,de ; bump hl by the index
0B0FD0 ED 27       0370*      ld hl,(hl) ; don't try this on a z80!
0B0FD2 C9          0371*      ret ; and out
0B0FD3             0372*  
0B0FD3             0373*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0FD3             0374*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0FD3             0375*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0FD3             0376*  ;         also populates scratch locations dx168 and dy168
0B0FD3             0377*  ; destroys: a,hl,bc,de
0B0FD3             0378*  dxy168:
0B0FD3             0379*  ; compute dx = x1-x0
0B0FD3 AF          0380*      xor a ; clear carry
0B0FD4 DD E5       0381*      push ix ; move ix to hl via the stack
0B0FD6 E1          0382*      pop hl ; hl = x1
0B0FD7 ED 42       0383*      sbc hl,bc ; hl = dx
0B0FD9 22 2E 10 0B 0384*      ld (dx168),hl ; dx to scratch
0B0FDD             0385*  ; compute dy = y1-y0
0B0FDD AF          0386*      xor a ; clear carry
0B0FDE FD E5       0387*      push iy ; move iy to hl via the stack
0B0FE0 E1          0388*      pop hl ; hl = y1
0B0FE1 ED 52       0389*      sbc hl,de ; hl = dy
0B0FE3 22 34 10 0B 0390*      ld (dy168),hl ; dy to scratch
0B0FE7             0391*  ; populate output registers and return
0B0FE7 EB          0392*      ex de,hl        ; ud.e = dy
0B0FE8 ED 4B 2E 10 0393*      ld bc,(dx168)   ; ub.c = dx
       0B          
0B0FED C9          0394*      ret
0B0FEE             0395*  
0B0FEE             0396*  ; compute the euclidian distance between two cartesian coordinates
0B0FEE             0397*  ; using the formula d = sqrt(dx^2+dy^2
0B0FEE             0398*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0FEE             0399*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0FEE             0400*  ; output; uh.l is the 16.8 fixed format distance
0B0FEE             0401*  ;       dx168/y are the 16.8 fixed format dx and dy
0B0FEE             0402*  ; destroys: a,hl,bc,de
0B0FEE             0403*  distance168:
0B0FEE             0404*  ; compute dx = x1-x0
0B0FEE AF          0405*      xor a ; clear carry
0B0FEF DD E5       0406*      push ix ; move ix to hl via the stack
0B0FF1 E1          0407*      pop hl ; hl = x1
0B0FF2 ED 42       0408*      sbc hl,bc ; hl = dx
0B0FF4 22 2E 10 0B 0409*      ld (dx168),hl ; dx to scratch
0B0FF8             0410*  ; ; test dx for overflow
0B0FF8             0411*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0FF8             0412*  ; 	ex de,hl
0B0FF8             0413*  ; 	sbc hl,de ; test for overflow
0B0FF8             0414*  ; 	push af ; carry indicates overflow
0B0FF8             0415*  ; compute dy = y1-y0
0B0FF8 AF          0416*      xor a ; clear carry
0B0FF9 FD E5       0417*      push iy ; move iy to hl via the stack
0B0FFB E1          0418*      pop hl ; hl = y1
0B0FFC ED 52       0419*      sbc hl,de ; hl = dy
0B0FFE 22 34 10 0B 0420*      ld (dy168),hl ; dy to scratch
0B1002             0421*  ; ; test dy for overflow
0B1002             0422*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B1002             0423*  ; 	ex de,hl
0B1002             0424*  ; 	sbc hl,de ; test for overflow
0B1002             0425*  ; 	push af ; carry indicates overflow
0B1002             0426*  ; compute dy^2
0B1002 2A 34 10 0B 0427*  	ld hl,(dy168)
0B1006 CD 7C 18 0B 0428*      call abs_hlu  ; make dy positive so we can use unsigned multiply
0B100A             0429*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B100A E5          0430*      push hl ; load hl/2 to bc via the stack
0B100B C1          0431*      pop bc ; bc = dy/2
0B100C EB          0432*      ex de,hl ; de = dy/2
0B100D CD FE 18 0B 0433*      call umul168 ; uh.l = dy^2/2
0B1011 E5          0434*      push hl ; dy^2/2 to the stack
0B1012             0435*  ; compute dx^2
0B1012 2A 2E 10 0B 0436*      ld hl,(dx168) ; get back dx
0B1016 CD 7C 18 0B 0437*      call abs_hlu  ; make dx positive so we can use unsigned multiply
0B101A             0438*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B101A E5          0439*      push hl ; load hl/2 to bc via the stack
0B101B C1          0440*      pop bc ; bc = dx/2
0B101C EB          0441*      ex de,hl ; de = dx/2
0B101D CD FE 18 0B 0442*      call umul168 ; uh.l = dx^2/2
0B1021             0443*  ; commpute dy^2+dx^2
0B1021 D1          0444*      pop de ; get back dx^2/2
0B1022 19          0445*      add hl,de ; hl = dx^2/2+dy^2/2
0B1023             0446*  ; compute sqrt(dx^2/2+dy^2/2)
0B1023 CD E7 10 0B 0447*      call sqrt168 ; uh.l = distance/2
0B1027             0448*      ; add hl,hl ; hl = distance
0B1027             0449*  ; ; check for overflow
0B1027             0450*  ; 	pop af ; get back the overflow flags
0B1027             0451*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B1027             0452*  ; 	ld b,a ; save the overflow flag
0B1027             0453*  ; 	pop af ; get back the overflow flags
0B1027             0454*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B1027             0455*  ; 	add a,b ; if a != 0 then we had overflow
0B1027             0456*  ;     ret z ; no overflow we're done
0B1027             0457*  ; @overflow:
0B1027             0458*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
0B1027 C9          0459*  	ret
0B1028             0460*  @scratch: ds 6
0B102E             0461*  dx168: ds 6
0B1034             0462*  dy168: ds 6
0B103A             0463*  
0B103A             0464*  ; atan2(ub.c,ud.e) --> uh.l
0B103A             0465*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B103A             0466*  ;   whether inputs are integers or fractional doesn't matter
0B103A             0467*  ;   so long as the sign bit of the upper byte is correct
0B103A             0468*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0B103A             0469*  ; angles are COMPASS HEADINGS based on
0B103A             0470*  ; screen coordinate conventions,where the y axis is flipped
0B103A             0471*  ; #E0 315      0       45 #20
0B103A             0472*  ;        -x,-y | +x,-y
0B103A             0473*  ; #C0 270------+------ 90 #40
0B103A             0474*  ;        -x,+y | +x,+y
0B103A             0475*  ; #A0 225   180 #80   135 #60
0B103A             0476*  atan2_168game:
0B103A             0477*  ; get signs and make everything positive
0B103A             0478*  ; get abs(x) and store its original sign
0B103A C5          0479*      push bc
0B103B E1          0480*      pop hl
0B103C CD 7C 18 0B 0481*      call abs_hlu ; if x was negative this also sets the sign flag
0B1040 E5          0482*      push hl ; store abs(x)
0B1041 C1          0483*      pop bc ; bc = abs(x)
0B1042 F5          0484*      push af ; store sign of x
0B1043             0485*  ; get abs(y) and store its original sign
0B1043 EB          0486*      ex de,hl ; hl = y
0B1044 CD 7C 18 0B 0487*      call abs_hlu ; if y was negative this also sets the sign flag
0B1048 EB          0488*      ex de,hl ; de = abs(y)
0B1049 F5          0489*      push af ; store sign of y
0B104A             0490*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B104A             0491*  ; this ensures that our lookup value is between 0 and 1 inclusive
0B104A AF          0492*      xor a ; clear the carry flag
0B104B D5          0493*      push de
0B104C E1          0494*      pop hl
0B104D ED 42       0495*      sbc hl,bc
0B104F F5          0496*      push af ; save sign of de - bc
0B1050 F2 59 10 0B 0497*      jp p,@1 ; bc <= de, so we skip ahead
0B1054             0498*  ; otherwise we swap bc and de
0B1054 C5          0499*      push bc
0B1055 E1          0500*      pop hl
0B1056 EB          0501*      ex de,hl
0B1057 E5          0502*      push hl
0B1058 C1          0503*      pop bc
0B1059             0504*  @1:
0B1059             0505*  ; now we're ready to snag our preliminary result
0B1059 CD C7 10 0B 0506*      call atan_168game ; uh.l comes back with prelim result
0B105D             0507*  ; now we adjust uh.l based on sign of de - bc
0B105D F1          0508*      pop af
0B105E F2 6A 10 0B 0509*      jp p,@2 ; bc <= de,so we skip ahead
0B1062 EB          0510*      ex de,hl
0B1063 21 00 40 00 0511*      ld hl,0x004000 ; 90 degrees
0B1067 AF          0512*      xor a ; clear the carry flag
0B1068 ED 52       0513*      sbc hl,de ; subtract result from 90 degrees
0B106A             0514*      ; ld de,0 ; prep to clear hlu
0B106A             0515*      ; ld d,h
0B106A             0516*      ; ld e,l
0B106A             0517*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
0B106A             0518*      ; fall through
0B106A             0519*  @2:
0B106A             0520*  ; now the fun part of adjusting the result
0B106A             0521*  ; based on which quadrant (x,y) is in
0B106A             0522*  ; #E0 315      0       45 #20
0B106A             0523*  ;        -x,-y | +x,-y
0B106A             0524*  ; #C0 270------+------ 90 #40
0B106A             0525*  ;        -x,+y | +x,+y
0B106A             0526*  ; #A0 225   180 #80   135 #60
0B106A F1          0527*      pop af ; sign of y
0B106B CA A8 10 0B 0528*      jp z,@y_zero
0B106F F2 88 10 0B 0529*      jp p,@y_pos
0B1073             0530*  ; y neg,check x
0B1073 F1          0531*      pop af ; sign of x
0B1074 CA 82 10 0B 0532*      jp z,@y_neg_x_zero
0B1078 F2 87 10 0B 0533*      jp p,@y_neg_x_pos
0B107C             0534*  ; y neg,x neg
0B107C             0535*  ; angle is 270-360
0B107C             0536*  ; negating the intermediate does the trick
0B107C CD 8C 18 0B 0537*      call neg_hlu
0B1080 18 31       0538*      jr @zero_hlu
0B1082             0539*  
0B1082             0540*  @y_neg_x_zero:
0B1082             0541*  ; y neg,x zero
0B1082             0542*  ; angle is 0
0B1082 21 00 00 00 0543*      ld hl,0
0B1086 C9          0544*      ret
0B1087             0545*  @y_neg_x_pos:
0B1087             0546*  ; y neg,x pos
0B1087             0547*  ; angle is 0 to 90
0B1087             0548*  ; so we're good
0B1087 C9          0549*      ret
0B1088             0550*  
0B1088             0551*  @y_pos:
0B1088 F1          0552*      pop af ; sign of x
0B1089 CA 98 10 0B 0553*      jp z,@y_pos_x_zero
0B108D F2 9D 10 0B 0554*      jp p,@y_pos_x_pos
0B1091             0555*  ; y pos,x neg
0B1091             0556*  ; angle is 180-270
0B1091             0557*  ; so we add 180 to intermediate
0B1091 11 00 80 00 0558*      ld de,0x008000
0B1095 19          0559*      add hl,de
0B1096 18 1B       0560*      jr @zero_hlu
0B1098             0561*  @y_pos_x_zero:
0B1098             0562*  ; y pos,x zero
0B1098             0563*  ; angle is 180
0B1098 21 00 80 00 0564*      ld hl,0x008000
0B109C C9          0565*      ret
0B109D             0566*  @y_pos_x_pos:
0B109D             0567*  ; y pos,x pos
0B109D             0568*  ; angle is 90-180
0B109D             0569*  ; neg the intermediate and add 180 degrees
0B109D CD 8C 18 0B 0570*      call neg_hlu
0B10A1 11 00 80 00 0571*      ld de,0x008000
0B10A5 19          0572*      add hl,de
0B10A6 18 0B       0573*      jr @zero_hlu
0B10A8             0574*  
0B10A8             0575*  @y_zero:
0B10A8 F1          0576*      pop af ; sign of x
0B10A9 FA AE 10 0B 0577*      jp m,@y_zero_x_neg
0B10AD             0578*  ; y zero,x pos
0B10AD             0579*  ; angle is 90,nothing to do
0B10AD C9          0580*      ret
0B10AE             0581*  @y_zero_x_neg:
0B10AE             0582*  ; y zero ,x neg
0B10AE             0583*  ; angle is 270
0B10AE 21 00 C0 00 0584*      ld hl,0x00C000
0B10B2 C9          0585*      ret
0B10B3             0586*  @zero_hlu:
0B10B3 AF          0587*      xor a
0B10B4 22 C1 10 0B 0588*      ld (@scratch),hl
0B10B8 32 C3 10 0B 0589*      ld (@scratch+2),a
0B10BC 2A C1 10 0B 0590*      ld hl,(@scratch)
0B10C0 C9          0591*      ret
0B10C1             0592*  @scratch: ds 6
0B10C7             0593*  
0B10C7             0594*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B10C7             0595*  ; output: uh.l is the 16.8 fixed format angle
0B10C7             0596*  ; destroys: a,hl,bc,de
0B10C7             0597*  ; the following note was written by github copilot:
0B10C7             0598*  ; note: this routine is a bit of a hack
0B10C7             0599*  ;      but it works
0B10C7             0600*  ;      and it's fast
0B10C7             0601*  ;      and it's small
0B10C7             0602*  ;      and it's accurate
0B10C7             0603*  ;      and it's easy to understand
0B10C7             0604*  ;      and it's easy to modify
0B10C7             0605*  ;      and it's easy to use
0B10C7             0606*  ;      and it's easy to remember
0B10C7             0607*  ;      and it's easy to love
0B10C7             0608*  ;      and it's easy to hate
0B10C7             0609*  ;      and it's easy to ignore
0B10C7             0610*  ;      and it's easy to forget
0B10C7             0611*  ;      and it's easy to remember
0B10C7             0612*  ;      and it's easy to forget
0B10C7             0613*  ;      and it's easy to remember
0B10C7             0614*  ;      (ok the bot is stuck in a loop)
0B10C7             0615*  ; REAL NOTE: only works for angles from 0 to 45 degrees
0B10C7             0616*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0B10C7             0617*  atan_168game:
0B10C7             0618*  ; because we use compass headings instead of geometric angles
0B10C7             0619*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0B10C7             0620*  ; we can do faster unsigned division here because we know dx and dy are positive
0B10C7 CD 13 18 0B 0621*  	call udiv168 ; uh.l = dx/dy
0B10CB             0622*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0B10CB             0623*  ; ; test uh.l for 0
0B10CB             0624*  ;     add hl,de
0B10CB             0625*  ;     or a
0B10CB             0626*  ;     sbc hl,de
0B10CB             0627*  ;     jr z,@is_zero
0B10CB             0628*  ; ; test uh.l for 1
0B10CB             0629*  ;     xor a ; clear carry
0B10CB             0630*  ;     ex de,hl
0B10CB             0631*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0B10CB             0632*  ;     sbc hl,de
0B10CB             0633*  ;     jr z,@is_45
0B10CB             0634*  ; ; END TODO
0B10CB             0635*  
0B10CB             0636*  ; no special cases so we move on
0B10CB             0637*  ; l contains the fractional portion of tan(uh.l)
0B10CB             0638*  ; we multiply it by three to get our lookup table index
0B10CB 26 03       0639*      ld h,3
0B10CD ED 6C       0640*      mlt hl ; gosh that is handy
0B10CF 11 00 00 00 0641*      ld de,0 ; clear deu
0B10D3 54          0642*      ld d,h ; copy hl to de
0B10D4 5D          0643*      ld e,l ; de contains our index
0B10D5 21 D2 14 0B 0644*      ld hl,atan_lut_168 ; grab the lut address
0B10D9 19          0645*      add hl,de ; bump hl by the index
0B10DA ED 27       0646*      ld hl,(hl) ; don't try this on a z80!
0B10DC C9          0647*      ret ; and out
0B10DD             0648*  @is_45:
0B10DD 21 00 20 00 0649*      ld hl,0x002000 ; 45 degrees decimal
0B10E1 C9          0650*      ret
0B10E2             0651*  ; for the case tan(0)
0B10E2             0652*  @is_zero:
0B10E2 21 00 00 00 0653*      ld hl,0x000000
0B10E6 C9          0654*      ret
0B10E7             0655*  
0B10E7             0656*  ; Expects  ADL mode
0B10E7             0657*  ; Inputs:  UH.L
0B10E7             0658*  ; Outputs: UH.L is the 16.8 square root
0B10E7             0659*  ;          UD.E is the difference inputHL-DE^2
0B10E7             0660*  ;          c flag reset
0B10E7             0661*  sqrt168:
0B10E7 CD F1 10 0B 0662*      call sqrt24
0B10EB EB          0663*      ex de,hl
0B10EC 29          0664*      add hl,hl
0B10ED 29          0665*      add hl,hl
0B10EE 29          0666*      add hl,hl
0B10EF 29          0667*      add hl,hl
0B10F0 C9          0668*      ret
0B10F1             0669*  
0B10F1             0670*  ; Expects  ADL mode
0B10F1             0671*  ; Inputs:  HL
0B10F1             0672*  ; Outputs: DE is the integer square root
0B10F1             0673*  ;          HL is the difference inputHL-DE^2
0B10F1             0674*  ;          c flag reset
0B10F1             0675*  sqrt24:
0B10F1 AF          0676*      xor a
0B10F2 45          0677*      ld b,l
0B10F3 C5          0678*      push bc
0B10F4 47          0679*      ld b,a
0B10F5 57          0680*      ld d,a
0B10F6 4F          0681*      ld c,a
0B10F7 6F          0682*      ld l,a
0B10F8 5F          0683*      ld e,a
0B10F9             0684*  
0B10F9             0685*      ;Iteration 1
0B10F9 29          0686*      add hl,hl
0B10FA CB 11       0687*      rl c
0B10FC 29          0688*      add hl,hl
0B10FD CB 11       0689*      rl c
0B10FF 91          0690*      sub c
0B1100 30 04       0691*      jr nc,$+6
0B1102 1C          0692*      inc e
0B1103 1C          0693*      inc e
0B1104 2F          0694*      cpl
0B1105 4F          0695*      ld c,a
0B1106             0696*  
0B1106             0697*      ;Iteration 2
0B1106 29          0698*      add hl,hl
0B1107 CB 11       0699*      rl c
0B1109 29          0700*      add hl,hl
0B110A CB 11       0701*      rl c
0B110C CB 13       0702*      rl e
0B110E 7B          0703*      ld a,e
0B110F 91          0704*      sub c
0B1110 30 04       0705*      jr nc,$+6
0B1112 1C          0706*      inc e
0B1113 1C          0707*      inc e
0B1114 2F          0708*      cpl
0B1115 4F          0709*      ld c,a
0B1116             0710*  
0B1116             0711*      ;Iteration 3
0B1116 29          0712*      add hl,hl
0B1117 CB 11       0713*      rl c
0B1119 29          0714*      add hl,hl
0B111A CB 11       0715*      rl c
0B111C CB 13       0716*      rl e
0B111E 7B          0717*      ld a,e
0B111F 91          0718*      sub c
0B1120 30 04       0719*      jr nc,$+6
0B1122 1C          0720*      inc e
0B1123 1C          0721*      inc e
0B1124 2F          0722*      cpl
0B1125 4F          0723*      ld c,a
0B1126             0724*  
0B1126             0725*      ;Iteration 4
0B1126 29          0726*      add hl,hl
0B1127 CB 11       0727*      rl c
0B1129 29          0728*      add hl,hl
0B112A CB 11       0729*      rl c
0B112C CB 13       0730*      rl e
0B112E 7B          0731*      ld a,e
0B112F 91          0732*      sub c
0B1130 30 04       0733*      jr nc,$+6
0B1132 1C          0734*      inc e
0B1133 1C          0735*      inc e
0B1134 2F          0736*      cpl
0B1135 4F          0737*      ld c,a
0B1136             0738*  
0B1136             0739*      ;Iteration 5
0B1136 29          0740*      add hl,hl
0B1137 CB 11       0741*      rl c
0B1139 29          0742*      add hl,hl
0B113A CB 11       0743*      rl c
0B113C CB 13       0744*      rl e
0B113E 7B          0745*      ld a,e
0B113F 91          0746*      sub c
0B1140 30 04       0747*      jr nc,$+6
0B1142 1C          0748*      inc e
0B1143 1C          0749*      inc e
0B1144 2F          0750*      cpl
0B1145 4F          0751*      ld c,a
0B1146             0752*  
0B1146             0753*      ;Iteration 6
0B1146 29          0754*      add hl,hl
0B1147 CB 11       0755*      rl c
0B1149 29          0756*      add hl,hl
0B114A CB 11       0757*      rl c
0B114C CB 13       0758*      rl e
0B114E 7B          0759*      ld a,e
0B114F 91          0760*      sub c
0B1150 30 04       0761*      jr nc,$+6
0B1152 1C          0762*      inc e
0B1153 1C          0763*      inc e
0B1154 2F          0764*      cpl
0B1155 4F          0765*      ld c,a
0B1156             0766*  
0B1156             0767*      ;Iteration 7
0B1156 29          0768*      add hl,hl
0B1157 CB 11       0769*      rl c
0B1159 29          0770*      add hl,hl
0B115A CB 11       0771*      rl c
0B115C CB 10       0772*      rl b
0B115E EB          0773*      ex de,hl
0B115F 29          0774*      add hl,hl
0B1160 E5          0775*      push hl
0B1161 ED 42       0776*      sbc hl,bc
0B1163 30 06       0777*      jr nc,$+8
0B1165 7C          0778*      ld a,h
0B1166 2F          0779*      cpl
0B1167 47          0780*      ld b,a
0B1168 7D          0781*      ld a,l
0B1169 2F          0782*      cpl
0B116A 4F          0783*      ld c,a
0B116B E1          0784*      pop hl
0B116C 30 02       0785*      jr nc,$+4
0B116E 23          0786*      inc hl
0B116F 23          0787*      inc hl
0B1170 EB          0788*      ex de,hl
0B1171             0789*  
0B1171             0790*      ;Iteration 8
0B1171 29          0791*      add hl,hl
0B1172 69          0792*      ld l,c
0B1173 60          0793*      ld h,b
0B1174 ED 6A       0794*      adc hl,hl
0B1176 ED 6A       0795*      adc hl,hl
0B1178 EB          0796*      ex de,hl
0B1179 29          0797*      add hl,hl
0B117A ED 52       0798*      sbc hl,de
0B117C 19          0799*      add hl,de
0B117D EB          0800*      ex de,hl
0B117E 30 04       0801*      jr nc,$+6
0B1180 ED 52       0802*      sbc hl,de
0B1182 13          0803*      inc de
0B1183 13          0804*      inc de
0B1184             0805*  
0B1184             0806*      ;Iteration 9
0B1184 F1          0807*      pop af
0B1185 17          0808*      rla
0B1186 ED 6A       0809*      adc hl,hl
0B1188 17          0810*      rla
0B1189 ED 6A       0811*      adc hl,hl
0B118B EB          0812*      ex de,hl
0B118C 29          0813*      add hl,hl
0B118D ED 52       0814*      sbc hl,de
0B118F 19          0815*      add hl,de
0B1190 EB          0816*      ex de,hl
0B1191 30 04       0817*      jr nc,$+6
0B1193 ED 52       0818*      sbc hl,de
0B1195 13          0819*      inc de
0B1196 13          0820*      inc de
0B1197             0821*  
0B1197             0822*      ;Iteration 10
0B1197 17          0823*      rla
0B1198 ED 6A       0824*      adc hl,hl
0B119A 17          0825*      rla
0B119B ED 6A       0826*      adc hl,hl
0B119D EB          0827*      ex de,hl
0B119E 29          0828*      add hl,hl
0B119F ED 52       0829*      sbc hl,de
0B11A1 19          0830*      add hl,de
0B11A2 EB          0831*      ex de,hl
0B11A3 30 04       0832*      jr nc,$+6
0B11A5 ED 52       0833*      sbc hl,de
0B11A7 13          0834*      inc de
0B11A8 13          0835*      inc de
0B11A9             0836*  
0B11A9             0837*      ;Iteration 11
0B11A9 17          0838*      rla
0B11AA ED 6A       0839*      adc hl,hl
0B11AC 17          0840*      rla
0B11AD ED 6A       0841*      adc hl,hl
0B11AF EB          0842*      ex de,hl
0B11B0 29          0843*      add hl,hl
0B11B1 ED 52       0844*      sbc hl,de
0B11B3 19          0845*      add hl,de
0B11B4 EB          0846*      ex de,hl
0B11B5 30 04       0847*      jr nc,$+6
0B11B7 ED 52       0848*      sbc hl,de
0B11B9 13          0849*      inc de
0B11BA 13          0850*      inc de
0B11BB             0851*  
0B11BB             0852*      ;Iteration 11
0B11BB 17          0853*      rla
0B11BC ED 6A       0854*      adc hl,hl
0B11BE 17          0855*      rla
0B11BF ED 6A       0856*      adc hl,hl
0B11C1 EB          0857*      ex de,hl
0B11C2 29          0858*      add hl,hl
0B11C3 ED 52       0859*      sbc hl,de
0B11C5 19          0860*      add hl,de
0B11C6 EB          0861*      ex de,hl
0B11C7 30 04       0862*      jr nc,$+6
0B11C9 ED 52       0863*      sbc hl,de
0B11CB 13          0864*      inc de
0B11CC 13          0865*      inc de
0B11CD             0866*  
0B11CD CB 1A       0867*      rr d
0B11CF CB 1B       0868*      rr e
0B11D1 C9          0869*      ret
0B11D2             0870*  
0B11D2             0871*  sin_lut_168:
0B11D2 00 00 00    0872*  	dl 0x000000 ; 0.000 00, 0.000
0B11D5 06 00 00    0873*  	dl 0x000006 ; 1.406 01, 0.025
0B11D8 0C 00 00    0874*  	dl 0x00000C ; 2.813 02, 0.049
0B11DB 12 00 00    0875*  	dl 0x000012 ; 4.219 03, 0.074
0B11DE 19 00 00    0876*  	dl 0x000019 ; 5.625 04, 0.098
0B11E1 1F 00 00    0877*  	dl 0x00001F ; 7.031 05, 0.122
0B11E4 25 00 00    0878*  	dl 0x000025 ; 8.438 06, 0.147
0B11E7 2B 00 00    0879*  	dl 0x00002B ; 9.844 07, 0.171
0B11EA 31 00 00    0880*  	dl 0x000031 ; 11.250 08, 0.195
0B11ED 38 00 00    0881*  	dl 0x000038 ; 12.656 09, 0.219
0B11F0 3E 00 00    0882*  	dl 0x00003E ; 14.063 0A, 0.243
0B11F3 44 00 00    0883*  	dl 0x000044 ; 15.469 0B, 0.267
0B11F6 4A 00 00    0884*  	dl 0x00004A ; 16.875 0C, 0.290
0B11F9 50 00 00    0885*  	dl 0x000050 ; 18.281 0D, 0.314
0B11FC 56 00 00    0886*  	dl 0x000056 ; 19.688 0E, 0.337
0B11FF 5C 00 00    0887*  	dl 0x00005C ; 21.094 0F, 0.360
0B1202 61 00 00    0888*  	dl 0x000061 ; 22.500 10, 0.383
0B1205 67 00 00    0889*  	dl 0x000067 ; 23.906 11, 0.405
0B1208 6D 00 00    0890*  	dl 0x00006D ; 25.313 12, 0.428
0B120B 73 00 00    0891*  	dl 0x000073 ; 26.719 13, 0.450
0B120E 78 00 00    0892*  	dl 0x000078 ; 28.125 14, 0.471
0B1211 7E 00 00    0893*  	dl 0x00007E ; 29.531 15, 0.493
0B1214 83 00 00    0894*  	dl 0x000083 ; 30.938 16, 0.514
0B1217 88 00 00    0895*  	dl 0x000088 ; 32.344 17, 0.535
0B121A 8E 00 00    0896*  	dl 0x00008E ; 33.750 18, 0.556
0B121D 93 00 00    0897*  	dl 0x000093 ; 35.156 19, 0.576
0B1220 98 00 00    0898*  	dl 0x000098 ; 36.563 1A, 0.596
0B1223 9D 00 00    0899*  	dl 0x00009D ; 37.969 1B, 0.615
0B1226 A2 00 00    0900*  	dl 0x0000A2 ; 39.375 1C, 0.634
0B1229 A7 00 00    0901*  	dl 0x0000A7 ; 40.781 1D, 0.653
0B122C AB 00 00    0902*  	dl 0x0000AB ; 42.188 1E, 0.672
0B122F B0 00 00    0903*  	dl 0x0000B0 ; 43.594 1F, 0.690
0B1232 B5 00 00    0904*  	dl 0x0000B5 ; 45.000 20, 0.707
0B1235 B9 00 00    0905*  	dl 0x0000B9 ; 46.406 21, 0.724
0B1238 BD 00 00    0906*  	dl 0x0000BD ; 47.813 22, 0.741
0B123B C1 00 00    0907*  	dl 0x0000C1 ; 49.219 23, 0.757
0B123E C5 00 00    0908*  	dl 0x0000C5 ; 50.625 24, 0.773
0B1241 C9 00 00    0909*  	dl 0x0000C9 ; 52.031 25, 0.788
0B1244 CD 00 00    0910*  	dl 0x0000CD ; 53.438 26, 0.803
0B1247 D1 00 00    0911*  	dl 0x0000D1 ; 54.844 27, 0.818
0B124A D4 00 00    0912*  	dl 0x0000D4 ; 56.250 28, 0.831
0B124D D8 00 00    0913*  	dl 0x0000D8 ; 57.656 29, 0.845
0B1250 DB 00 00    0914*  	dl 0x0000DB ; 59.063 2A, 0.858
0B1253 DE 00 00    0915*  	dl 0x0000DE ; 60.469 2B, 0.870
0B1256 E1 00 00    0916*  	dl 0x0000E1 ; 61.875 2C, 0.882
0B1259 E4 00 00    0917*  	dl 0x0000E4 ; 63.281 2D, 0.893
0B125C E7 00 00    0918*  	dl 0x0000E7 ; 64.688 2E, 0.904
0B125F EA 00 00    0919*  	dl 0x0000EA ; 66.094 2F, 0.914
0B1262 EC 00 00    0920*  	dl 0x0000EC ; 67.500 30, 0.924
0B1265 EE 00 00    0921*  	dl 0x0000EE ; 68.906 31, 0.933
0B1268 F1 00 00    0922*  	dl 0x0000F1 ; 70.313 32, 0.942
0B126B F3 00 00    0923*  	dl 0x0000F3 ; 71.719 33, 0.950
0B126E F4 00 00    0924*  	dl 0x0000F4 ; 73.125 34, 0.957
0B1271 F6 00 00    0925*  	dl 0x0000F6 ; 74.531 35, 0.964
0B1274 F8 00 00    0926*  	dl 0x0000F8 ; 75.938 36, 0.970
0B1277 F9 00 00    0927*  	dl 0x0000F9 ; 77.344 37, 0.976
0B127A FB 00 00    0928*  	dl 0x0000FB ; 78.750 38, 0.981
0B127D FC 00 00    0929*  	dl 0x0000FC ; 80.156 39, 0.985
0B1280 FD 00 00    0930*  	dl 0x0000FD ; 81.563 3A, 0.989
0B1283 FE 00 00    0931*  	dl 0x0000FE ; 82.969 3B, 0.992
0B1286 FE 00 00    0932*  	dl 0x0000FE ; 84.375 3C, 0.995
0B1289 FF 00 00    0933*  	dl 0x0000FF ; 85.781 3D, 0.997
0B128C FF 00 00    0934*  	dl 0x0000FF ; 87.188 3E, 0.999
0B128F FF 00 00    0935*  	dl 0x0000FF ; 88.594 3F, 1.000
0B1292 00 01 00    0936*  	dl 0x000100 ; 90.000 40, 1.000
0B1295 FF 00 00    0937*  	dl 0x0000FF ; 91.406 41, 1.000
0B1298 FF 00 00    0938*  	dl 0x0000FF ; 92.813 42, 0.999
0B129B FF 00 00    0939*  	dl 0x0000FF ; 94.219 43, 0.997
0B129E FE 00 00    0940*  	dl 0x0000FE ; 95.625 44, 0.995
0B12A1 FE 00 00    0941*  	dl 0x0000FE ; 97.031 45, 0.992
0B12A4 FD 00 00    0942*  	dl 0x0000FD ; 98.438 46, 0.989
0B12A7 FC 00 00    0943*  	dl 0x0000FC ; 99.844 47, 0.985
0B12AA FB 00 00    0944*  	dl 0x0000FB ; 101.250 48, 0.981
0B12AD F9 00 00    0945*  	dl 0x0000F9 ; 102.656 49, 0.976
0B12B0 F8 00 00    0946*  	dl 0x0000F8 ; 104.063 4A, 0.970
0B12B3 F6 00 00    0947*  	dl 0x0000F6 ; 105.469 4B, 0.964
0B12B6 F4 00 00    0948*  	dl 0x0000F4 ; 106.875 4C, 0.957
0B12B9 F3 00 00    0949*  	dl 0x0000F3 ; 108.281 4D, 0.950
0B12BC F1 00 00    0950*  	dl 0x0000F1 ; 109.688 4E, 0.942
0B12BF EE 00 00    0951*  	dl 0x0000EE ; 111.094 4F, 0.933
0B12C2 EC 00 00    0952*  	dl 0x0000EC ; 112.500 50, 0.924
0B12C5 EA 00 00    0953*  	dl 0x0000EA ; 113.906 51, 0.914
0B12C8 E7 00 00    0954*  	dl 0x0000E7 ; 115.313 52, 0.904
0B12CB E4 00 00    0955*  	dl 0x0000E4 ; 116.719 53, 0.893
0B12CE E1 00 00    0956*  	dl 0x0000E1 ; 118.125 54, 0.882
0B12D1 DE 00 00    0957*  	dl 0x0000DE ; 119.531 55, 0.870
0B12D4 DB 00 00    0958*  	dl 0x0000DB ; 120.938 56, 0.858
0B12D7 D8 00 00    0959*  	dl 0x0000D8 ; 122.344 57, 0.845
0B12DA D4 00 00    0960*  	dl 0x0000D4 ; 123.750 58, 0.831
0B12DD D1 00 00    0961*  	dl 0x0000D1 ; 125.156 59, 0.818
0B12E0 CD 00 00    0962*  	dl 0x0000CD ; 126.563 5A, 0.803
0B12E3 C9 00 00    0963*  	dl 0x0000C9 ; 127.969 5B, 0.788
0B12E6 C5 00 00    0964*  	dl 0x0000C5 ; 129.375 5C, 0.773
0B12E9 C1 00 00    0965*  	dl 0x0000C1 ; 130.781 5D, 0.757
0B12EC BD 00 00    0966*  	dl 0x0000BD ; 132.188 5E, 0.741
0B12EF B9 00 00    0967*  	dl 0x0000B9 ; 133.594 5F, 0.724
0B12F2 B5 00 00    0968*  	dl 0x0000B5 ; 135.000 60, 0.707
0B12F5 B0 00 00    0969*  	dl 0x0000B0 ; 136.406 61, 0.690
0B12F8 AB 00 00    0970*  	dl 0x0000AB ; 137.813 62, 0.672
0B12FB A7 00 00    0971*  	dl 0x0000A7 ; 139.219 63, 0.653
0B12FE A2 00 00    0972*  	dl 0x0000A2 ; 140.625 64, 0.634
0B1301 9D 00 00    0973*  	dl 0x00009D ; 142.031 65, 0.615
0B1304 98 00 00    0974*  	dl 0x000098 ; 143.438 66, 0.596
0B1307 93 00 00    0975*  	dl 0x000093 ; 144.844 67, 0.576
0B130A 8E 00 00    0976*  	dl 0x00008E ; 146.250 68, 0.556
0B130D 88 00 00    0977*  	dl 0x000088 ; 147.656 69, 0.535
0B1310 83 00 00    0978*  	dl 0x000083 ; 149.063 6A, 0.514
0B1313 7E 00 00    0979*  	dl 0x00007E ; 150.469 6B, 0.493
0B1316 78 00 00    0980*  	dl 0x000078 ; 151.875 6C, 0.471
0B1319 73 00 00    0981*  	dl 0x000073 ; 153.281 6D, 0.450
0B131C 6D 00 00    0982*  	dl 0x00006D ; 154.688 6E, 0.428
0B131F 67 00 00    0983*  	dl 0x000067 ; 156.094 6F, 0.405
0B1322 61 00 00    0984*  	dl 0x000061 ; 157.500 70, 0.383
0B1325 5C 00 00    0985*  	dl 0x00005C ; 158.906 71, 0.360
0B1328 56 00 00    0986*  	dl 0x000056 ; 160.313 72, 0.337
0B132B 50 00 00    0987*  	dl 0x000050 ; 161.719 73, 0.314
0B132E 4A 00 00    0988*  	dl 0x00004A ; 163.125 74, 0.290
0B1331 44 00 00    0989*  	dl 0x000044 ; 164.531 75, 0.267
0B1334 3E 00 00    0990*  	dl 0x00003E ; 165.938 76, 0.243
0B1337 38 00 00    0991*  	dl 0x000038 ; 167.344 77, 0.219
0B133A 31 00 00    0992*  	dl 0x000031 ; 168.750 78, 0.195
0B133D 2B 00 00    0993*  	dl 0x00002B ; 170.156 79, 0.171
0B1340 25 00 00    0994*  	dl 0x000025 ; 171.563 7A, 0.147
0B1343 1F 00 00    0995*  	dl 0x00001F ; 172.969 7B, 0.122
0B1346 19 00 00    0996*  	dl 0x000019 ; 174.375 7C, 0.098
0B1349 12 00 00    0997*  	dl 0x000012 ; 175.781 7D, 0.074
0B134C 0C 00 00    0998*  	dl 0x00000C ; 177.188 7E, 0.049
0B134F 06 00 00    0999*  	dl 0x000006 ; 178.594 7F, 0.025
0B1352 00 00 00    1000*  	dl 0x000000 ; 180.000 80, 0.000
0B1355 FA FF FF    1001*  	dl 0xFFFFFA ; 181.406 81, -0.025
0B1358 F4 FF FF    1002*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0B135B EE FF FF    1003*  	dl 0xFFFFEE ; 184.219 83, -0.074
0B135E E7 FF FF    1004*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0B1361 E1 FF FF    1005*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0B1364 DB FF FF    1006*  	dl 0xFFFFDB ; 188.438 86, -0.147
0B1367 D5 FF FF    1007*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0B136A CF FF FF    1008*  	dl 0xFFFFCF ; 191.250 88, -0.195
0B136D C8 FF FF    1009*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0B1370 C2 FF FF    1010*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B1373 BC FF FF    1011*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0B1376 B6 FF FF    1012*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B1379 B0 FF FF    1013*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B137C AA FF FF    1014*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0B137F A4 FF FF    1015*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B1382 9F FF FF    1016*  	dl 0xFFFF9F ; 202.500 90, -0.383
0B1385 99 FF FF    1017*  	dl 0xFFFF99 ; 203.906 91, -0.405
0B1388 93 FF FF    1018*  	dl 0xFFFF93 ; 205.313 92, -0.428
0B138B 8D FF FF    1019*  	dl 0xFFFF8D ; 206.719 93, -0.450
0B138E 88 FF FF    1020*  	dl 0xFFFF88 ; 208.125 94, -0.471
0B1391 82 FF FF    1021*  	dl 0xFFFF82 ; 209.531 95, -0.493
0B1394 7D FF FF    1022*  	dl 0xFFFF7D ; 210.938 96, -0.514
0B1397 78 FF FF    1023*  	dl 0xFFFF78 ; 212.344 97, -0.535
0B139A 72 FF FF    1024*  	dl 0xFFFF72 ; 213.750 98, -0.556
0B139D 6D FF FF    1025*  	dl 0xFFFF6D ; 215.156 99, -0.576
0B13A0 68 FF FF    1026*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0B13A3 63 FF FF    1027*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0B13A6 5E FF FF    1028*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0B13A9 59 FF FF    1029*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0B13AC 55 FF FF    1030*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0B13AF 50 FF FF    1031*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0B13B2 4B FF FF    1032*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0B13B5 47 FF FF    1033*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0B13B8 43 FF FF    1034*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0B13BB 3F FF FF    1035*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0B13BE 3B FF FF    1036*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0B13C1 37 FF FF    1037*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0B13C4 33 FF FF    1038*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0B13C7 2F FF FF    1039*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0B13CA 2C FF FF    1040*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0B13CD 28 FF FF    1041*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0B13D0 25 FF FF    1042*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0B13D3 22 FF FF    1043*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0B13D6 1F FF FF    1044*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0B13D9 1C FF FF    1045*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0B13DC 19 FF FF    1046*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0B13DF 16 FF FF    1047*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0B13E2 14 FF FF    1048*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0B13E5 12 FF FF    1049*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0B13E8 0F FF FF    1050*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0B13EB 0D FF FF    1051*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0B13EE 0C FF FF    1052*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0B13F1 0A FF FF    1053*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0B13F4 08 FF FF    1054*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0B13F7 07 FF FF    1055*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0B13FA 05 FF FF    1056*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0B13FD 04 FF FF    1057*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0B1400 03 FF FF    1058*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0B1403 02 FF FF    1059*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0B1406 02 FF FF    1060*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0B1409 01 FF FF    1061*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0B140C 01 FF FF    1062*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0B140F 01 FF FF    1063*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0B1412 00 FF FF    1064*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0B1415 01 FF FF    1065*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0B1418 01 FF FF    1066*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0B141B 01 FF FF    1067*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0B141E 02 FF FF    1068*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0B1421 02 FF FF    1069*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0B1424 03 FF FF    1070*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0B1427 04 FF FF    1071*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0B142A 05 FF FF    1072*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0B142D 07 FF FF    1073*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0B1430 08 FF FF    1074*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0B1433 0A FF FF    1075*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0B1436 0C FF FF    1076*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0B1439 0D FF FF    1077*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0B143C 0F FF FF    1078*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0B143F 12 FF FF    1079*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0B1442 14 FF FF    1080*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0B1445 16 FF FF    1081*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0B1448 19 FF FF    1082*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0B144B 1C FF FF    1083*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0B144E 1F FF FF    1084*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0B1451 22 FF FF    1085*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0B1454 25 FF FF    1086*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0B1457 28 FF FF    1087*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0B145A 2C FF FF    1088*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0B145D 2F FF FF    1089*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0B1460 33 FF FF    1090*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0B1463 37 FF FF    1091*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0B1466 3B FF FF    1092*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0B1469 3F FF FF    1093*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0B146C 43 FF FF    1094*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0B146F 47 FF FF    1095*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0B1472 4B FF FF    1096*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0B1475 50 FF FF    1097*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0B1478 55 FF FF    1098*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0B147B 59 FF FF    1099*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0B147E 5E FF FF    1100*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0B1481 63 FF FF    1101*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0B1484 68 FF FF    1102*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0B1487 6D FF FF    1103*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0B148A 72 FF FF    1104*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0B148D 78 FF FF    1105*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0B1490 7D FF FF    1106*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0B1493 82 FF FF    1107*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0B1496 88 FF FF    1108*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0B1499 8D FF FF    1109*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0B149C 93 FF FF    1110*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0B149F 99 FF FF    1111*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0B14A2 9F FF FF    1112*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0B14A5 A4 FF FF    1113*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B14A8 AA FF FF    1114*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0B14AB B0 FF FF    1115*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B14AE B6 FF FF    1116*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B14B1 BC FF FF    1117*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0B14B4 C2 FF FF    1118*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B14B7 C8 FF FF    1119*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B14BA CF FF FF    1120*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0B14BD D5 FF FF    1121*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B14C0 DB FF FF    1122*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0B14C3 E1 FF FF    1123*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B14C6 E7 FF FF    1124*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B14C9 EE FF FF    1125*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0B14CC F4 FF FF    1126*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B14CF FA FF FF    1127*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0B14D2             1128*  
0B14D2             1129*  atan_lut_168:
0B14D2 00 00 00    1130*  	dl 0x000000 ; 000000, 0.000
0B14D5 28 00 00    1131*  	dl 0x000028 ; 000001, 0.224
0B14D8 51 00 00    1132*  	dl 0x000051 ; 000002, 0.448
0B14DB 7A 00 00    1133*  	dl 0x00007A ; 000003, 0.671
0B14DE A2 00 00    1134*  	dl 0x0000A2 ; 000004, 0.895
0B14E1 CB 00 00    1135*  	dl 0x0000CB ; 000005, 1.119
0B14E4 F4 00 00    1136*  	dl 0x0000F4 ; 000006, 1.343
0B14E7 1D 01 00    1137*  	dl 0x00011D ; 000007, 1.566
0B14EA 45 01 00    1138*  	dl 0x000145 ; 000008, 1.790
0B14ED 6E 01 00    1139*  	dl 0x00016E ; 000009, 2.013
0B14F0 97 01 00    1140*  	dl 0x000197 ; 00000A, 2.237
0B14F3 BF 01 00    1141*  	dl 0x0001BF ; 00000B, 2.460
0B14F6 E8 01 00    1142*  	dl 0x0001E8 ; 00000C, 2.684
0B14F9 11 02 00    1143*  	dl 0x000211 ; 00000D, 2.907
0B14FC 39 02 00    1144*  	dl 0x000239 ; 00000E, 3.130
0B14FF 62 02 00    1145*  	dl 0x000262 ; 00000F, 3.353
0B1502 8B 02 00    1146*  	dl 0x00028B ; 000010, 3.576
0B1505 B3 02 00    1147*  	dl 0x0002B3 ; 000011, 3.799
0B1508 DC 02 00    1148*  	dl 0x0002DC ; 000012, 4.022
0B150B 04 03 00    1149*  	dl 0x000304 ; 000013, 4.245
0B150E 2D 03 00    1150*  	dl 0x00032D ; 000014, 4.467
0B1511 55 03 00    1151*  	dl 0x000355 ; 000015, 4.690
0B1514 7E 03 00    1152*  	dl 0x00037E ; 000016, 4.912
0B1517 A6 03 00    1153*  	dl 0x0003A6 ; 000017, 5.134
0B151A CE 03 00    1154*  	dl 0x0003CE ; 000018, 5.356
0B151D F7 03 00    1155*  	dl 0x0003F7 ; 000019, 5.578
0B1520 1F 04 00    1156*  	dl 0x00041F ; 00001A, 5.799
0B1523 48 04 00    1157*  	dl 0x000448 ; 00001B, 6.021
0B1526 70 04 00    1158*  	dl 0x000470 ; 00001C, 6.242
0B1529 98 04 00    1159*  	dl 0x000498 ; 00001D, 6.463
0B152C C0 04 00    1160*  	dl 0x0004C0 ; 00001E, 6.684
0B152F E8 04 00    1161*  	dl 0x0004E8 ; 00001F, 6.905
0B1532 11 05 00    1162*  	dl 0x000511 ; 000020, 7.125
0B1535 39 05 00    1163*  	dl 0x000539 ; 000021, 7.345
0B1538 61 05 00    1164*  	dl 0x000561 ; 000022, 7.565
0B153B 89 05 00    1165*  	dl 0x000589 ; 000023, 7.785
0B153E B1 05 00    1166*  	dl 0x0005B1 ; 000024, 8.005
0B1541 D9 05 00    1167*  	dl 0x0005D9 ; 000025, 8.224
0B1544 01 06 00    1168*  	dl 0x000601 ; 000026, 8.443
0B1547 28 06 00    1169*  	dl 0x000628 ; 000027, 8.662
0B154A 50 06 00    1170*  	dl 0x000650 ; 000028, 8.881
0B154D 78 06 00    1171*  	dl 0x000678 ; 000029, 9.099
0B1550 A0 06 00    1172*  	dl 0x0006A0 ; 00002A, 9.317
0B1553 C7 06 00    1173*  	dl 0x0006C7 ; 00002B, 9.535
0B1556 EF 06 00    1174*  	dl 0x0006EF ; 00002C, 9.752
0B1559 16 07 00    1175*  	dl 0x000716 ; 00002D, 9.970
0B155C 3E 07 00    1176*  	dl 0x00073E ; 00002E, 10.187
0B155F 65 07 00    1177*  	dl 0x000765 ; 00002F, 10.403
0B1562 8D 07 00    1178*  	dl 0x00078D ; 000030, 10.620
0B1565 B4 07 00    1179*  	dl 0x0007B4 ; 000031, 10.836
0B1568 DB 07 00    1180*  	dl 0x0007DB ; 000032, 11.051
0B156B 03 08 00    1181*  	dl 0x000803 ; 000033, 11.267
0B156E 2A 08 00    1182*  	dl 0x00082A ; 000034, 11.482
0B1571 51 08 00    1183*  	dl 0x000851 ; 000035, 11.697
0B1574 78 08 00    1184*  	dl 0x000878 ; 000036, 11.911
0B1577 9F 08 00    1185*  	dl 0x00089F ; 000037, 12.125
0B157A C6 08 00    1186*  	dl 0x0008C6 ; 000038, 12.339
0B157D ED 08 00    1187*  	dl 0x0008ED ; 000039, 12.553
0B1580 13 09 00    1188*  	dl 0x000913 ; 00003A, 12.766
0B1583 3A 09 00    1189*  	dl 0x00093A ; 00003B, 12.978
0B1586 61 09 00    1190*  	dl 0x000961 ; 00003C, 13.191
0B1589 87 09 00    1191*  	dl 0x000987 ; 00003D, 13.403
0B158C AE 09 00    1192*  	dl 0x0009AE ; 00003E, 13.614
0B158F D4 09 00    1193*  	dl 0x0009D4 ; 00003F, 13.825
0B1592 FB 09 00    1194*  	dl 0x0009FB ; 000040, 14.036
0B1595 21 0A 00    1195*  	dl 0x000A21 ; 000041, 14.247
0B1598 47 0A 00    1196*  	dl 0x000A47 ; 000042, 14.457
0B159B 6D 0A 00    1197*  	dl 0x000A6D ; 000043, 14.666
0B159E 94 0A 00    1198*  	dl 0x000A94 ; 000044, 14.876
0B15A1 BA 0A 00    1199*  	dl 0x000ABA ; 000045, 15.085
0B15A4 E0 0A 00    1200*  	dl 0x000AE0 ; 000046, 15.293
0B15A7 05 0B 00    1201*  	dl 0x000B05 ; 000047, 15.501
0B15AA 2B 0B 00    1202*  	dl 0x000B2B ; 000048, 15.709
0B15AD 51 0B 00    1203*  	dl 0x000B51 ; 000049, 15.916
0B15B0 77 0B 00    1204*  	dl 0x000B77 ; 00004A, 16.123
0B15B3 9C 0B 00    1205*  	dl 0x000B9C ; 00004B, 16.329
0B15B6 C2 0B 00    1206*  	dl 0x000BC2 ; 00004C, 16.535
0B15B9 E7 0B 00    1207*  	dl 0x000BE7 ; 00004D, 16.740
0B15BC 0C 0C 00    1208*  	dl 0x000C0C ; 00004E, 16.945
0B15BF 32 0C 00    1209*  	dl 0x000C32 ; 00004F, 17.150
0B15C2 57 0C 00    1210*  	dl 0x000C57 ; 000050, 17.354
0B15C5 7C 0C 00    1211*  	dl 0x000C7C ; 000051, 17.558
0B15C8 A1 0C 00    1212*  	dl 0x000CA1 ; 000052, 17.761
0B15CB C6 0C 00    1213*  	dl 0x000CC6 ; 000053, 17.964
0B15CE EB 0C 00    1214*  	dl 0x000CEB ; 000054, 18.166
0B15D1 0F 0D 00    1215*  	dl 0x000D0F ; 000055, 18.368
0B15D4 34 0D 00    1216*  	dl 0x000D34 ; 000056, 18.569
0B15D7 58 0D 00    1217*  	dl 0x000D58 ; 000057, 18.770
0B15DA 7D 0D 00    1218*  	dl 0x000D7D ; 000058, 18.970
0B15DD A1 0D 00    1219*  	dl 0x000DA1 ; 000059, 19.170
0B15E0 C6 0D 00    1220*  	dl 0x000DC6 ; 00005A, 19.370
0B15E3 EA 0D 00    1221*  	dl 0x000DEA ; 00005B, 19.569
0B15E6 0E 0E 00    1222*  	dl 0x000E0E ; 00005C, 19.767
0B15E9 32 0E 00    1223*  	dl 0x000E32 ; 00005D, 19.965
0B15EC 56 0E 00    1224*  	dl 0x000E56 ; 00005E, 20.163
0B15EF 7A 0E 00    1225*  	dl 0x000E7A ; 00005F, 20.360
0B15F2 9E 0E 00    1226*  	dl 0x000E9E ; 000060, 20.556
0B15F5 C1 0E 00    1227*  	dl 0x000EC1 ; 000061, 20.752
0B15F8 E5 0E 00    1228*  	dl 0x000EE5 ; 000062, 20.947
0B15FB 08 0F 00    1229*  	dl 0x000F08 ; 000063, 21.142
0B15FE 2C 0F 00    1230*  	dl 0x000F2C ; 000064, 21.337
0B1601 4F 0F 00    1231*  	dl 0x000F4F ; 000065, 21.531
0B1604 72 0F 00    1232*  	dl 0x000F72 ; 000066, 21.724
0B1607 95 0F 00    1233*  	dl 0x000F95 ; 000067, 21.917
0B160A B8 0F 00    1234*  	dl 0x000FB8 ; 000068, 22.109
0B160D DB 0F 00    1235*  	dl 0x000FDB ; 000069, 22.301
0B1610 FE 0F 00    1236*  	dl 0x000FFE ; 00006A, 22.493
0B1613 21 10 00    1237*  	dl 0x001021 ; 00006B, 22.683
0B1616 44 10 00    1238*  	dl 0x001044 ; 00006C, 22.874
0B1619 66 10 00    1239*  	dl 0x001066 ; 00006D, 23.063
0B161C 89 10 00    1240*  	dl 0x001089 ; 00006E, 23.253
0B161F AB 10 00    1241*  	dl 0x0010AB ; 00006F, 23.441
0B1622 CD 10 00    1242*  	dl 0x0010CD ; 000070, 23.629
0B1625 EF 10 00    1243*  	dl 0x0010EF ; 000071, 23.817
0B1628 11 11 00    1244*  	dl 0x001111 ; 000072, 24.004
0B162B 33 11 00    1245*  	dl 0x001133 ; 000073, 24.191
0B162E 55 11 00    1246*  	dl 0x001155 ; 000074, 24.376
0B1631 77 11 00    1247*  	dl 0x001177 ; 000075, 24.562
0B1634 99 11 00    1248*  	dl 0x001199 ; 000076, 24.747
0B1637 BA 11 00    1249*  	dl 0x0011BA ; 000077, 24.931
0B163A DC 11 00    1250*  	dl 0x0011DC ; 000078, 25.115
0B163D FD 11 00    1251*  	dl 0x0011FD ; 000079, 25.298
0B1640 1E 12 00    1252*  	dl 0x00121E ; 00007A, 25.481
0B1643 3F 12 00    1253*  	dl 0x00123F ; 00007B, 25.663
0B1646 60 12 00    1254*  	dl 0x001260 ; 00007C, 25.844
0B1649 81 12 00    1255*  	dl 0x001281 ; 00007D, 26.025
0B164C A2 12 00    1256*  	dl 0x0012A2 ; 00007E, 26.206
0B164F C3 12 00    1257*  	dl 0x0012C3 ; 00007F, 26.386
0B1652 E4 12 00    1258*  	dl 0x0012E4 ; 000080, 26.565
0B1655 04 13 00    1259*  	dl 0x001304 ; 000081, 26.744
0B1658 25 13 00    1260*  	dl 0x001325 ; 000082, 26.922
0B165B 45 13 00    1261*  	dl 0x001345 ; 000083, 27.100
0B165E 65 13 00    1262*  	dl 0x001365 ; 000084, 27.277
0B1661 85 13 00    1263*  	dl 0x001385 ; 000085, 27.453
0B1664 A5 13 00    1264*  	dl 0x0013A5 ; 000086, 27.629
0B1667 C5 13 00    1265*  	dl 0x0013C5 ; 000087, 27.805
0B166A E5 13 00    1266*  	dl 0x0013E5 ; 000088, 27.979
0B166D 05 14 00    1267*  	dl 0x001405 ; 000089, 28.154
0B1670 24 14 00    1268*  	dl 0x001424 ; 00008A, 28.327
0B1673 44 14 00    1269*  	dl 0x001444 ; 00008B, 28.501
0B1676 63 14 00    1270*  	dl 0x001463 ; 00008C, 28.673
0B1679 83 14 00    1271*  	dl 0x001483 ; 00008D, 28.845
0B167C A2 14 00    1272*  	dl 0x0014A2 ; 00008E, 29.017
0B167F C1 14 00    1273*  	dl 0x0014C1 ; 00008F, 29.187
0B1682 E0 14 00    1274*  	dl 0x0014E0 ; 000090, 29.358
0B1685 FF 14 00    1275*  	dl 0x0014FF ; 000091, 29.527
0B1688 1E 15 00    1276*  	dl 0x00151E ; 000092, 29.697
0B168B 3C 15 00    1277*  	dl 0x00153C ; 000093, 29.865
0B168E 5B 15 00    1278*  	dl 0x00155B ; 000094, 30.033
0B1691 79 15 00    1279*  	dl 0x001579 ; 000095, 30.201
0B1694 98 15 00    1280*  	dl 0x001598 ; 000096, 30.368
0B1697 B6 15 00    1281*  	dl 0x0015B6 ; 000097, 30.534
0B169A D4 15 00    1282*  	dl 0x0015D4 ; 000098, 30.700
0B169D F2 15 00    1283*  	dl 0x0015F2 ; 000099, 30.865
0B16A0 10 16 00    1284*  	dl 0x001610 ; 00009A, 31.030
0B16A3 2E 16 00    1285*  	dl 0x00162E ; 00009B, 31.194
0B16A6 4C 16 00    1286*  	dl 0x00164C ; 00009C, 31.357
0B16A9 6A 16 00    1287*  	dl 0x00166A ; 00009D, 31.520
0B16AC 87 16 00    1288*  	dl 0x001687 ; 00009E, 31.682
0B16AF A5 16 00    1289*  	dl 0x0016A5 ; 00009F, 31.844
0B16B2 C2 16 00    1290*  	dl 0x0016C2 ; 0000A0, 32.005
0B16B5 DF 16 00    1291*  	dl 0x0016DF ; 0000A1, 32.166
0B16B8 FC 16 00    1292*  	dl 0x0016FC ; 0000A2, 32.326
0B16BB 19 17 00    1293*  	dl 0x001719 ; 0000A3, 32.486
0B16BE 36 17 00    1294*  	dl 0x001736 ; 0000A4, 32.645
0B16C1 53 17 00    1295*  	dl 0x001753 ; 0000A5, 32.803
0B16C4 70 17 00    1296*  	dl 0x001770 ; 0000A6, 32.961
0B16C7 8C 17 00    1297*  	dl 0x00178C ; 0000A7, 33.118
0B16CA A9 17 00    1298*  	dl 0x0017A9 ; 0000A8, 33.275
0B16CD C5 17 00    1299*  	dl 0x0017C5 ; 0000A9, 33.431
0B16D0 E2 17 00    1300*  	dl 0x0017E2 ; 0000AA, 33.587
0B16D3 FE 17 00    1301*  	dl 0x0017FE ; 0000AB, 33.742
0B16D6 1A 18 00    1302*  	dl 0x00181A ; 0000AC, 33.896
0B16D9 36 18 00    1303*  	dl 0x001836 ; 0000AD, 34.050
0B16DC 52 18 00    1304*  	dl 0x001852 ; 0000AE, 34.203
0B16DF 6E 18 00    1305*  	dl 0x00186E ; 0000AF, 34.356
0B16E2 8A 18 00    1306*  	dl 0x00188A ; 0000B0, 34.509
0B16E5 A5 18 00    1307*  	dl 0x0018A5 ; 0000B1, 34.660
0B16E8 C1 18 00    1308*  	dl 0x0018C1 ; 0000B2, 34.811
0B16EB DC 18 00    1309*  	dl 0x0018DC ; 0000B3, 34.962
0B16EE F7 18 00    1310*  	dl 0x0018F7 ; 0000B4, 35.112
0B16F1 13 19 00    1311*  	dl 0x001913 ; 0000B5, 35.262
0B16F4 2E 19 00    1312*  	dl 0x00192E ; 0000B6, 35.410
0B16F7 49 19 00    1313*  	dl 0x001949 ; 0000B7, 35.559
0B16FA 64 19 00    1314*  	dl 0x001964 ; 0000B8, 35.707
0B16FD 7F 19 00    1315*  	dl 0x00197F ; 0000B9, 35.854
0B1700 99 19 00    1316*  	dl 0x001999 ; 0000BA, 36.001
0B1703 B4 19 00    1317*  	dl 0x0019B4 ; 0000BB, 36.147
0B1706 CE 19 00    1318*  	dl 0x0019CE ; 0000BC, 36.293
0B1709 E9 19 00    1319*  	dl 0x0019E9 ; 0000BD, 36.438
0B170C 03 1A 00    1320*  	dl 0x001A03 ; 0000BE, 36.582
0B170F 1D 1A 00    1321*  	dl 0x001A1D ; 0000BF, 36.726
0B1712 37 1A 00    1322*  	dl 0x001A37 ; 0000C0, 36.870
0B1715 51 1A 00    1323*  	dl 0x001A51 ; 0000C1, 37.013
0B1718 6B 1A 00    1324*  	dl 0x001A6B ; 0000C2, 37.155
0B171B 85 1A 00    1325*  	dl 0x001A85 ; 0000C3, 37.297
0B171E 9F 1A 00    1326*  	dl 0x001A9F ; 0000C4, 37.439
0B1721 B9 1A 00    1327*  	dl 0x001AB9 ; 0000C5, 37.579
0B1724 D2 1A 00    1328*  	dl 0x001AD2 ; 0000C6, 37.720
0B1727 EC 1A 00    1329*  	dl 0x001AEC ; 0000C7, 37.859
0B172A 05 1B 00    1330*  	dl 0x001B05 ; 0000C8, 37.999
0B172D 1E 1B 00    1331*  	dl 0x001B1E ; 0000C9, 38.137
0B1730 37 1B 00    1332*  	dl 0x001B37 ; 0000CA, 38.276
0B1733 50 1B 00    1333*  	dl 0x001B50 ; 0000CB, 38.413
0B1736 69 1B 00    1334*  	dl 0x001B69 ; 0000CC, 38.550
0B1739 82 1B 00    1335*  	dl 0x001B82 ; 0000CD, 38.687
0B173C 9B 1B 00    1336*  	dl 0x001B9B ; 0000CE, 38.823
0B173F B4 1B 00    1337*  	dl 0x001BB4 ; 0000CF, 38.959
0B1742 CC 1B 00    1338*  	dl 0x001BCC ; 0000D0, 39.094
0B1745 E5 1B 00    1339*  	dl 0x001BE5 ; 0000D1, 39.228
0B1748 FD 1B 00    1340*  	dl 0x001BFD ; 0000D2, 39.362
0B174B 16 1C 00    1341*  	dl 0x001C16 ; 0000D3, 39.496
0B174E 2E 1C 00    1342*  	dl 0x001C2E ; 0000D4, 39.629
0B1751 46 1C 00    1343*  	dl 0x001C46 ; 0000D5, 39.762
0B1754 5E 1C 00    1344*  	dl 0x001C5E ; 0000D6, 39.894
0B1757 76 1C 00    1345*  	dl 0x001C76 ; 0000D7, 40.025
0B175A 8E 1C 00    1346*  	dl 0x001C8E ; 0000D8, 40.156
0B175D A5 1C 00    1347*  	dl 0x001CA5 ; 0000D9, 40.286
0B1760 BD 1C 00    1348*  	dl 0x001CBD ; 0000DA, 40.416
0B1763 D5 1C 00    1349*  	dl 0x001CD5 ; 0000DB, 40.546
0B1766 EC 1C 00    1350*  	dl 0x001CEC ; 0000DC, 40.675
0B1769 04 1D 00    1351*  	dl 0x001D04 ; 0000DD, 40.803
0B176C 1B 1D 00    1352*  	dl 0x001D1B ; 0000DE, 40.931
0B176F 32 1D 00    1353*  	dl 0x001D32 ; 0000DF, 41.059
0B1772 49 1D 00    1354*  	dl 0x001D49 ; 0000E0, 41.186
0B1775 60 1D 00    1355*  	dl 0x001D60 ; 0000E1, 41.312
0B1778 77 1D 00    1356*  	dl 0x001D77 ; 0000E2, 41.438
0B177B 8E 1D 00    1357*  	dl 0x001D8E ; 0000E3, 41.564
0B177E A5 1D 00    1358*  	dl 0x001DA5 ; 0000E4, 41.689
0B1781 BB 1D 00    1359*  	dl 0x001DBB ; 0000E5, 41.814
0B1784 D2 1D 00    1360*  	dl 0x001DD2 ; 0000E6, 41.938
0B1787 E9 1D 00    1361*  	dl 0x001DE9 ; 0000E7, 42.061
0B178A FF 1D 00    1362*  	dl 0x001DFF ; 0000E8, 42.184
0B178D 15 1E 00    1363*  	dl 0x001E15 ; 0000E9, 42.307
0B1790 2C 1E 00    1364*  	dl 0x001E2C ; 0000EA, 42.429
0B1793 42 1E 00    1365*  	dl 0x001E42 ; 0000EB, 42.551
0B1796 58 1E 00    1366*  	dl 0x001E58 ; 0000EC, 42.672
0B1799 6E 1E 00    1367*  	dl 0x001E6E ; 0000ED, 42.793
0B179C 84 1E 00    1368*  	dl 0x001E84 ; 0000EE, 42.913
0B179F 99 1E 00    1369*  	dl 0x001E99 ; 0000EF, 43.033
0B17A2 AF 1E 00    1370*  	dl 0x001EAF ; 0000F0, 43.152
0B17A5 C5 1E 00    1371*  	dl 0x001EC5 ; 0000F1, 43.271
0B17A8 DA 1E 00    1372*  	dl 0x001EDA ; 0000F2, 43.390
0B17AB F0 1E 00    1373*  	dl 0x001EF0 ; 0000F3, 43.508
0B17AE 05 1F 00    1374*  	dl 0x001F05 ; 0000F4, 43.625
0B17B1 1B 1F 00    1375*  	dl 0x001F1B ; 0000F5, 43.742
0B17B4 30 1F 00    1376*  	dl 0x001F30 ; 0000F6, 43.859
0B17B7 45 1F 00    1377*  	dl 0x001F45 ; 0000F7, 43.975
0B17BA 5A 1F 00    1378*  	dl 0x001F5A ; 0000F8, 44.091
0B17BD 6F 1F 00    1379*  	dl 0x001F6F ; 0000F9, 44.206
0B17C0 84 1F 00    1380*  	dl 0x001F84 ; 0000FA, 44.321
0B17C3 99 1F 00    1381*  	dl 0x001F99 ; 0000FB, 44.435
0B17C6 AD 1F 00    1382*  	dl 0x001FAD ; 0000FC, 44.549
0B17C9 C2 1F 00    1383*  	dl 0x001FC2 ; 0000FD, 44.662
0B17CC D7 1F 00    1384*  	dl 0x001FD7 ; 0000FE, 44.775
0B17CF EB 1F 00    1385*  	dl 0x001FEB ; 0000FF, 44.888
0B17D2 00 20 00    1386*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B17D5             1387*  
0B17D5             1388*  
0B17D5             1389*  	; ======= div_168_signed.inc stuff =======
0B17D5             1390*  
0B17D5             1391*  	; 24-bit integer and 16.8 fixed point division routines
0B17D5             1392*  ; by Brandon R. Gates (BeeGee747)
0B17D5             1393*  ; have undergone cursory testing and seem to be generating
0B17D5             1394*  ; correct results (assuming no overflows) but seem very inefficient,
0B17D5             1395*  ; so they have been published for review and improvement
0B17D5             1396*  ; see: https://discord.com/channels/1158535358624039014/1158536711148675072/1212136741608099910
0B17D5             1397*  ;
0B17D5             1398*  ; ---------------------------------------------------------
0B17D5             1399*  ; BEGIN DIVISION ROUTINES
0B17D5             1400*  ; ---------------------------------------------------------
0B17D5             1401*  ;
0B17D5             1402*  ; perform signed division of 16.8 fixed place values
0B17D5             1403*  ; with an signed 16.8 fixed place result
0B17D5             1404*  ; inputs: ub.c is dividend,ud.e is divisor
0B17D5             1405*  ; outputs: uh.l is quotient
0B17D5             1406*  ; destroys: a,bc
0B17D5             1407*  ; note: uses carry flag to test for sign of operands and result
0B17D5             1408*  ;       which can be confusing and should perhaps be changed
0B17D5             1409*  ; note2: helper functions abs_hlu and neg_hlu have been modified
0B17D5             1410*  ;       to return accurate flags according to the origional signs
0B17D5             1411*  ;       (or zero) of this function's inputs
0B17D5             1412*  sdiv168:
0B17D5             1413*  ; make everything positive and save signs
0B17D5 C5          1414*      push bc         ; get bc to hl
0B17D6 E1          1415*      pop hl          ; for the next call
0B17D7 CD 7C 18 0B 1416*      call abs_hlu    ; sets sign flag if hlu was negative, zero if zero
0B17DB CA 0E 18 0B 1417*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
0B17DF F5          1418*      push af         ; save sign of bc
0B17E0 E5          1419*      push hl         ; now put abs(hl)
0B17E1 C1          1420*      pop bc          ; back into bc = abs(bc)
0B17E2 EB          1421*      ex de,hl        ; now we do de same way
0B17E3 CD 7C 18 0B 1422*      call abs_hlu
0B17E7 CA 10 18 0B 1423*      jp z,@div_by_zero  ; if de was zero, answer is undefined and we're done
0B17EB EB          1424*      ex de,hl        ; hl back to de = abs(de)
0B17EC             1425*  ; determine sign of result
0B17EC F2 F7 17 0B 1426*      jp p,@de_pos    ; sign positive,de is positive
0B17F0 F1          1427*      pop af          ; get back sign of bc
0B17F1 FA 00 18 0B 1428*      jp m,@result_pos  ; bc and de negative, result is positive
0B17F5 18 05       1429*      jr @result_neg
0B17F7             1430*  @de_pos:
0B17F7 F1          1431*      pop af          ; get back sign of bc
0B17F8 F2 00 18 0B 1432*      jp p,@result_pos   ; bc and de are both positive so result is positive
0B17FC             1433*                      ; fall through to result_neg
0B17FC             1434*  @result_neg:
0B17FC AF          1435*      xor a           ; zero a and clear carry
0B17FD 3D          1436*      dec a           ; set sign flag to negative
0B17FE 18 02       1437*      jr @do_div
0B1800             1438*  @result_pos:
0B1800 AF          1439*      xor a           ; zero a and clear carry
0B1801 3C          1440*      inc a           ; set sign flag to negative
0B1802             1441*                      ; fall through to do_div
0B1802             1442*  @do_div:
0B1802 F5          1443*      push af         ; save sign of result
0B1803 CD 13 18 0B 1444*      call udiv168
0B1807 F1          1445*      pop af          ; get back sign of result
0B1808 F0          1446*      ret p           ; result is positive so nothing to do
0B1809 CD 8C 18 0B 1447*      call neg_hlu    ; result is negative so negate it
0B180D C9          1448*      ret
0B180E             1449*  @is_zero:           ; result is zero
0B180E AF          1450*      xor a           ; sets zero flag, which we want,
0B180F             1451*                      ; sets pv flag which we might not (zero is parity even)
0B180F             1452*                      ; resets all others which is okay
0B180F C9          1453*      ret
0B1810             1454*  @div_by_zero:       ; result is undefined, which isn't defined in binary
0B1810             1455*                      ; so we'll just return zero until i can think of something better
0B1810 F1          1456*      pop af          ; dummy pop
0B1811 AF          1457*      xor a           ; sets zero flag, which is ok,
0B1812             1458*                      ; sets pv flag which could be interpreted as overflow, which is good
0B1812             1459*                      ; resets all others which is okay
0B1812 C9          1460*      ret
0B1813             1461*  
0B1813             1462*  ; ; perform unsigned division of 16.8 fixed place values
0B1813             1463*  ; ; with an unsigned 16.8 fixed place result
0B1813             1464*  ; ; inputs: ub.c is dividend,ud.e is divisor
0B1813             1465*  ; ; outputs: uh.l is quotient
0B1813             1466*  ; ; destroys: a,bc
0B1813             1467*  ; udiv168:
0B1813             1468*  ; ; get the 16-bit integer part of the quotient
0B1813             1469*  ;     ; call div_24
0B1813             1470*  ;     call udiv24
0B1813             1471*  ;     ; call dumpRegistersHex
0B1813             1472*  ; ; load quotient to upper three bytes of output
0B1813             1473*  ;     ld (div168_out+1),bc
0B1813             1474*  ; ; TODO: THIS MAY BE BUGGED
0B1813             1475*  ; ; check remainder for zero, and if it is
0B1813             1476*  ; ; we can skip calculating the fractional part
0B1813             1477*  ;     add hl,de
0B1813             1478*  ;     or a
0B1813             1479*  ;     sbc hl,de
0B1813             1480*  ;     jr nz,@div256
0B1813             1481*  ;     xor a
0B1813             1482*  ;     jr @write_frac
0B1813             1483*  ; ; END TODO
0B1813             1484*  ; @div256:
0B1813             1485*  ; ; divide divisor by 256
0B1813             1486*  ;     push hl ; save remainder
0B1813             1487*  ; ; TODO: it feels like this could be more efficient
0B1813             1488*  ;     ld (arith24ude),de
0B1813             1489*  ;     ld a,d
0B1813             1490*  ;     ld (arith24ude),a
0B1813             1491*  ;     ld a,(ude+2)
0B1813             1492*  ;     ld (ude+1),a
0B1813             1493*  ;     xor a
0B1813             1494*  ;     ld (ude+2),a
0B1813             1495*  ;     ld hl,(arith24ude) ; (just for now, we want it in de eventually)
0B1813             1496*  ; ; TODO: THIS MAY BE BUGGED
0B1813             1497*  ; ; now we check the shifted divisor for zero, and if it is
0B1813             1498*  ; ; we again set the fractional part to zero
0B1813             1499*  ;     add hl,de
0B1813             1500*  ;     or a
0B1813             1501*  ;     sbc hl,de
0B1813             1502*  ;     ex de,hl ; now de is where it's supposed to be
0B1813             1503*  ;     pop hl ; get remainder back
0B1813             1504*  ; ; TODO: THIS MAY BE BUGGED
0B1813             1505*  ;     jr nz,@div_frac
0B1813             1506*  ;     xor a
0B1813             1507*  ;     jr @write_frac
0B1813             1508*  ; ; END TODO
0B1813             1509*  ; ; now divide the remainder by the shifted divisor
0B1813             1510*  ; @div_frac:
0B1813             1511*  ;     push hl ; my kingdom for ld bc,hl
0B1813             1512*  ;     pop bc  ; or even ex bc,hl
0B1813             1513*  ;     ; call div_24
0B1813             1514*  ;     call udiv24
0B1813             1515*  ; ; load low byte of quotient to low byte of output
0B1813             1516*  ;     ld a,c
0B1813             1517*  ; @write_frac:
0B1813             1518*  ;     ld (div168_out),a
0B1813             1519*  ; ; load hl with return value
0B1813             1520*  ;     ld hl,(div168_out)
0B1813             1521*  ; ; load a with any overflow
0B1813             1522*  ;     ld a,(div168_out+3)
0B1813             1523*  ;     ret ; uh.l is the 16.8 result
0B1813             1524*  ; div168_out: ds 4 ; the extra byte is for overflow
0B1813             1525*  
0B1813             1526*  ; perform unsigned division of fixed place values
0B1813             1527*  ; with an unsigned 16.8 fixed place result
0B1813             1528*  ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
0B1813             1529*  ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
0B1813             1530*  ; destroys: a,bc
0B1813             1531*  udiv168:
0B1813             1532*  ; shift dividend left 8 bits
0B1813 ED 43 12 0E 1533*      ld (arith24ubc+1),bc
       0B          
0B1818 AF          1534*      xor a
0B1819 32 11 0E 0B 1535*      ld (arith24ubc),a
0B181D ED 4B 11 0E 1536*      ld bc,(arith24ubc)
       0B          
0B1822 CD 61 0E 0B 1537*      call udiv24
0B1826             1538*  ; flip-flop outptuts to satisfy downstream consumers
0B1826             1539*  ; TODO: this is a hack and should be fixed
0B1826             1540*  ; (so says copilot ... but it's not wrong)
0B1826 E5          1541*      push hl
0B1827 C5          1542*      push bc
0B1828 E1          1543*      pop hl
0B1829 C1          1544*      pop bc
0B182A C9          1545*      ret
0B182B             1546*  
0B182B             1547*  ; this is an adaptation of Div16 extended to 24 bits
0B182B             1548*  ; from https://map.grauw.nl/articles/mult_div_shifts.php
0B182B             1549*  ; it works by shifting each byte of the dividend left into carry 8 times
0B182B             1550*  ; and adding the dividend into hl if the carry is set
0B182B             1551*  ; thus hl accumulates a remainder depending on the result of each iteration
0B182B             1552*  ; ---------------------------------------------------------
0B182B             1553*  ; Divide 24-bit unsigned values
0B182B             1554*  ;   with 24-bit unsigned result
0B182B             1555*  ;   and 24-bit remainder
0B182B             1556*  ; In: Divide ubc by ude
0B182B             1557*  ; Out: ubc = result, uhl = remainder
0B182B             1558*  ; Destroys: a,hl,bc
0B182B             1559*  div_24:
0B182B 21 00 00 00 1560*      ld hl,0     ; Clear accumulator for remainder
0B182F             1561*  ; put dividend in scratch so we can get at all its bytes
0B182F ED 43 11 0E 1562*      ld (arith24ubc),bc ; scratch ubc also accumulates the quotient
       0B          
0B1834 3A 13 0E 0B 1563*      ld a,(arith24ubc+2); grab the upper byte of the dividend
0B1838 06 08       1564*      ld b,8      ; loop counter for 8 bits in a byte
0B183A             1565*  @loop0:
0B183A 17          1566*      rla         ; shift the next bit of dividend into the carry flag
0B183B ED 6A       1567*      adc hl,hl   ; shift the remainder left one bit and add carry if any
0B183D ED 52       1568*      sbc hl,de   ; subtract divisor from remainder
0B183F 30 01       1569*      jr nc,@noadd0   ; if no carry,remainder is <= divisor
0B1841             1570*                  ; meaning remainder is divisible by divisor
0B1841 19          1571*      add hl,de   ; otherwise add divisor back to remainder
0B1842             1572*                  ; reversing the previous subtraction
0B1842             1573*  @noadd0:
0B1842 10 F6       1574*      djnz @loop0 ; repeat for all 8 bits
0B1844 17          1575*      rla         ; now we shift a left one more time
0B1845 2F          1576*      cpl         ; then flip its bits for some reason
0B1846 32 13 0E 0B 1577*      ld (arith24ubc+2),a; magically this is the upper byte of the quotient
0B184A 3A 12 0E 0B 1578*      ld a,(arith24ubc+1); now we pick up the middle byte of the dividend
0B184E 06 08       1579*      ld b,8      ; set up the next loop and do it all again ...
0B1850             1580*  @loop1:
0B1850 17          1581*      rla
0B1851 ED 6A       1582*      adc hl,hl
0B1853 ED 52       1583*      sbc hl,de
0B1855 30 01       1584*      jr nc,@noadd1
0B1857 19          1585*      add hl,de
0B1858             1586*  @noadd1:
0B1858 10 F6       1587*      djnz @loop1
0B185A 17          1588*      rla
0B185B 2F          1589*      cpl
0B185C 32 12 0E 0B 1590*      ld (arith24ubc+1),a ; writing the middle byte of quotient
0B1860 3A 11 0E 0B 1591*      ld a,(arith24ubc)
0B1864 06 08       1592*      ld b,8
0B1866             1593*  @loop2:          ; compute low byte of quotient
0B1866 17          1594*      rla
0B1867 ED 6A       1595*      adc hl,hl
0B1869 ED 52       1596*      sbc hl,de
0B186B 30 01       1597*      jr nc,@noadd2
0B186D 19          1598*      add hl,de
0B186E             1599*  @noadd2:
0B186E 10 F6       1600*      djnz @loop2
0B1870 17          1601*      rla
0B1871 2F          1602*      cpl
0B1872 32 11 0E 0B 1603*      ld (arith24ubc),a  ; ... write low byte of quotient
0B1876 ED 4B 11 0E 1604*      ld bc,(arith24ubc) ; load quotient into bc for return
       0B          
0B187B C9          1605*      ret         ; hl already contains remainder so we're done
0B187C             1606*  
0B187C             1607*  ; ---------------------------------------------------------
0B187C             1608*  ; BEGIN HELPER ROUTINES
0B187C             1609*  ; ---------------------------------------------------------
0B187C             1610*  ;
0B187C             1611*  ; absolute value of hlu
0B187C             1612*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B187C             1613*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0B187C             1614*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0B187C             1615*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0B187C             1616*  ; destroys: a
0B187C             1617*  abs_hlu:
0B187C 19          1618*      add hl,de
0B187D B7          1619*      or a
0B187E ED 52       1620*      sbc hl,de
0B1880 FA 85 18 0B 1621*      jp m,@is_neg
0B1884 C9          1622*      ret         ; hlu is positive or zero so we're done
0B1885             1623*  @is_neg:
0B1885 F5          1624*      push af     ; otherwise, save current flags for return
0B1886 CD 8C 18 0B 1625*      call neg_hlu ; negate hlu
0B188A F1          1626*      pop af      ; get back flags
0B188B C9          1627*      ret
0B188C             1628*  
0B188C             1629*  ; flip the sign of hlu
0B188C             1630*  ; inputs: hlu
0B188C             1631*  ; returns: 0-hlu, flags set appropriately for the result:
0B188C             1632*  ;         s1,z0,pv0,n1,c1 if result is negative
0B188C             1633*  ;         s0,z1,pv0,n1,c0 if result is zero
0B188C             1634*  ;         s0,z0,pv0,n1,c1 if result is positive
0B188C             1635*  ; destroys a
0B188C             1636*  neg_hlu:
0B188C D5          1637*      push de     ; save de
0B188D EB          1638*      ex de,hl    ; put hl into de
0B188E 21 00 00 00 1639*      ld hl,0     ; clear hl
0B1892 AF          1640*      xor a       ; clear carry
0B1893 ED 52       1641*      sbc hl,de   ; 0-hlu = -hlu
0B1895 D1          1642*      pop de      ; get de back
0B1896 C9          1643*      ret         ; easy peasy
0B1897             1644*  
0B1897             1645*  ;------------------------------------------------------------------------
0B1897             1646*  ; divide hlu by 2, inspired by above
0B1897             1647*  ;------------------------------------------------------------------------
0B1897             1648*  hlu_div2:
0B1897 22 1B 0F 0B 1649*  	ld		(bitbuf1),hl
0B189B 21 1D 0F 0B 1650*  	ld		hl,bitbuf1+2
0B189F CB 1E       1651*  	rr		(hl)
0B18A1 2B          1652*  	dec		hl
0B18A2 CB 1E       1653*  	rr		(hl)
0B18A4 2B          1654*  	dec		hl
0B18A5 CB 1E       1655*  	rr		(hl)
0B18A7 23          1656*  	inc		hl
0B18A8 23          1657*  	inc		hl
0B18A9 2A 1B 0F 0B 1658*      ld hl,(bitbuf1)
0B18AD C9          1659*      ret
0B18AE             1660*  
0B18AE             1661*  ; this is my little hack to divide by 16
0B18AE             1662*  hlu_div16:
0B18AE AF          1663*      xor a
0B18AF 29          1664*      add hl,hl
0B18B0 17          1665*      rla
0B18B1 29          1666*      add hl,hl
0B18B2 17          1667*      rla
0B18B3 29          1668*      add hl,hl
0B18B4 17          1669*      rla
0B18B5 29          1670*      add hl,hl
0B18B6 17          1671*      rla
0B18B7 22 C4 18 0B 1672*      ld (@scratch),hl
0B18BB 32 C7 18 0B 1673*      ld (@scratch+3),a
0B18BF 2A C5 18 0B 1674*      ld hl,(@scratch+1)
0B18C3 C9          1675*      ret
0B18C4             1676*  @scratch: ds 4
0B18C8             1677*  
0B18C8             1678*  ; -----------------------------------------------------------------------
0B18C8             1679*  ; EEMES TUTORIALS
0B18C8             1680*  ; -----------------------------------------------------------------------
0B18C8             1681*  ; https://tutorials.eeems.ca/Z80ASM/part4.htm
0B18C8             1682*  ; DEHL=BC*DE
0B18C8             1683*  Mul16:
0B18C8 21 00 00 00 1684*      ld hl,0
0B18CC 3E 10       1685*      ld a,16
0B18CE             1686*  Mul16Loop:
0B18CE 29          1687*      add hl,hl
0B18CF CB 13       1688*      rl e
0B18D1 CB 12       1689*      rl d
0B18D3 D2 DD 18 0B 1690*      jp nc,NoMul16
0B18D7 09          1691*      add hl,bc
0B18D8 D2 DD 18 0B 1692*      jp nc,NoMul16
0B18DC 13          1693*      inc de
0B18DD             1694*  NoMul16:
0B18DD 3D          1695*      dec a
0B18DE C2 CE 18 0B 1696*      jp nz,Mul16Loop
0B18E2 C9          1697*      ret
0B18E3             1698*  
0B18E3             1699*  ; DEUHLU=BCU*DEU
0B18E3             1700*  umul2448:
0B18E3 21 00 00 00 1701*      ld hl,0
0B18E7 3E 18       1702*      ld a,24
0B18E9             1703*  umul2448Loop:
0B18E9 29          1704*      add hl,hl
0B18EA EB          1705*      ex de,hl
0B18EB ED 6A       1706*      adc hl,hl
0B18ED EB          1707*      ex de,hl
0B18EE D2 F8 18 0B 1708*      jp nc,Noumul2448
0B18F2 09          1709*      add hl,bc
0B18F3 D2 F8 18 0B 1710*      jp nc,Noumul2448
0B18F7 13          1711*      inc de
0B18F8             1712*  Noumul2448:
0B18F8 3D          1713*      dec a
0B18F9 C2 E9 18 0B 1714*      jp nz,umul2448Loop
0B18FD C9          1715*      ret
0B18FE             1716*  
0B18FE             1717*  ; UH.L=UB.C*UD.E
0B18FE             1718*  umul168:
0B18FE CD E3 18 0B 1719*      call umul2448
0B1902             1720*  ; UDEU.HL is the 32.16 fixed result
0B1902             1721*  ; we want UH.L to be the 16.8 fixed result
0B1902             1722*  ; so we divide by 256 by shiftng down a byte
0B1902             1723*  ; easiest way is to write deu and hlu to scratch
0B1902 ED 53 17 19 1724*      ld (umul168out+3),de
       0B          
0B1907 22 14 19 0B 1725*      ld (umul168out),hl
0B190B             1726*  ; then load hlu from scratch shfited forward a byte
0B190B 2A 15 19 0B 1727*      ld hl,(umul168out+1)
0B190F 3A 19 19 0B 1728*      ld a,(umul168out+5) ; send a back with any overflow
0B1913 C9          1729*      ret
0B1914             1730*  umul168out: ds 6
0B191A             1731*  
0B191A             1732*  ; perform signed multiplication of 16.8 fixed place values
0B191A             1733*  ; with an signed 16.8 fixed place result
0B191A             1734*  ; inputs: ub.c and ud.e are the operands
0B191A             1735*  ; outputs: uh.l is the product
0B191A             1736*  ; destroys: a,bc
0B191A             1737*  ; TODO: make flags appropriate to the sign of the result
0B191A             1738*  smul168:
0B191A             1739*  ; make everything positive and save signs
0B191A C5          1740*      push bc         ; get bc to hl
0B191B E1          1741*      pop hl          ; for the next call
0B191C CD 7C 18 0B 1742*      call abs_hlu    ; sets sign flag if ubc was negative, zero if zero
0B1920             1743*  
0B1920             1744*      ; call dumpFlags ; passes
0B1920             1745*  
0B1920 CA 53 19 0B 1746*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
0B1924 F5          1747*      push af         ; save sign of bc
0B1925 E5          1748*      push hl         ; now put abs(hl)
0B1926 C1          1749*      pop bc          ; back into bc = abs(bc)
0B1927 EB          1750*      ex de,hl        ; now we do de same way
0B1928 CD 7C 18 0B 1751*      call abs_hlu    ; sets sign flag if ude was negative, zero if zero
0B192C             1752*  
0B192C             1753*      ; call dumpFlags ; passes
0B192C             1754*  
0B192C CA 53 19 0B 1755*      jp z,@is_zero  ; if de was zero, answer is zero and we're done
0B1930 EB          1756*      ex de,hl        ; hl back to de = abs(de)
0B1931             1757*  ; determine sign of result
0B1931 F2 3C 19 0B 1758*      jp p,@de_pos    ; sign positive,de is positive
0B1935             1759*  
0B1935             1760*      ; call dumpFlags ; correctly doesnt make it here
0B1935             1761*  
0B1935 F1          1762*      pop af          ; get back sign of bc
0B1936             1763*  
0B1936             1764*      ; call dumpFlags ; correctly doesn't make it here
0B1936             1765*  
0B1936 FA 45 19 0B 1766*      jp m,@result_pos  ; bc and de negative, result is positive
0B193A             1767*  
0B193A             1768*      ; call dumpFlags  ; corectly doesn't make it here
0B193A             1769*  
0B193A 18 05       1770*      jr @result_neg
0B193C             1771*  @de_pos:
0B193C F1          1772*      pop af          ; get back sign of bc
0B193D             1773*  
0B193D             1774*      ; call dumpFlags  ; passes
0B193D             1775*  
0B193D F2 45 19 0B 1776*      jp p,@result_pos   ; bc and de are both positive so result is positive
0B1941             1777*  
0B1941             1778*      ; call dumpFlags ; correctly makes it here
0B1941             1779*  
0B1941             1780*                      ; fall through to result_neg
0B1941             1781*  @result_neg:
0B1941 AF          1782*      xor a           ; zero a and clear carry
0B1942 3D          1783*      dec a           ; set sign flag to negative
0B1943             1784*  
0B1943             1785*      ; call dumpFlags ; passes
0B1943             1786*  
0B1943 18 02       1787*      jr @do_mul
0B1945             1788*  @result_pos:
0B1945 AF          1789*      xor a           ; zero a and clear carry
0B1946 3C          1790*      inc a           ; set sign flag to positive
0B1947             1791*                      ; fall through to do_mul
0B1947             1792*  
0B1947             1793*      ; call dumpFlags ; correctly doesn't make it here
0B1947             1794*  
0B1947             1795*  @do_mul:
0B1947 F5          1796*      push af         ; save sign of result
0B1948 CD FE 18 0B 1797*      call umul168
0B194C F1          1798*      pop af          ; get back sign of result
0B194D             1799*  
0B194D             1800*      ; call dumpFlags ; passes
0B194D             1801*  
0B194D F0          1802*      ret p           ; result is positive so nothing to do
0B194E             1803*  
0B194E             1804*      ; call dumpRegistersHex ; passes
0B194E             1805*  
0B194E CD 8C 18 0B 1806*      call neg_hlu    ; result is negative so negate it
0B1952             1807*  
0B1952             1808*      ; call dumpRegistersHex ; passes
0B1952 C9          1809*      ret
0B1953             1810*  @is_zero:           ; result is zero
0B1953 AF          1811*      xor a           ; sets zero flag, which we want,
0B1954             1812*                      ; sets pv flag which we might not (zero is parity even)
0B1954             1813*                      ; resets all others which is okay
0B1954 C9          1814*      ret
0B1955             0029   
0B1955             0030   ; APPLICATION INCLUDES
0B1955 55 73 61 67 0031   str_usage: ASCIZ "Usage: scratch <args>\r\n"
       65 3A 20 73 
       63 72 61 74 
       63 68 20 3C 
       61 72 67 73 
       3E 0D 0A 00 
0B196D 45 72 72 6F 0032   str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B1976 53 75 63 63 0033   str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B1981             0034   
0B1981             0035   ; This is a scratch moslet for testing new features
0B1981             0036   ; Parameters:
0B1981             0037   ;
0B1981             0038   
0B1981             0039   ; ========= BOILERPLATE MAIN LOOP =========
0B1981             0040   ; The main routine
0B1981             0041   ; IXU: argv - pointer to array of parameters
0B1981             0042   ;   C: argc - number of parameters
0B1981             0043   ; Returns:
0B1981             0044   ;  HL: Error code, or 0 if OK
0B1981             0045   
0B1981             0046   min_args: equ 2
0B1981             0047   
0B1981             0048   _main:
0B1981 79          0049       ld a,c              ; how many arguments?
0B1982 FE 02       0050       cp min_args         ; not enough?
0B1984 30 1A       0051       jr nc,main          ; if enough, go to main loop
0B1986 21 55 19 0B 0052       ld hl,str_usage     ; if not enough, print usage
0B198A CD 67 02 0B 0053       call printString
0B198E             0054                           ; fall through to _main_end_error
0B198E             0055   
0B198E             0056   _main_end_error:
0B198E 21 6D 19 0B 0057       ld hl,str_error     ; print error message
0B1992 CD 67 02 0B 0058       call printString
0B1996 21 13 00 00 0059       ld hl,19            ; return error code 19
0B199A C9          0060       ret
0B199B             0061   
0B199B             0062   _main_end_ok:
0B199B             0063       ; ld hl,str_success   ; print success message
0B199B             0064       ; call printString
0B199B 21 00 00 00 0065       ld hl,0             ; return 0 for success
0B199F C9          0066       ret
0B19A0             0067   
0B19A0             0068   ; ========= BEGIN CUSTOM MAIN LOOP =========
0B19A0             0069   main:
0B19A0 0D          0070       dec c               ; decrement the argument count to skip the program name
0B19A1             0071   
0B19A1             0072   test_s168_to_ascii:
0B19A1 CD 7C 1A 0B 0073       call get_numeric_arg ; de contains the numeric value of the first argument
0B19A5 EB          0074       ex de,hl            ; parameter to hl
0B19A6 11 BE 19 0B 0075       ld de,@buffer       ; point to the buffer
0B19AA CD B1 03 0B 0076       call s168_to_ascii  ; convert the number to ASCII
0B19AE 21 BE 19 0B 0077       ld hl,@buffer       ; point to the buffer
0B19B2 CD 67 02 0B 0078       call printString    ; print the number
0B19B6 CD 7C 02 0B 0079       call printNewLine   ; print a newline
0B19BA C3 9B 19 0B 0080       jp _main_end_ok
0B19BE 00 00 00 00 0081   @buffer: blkb 11,0
       00 00 00 00 
       00 00 00    
0B19C9             0082   
0B19C9             0083   test_u168_to_ascii:
0B19C9 CD 7C 1A 0B 0084       call get_numeric_arg ; de contains the numeric value of the first argument
0B19CD EB          0085       ex de,hl            ; parameter to hl
0B19CE 11 E6 19 0B 0086       ld de,@buffer       ; point to the buffer
0B19D2 CD 61 03 0B 0087       call u168_to_ascii  ; convert the number to ASCII
0B19D6 21 E6 19 0B 0088       ld hl,@buffer       ; point to the buffer
0B19DA CD 67 02 0B 0089       call printString    ; print the number
0B19DE CD 7C 02 0B 0090       call printNewLine   ; print a newline
0B19E2 C3 9B 19 0B 0091       jp _main_end_ok
0B19E6 00 00 00 00 0092   @buffer: blkb 11,0
       00 00 00 00 
       00 00 00    
0B19F1             0093   
0B19F1             0094   test_printDecFrac:
0B19F1 CD 7C 1A 0B 0095       call get_numeric_arg ; de contains the numeric value of the first argument
0B19F5 EB          0096       ex de,hl            ; move de to hl
0B19F6 CD B7 02 0B 0097       call printDecFrac   ; print the number
0B19FA             0098       ; call printNewLine   ; print a newline
0B19FA 76          0099       halt
0B19FB C3 9B 19 0B 0100       jp _main_end_ok
0B19FF             0101   
0B19FF             0102   test_print_A:
0B19FF CD 7C 1A 0B 0103       call get_numeric_arg ; de contains the numeric value of the first argument
0B1A03 7A          0104       ld a,d              ; low byte of integer portion
0B1A04 CD B8 0D 0B 0105       call print_A        ; print the number
0B1A08 CD 7C 02 0B 0106       call printNewLine   ; print a newline
0B1A0C C3 9B 19 0B 0107       jp _main_end_ok
0B1A10             0108   
0B1A10             0109   test_print_HLU_s24:
0B1A10 CD 7C 1A 0B 0110       call get_numeric_arg ; de contains the numeric value of the first argument
0B1A14 EB          0111       ex de,hl            ; parameter to hl
0B1A15 CD DB 04 0B 0112       call dumpRegistersHex ; print the registers
0B1A19 CD 0C 0D 0B 0113       call print_HLU_s24  ; print the number
0B1A1D CD 7C 02 0B 0114       call printNewLine   ; print a newline
0B1A21 C3 9B 19 0B 0115       jp _main_end_ok
0B1A25             0116   
0B1A25             0117   test_deg_360_to_255:
0B1A25 CD 7C 1A 0B 0118       call get_numeric_arg ; de contains the numeric value of the first argument
0B1A29 EB          0119       ex de,hl             ;
0B1A2A CD 4D 0F 0B 0120       call deg_360_to_255
0B1A2E CD DB 04 0B 0121       call dumpRegistersHex ; print the registers
0B1A32             0122       ; call printDec       ; print the number
0B1A32 CD 0C 0D 0B 0123       call print_HLU_s24
0B1A36 CD 7C 02 0B 0124       call printNewLine   ; print a newline
0B1A3A C3 9B 19 0B 0125       jp _main_end_ok
0B1A3E             0126   
0B1A3E             0127   test_udiv168:
0B1A3E             0128   ; get dividend
0B1A3E CD 7C 1A 0B 0129       call get_numeric_arg
0B1A42 ED 53 64 1A 0130       ld (@dividend),de
       0B          
0B1A47             0131   ; get divisor
0B1A47 CD 7C 1A 0B 0132       call get_numeric_arg
0B1A4B             0133   ; do the division
0B1A4B 2A 64 1A 0B 0134       ld hl,(@dividend)
0B1A4F CD 61 0E 0B 0135       call udiv24
0B1A53 EB          0136       ex de,hl ; result to hl for printing
0B1A54 CD DB 04 0B 0137       call dumpRegistersHex ; print the registers
0B1A58 CD EA 02 0B 0138       call printDec       ; print the number
0B1A5C CD 7C 02 0B 0139       call printNewLine   ; print a newline
0B1A60 C3 9B 19 0B 0140       jp _main_end_ok
0B1A64 00 00 00    0141   @dividend: dl 0
0B1A67             0142   
0B1A67             0143   test_ascii_to_s168:
0B1A67             0144   ; assume the first argument is numeric
0B1A67 CD 7C 1A 0B 0145       call get_numeric_arg ; de contains the numeric value of the first argument
0B1A6B EB          0146       ex de,hl            ; parameter to hl
0B1A6C CD DB 04 0B 0147       call dumpRegistersHex ; print the registers
0B1A70 CD EA 02 0B 0148       call printDec       ; print the number
0B1A74 CD 7C 02 0B 0149       call printNewLine   ; print a newline
0B1A78 C3 9B 19 0B 0150       jp _main_end_ok
0B1A7C             0151   
0B1A7C             0152   ; ========== HELPER FUNCTIONS ==========
0B1A7C             0153   get_numeric_arg:
0B1A7C ED 32 03    0154       lea ix,ix+3 ; point to the next argument
0B1A7F DD 27 00    0155       ld hl,(ix)  ; get the argument string
0B1A82 CD 98 01 0B 0156       call asc_to_s168 ; convert the string to a number
0B1A86             0157       ; call asc_to_sint ; DEBUG
0B1A86 C9          0158       ret ; return with the value in DE
0B1A87             0159   
0B1A87             0160   get_plot_coords:
0B1A87             0161   ; get the move coordinates
0B1A87 ED 32 03    0162       lea ix,ix+3 ; pointer to next argument address
0B1A8A DD 27 00    0163       ld hl,(ix)  ; pointer to the x coordinate string
0B1A8D CD 98 01 0B 0164       call asc_to_s168 ; de = x coordinate
0B1A91 D5          0165       push de
0B1A92 C1          0166       pop bc ; bc = x coordinate
0B1A93 ED 32 03    0167       lea ix,ix+3 ; pointer to next argument address
0B1A96 DD 27 00    0168       ld hl,(ix)  ; pointer to the y coordinate string
0B1A99 CD 98 01 0B 0169       call asc_to_s168 ; de = y coordinate
0B1A9D C9          0170       ret
0B1A9E             0171   
0B1A9E             0172   ; match the next argument after ix to the dispatch table at iy
0B1A9E             0173   ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B1A9E             0174   ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B1A9E             0175   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B1A9E             0176   ;          ON MATCH: iy=dispatch address, a=0 and zero flag se
0B1A9E             0177   ; destroys: a, hl, de, ix, iy, flags
0B1A9E             0178   match_next:
0B1A9E ED 32 03    0179       lea ix,ix+3         ; point to the next argument
0B1AA1             0180   @loop:
0B1AA1 FD 27 00    0181       ld hl,(iy)          ; pointer argument dispatch record
0B1AA4             0182       signHL              ; check for list terminator
0B1AA4 19          0001M          add hl,de
0B1AA5 B7          0002M          or a
0B1AA6 ED 52       0003M          sbc hl,de
0B1AA8 CA C0 1A 0B 0183       jp z,@no_match      ; if a=0, return error
0B1AAC 23          0184       inc hl              ; skip over jp instruction
0B1AAD 23          0185       inc hl
0B1AAE DD 17 00    0186       ld de,(ix)          ; pointer to the argument string
0B1AB1 CD C6 1A 0B 0187       call str_equal      ; compare the argument to the dispatch table entry
0B1AB5 CA C2 1A 0B 0188       jp z,@match         ; if equal, return success
0B1AB9 ED 33 03    0189       lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B1ABC C3 A1 1A 0B 0190       jp @loop            ; and loop
0B1AC0             0191   @no_match:
0B1AC0 3C          0192       inc a               ; no match so return a=1 and zero flag reset
0B1AC1 C9          0193       ret
0B1AC2             0194   @match:
0B1AC2 FD 37 00    0195       ld iy,(iy)          ; get the function pointer
0B1AC5 C9          0196       ret                 ; return a=0 and zero flag set
0B1AC6             0197   
0B1AC6             0198   ; compare two zero-terminated strings for equality, case-sensitive
0B1AC6             0199   ; hl: pointer to first string, de: pointer to second string
0B1AC6             0200   ; returns: z if equal, nz if not equal
0B1AC6             0201   ; destroys: a, hl, de
0B1AC6             0202   str_equal:
0B1AC6 1A          0203       ld a,(de)           ; get the first character
0B1AC7 BE          0204       cp (hl)             ; compare to the second character
0B1AC8 C0          0205       ret nz              ; if not equal, return
0B1AC9 B7          0206       or a
0B1ACA C8          0207       ret z               ; if equal and zero, return
0B1ACB 23          0208       inc hl              ; next character
0B1ACC 13          0209       inc de
0B1ACD C3 C6 1A 0B 0210       jp str_equal        ; loop until end of string
0B1AD1             0211   
0B1AD1             0212   ; print the parameter string pointed to by ix
0B1AD1             0213   ; destroys: a, hl
0B1AD1             0214   print_param:
0B1AD1 DD 27 00    0215       ld hl,(ix)          ; get the parameter pointer
0B1AD4 CD 67 02 0B 0216       call printString    ; print the parameter string
0B1AD8 3E 20       0217       ld a,' '            ; print a space separator
0B1ADA 5B D7       0218       rst.lil $10
0B1ADC C9          0219       ret
0B1ADD             0220   
0B1ADD             0221   ; print the parameters
0B1ADD             0222   ; inputs: b = number of parameters, ix = pointer to the parameters
0B1ADD             0223   ; destroys: a, hl, bc
0B1ADD             0224   print_params:
0B1ADD 41          0225       ld b,c              ; loop counter = number of parameters
0B1ADE DD E5       0226       push ix             ; save the pointer to the parameters
0B1AE0             0227   @loop:
0B1AE0 C5          0228       push bc             ; save the loop counter
0B1AE1 CD D1 1A 0B 0229       call print_param    ; print the parameter
0B1AE5 ED 32 03    0230       lea ix,ix+3         ; next parameter pointer
0B1AE8 C1          0231       pop bc              ; get back the loop counter
0B1AE9 10 F5       0232       djnz @loop          ; loop until done
0B1AEB DD E1       0233       pop ix              ; restore the pointer to the parameters
0B1AED C9          0234       ret
0B1AEE             0235   
0B1AEE             0236   debug_print:
0B1AEE CD 7C 02 0B 0237       call printNewLine   ; DEBUG
0B1AF2 CD 0E 06 0B 0238       call dumpFlags      ; DEBUG
0B1AF6 CD D1 1A 0B 0239       call print_param    ; DEBUG
0B1AFA CD 7C 02 0B 0240       call printNewLine   ; DEBUG
0B1AFE CD 7C 02 0B 0241       call printNewLine   ; DEBUG
0B1B02 C9          0242       ret
