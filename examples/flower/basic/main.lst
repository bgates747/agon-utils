PC     Output      Line
040000             0001   ;
040000             0002   ; Title:	BBC Basic Interpreter - Z80 version
040000             0003   ;		Command, Error and Lexical Analysis Module - "MAIN"
040000             0004   ; Author:	(C) Copyright  R.T.Russell  1984
040000             0005   ; Modified By:	Dean Belfield
040000             0006   ; Created:	12/05/2023
040000             0007   ; Last Updated:	26/11/2023
040000             0008   ;
040000             0009   ; Modinfo:
040000             0010   ; 07/05/1984:	Version 2.3
040000             0011   ; 01/03/1987:	Version 3.0
040000             0012   ; 03/05/2022:	Modified by Dean Belfield
040000             0013   ; 06/06/2023:	Modified to run in ADL mode
040000             0014   ; 26/06/2023:	Fixed binary and unary indirection
040000             0015   ; 17/08/2023:	Added binary constants
040000             0016   ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
040000             0017   ; 26/11/2023:	Fixed bug in AUTOLOAD
040000             0018   
040000             0019   			.ASSUME	ADL = 1
040000             0020   
040000             0021   			INCLUDE "mos_api.inc"	; In MOS/src
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ; ;
040000             0190*  ; ; FatFS structures
040000             0191*  ; ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ; ;
040000             0193*  ; ; Object ID and allocation information (FFOBJID)
040000             0194*  ; ;
040000             0195*  ; FFOBJID	.STRUCT
040000             0196*  ; 	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ; 	id:		DS	2	; Hosting volume mount ID
040000             0198*  ; 	attr:		DS	1	; Object attribute
040000             0199*  ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ; ;
040000             0204*  ; ; File object structure (FIL)
040000             0205*  ; ;
040000             0206*  ; FIL .STRUCT
040000             0207*  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ; 	flag:		DS	1	; File status flags
040000             0209*  ; 	err:		DS	1	; Abort flag (error code)
040000             0210*  ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ; 	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ; FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ; ;
040000             0217*  ; ; Directory object structure (DIR)
040000             0218*  ; ;
040000             0219*  ; DIR .STRUCT
040000             0220*  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0221*  ; 	dptr:		DS	4	; Current read/write offset
040000             0222*  ; 	clust:		DS	4	; Current cluster
040000             0223*  ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ; 	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ; DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ; ;
040000             0229*  ; ; File information structure (FILINFO)
040000             0230*  ; ;
040000             0231*  ; FILINFO .STRUCT
040000             0232*  ; 	fsize:		DS 	4	; File size
040000             0233*  ; 	fdate:		DS	2	; Modified date
040000             0234*  ; 	ftime:		DS	2	; Modified time
040000             0235*  ; 	fattrib:	DS	1	; File attribute
040000             0236*  ; 	altname:	DS	13	; Alternative file name
040000             0237*  ; 	fname:		DS	256	; Primary file name
040000             0238*  ; FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  MOSCALL:		MACRO	function
040000             0246*  			LD	A, function
040000             0247*  			RST.LIS	08h
040000             0248*  			ENDMACRO
040000             0022   			INCLUDE "ram.asm"
040000             0001*  ;
040000             0002*  ; Title:	BBC Basic Interpreter - Z80 version
040000             0003*  ;		RAM Module for BBC Basic Interpreter
040000             0004*  ;		For use with Version 2.0 of BBC BASIC
040000             0005*  ;		Standard CP/M Distribution Version
040000             0006*  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
040000             0007*  ; Modified By:	Dean Belfield
040000             0008*  ; Created:	12/05/2023
040000             0009*  ; Last Updated:	26/06/2023
040000             0010*  ;
040000             0011*  ; Modinfo:
040000             0012*  ; 06/06/2023:	Modified to run in ADL mode
040000             0013*  ; 26/06/2023:	Added temporary stores R0 and R1
040000             0014*  
040000             0015*  			.ASSUME	ADL = 1
040000             0016*  
040000             0017*  			; DEFINE	LORAM, SPACE = ROM
040000             0018*  			; SEGMENT LORAM
040000             0019*  
040000             0020*  			; XDEF	ACCS
040000             0021*  			; XDEF	BUFFER
040000             0022*  			; XDEF	STAVAR
040000             0023*  			; XDEF	DYNVAR
040000             0024*  			; XDEF	FNPTR
040000             0025*  			; XDEF	PROPTR
040000             0026*  			; XDEF	PAGE_
040000             0027*  			; XDEF	TOP
040000             0028*  			; XDEF	LOMEM
040000             0029*  			; XDEF 	FREE
040000             0030*  			; XDEF	HIMEM
040000             0031*  			; XDEF	LINENO
040000             0032*  			; XDEF	TRACEN
040000             0033*  			; XDEF	AUTONO
040000             0034*  			; XDEF	ERRTRP
040000             0035*  			; XDEF	ERRTXT
040000             0036*  			; XDEF	DATPTR
040000             0037*  			; XDEF	ERL
040000             0038*  			; XDEF	ERRLIN
040000             0039*  			; XDEF	RANDOM
040000             0040*  			; XDEF	COUNT
040000             0041*  			; XDEF	WIDTH
040000             0042*  			; XDEF	ERR
040000             0043*  			; XDEF	LISTON
040000             0044*  			; XDEF	INCREM
040000             0045*  
040000             0046*  			; XDEF	FLAGS
040000             0047*  			; XDEF	OSWRCHPT
040000             0048*  			; XDEF	OSWRCHCH
040000             0049*  			; XDEF	OSWRCHFH
040000             0050*  			; XDEF	KEYDOWN
040000             0051*  			; XDEF	KEYASCII
040000             0052*  			; XDEF	KEYCOUNT
040000             0053*  
040000             0054*  			; XDEF	R0
040000             0055*  			; XDEF	R1
040000             0056*  
040000             0057*  			; XDEF	RAM_START
040000             0058*  			; XDEF	RAM_END
040000             0059*  			; XDEF	USER
040000             0060*  
040000             0061*  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
040000             0062*  RAM_START:
040000             0063*  ;
040000             0064*  ACCS:			DS		256             ; String Accumulator
040100             0065*  BUFFER:			DS		256             ; String Input Buffer
040200             0066*  STAVAR:			DS	 	27*4            ; Static Variables
04026C             0067*  DYNVAR: 		DS 		54*3            ; Dynamic Variable Pointers
04030E             0068*  FNPTR:  		DS    		3               ; Dynamic Function Pointers
040311             0069*  PROPTR: 		DS		3               ; Dynamic Procedure Pointers
040314             0070*  ;
040314             0071*  PAGE_:   		DS		3               ; Start of User Program
040317             0072*  TOP:    		DS		3               ; First Location after User Program
04031A             0073*  LOMEM:  		DS		3               ; Start of Dynamic Storage
04031D             0074*  FREE:   		DS		3               ; First Free Space Byte
040320             0075*  HIMEM:  		DS		3               ; First Protected Byte
040323             0076*  ;
040323             0077*  LINENO: 		DS		3               ; Line Number
040326             0078*  TRACEN:			DS		3               ; Trace Flag
040329             0079*  AUTONO:			DS		3               ; Auto Flag
04032C             0080*  ERRTRP:			DS		3               ; Error Trap
04032F             0081*  ERRTXT:			DS		2               ; Error Message Pointer
040331             0082*  DATPTR:			DS		2               ; Data Pointer
040333             0083*  ERL:			DS		2               ; Error Line
040335             0084*  ERRLIN:			DS		3               ; The "ON ERROR" Line
040338             0085*  RANDOM:			DS		5               ; Random Number
04033D             0086*  COUNT:			DS		1               ; Print Position
04033E             0087*  WIDTH:			DS		1               ; Print Width
04033F             0088*  ERR:			DS		1               ; Error Number
040340             0089*  LISTON:			DS		1               ; LISTO (bottom nibble)
040341             0090*  							; - BIT 0: If set, output a space after the line number
040341             0091*  							; - BIT 1: If set, then indent FOR/NEXT loops
040341             0092*  							; - BIT 2: If set, then indent REPEAT/UNTIL loops
040341             0093*  							; - BIT 3: If set, then output to buffer for *EDIT
040341             0094*  							; OPT FLAG (top nibble)
040341             0095*  							; - BIT 4: If set, then list whilst assembling
040341             0096*  							; - BIT 5: If set, then assembler errors are reported
040341             0097*  							; - BIT 6: If set, then place the code starting at address pointed to by O%
040341             0098*  							; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
040341             0099*  INCREM:			DS		1               ; Auto-Increment Value
040342             0100*  ;
040342             0101*  ; Extra Agon-implementation specific system variables
040342             0102*  ;
040342             0103*  FLAGS:			DS		1		; Miscellaneous flags
040343             0104*  							; - BIT 7: Set if ESC pressed
040343             0105*  							; - BIT 6: Set to disable ESC
040343             0106*  OSWRCHPT:		DS		2		; Pointer for *EDIT
040345             0107*  OSWRCHCH:		DS		1		; Channel of OSWRCH
040346             0108*  							; - 0: Console
040346             0109*  							; - 1: File
040346             0110*  OSWRCHFH:		DS		1		; File handle for OSWRCHCHN
040347             0111*  KEYDOWN:		DS		1		; Keydown flag
040348             0112*  KEYASCII:		DS		1		; ASCII code of pressed key
040349             0113*  KEYCOUNT:		DS		1		; Counts every time a key is pressed
04034A             0114*  R0:			DS		3		; General purpose storage for 8/16 to 24 bit operations
04034D             0115*  R1:			DS		3		;
040350             0116*  ;
040350             0117*  ; This must be at the end
040350             0118*  ;
040350             0119*  RAM_END:
040350 FF FF FF FF 0120*  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040400             0121*  USER:							; Must be aligned on a page boundary
040400             0122*  
040400             0023   			INCLUDE	"equs.inc"
040400             0001*  ;
040400             0002*  ; Title:	BBC Basic for AGON - Equs
040400             0003*  ; Author:	Dean Belfield
040400             0004*  ; Created:	12/05/2023
040400             0005*  ; Last Updated:	08/06/2023
040400             0006*  ;
040400             0007*  ; Modinfo:
040400             0008*  ; 08/06/2023:	Added SIZEW
040400             0009*  
040400             0010*  			; XREF		STAVAR
040400             0011*  			; XREF		ACCS
040400             0012*  
040400             0013*  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
040400             0014*  ;Stack_Top:		EQU		0000h	; Stack at top
040400             0015*  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
040400             0016*  
040400             0017*  ; For GPIO
040400             0018*  ; PA not available on eZ80L92
040400             0019*  ;
040400             0020*  PA_DR:			EQU		96h
040400             0021*  PA_DDR:			EQU		97h
040400             0022*  PA_ALT1:		EQU		98h
040400             0023*  PA_ALT2:		EQU		99h
040400             0024*  PB_DR:          	EQU		9Ah
040400             0025*  PB_DDR:        	 	EQU		9Bh
040400             0026*  PB_ALT1:        	EQU		9Ch
040400             0027*  PB_ALT2:        	EQU		9Dh
040400             0028*  PC_DR:          	EQU		9Eh
040400             0029*  PC_DDR:         	EQU		9Fh
040400             0030*  PC_ALT1:        	EQU		A0h
040400             0031*  PC_ALT2:        	EQU		A1h
040400             0032*  PD_DR:          	EQU		A2h
040400             0033*  PD_DDR:			EQU		A3h
040400             0034*  PD_ALT1:		EQU		A4h
040400             0035*  PD_ALT2:		EQU		A5h
040400             0036*  
040400             0037*  GPIOMODE_OUT:		EQU		0	; Output
040400             0038*  GPIOMODE_IN:		EQU		1	; Input
040400             0039*  GPIOMODE_DIO:		EQU		2	; Open Drain IO
040400             0040*  GPIOMODE_SIO:		EQU		3	; Open Source IO
040400             0041*  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040400             0042*  GPIOMODE_ALTF:		EQU		5;	; Alt Function
040400             0043*  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040400             0044*  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040400             0045*  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040400             0046*  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040400             0047*  
040400             0048*  ; Originally in ram.asm
040400             0049*  ;
040400             0050*  OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
040400             0051*  PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
040400             0052*  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
040400             0053*  
040400             0054*  ; Originally in main.asm
040400             0055*  ;
040400             0056*  CR:			EQU     0DH
040400             0057*  LF:			EQU     0AH
040400             0058*  ESC:			EQU     1BH
040400             0024   			INCLUDE "macros.inc"
040400             0001*  	; Title:	BBC Basic Interpreter - Z80 version
040400             0002*  	;		Useful macros
040400             0003*  	; Author:	Dean Belfield
040400             0004*  	; Created:	12/05/2023
040400             0005*  	; Last Updated:	11/06/2023
040400             0006*  	;
040400             0007*  	; Modinfo:
040400             0008*  	; 11/06/2023:	Modified to run in ADL mode
040400             0009*  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040400             0010*  
040400             0011*  	MACRO EXREG	rp1, rp2
040400             0012*  		PUSH	rp1
040400             0013*  		POP	rp2
040400             0014*  	ENDMACRO
040400             0015*  
040400             0016*  	; MACRO ADD8U_DE	reg
040400             0017*  		MACRO ADD8U_DE
040400             0018*  		ADD	A, E
040400             0019*  		LD	E, A
040400             0020*  		ADC	A, D
040400             0021*  		SUB	E
040400             0022*  		LD	D, A
040400             0023*  	ENDMACRO
040400             0024*  
040400             0025*  	; MACRO ADD8U_HL	reg
040400             0026*  	MACRO ADD8U_HL
040400             0027*  		ADD	A, L
040400             0028*  		LD	L, A
040400             0029*  		ADC	A, H
040400             0030*  		SUB	L
040400             0031*  		LD	H, A
040400             0032*  	ENDMACRO
040400             0033*  
040400             0034*  	MACRO VDU	val
040400             0035*  		LD	A, val
040400             0036*  		CALL	OSWRCH
040400             0037*  	ENDMACRO
040400             0038*  
040400             0039*  	MACRO SET_GPIO	reg, val
040400             0040*  		IN0	A, (reg)
040400             0041*  		OR	val
040400             0042*  		OUT0	(reg), A
040400             0043*  	ENDMACRO
040400             0044*  
040400             0045*  	MACRO RES_GPIO	reg, val
040400             0046*  		PUSH	BC
040400             0047*  		LD	A, val
040400             0048*  		CPL
040400             0049*  		LD	C, A
040400             0050*  		IN0	A, (reg)
040400             0051*  		AND	C
040400             0052*  		OUT0	(reg), A
040400             0053*  		POP	BC
040400             0054*  	ENDMACRO
040400             0025   			; include "eval.asm"
040400             0026   			; include "exec.asm"
040400             0027   			; include "fpp.asm"
040400             0028   			; include "sorry.asm"
040400             0029   
040400             0030   			; SEGMENT CODE
040400             0031   
040400             0032   			; XDEF	_main
040400             0033   
040400             0034   			; XDEF	COLD
040400             0035   			; XDEF	WARM
040400             0036   			; XDEF	CLOOP
040400             0037   			; XDEF	DELETE
040400             0038   			; XDEF	LIST_
040400             0039   			; XDEF	RENUM
040400             0040   			; XDEF	AUTO
040400             0041   			; XDEF	NEW
040400             0042   			; XDEF	OLD
040400             0043   			; XDEF	LOAD
040400             0044   			; XDEF	SAVE
040400             0045   			; XDEF	ERROR_
040400             0046   			; XDEF	EXTERR
040400             0047   			; XDEF	LOAD0
040400             0048   			; XDEF	CLEAR
040400             0049   			; XDEF	CRLF
040400             0050   			; XDEF	OUTCHR
040400             0051   			; XDEF	OUT_
040400             0052   			; XDEF	FINDL
040400             0053   			; XDEF	SETLIN
040400             0054   			; XDEF	PBCDL
040400             0055   			; XDEF	SAYLN
040400             0056   			; XDEF	PUTVAR
040400             0057   			; XDEF	GETVAR
040400             0058   			; XDEF	GETDEF
040400             0059   			; XDEF	CREATE
040400             0060   			; XDEF	RANGE
040400             0061   			; XDEF	LEXAN2
040400             0062   			; XDEF	REPORT
040400             0063   			; XDEF	TELL
040400             0064   			; XDEF	SPACE_
040400             0065   			; XDEF	KEYWDS
040400             0066   			; XDEF	KEYWDL
040400             0067   			; XDEF	ONEDIT
040400             0068   			; XDEF	ONEDIT1
040400             0069   			; XDEF	LISTIT
040400             0070   			; XDEF	CLEAN
040400             0071   
040400             0072   			; XREF	LISTON
040400             0073   			; XREF	ERRTXT
040400             0074   			; XREF	OSINIT
040400             0075   			; XREF	HIMEM
040400             0076   			; XREF	PAGE_
040400             0077   			; XREF	CHAIN0
040400             0078   			; XREF	PROMPT
040400             0079   			; XREF	ERRTRP
040400             0080   			; XREF	ERRLIN
040400             0081   			; XREF	AUTONO
040400             0082   			; XREF	LINENO
040400             0083   			; XREF	INCREM
040400             0084   			; XREF	OSLINE
040400             0085   			; XREF	COUNT
040400             0086   			; XREF	NXT
040400             0087   			; XREF	BUFFER
040400             0088   			; XREF	XEQ
040400             0089   			; XREF	TOP
040400             0090   			; XREF	EXPRI
040400             0091   			; XREF	SEARCH
040400             0092   			; XREF	LTRAP
040400             0093   			; XREF	LOMEM
040400             0094   			; XREF	DECODE
040400             0095   			; XREF	EXPRS
040400             0096   			; XREF	OSSAVE
040400             0097   			; XREF	ERR
040400             0098   			; XREF	ERL
040400             0099   			; XREF	TRACEN
040400             0100   			; XREF	RESET
040400             0101   			; XREF	OSSHUT
040400             0102   			; XREF	OSLOAD
040400             0103   			; XREF	FREE
040400             0104   			; XREF	DYNVAR
040400             0105   			; XREF	FILL
040400             0106   			; XREF	OSWRCH
040400             0107   			; XREF	WIDTH
040400             0108   			; XREF	COMMA
040400             0109   			; XREF	MUL16
040400             0110   			; XREF	BRAKET
040400             0111   			; XREF	X4OR5
040400             0112   			; XREF	LOADN
040400             0113   			; XREF	SFIX
040400             0114   			; XREF	ITEMI
040400             0115   			; XREF	FNPTR
040400             0116   			; XREF	PROPTR
040400             0117   			; XREF	CHECK
040400             0118   			; XREF	TERMQ
040400             0119   			; XREF	OSWRCHCH
040400             0120   			; XREF	NEWIT
040400             0121   			; XREF	BAD
040400             0122   			; XREF	RAM_START
040400             0123   			; XREF	RAM_END
040400             0124   			; XREF	R0
040400             0125   			; XREF	STAR_VERSION
040400             0126   
040400             0127   			; XREF	_end			; In init.asm
040400             0128   ;
040400             0129   ; A handful of common token IDs
040400             0130   ;
040400             0131   TERROR:			EQU     85H
040400             0132   LINE_:			EQU     86H
040400             0133   ELSE_:			EQU     8BH
040400             0134   THEN:			EQU     8CH
040400             0135   LINO:			EQU     8DH
040400             0136   FN:			EQU     A4H
040400             0137   TO:			EQU     B8H
040400             0138   REN:			EQU     CCH
040400             0139   DATA_:			EQU     DCH
040400             0140   DIM:			EQU     DEH
040400             0141   FOR:			EQU     E3H
040400             0142   GOSUB:			EQU     E4H
040400             0143   GOTO:			EQU     E5H
040400             0144   TIF:			EQU     E7H
040400             0145   LOCAL_:			EQU     EAH
040400             0146   NEXT:			EQU     EDH
040400             0147   ON_:			EQU     EEH
040400             0148   PROC:			EQU     F2H
040400             0149   REM:			EQU     F4H
040400             0150   REPEAT:			EQU     F5H
040400             0151   RESTOR:			EQU     F7H
040400             0152   TRACE:			EQU     FCH
040400             0153   UNTIL:			EQU     FDH
040400             0154   ;
040400             0155   ; This defines the block of tokens that are pseudo-variables.
040400             0156   ; There are two versions of each token, a GET and a SET
040400             0157   
040400             0158   ; Name  : GET : SET
040400             0159   ; ------:-----:----
040400             0160   ; PTR   : 8Fh : CFh
040400             0161   ; PAGE  : 90h : D0h
040400             0162   ; TIME  : 91h : D1h
040400             0163   ; LOMEM : 92h : D2h
040400             0164   ; HIMEM : 93h : D3h
040400             0165   ;
040400             0166   ; Examples:
040400             0167   ;   LET A% = PAGE : REM This is the GET version
040400             0168   ;   PAGE = 40000  : REM This is the SET version
040400             0169   ;
040400             0170   TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
040400             0171   TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
040400             0172   OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
040400             0173   
040400             0174   ; The main routine
040400             0175   ; IXU: argv - pointer to array of parameters
040400             0176   ;   C: argc - number of parameters
040400             0177   ; Returns:
040400             0178   ;  HL: Error code, or 0 if OK
040400             0179   ;
040400 21 00 00 04 0180   _main:			LD	HL, ACCS		; Clear the ACCS
040404 36 00       0181   			LD	(HL), 0
040406 79          0182   			LD	A, C
040407 FE 02       0183   			CP	2
040409 28 2D       0184   			JR	Z, AUTOLOAD		; 2 parameters = autoload
04040B 38 3F       0185   			JR	C, COLD			; 1 parameter = normal start
04040D CD BF 14 04 0186   			CALL	STAR_VERSION
040411 CD DA 11 04 0187   			CALL	TELL
040415 55 73 61 67 0188   			DB	"Usage:\n\r"
       65 3A 0A 0D 
04041D 52 55 4E 20 0189   			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
040430 21 00 00 00 0190   			LD	HL, 0			; The error code
040434 C3 E2 14 04 0191   			JP	_end
040438             0192   ;
040438 DD 27 03    0193   AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
04043B 11 00 00 04 0194   			LD	DE, ACCS		;  DE: Destination address
04043F 7E          0195   AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
040440 12          0196   			LD	(DE), A			;
040441 23          0197   			INC	HL			; Increase the source pointer
040442 1C          0198   			INC	E			; We only need to increase E as ACCS is on a page boundary
040443 28 03       0199   			JR	Z, AUTOLOAD_2		; End if we hit the page boundary
040445 B7          0200   			OR	A
040446 20 F7       0201   			JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
040448 1D          0202   AUTOLOAD_2:		DEC	E
040449 3E 0D       0203   			LD	A, CR
04044B 12          0204   			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
04044C             0205   ;
04044C E1          0206   COLD:			POP	HL			; Pop the return address to init off SPS
04044D E5          0207   			PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
04044E 21 00 02 04 0208   			LD	HL, STAVAR		; Cold start
040452 F9          0209   			LD	SP, HL
040453 36 0A       0210   			LD	(HL), 10
040455 23          0211   			INC	HL
040456 36 09       0212   			LD	(HL),9
040458 CD E2 11 04 0213   			CALL    OSINIT			; Call the machine specific OS initialisation routines
04045C ED 53 20 03 0214   			LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
       04          
040461 22 14 03 04 0215   			LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
040465 3E B7       0216   			LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
040467 32 40 03 04 0217   			LD      (LISTON),A
04046B 21 A6 04 04 0218   			LD      HL,NOTICE
04046F 22 2F 03 04 0219   			LD      (ERRTXT),HL
040473 CD B6 0C 04 0220   			CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
040477 3A 00 00 04 0221   			LD	A,(ACCS)		; Check if there is a filename in ACCS
04047B B7          0222   			OR	A
04047C C2 FF 11 04 0223   			JP	NZ,CHAIN0		; Yes, so load and run
040480 CD BF 14 04 0224   			CALL	STAR_VERSION		;
040484 CD DA 11 04 0225   			CALL    TELL			; Output the welcome message
040488 42 42 43 20 0226   			DB    	"BBC BASIC (Z80) Version 3.00\n\r"
       42 41 53 49 
       43 20 28 5A 
       38 30 29 20 
       56 65 72 73 
       69 6F 6E 20 
       33 2E 30 30 
       0A 0D       
0404A6 28 43 29 20 0227   NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
       43 6F 70 79 
       72 69 67 68 
       74 20 52 2E 
       54 2E 52 75 
       73 73 65 6C 
       6C 20 31 39 
       38 37 0A 0D 
0404C6 0A 0D 00    0228   			DB	"\n\r", 0
0404C9             0229   ;
0404C9 F6          0230   WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
0404CA             0231   ;
0404CA             0232   ; This is the main entry point for BASIC
0404CA             0233   ;
0404CA 37          0234   CLOOP:			SCF				; See above - not sure why this is here!
0404CB ED 7B 20 03 0235   			LD      SP,(HIMEM)
       04          
0404D0 CD 1C 12 04 0236   			CALL    PROMPT          	; Prompt user
0404D4 21 40 03 04 0237   			LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
0404D8 7E          0238   			LD      A,(HL)			; Fetch the value
0404D9 E6 0F       0239   			AND     0FH             	; Bottom nibble: LISTO
0404DB F6 B0       0240   			OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
0404DD 77          0241   			LD      (HL),A			; Store back in
0404DE ED 62       0242   			SBC     HL,HL           	; HL: 0
0404E0 22 2C 03 04 0243   			LD      (ERRTRP),HL		; Clear ERRTRP sysvar
0404E4 22 35 03 04 0244   			LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
0404E8             0245   ;
0404E8 2A 29 03 04 0246   			LD      HL,(AUTONO)		; Get the auto line number
0404EC 22 23 03 04 0247   			LD      (LINENO),HL		; Store in line number
0404F0 7C          0248   			LD      A,H			; If the auto line number is zero then
0404F1 B5          0249   			OR      L
0404F2 28 1E       0250   			JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
0404F4             0251   ;
0404F4             0252   ; This section handles auto line numbering
0404F4             0253   ;
0404F4 E5          0254   			PUSH    HL			; Stack the line number
0404F5 CD 45 0E 04 0255   			CALL    PBCD           	 	; Output the line number
0404F9 E1          0256   			POP     HL			; Pop the line number back off the stack
0404FA             0257   ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
0404FA             0258   ;			LD      B,0			; So clear B
0404FA 01 00 00 00 0259   			LD	BC, 0			; Load BC with Increment
0404FE 3A 41 03 04 0260   			LD	A,(INCREM)
040502 4F          0261   			LD	C, A
040503 09          0262   			ADD     HL,BC			; Add the increment to the line number
040504 DA 6F 10 04 0263   			JP      C,TOOBIG_MAIN		; And error if we wrap
040508 22 29 03 04 0264   			LD      (AUTONO),HL		; Store the new auto line number
04050C 3E 20       0265   			LD      A,' '			; Print a space
04050E CD 99 0D 04 0266   			CALL    OUTCHR
040512             0267   ;
040512             0268   ; This section invokes the line editor
040512             0269   ;
040512 21 00 00 04 0270   NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
040516 CD 39 12 04 0271   			CALL    OSLINE          	; Call the line editor in MOS
04051A CD 26 05 04 0272   ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
04051E DC 89 0C 04 0273   			CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
040522 C3 CA 04 04 0274   			JP      CLOOP			; Jump back to immediate mode
040526             0275   ;
040526             0276   ; This bit enters the line into memory
040526             0277   ; Also called from OSLOAD_TXT
040526             0278   ; Returns:
040526             0279   ; F: C if a new line has been entered (CLEAN will need to be called)
040526             0280   ;
040526 AF          0281   ONEDIT1:		XOR     A			; Entry point after *EDIT
040527 32 3D 03 04 0282   			LD      (COUNT),A
04052B FD 21 00 00 0283   			LD      IY,ACCS
       04          
040530 CD 43 10 04 0284   			CALL    LINNUM			; HL: The line number from the input buffer
040534 CD 56 12 04 0285   			CALL    NXT			; Skip spaces
040538 7C          0286   			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
040539 B5          0287   			OR      L
04053A 28 04       0288   			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
04053C 22 23 03 04 0289   			LD      (LINENO),HL		; Otherwise store it
040540             0290   ;
040540             0291   ; This bit does the lexical analysis and tokenisation
040540             0292   ;
040540 0E 01       0293   LNZERO:			LD	C,1			; Left mode
040542 11 00 01 04 0294   			LD      DE,BUFFER		; Buffer for tokenised BASIC
040546 CD E9 10 04 0295   			CALL    LEXAN2          	; Lexical analysis on the user input
04054A 12          0296   			LD      (DE),A          	; Terminator
04054B AF          0297   			XOR     A
04054C             0298   ;			LD      B,A
04054C             0299   ;			LD      C,E             	; BC: Line length
04054C 01 00 00 00 0300   			LD	BC,0
040550 4B          0301   			LD	C,E			; BC: Line length
040551 13          0302   			INC     DE
040552 12          0303   			LD      (DE),A          	; Zero next
040553 2A 23 03 04 0304   			LD      HL,(LINENO)		; Get the line number
040557 7C          0305   			LD      A,H			; Is it zero, i.e. a command with no line number?
040558 B5          0306   			OR      L
040559 FD 21 00 01 0307   			LD      IY,BUFFER       	; Yes, so we're in immediate mode
       04          
04055E CA 70 12 04 0308   			JP      Z,XEQ           	; Execute it
040562             0309   ;
040562             0310   ; This section stores the BASIC line in memory
040562             0311   ;
040562 C5          0312   			PUSH    BC
040563 E5          0313   			PUSH    HL
040564 CD 95 0C 04 0314   			CALL    SETTOP          	; Set TOP sysvar
040568 E1          0315   			POP     HL
040569 CD D9 0D 04 0316   			CALL    FINDL			; Find the address of the line
04056D CC 4C 0C 04 0317   			CALL    Z,DEL			; Delete the existing line if found
040571 C1          0318   			POP     BC
040572 79          0319   			LD      A,C			; Check for the line length being zero, i.e.
040573 B7          0320   			OR      A			; the user has just entered a line number in the command line
040574 C8          0321   			RET	Z 	         	; If so, then don't do anything else
040575 C6 04       0322   			ADD     A,4
040577 4F          0323   			LD      C,A             	; Length inclusive
040578 D5          0324   			PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
040579 C5          0325   			PUSH    BC              	; BC: Line length
04057A EB          0326   			EX      DE,HL			; DE: Address of the line in memory
04057B 2A 17 03 04 0327   			LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
04057F E5          0328   			PUSH    HL			; Stack TOP (current TOP value)
040580 09          0329   			ADD     HL,BC			; Add the line length to HL, the new TOP value
040581 E5          0330   			PUSH    HL			; Stack HL (new TOP value)
040582 24          0331   			INC     H			; Add 256 to HL
040583 AF          0332   			XOR     A
040584 ED 72       0333   			SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
040586 E1          0334   			POP     HL			; Pop HL (new TOP value)
040587 D2 AA 0B 04 0335   			JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
04058B 22 17 03 04 0336   			LD      (TOP),HL		; Store new value of TOP
04058F E3          0337   			EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
040590 E5          0338   			PUSH    HL			; PUSH current TOP value
040591 23          0339   			INC     HL
040592 B7          0340   			OR      A
040593 ED 52       0341   			SBC     HL,DE			; DE: Address of the line in memory
040595 44          0342   			LD      B,H             	; BC: Amount to move
040596 4D          0343   			LD      C,L
040597 E1          0344   			POP     HL			; HL: Destination (current TOP value)
040598 D1          0345   			POP     DE			; DE: Source (new TOP value)
040599 28 02       0346   			JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
04059B ED B8       0347   			LDDR                    	; Otherwise, make space for the new line in the program
04059D C1          0348   ATEND:			POP     BC              	; BC: Line length
04059E D1          0349   			POP     DE              	; DE: Line number
04059F 23          0350   			INC     HL			; HL: Destination address
0405A0 71          0351   			LD      (HL),C          	; Store length
0405A1 23          0352   			INC     HL
0405A2 73          0353   			LD      (HL),E          	; Store line number
0405A3 23          0354   			INC     HL
0405A4 72          0355   			LD      (HL),D
0405A5 23          0356   			INC     HL
0405A6 11 00 01 04 0357   			LD      DE,BUFFER		; DE: Location of the new, tokenised line
0405AA EB          0358   			EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
0405AB 0D          0359   			DEC     C			; Subtract 3 from the number of bytes to copy to
0405AC 0D          0360   			DEC     C			; compensate for the 3 bytes stored above (length and line number)
0405AD 0D          0361   			DEC     C
0405AE ED B0       0362   			LDIR                    	; Add the line to the BASIC program
0405B0 37          0363   			SCF				; To flag we need to call CLEAN
0405B1 C9          0364   			RET
0405B2             0365   ;
0405B2             0366   ; List of tokens and keywords. If a keyword is followed by 0 then
0405B2             0367   ; it will only match with the keyword followed immediately by
0405B2             0368   ; a delimiter
0405B2             0369   ;
0405B2 80 41 4E 44 0370   KEYWDS:			DB    80H, "AND"
0405B6 94 41 42 53 0371   			DB    94H, "ABS"
0405BA 95 41 43 53 0372   			DB    95H, "ACS"
0405BE 96 41 44 56 0373   			DB    96H, "ADVAL"
       41 4C       
0405C4 97 41 53 43 0374   			DB    97H, "ASC"
0405C8 98 41 53 4E 0375   			DB    98H, "ASN"
0405CC 99 41 54 4E 0376   			DB    99H, "ATN"
0405D0 C6 41 55 54 0377   			DB    C6H, "AUTO"
       4F          
0405D5 9A 42 47 45 0378   			DB    9AH, "BGET", 0
       54 00       
0405DB D5 42 50 55 0379   			DB    D5H, "BPUT", 0
       54 00       
0405E1 FB 43 4F 4C 0380   			DB    FBH, "COLOUR"
       4F 55 52    
0405E8 FB 43 4F 4C 0381   			DB    FBH, "COLOR"
       4F 52       
0405EE D6 43 41 4C 0382   			DB    D6H, "CALL"
       4C          
0405F3 D7 43 48 41 0383   			DB    D7H, "CHAIN"
       49 4E       
0405F9 BD 43 48 52 0384   			DB    BDH, "CHR$"
       24          
0405FE D8 43 4C 45 0385   			DB    D8H, "CLEAR", 0
       41 52 00    
040605 D9 43 4C 4F 0386   			DB    D9H, "CLOSE", 0
       53 45 00    
04060C DA 43 4C 47 0387   			DB    DAH, "CLG", 0
       00          
040611 DB 43 4C 53 0388   			DB    DBH, "CLS", 0
       00          
040616 9B 43 4F 53 0389   			DB    9BH, "COS"
04061A 9C 43 4F 55 0390   			DB    9CH, "COUNT", 0
       4E 54 00    
040621 DC 44 41 54 0391   			DB    DCH, "DATA"
       41          
040626 9D 44 45 47 0392   			DB    9DH, "DEG"
04062A DD 44 45 46 0393   			DB    DDH, "DEF"
04062E C7 44 45 4C 0394   			DB    C7H, "DELETE"
       45 54 45    
040635 81 44 49 56 0395   			DB    81H, "DIV"
040639 DE 44 49 4D 0396   			DB    DEH, "DIM"
04063D DF 44 52 41 0397   			DB    DFH, "DRAW"
       57          
040642 E1 45 4E 44 0398   			DB    E1H, "ENDPROC", 0
       50 52 4F 43 
       00          
04064B E0 45 4E 44 0399   			DB    E0H, "END", 0
       00          
040650 E2 45 4E 56 0400   			DB    E2H, "ENVELOPE"
       45 4C 4F 50 
       45          
040659 8B 45 4C 53 0401   			DB    8BH, "ELSE"
       45          
04065E A0 45 56 41 0402   			DB    A0H, "EVAL"
       4C          
040663 9E 45 52 4C 0403   			DB    9EH, "ERL", 0
       00          
040668 85 45 52 52 0404   			DB    85H, "ERROR"
       4F 52       
04066E C5 45 4F 46 0405   			DB    C5H, "EOF", 0
       00          
040673 82 45 4F 52 0406   			DB    82H, "EOR"
040677 9F 45 52 52 0407   			DB    9FH, "ERR", 0
       00          
04067C A1 45 58 50 0408   			DB    A1H, "EXP"
040680 A2 45 58 54 0409   			DB    A2H, "EXT", 0
       00          
040685 E3 46 4F 52 0410   			DB    E3H, "FOR"
040689 A3 46 41 4C 0411   			DB    A3H, "FALSE", 0
       53 45 00    
040690 A4 46 4E    0412   			DB    A4H, "FN"
040693 E5 47 4F 54 0413   			DB    E5H, "GOTO"
       4F          
040698 BE 47 45 54 0414   			DB    BEH, "GET$"
       24          
04069D A5 47 45 54 0415   			DB    A5H, "GET"
0406A1 E4 47 4F 53 0416   			DB    E4H, "GOSUB"
       55 42       
0406A7 E6 47 43 4F 0417   			DB    E6H, "GCOL"
       4C          
0406AC 93 48 49 4D 0418   			DB    93H, "HIMEM", 0
       45 4D 00    
0406B3 E8 49 4E 50 0419   			DB    E8H, "INPUT"
       55 54       
0406B9 E7 49 46    0420   			DB    E7H, "IF"
0406BC BF 49 4E 4B 0421   			DB    BFH, "INKEY$"
       45 59 24    
0406C3 A6 49 4E 4B 0422   			DB    A6H, "INKEY"
       45 59       
0406C9 A8 49 4E 54 0423   			DB    A8H, "INT"
0406CD A7 49 4E 53 0424   			DB    A7H, "INSTR("
       54 52 28    
0406D4 C9 4C 49 53 0425   			DB    C9H, "LIST"
       54          
0406D9 86 4C 49 4E 0426   			DB    86H, "LINE"
       45          
0406DE C8 4C 4F 41 0427   			DB    C8H, "LOAD"
       44          
0406E3 92 4C 4F 4D 0428   			DB    92H, "LOMEM", 0
       45 4D 00    
0406EA EA 4C 4F 43 0429   			DB    EAH, "LOCAL"
       41 4C       
0406F0 C0 4C 45 46 0430   			DB    C0H, "LEFT$("
       54 24 28    
0406F7 A9 4C 45 4E 0431   			DB    A9H, "LEN"
0406FB E9 4C 45 54 0432   			DB    E9H, "LET"
0406FF AB 4C 4F 47 0433   			DB    ABH, "LOG"
040703 AA 4C 4E    0434   			DB    AAH, "LN"
040706 C1 4D 49 44 0435   			DB    C1H, "MID$("
       24 28       
04070C EB 4D 4F 44 0436   			DB    EBH, "MODE"
       45          
040711 83 4D 4F 44 0437   			DB    83H, "MOD"
040715 EC 4D 4F 56 0438   			DB    ECH, "MOVE"
       45          
04071A ED 4E 45 58 0439   			DB    EDH, "NEXT"
       54          
04071F CA 4E 45 57 0440   			DB    CAH, "NEW", 0
       00          
040724 AC 4E 4F 54 0441   			DB    ACH, "NOT"
040728 CB 4F 4C 44 0442   			DB    CBH, "OLD", 0
       00          
04072D EE 4F 4E    0443   			DB    EEH, "ON"
040730 87 4F 46 46 0444   			DB    87H, "OFF"
040734 84 4F 52    0445   			DB    84H, "OR"
040737 8E 4F 50 45 0446   			DB    8EH, "OPENIN"
       4E 49 4E    
04073E AE 4F 50 45 0447   			DB    AEH, "OPENOUT"
       4E 4F 55 54 
040746 AD 4F 50 45 0448   			DB    ADH, "OPENUP"
       4E 55 50    
04074D FF 4F 53 43 0449   			DB    FFH, "OSCLI"
       4C 49       
040753 F1 50 52 49 0450   			DB    F1H, "PRINT"
       4E 54       
040759 90 50 41 47 0451   			DB    90H, "PAGE", 0
       45 00       
04075F 8F 50 54 52 0452   			DB    8FH, "PTR", 0
       00          
040764 AF 50 49 00 0453   			DB    AFH, "PI", 0
040768 F0 50 4C 4F 0454   			DB    F0H, "PLOT"
       54          
04076D B0 50 4F 49 0455   			DB    B0H, "POINT("
       4E 54 28    
040774 F2 50 52 4F 0456   			DB    F2H, "PROC"
       43          
040779 B1 50 4F 53 0457   			DB    B1H, "POS", 0
       00          
04077E CE 50 55 54 0458   			DB    CEH, "PUT"
040782 F8 52 45 54 0459   			DB    F8H, "RETURN", 0
       55 52 4E 00 
04078A F5 52 45 50 0460   			DB    F5H, "REPEAT"
       45 41 54    
040791 F6 52 45 50 0461   			DB    F6H, "REPORT", 0
       4F 52 54 00 
040799 F3 52 45 41 0462   			DB    F3H, "READ"
       44          
04079E F4 52 45 4D 0463   			DB    F4H, "REM"
0407A2 F9 52 55 4E 0464   			DB    F9H, "RUN", 0
       00          
0407A7 B2 52 41 44 0465   			DB    B2H, "RAD"
0407AB F7 52 45 53 0466   			DB    F7H, "RESTORE"
       54 4F 52 45 
0407B3 C2 52 49 47 0467   			DB    C2H, "RIGHT$("
       48 54 24 28 
0407BB B3 52 4E 44 0468   			DB    B3H, "RND", 0
       00          
0407C0 CC 52 45 4E 0469   			DB    CCH, "RENUMBER"
       55 4D 42 45 
       52          
0407C9 88 53 54 45 0470   			DB    88H, "STEP"
       50          
0407CE CD 53 41 56 0471   			DB    CDH, "SAVE"
       45          
0407D3 B4 53 47 4E 0472   			DB    B4H, "SGN"
0407D7 B5 53 49 4E 0473   			DB    B5H, "SIN"
0407DB B6 53 51 52 0474   			DB    B6H, "SQR"
0407DF 89 53 50 43 0475   			DB    89H, "SPC"
0407E3 C3 53 54 52 0476   			DB    C3H, "STR$"
       24          
0407E8 C4 53 54 52 0477   			DB    C4H, "STRING$("
       49 4E 47 24 
       28          
0407F1 D4 53 4F 55 0478   			DB    D4H, "SOUND"
       4E 44       
0407F7 FA 53 54 4F 0479   			DB    FAH, "STOP", 0
       50 00       
0407FD B7 54 41 4E 0480   			DB    B7H, "TAN"
040801 8C 54 48 45 0481   			DB    8CH, "THEN"
       4E          
040806 B8 54 4F    0482   			DB    B8H, "TO"
040809 8A 54 41 42 0483   			DB    8AH, "TAB("
       28          
04080E FC 54 52 41 0484   			DB    FCH, "TRACE"
       43 45       
040814 91 54 49 4D 0485   			DB    91H, "TIME", 0
       45 00       
04081A B9 54 52 55 0486   			DB    B9H, "TRUE", 0
       45 00       
040820 FD 55 4E 54 0487   			DB    FDH, "UNTIL"
       49 4C       
040826 BA 55 53 52 0488   			DB    BAH, "USR"
04082A EF 56 44 55 0489   			DB    EFH, "VDU"
04082E BB 56 41 4C 0490   			DB    BBH, "VAL"
040832 BC 56 50 4F 0491   			DB    BCH, "VPOS", 0
       53 00       
040838 FE 57 49 44 0492   			DB    FEH, "WIDTH"
       54 48       
04083E D3 48 49 4D 0493   			DB    D3H, "HIMEM"
       45 4D       
040844 D2 4C 4F 4D 0494   			DB    D2H, "LOMEM"
       45 4D       
04084A D0 50 41 47 0495   			DB    D0H, "PAGE"
       45          
04084F CF 50 54 52 0496   			DB    CFH, "PTR"
040853 D1 54 49 4D 0497   			DB    D1H, "TIME"
       45          
040858             0498   ;
040858             0499   ; These are indexed from the ERRWDS table
040858             0500   ;
040858 01 4D 69 73 0501   			DB    01H, "Missing "
       73 69 6E 67 
       20          
040861 02 4E 6F 20 0502   			DB    02H, "No such "
       73 75 63 68 
       20          
04086A 03 42 61 64 0503   			DB    03H, "Bad "
       20          
04086F 04 20 72 61 0504   			DB    04H, " range"
       6E 67 65    
040876 05 76 61 72 0505   			DB    05H, "variable"
       69 61 62 6C 
       65          
04087F 06 4F 75 74 0506   			DB    06H, "Out of"
       20 6F 66    
040886 07 4E 6F 20 0507   			DB    07H, "No "
04088A 08 20 73 70 0508   			DB    08H, " space"
       61 63 65    
040891             0509   
040891             0510   KEYWDL:			EQU     $-KEYWDS
040891 FF FF       0511   			DW    -1
040893             0512   ;
040893             0513   ; Error messages
040893             0514   ;
040893 07 72 6F 6F 0515   ERRWDS:			DB    7, "room", 0		;  0: No room
       6D 00       
040899 06 04 00    0516   			DB    6, 4, 0			;  1: Out of range
04089C 00          0517   			DB    0				;  2: *
04089D 00          0518   			DB    0				;  3: *
04089E 4D 69 73 74 0519   			DB    "Mistake", 0		;  4: Mistake
       61 6B 65 00 
0408A6 01 2C 00    0520   			DB    1, ",", 0			;  5: Missing ,
0408A9 54 79 70 65 0521   			DB    "Type mismatch", 0	;  6: Type mismatch
       20 6D 69 73 
       6D 61 74 63 
       68 00       
0408B7 07 A4 00    0522   			DB    7, FN, 0			;  7: No FN
0408BA 00          0523   			DB    0				;  8: *
0408BB 01 22 00    0524   			DB    1, 34, 0			;  9: Missing "
0408BE 03 DE 00    0525   			DB    3, DIM, 0			; 10: Bad DIM
0408C1 DE 08 00    0526   			DB    DIM, 8, 0			; 11: DIM space
0408C4 4E 6F 74 20 0527   			DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
       EA 00       
0408CA 07 F2 00    0528   			DB    7, PROC, 0		; 13: No PROC
0408CD 41 72 72 61 0529   			DB    "Array", 0		; 14: Array
       79 00       
0408D3 53 75 62 73 0530   			DB    "Subscript", 0		; 15: Subscript
       63 72 69 70 
       74 00       
0408DD 53 79 6E 74 0531   			DB    "Syntax error", 0		; 16: Syntax error
       61 78 20 65 
       72 72 6F 72 
       00          
0408EA 45 73 63 61 0532   			DB    "Escape", 0		; 17: Escape
       70 65 00    
0408F1 44 69 76 69 0533   			DB    "Division by zero", 0	; 18: Division by zero
       73 69 6F 6E 
       20 62 79 20 
       7A 65 72 6F 
       00          
040902 53 74 72 69 0534   			DB    "String too long", 0	; 19: String too long
       6E 67 20 74 
       6F 6F 20 6C 
       6F 6E 67 00 
040912 54 6F 6F 20 0535   			DB    "Too big", 0		; 20: Too big
       62 69 67 00 
04091A 2D 76 65 20 0536   			DB    "-ve root", 0		; 21: -ve root
       72 6F 6F 74 
       00          
040923 4C 6F 67 04 0537   			DB    "Log", 4, 0		; 22: Log range
       00          
040928 41 63 63 75 0538   			DB    "Accuracy lost", 0	; 23: Accuracy lost
       72 61 63 79 
       20 6C 6F 73 
       74 00       
040936 45 78 70 04 0539   			DB    "Exp", 4, 0		; 24: Exp range
       00          
04093B 00          0540   			DB    0				; 25: *
04093C 02 05 00    0541   			DB    2, 5, 0			; 26: No such variable
04093F 01 29 00    0542   			DB    1, ")", 0			; 27: Missing )
040942 03 48 45 58 0543   			DB    3, "HEX", 0		; 28: Bad HEX
       00          
040947 02 A4 2F F2 0544   			DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
       00          
04094C 03 63 61 6C 0545   			DB    3, "call", 0		; 30: Bad call
       6C 00       
040952 41 72 67 75 0546   			DB    "Arguments", 0		; 31: Arguments
       6D 65 6E 74 
       73 00       
04095C 07 E3 00    0547   			DB    7, FOR, 0			; 32: No FOR
04095F 43 61 6E 27 0548   			DB    "Can't match ", FOR, 0	; 33: Can't match FOR
       74 20 6D 61 
       74 63 68 20 
       E3 00       
04096D E3 20 05 00 0549   			DB    FOR, " ", 5, 0		; 34: FOR variable
040971 00          0550   			DB    0				; 35: *
040972 07 B8 00    0551   			DB    7, TO, 0			; 36: No TO
040975 00          0552   			DB    0				; 37: *
040976 07 E4 00    0553   			DB    7, GOSUB, 0		; 38: No GOSUB
040979 EE 20 73 79 0554   			DB    ON_, " syntax", 0		; 39: ON syntax
       6E 74 61 78 
       00          
040982 EE 04 00    0555   			DB    ON_, 4, 0			; 40: ON range
040985 02 6C 69 6E 0556   			DB    2, "line", 0		; 41: No such line
       65 00       
04098B 06 20 DC 00 0557   			DB    6, " ", DATA_, 0		; 42: Out of DATA
04098F 07 F5 00    0558   			DB    7, REPEAT, 0		; 43: No REPEAT
040992 00          0559   			DB    0				; 44: *
040993 01 23 00    0560   			DB    1, "#", 0			; 45: Missing #
040996             0561   ;
040996             0562   ; COMMANDS:
040996             0563   ;
040996             0564   ; DELETE line,line
040996             0565   ;
040996 CD 95 0C 04 0566   DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
04099A CD 9D 10 04 0567   			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
04099E 7E          0568   DELET1:			LD      A,(HL)			; Check whether it's the last line
04099F B7          0569   			OR      A
0409A0 CA 27 0A 04 0570   			JP      Z,WARMNC		; Yes, so do nothing
0409A4 23          0571   			INC     HL			; Skip the line length byte
0409A5 11 00 00 00 0572   			LD	DE, 0			; Clear DE
0409A9 5E          0573   			LD      E,(HL)			; Fetch the line number in DE
0409AA 23          0574   			INC     HL
0409AB 56          0575   			LD      D,(HL)
0409AC 7A          0576   			LD      A,D			; If the line number is zero then
0409AD B3          0577   			OR      E
0409AE 28 1D       0578   			JR      Z,CLOOP1        	; Do nothing
0409B0 2B          0579   			DEC     HL			; Decrement BASIC program pointer back to length
0409B1 2B          0580   			DEC     HL
0409B2 EB          0581   			EX      DE,HL			; Check if we've gone past the terminating line
0409B3 37          0582   			SCF
0409B4 ED 42       0583   			SBC     HL,BC
0409B6 EB          0584   			EX      DE,HL
0409B7 30 6E       0585   			JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
0409B9 C5          0586   			PUSH    BC
0409BA CD 4C 0C 04 0587   			CALL    DEL			; Delete the line pointed to by HL
0409BE C1          0588   			POP     BC
0409BF 18 DD       0589   			JR      DELET1			; And loop round to the next line
0409C1             0590   ;
0409C1             0591   ; LISTO expr
0409C1             0592   ;
0409C1 FD 23       0593   LISTO:			INC     IY              	; Skip "O" byte
0409C3 CD 8A 12 04 0594   			CALL    EXPRI			; Get expr
0409C7 D9          0595   			EXX
0409C8 7D          0596   			LD      A,L
0409C9 32 40 03 04 0597   			LD      (LISTON),A		; Store in LISTON sysvar
0409CD C3 CA 04 04 0598   CLOOP1:			JP      CLOOP
0409D1             0599   ;
0409D1             0600   ; LIST
0409D1             0601   ; LIST line
0409D1             0602   ; LIST line,line [IF string]
0409D1             0603   ; LIST ,line
0409D1             0604   ; LIST line,
0409D1             0605   ;
0409D1 FE 4F       0606   LIST_:			CP      'O'			; Check for O (LISTO)
0409D3 28 EC       0607   			JR      Z,LISTO			; and jump to LISTO if zero
0409D5 CD 9D 10 04 0608   			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0409D9 CD 56 12 04 0609   			CALL    NXT			; Skip space
0409DD FE E7       0610   			CP      TIF             	; Check for IF clause (token IF)
0409DF 3E 00       0611   			LD      A,0             	; Initialise the IF clause string length
0409E1 20 17       0612   			JR      NZ,LISTB		; If there is no IF clause, skip the next bit
0409E3             0613   ;
0409E3 FD 23       0614   			INC     IY              	; Skip the IF token
0409E5 CD 56 12 04 0615   			CALL    NXT             	; And skip any spaces
0409E9 EB          0616   			EX      DE,HL			; DE: Address in memory
0409EA FD E5       0617   			PUSH    IY			; LD IY, HL
0409EC E1          0618   			POP     HL              	; HL is now the address of the tokenised line
0409ED 3E 0D       0619   			LD      A,CR
0409EF C5          0620   			PUSH    BC			; Stack the second line number arg
0409F0 01 00 01 00 0621   			LD      BC,256
0409F4 ED B1       0622   			CPIR                    	; Locate CR byte
0409F6 79          0623   			LD      A,C
0409F7 2F          0624   			CPL                    	 	; A: Substring length (of IF clause)
0409F8 C1          0625   			POP     BC			; Restore the second line number arg
0409F9 EB          0626   			EX      DE,HL			; HL: Address in memory
0409FA             0627   ;
0409FA 5F          0628   LISTB:			LD      E,A             	; E: IF clause string length
0409FB 78          0629   			LD      A,B			; Check whether a second line number was passed (BC!=0)
0409FC B1          0630   			OR      C
0409FD 20 01       0631   			JR      NZ,LISTA		; If there isn't a second line number
0409FF 0B          0632   			DEC     BC			; then we set it to the maximum of 65535
040A00             0633   ;
040A00 D9          0634   LISTA:			EXX
040A01 DD 21 40 03 0635   			LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
       04          
040A06 01 00 00 00 0636   			LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
040A0A D9          0637   			EXX
040A0B 3E 14       0638   			LD      A,20			; Number of lines to list
040A0D             0639   ;
040A0D C5          0640   LISTC:			PUSH    BC              	; Save second line number
040A0E D5          0641   			PUSH    DE              	; Save IF clause length
040A0F E5          0642   			PUSH    HL              	; Save BASIC program counter
040A10 08          0643   			EX      AF,AF'
040A11             0644   ;
040A11             0645   ; BBC BASIC for Z80 lines are stored as follows:
040A11             0646   ;
040A11             0647   ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
040A11             0648   ; - [&00] [&FF] [&FF]: End of program marker
040A11             0649   ;
040A11             0650   ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
040A11             0651   ;
040A11 7E          0652   			LD      A,(HL)			; Check for end of program marker
040A12 B7          0653   			OR      A			; If found
040A13 28 12       0654   			JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
040A15             0655   ;
040A15             0656   ; Check if past terminating line number
040A15             0657   ;
040A15 7B          0658   			LD      A,E             	; A: IF clause length
040A16 23          0659   			INC     HL			; Skip the length byte
040A17 11 00 00 00 0660   			LD	DE,0			; Clear DE
040A1B 5E          0661   			LD      E,(HL)			; Fetch the line number in DE
040A1C 23          0662   			INC     HL
040A1D 56          0663   			LD      D,(HL)
040A1E 2B          0664   			DEC     HL			; Step HL back to the length byte
040A1F 2B          0665   			DEC     HL
040A20 D5          0666   			PUSH    DE             	 	; Push the line number on the stack
040A21 EB          0667   			EX      DE,HL			; HL: line number
040A22 37          0668   			SCF				; Do a 16-bit compare of HL and DE
040A23 ED 42       0669   			SBC     HL,BC
040A25 EB          0670   			EX      DE,HL
040A26 D1          0671   			POP     DE              	; Restore the line number
040A27 D2 C9 04 04 0672   WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
040A2B 4E          0673   			LD      C,(HL)          	; C: Line length + 4
040A2C 47          0674   			LD      B,A             	; B: IF clause length
040A2D             0675   ;
040A2D             0676   ; Check if "UNLISTABLE":
040A2D             0677   ;
040A2D 7A          0678   			LD      A,D			; TODO: What is "UNLISTABLE?"
040A2E B3          0679   			OR      E
040A2F CA CA 04 04 0680   			JP      Z,CLOOP
040A33             0681   ;
040A33             0682   ; Check for IF clause:
040A33             0683   ;
040A33 23          0684   			INC     HL			; Skip the length
040A34 23          0685   			INC     HL			; Skip the line number
040A35 23          0686   			INC     HL              	; HL: Address of the tokenised BASIC line
040A36 0D          0687   			DEC     C			;  C: Line length
040A37 0D          0688   			DEC     C
040A38 0D          0689   			DEC     C
040A39 0D          0690   			DEC     C
040A3A D5          0691   			PUSH    DE              	; Save the line number
040A3B E5          0692   			PUSH    HL              	; Save the BASIC program address
040A3C AF          0693   			XOR     A               	;
040A3D B8          0694   			CP      B              	 	; Check for an IF clause (B!=0)
040A3E FD E5       0695   			PUSH    IY			; LD IY, DE
040A40 D1          0696   			POP     DE              	; DE: Address of the IF clause string in the input buffer
040A41 C4 A6 12 04 0697   			CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
040A45 E1          0698   			POP     HL              	; Restore BASIC program address
040A46 D1          0699   			POP     DE              	; Restore line number
040A47 FD E5       0700   			PUSH    IY
040A49 CC DC 0C 04 0701   			CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
040A4D FD E1       0702   			POP     IY
040A4F             0703   ;
040A4F 08          0704   			EX      AF,AF'
040A50 3D          0705   			DEC     A			; Decrement line list counter
040A51 CD C3 12 04 0706   			CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
040A55 E1          0707   			POP     HL             	 	; Restore BASIC program address to beginning of line
040A56 11 00 00 00 0708   			LD	DE,0
040A5A 5E          0709   			LD      E,(HL)			; Fetch the length of line in DE
040A5B 19          0710   			ADD     HL,DE           	; Go to the next line
040A5C D1          0711   			POP     DE              	; Restore IF clause length
040A5D C1          0712   			POP     BC              	; Restore second line number
040A5E 18 AD       0713   			JR      LISTC			; Loop back to do next line
040A60             0714   ;
040A60             0715   ; RENUMBER
040A60             0716   ; RENUMBER start
040A60             0717   ; RENUMBER start,increment
040A60             0718   ; RENUMBER ,increment
040A60             0719   ;
040A60 CD C0 0C 04 0720   RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
040A64 CD 75 10 04 0721   			CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
040A68 D9          0722   			EXX
040A69 2A 14 03 04 0723   			LD      HL,(PAGE_)		; HL: Top of program
040A6D ED 5B 1A 03 0724   			LD      DE,(LOMEM)		; DE: Start address of the heap
       04          
040A72             0725   ;
040A72             0726   ; Build the table
040A72             0727   ;
040A72 7E          0728   RENUM1:			LD      A,(HL)          	; Fetch the line length byte
040A73 B7          0729   			OR      A			; Is it zero, i.e. the end of program marker?
040A74 28 36       0730   			JR      Z,RENUM2		; Yes, so skip to the next part
040A76 23          0731   			INC     HL
040A77 4E          0732   			LD      C,(HL)          	; BC: The OLD line number
040A78 23          0733   			INC     HL
040A79 46          0734   			LD      B,(HL)
040A7A 78          0735   			LD      A,B			; Check whether the line number is zero - we only need to check the LSW
040A7B B1          0736   			OR      C
040A7C CA CA 04 04 0737   			JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
040A80 EB          0738   			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
040A81 71          0739   			LD      (HL),C			; Store the OLD line number in the heap
040A82 23          0740   			INC     HL
040A83 70          0741   			LD      (HL),B
040A84 23          0742   			INC     HL
040A85 D9          0743   			EXX				; HL: line number, BC: increment (16-bit values)
040A86 E5          0744   			PUSH    HL			; HL: Stack the NEW line number value
040A87 52 09       0745   			ADD.S   HL,BC           	; Add the increment
040A89 DA 6F 10 04 0746   			JP      C,TOOBIG_MAIN        	; If > 65535, then error: "Too big"
040A8D D9          0747   			EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
040A8E C1          0748   			POP     BC			; BC: Pop the NEW line number value off the stack
040A8F 71          0749   			LD      (HL),C			; Store the NEW line number in the heap
040A90 23          0750   			INC     HL
040A91 70          0751   			LD      (HL),B
040A92 23          0752   			INC     HL
040A93 EB          0753   			EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
040A94 2B          0754   			DEC     HL			; Back up to the line length byte
040A95 2B          0755   			DEC     HL
040A96 01 00 00 00 0756   			LD	BC, 0
040A9A 4E          0757   			LD      C,(HL)			; BC: Line length
040A9B 09          0758   			ADD	HL,BC           	; Advance HL to next line
040A9C EB          0759   			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
040A9D E5          0760   			PUSH    HL
040A9E 24          0761   			INC     H			; Increment to next page
040A9F ED 72       0762   			SBC     HL,SP			; Subtract from SP
040AA1 E1          0763   			POP     HL
040AA2 EB          0764   			EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
040AA3 38 CD       0765   			JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
040AA5 CD C1 0B 04 0766   			CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
040AA9 CC          0767   			DB    	REN
040AAA 08          0768   			DB    	8
040AAB 00          0769   			DB    	0
040AAC             0770   ;
040AAC             0771   ; At this point a list of BASIC line numbers have been written to the heap
040AAC             0772   ; as word pairs:
040AAC             0773   ; - DW: The OLD line number
040AAC             0774   ; - DW: The NEW line number
040AAC             0775   ;
040AAC EB          0776   RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
040AAD 36 FF       0777   			LD      (HL),-1			; Mark the end with FFFFh
040AAF 23          0778   			INC     HL
040AB0 36 FF       0779   			LD      (HL),-1
040AB2 ED 5B 1A 03 0780   			LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
       04          
040AB7 D9          0781   			EXX
040AB8 2A 14 03 04 0782   			LD      HL,(PAGE_)		; HL: Start of the BASIC program area
040ABC 4E          0783   RENUM3:			LD      C,(HL)			; Fetch the first line length byte
040ABD 79          0784   			LD      A,C			; If it is zero, then no program, so...
040ABE B7          0785   			OR      A
040ABF CA C9 04 04 0786   			JP      Z,WARM			; Jump to warm start
040AC3 D9          0787   			EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
040AC4 EB          0788   			EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
040AC5 23          0789   			INC     HL			; Skip to the NEW line number
040AC6 23          0790   			INC     HL
040AC7 5E          0791   			LD      E,(HL)			; DE: The NEW line number
040AC8 23          0792   			INC     HL
040AC9 56          0793   			LD      D,(HL)
040ACA 23          0794   			INC     HL
040ACB D5          0795   			PUSH    DE			; Stack the NEW line number
040ACC EB          0796   			EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
040ACD 22 23 03 04 0797   			LD      (LINENO),HL		; Store the line number in LINENO
040AD1 D9          0798   			EXX				; HL: Pointer to the BASIC program area
040AD2 D1          0799   			POP     DE			; DE: The NEW line number
040AD3 23          0800   			INC     HL
040AD4 73          0801   			LD      (HL),E          	; Write out the NEW line number to the BASIC program
040AD5 23          0802   			INC     HL
040AD6 72          0803   			LD      (HL),D
040AD7 23          0804   			INC     HL
040AD8 0D          0805   			DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
040AD9 0D          0806   			DEC     C
040ADA 0D          0807   			DEC     C
040ADB 79          0808   			LD	A,C
040ADC 01 00 00 00 0809   			LD	BC,0
040AE0 4F          0810   			LD	C,A			; BC: Line length
040AE1             0811   ;
040AE1 3E 8D       0812   RENUM7:			LD      A,LINO			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
040AE3 ED B1       0813   			CPIR                    	; Search for the token
040AE5 20 D5       0814   			JR      NZ,RENUM3		; If not found, then loop to process the next line
040AE7             0815   ;
040AE7             0816   ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
040AE7             0817   ;
040AE7 C5          0818   			PUSH    BC			; Stack everything
040AE8 E5          0819   			PUSH    HL
040AE9 E5          0820   			PUSH    HL			; HL: Pointer to encoded line number
040AEA FD E1       0821   			POP     IY			; IY: Pointer to encoded line number
040AEC D9          0822   			EXX
040AED CD DF 12 04 0823   			CALL    DECODE			; Decode the encoded line number (in HL')
040AF1 D9          0824   			EXX				; HL: Decoded line number
040AF2 44          0825   			LD      B,H			; BC: Decoded line number
040AF3 4D          0826   			LD      C,L
040AF4 2A 1A 03 04 0827   			LD      HL,(LOMEM)		; HL: Pointer to heap
040AF8             0828   ;
040AF8             0829   ; This section of code cross-references the decoded (OLD) line number with the list
040AF8             0830   ; created previously in the global heap
040AF8             0831   ;
040AF8 5E          0832   RENUM4:			LD      E,(HL)          	; DE: The OLD line number
040AF9 23          0833   			INC     HL
040AFA 56          0834   			LD      D,(HL)
040AFB 23          0835   			INC     HL
040AFC EB          0836   			EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
040AFD B7          0837   			OR      A               	; Clear the carry and...
040AFE 52 ED 42    0838   			SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
040B01 EB          0839   			EX      DE,HL			; HL: Pointer in the global heap
040B02 5E          0840   			LD      E,(HL)          	; DE: The NEW line number
040B03 23          0841   			INC     HL
040B04 56          0842   			LD      D,(HL)
040B05 23          0843   			INC     HL
040B06 38 F0       0844   			JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
040B08 EB          0845   			EX      DE,HL			; DE: Pointer in the global heap
040B09 28 1D       0846   			JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
040B0B             0847   ;
040B0B CD DA 11 04 0848   			CALL    TELL			; Display this error if the line number is not found
040B0F 46 61 69 6C 0849   			DB    	"Failed at "
       65 64 20 61 
       74 20       
040B19 00          0850   			DB    	0
040B1A 2A 23 03 04 0851   			LD      HL,(LINENO)
040B1E CD 41 0E 04 0852   			CALL    PBCDL
040B22 CD 91 0D 04 0853   			CALL    CRLF
040B26 18 07       0854   			JR      RENUM6			; And carry on renumbering
040B28             0855   ;
040B28             0856   ; This snippet re-encodes the line number in the BASIC program
040B28             0857   ;
040B28 D1          0858   RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
040B29 D5          0859   			PUSH    DE
040B2A 1B          0860   			DEC     DE			; Back up a byte to the LINO token
040B2B CD A6 11 04 0861   			CALL    ENCODE          	; Re-write the new line number out
040B2F E1          0862   RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
040B30 C1          0863   			POP     BC			; BC: The remaining line length
040B31 18 AE       0864   			JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
040B33             0865   ;
040B33             0866   ; AUTO
040B33             0867   ; AUTO start,increment
040B33             0868   ; AUTO start
040B33             0869   ; AUTO ,increment
040B33             0870   ;
040B33 CD 75 10 04 0871   AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
040B37 22 29 03 04 0872   			LD      (AUTONO),HL		; Store the start in AUTONO
040B3B 79          0873   			LD      A,C			; Increment is 8 bit (0-255)
040B3C 32 41 03 04 0874   			LD      (INCREM),A		; Store that in INCREM
040B40 18 2E       0875   			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
040B42             0876   ;
040B42             0877   ; BAD
040B42             0878   ; NEW
040B42             0879   ;
040B42 CD DA 11 04 0880   BAD:			CALL    TELL            	; Output "Bad program" error
040B46 03          0881   			DB    3				; Token for "BAD"
040B47 70 72 6F 67 0882   			DB    "program"
       72 61 6D    
040B4E 0D          0883   			DB    CR
040B4F 0A          0884   			DB    LF
040B50 00          0885   			DB    0				; Falls through to NEW
040B51             0886   ;
040B51 CD B6 0C 04 0887   NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
040B55 18 19       0888   			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
040B57             0889   ;
040B57             0890   ; OLD
040B57             0891   ;
040B57 2A 14 03 04 0892   OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
040B5B E5          0893   			PUSH    HL			; Stack it
040B5C 23          0894   			INC     HL			; Skip the potential length byte of first line of code
040B5D 23          0895   			INC     HL			; And the line number word
040B5E 23          0896   			INC     HL
040B5F 01 FC 00 00 0897   			LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
040B63 3E 0D       0898   			LD      A,CR
040B65 ED B1       0899   			CPIR
040B67 20 D9       0900   			JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
040B69 7D          0901   			LD      A,L			; It could still be garbage though! Store the position in A; this requires
040B6A E1          0902   			POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
040B6B 77          0903   			LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
040B6C CD 89 0C 04 0904   			CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
040B70 C3 CA 04 04 0905   CLOOP0:			JP      CLOOP			; Jump back to the command loop
040B74             0906   ;
040B74             0907   ; LOAD filename
040B74             0908   ;
040B74 CD FC 12 04 0909   LOAD:			CALL    EXPRS           	; Get the filename
040B78 3E 0D       0910   			LD      A,CR			; DE points to the last byte of filename in ACCS
040B7A 12          0911   			LD      (DE),A			; Terminate filename with a CR
040B7B CD 69 0C 04 0912   			CALL    LOAD0			; Load the file in, then CLEAN
040B7F CD C0 0C 04 0913   			CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
040B83 18 21       0914   			JR      WARM0			; Jump back to the command loop
040B85             0915   ;
040B85             0916   ; SAVE filename
040B85             0917   ;
040B85 CD 95 0C 04 0918   SAVE:			CALL    SETTOP          	; Set TOP sysvar
040B89 CD FC 12 04 0919   			CALL    EXPRS           	; Get the filename
040B8D 3E 0D       0920   			LD      A,CR			; Terminate the filename with a CR
040B8F 12          0921   			LD      (DE),A
040B90 ED 5B 14 03 0922   			LD      DE,(PAGE_)		; DE: Start of program memory
       04          
040B95 2A 17 03 04 0923   			LD      HL,(TOP)		; HL: Top of program memory
040B99 B7          0924   			OR      A			; Calculate program size (TOP-PAGE)
040B9A ED 52       0925   			SBC     HL,DE
040B9C 44          0926   			LD      B,H             	; BC: Length of program in bytes
040B9D 4D          0927   			LD      C,L
040B9E 21 00 00 04 0928   			LD      HL,ACCS			; HL: Address of the filename
040BA2 CD 18 13 04 0929   			CALL    OSSAVE			; Call the SAVE routine in patch.asm
040BA6 C3 C9 04 04 0930   WARM0:			JP      WARM			; Jump back to the command loop
040BAA             0931   
040BAA             0932   ;
040BAA             0933   ; ERROR
040BAA             0934   ; Called whenever BASIC needs to halt with an error
040BAA             0935   ; Error messages are indexed from 0
040BAA             0936   ; Inputs:
040BAA             0937   ;  A: Error number
040BAA             0938   ;
040BAA ED 7B 20 03 0939   ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
040BAF 21 93 08 04 0940   			LD      HL,ERRWDS		; Index into the error string table
040BB3 B7          0941   			OR      A			; We don't need to search for the first error
040BB4 28 0A       0942   			JR      Z,ERROR1		; So skip the search routine
040BB6             0943   ;
040BB6             0944   ; Search the error table for error #A
040BB6             0945   ; HL will end up being the pointer into the correct error
040BB6             0946   ; There is no bounds checking on this, so invalid error numbers will probably output garbage
040BB6             0947   ;
040BB6 47          0948   			LD      B,A             	; Store error number in B
040BB7 08          0949   			EX      AF,AF'			; Store error number in AF'
040BB8 AF          0950   			XOR     A
040BB9 BE          0951   ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
040BBA 23          0952   			INC     HL			; Increment the string pointer
040BBB 20 FC       0953   			JR      NZ,ERROR0		; Loop until with hit a 0
040BBD 10 FA       0954   			DJNZ    ERROR0			; Decrements the error number and loop until 0
040BBF 08          0955   			EX      AF,AF'			; Restore the error number from AF'
040BC0             0956   ;
040BC0             0957   ; At this point HL points to the tokenised error string
040BC0             0958   ;
040BC0 E5          0959   ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
040BC1             0960   
040BC1             0961   ;
040BC1             0962   ; EXTERR
040BC1             0963   ; Inputs:
040BC1             0964   ;  A: Error number
040BC1             0965   ;
040BC1             0966   ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
040BC1             0967   ; The error text immediately follows the CALL to EXTERR, for example:
040BC1             0968   ; > CALL  EXTERR
040BC1             0969   ; > DB    "Silly", 0
040BC1             0970   ; So we can get the address of the string by popping the return address off the stack
040BC1             0971   ;
040BC1 E1          0972   EXTERR:			POP     HL			; Pop the error string pointer
040BC2 22 2F 03 04 0973   			LD      (ERRTXT),HL		; Store in ERRTXT sysvar
040BC6 ED 7B 20 03 0974   			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
040BCB 32 3F 03 04 0975   			LD      (ERR),A			; Store error number in ERR sysvar
040BCF CD F8 0D 04 0976   			CALL    SETLIN			; Get line number
040BD3 22 33 03 04 0977   			LD      (ERL),HL		; Store in ERL sysvar
040BD7 B7          0978   			OR      A			; Is error number 0?
040BD8 28 0D       0979   			JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
040BDA             0980   ;
040BDA 2A 2C 03 04 0981   			LD      HL,(ERRTRP)		; Check whether the error is trapped
040BDE 7C          0982   			LD      A,H
040BDF B5          0983   			OR      L
040BE0 E5          0984   			PUSH    HL			; HL: Error line
040BE1 FD E1       0985   			POP     IY			; IY: HL
040BE3 C2 70 12 04 0986   			JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
040BE7             0987   ;
040BE7 21 00 00 00 0988   ERROR2:			LD      HL,0
040BEB 22 29 03 04 0989   			LD      (AUTONO),HL		; Cancel AUTO
040BEF 22 26 03 04 0990   			LD      (TRACEN),HL     	; Cancel TRACE
040BF3 CD 35 13 04 0991   			CALL    RESET           	; Reset OPSYS
040BF7 CD 91 0D 04 0992   			CALL    CRLF			; Output newline
040BFB CD CC 11 04 0993   			CALL    REPORT          	; Output the error message
040BFF CD 2C 0E 04 0994   			CALL    SAYLN			; Output " at line nnnn" message.
040C03 1E 00       0995   			LD      E,0			; Close all files
040C05 DC 51 13 04 0996   			CALL    C,OSSHUT
040C09 CD 91 0D 04 0997   			CALL    CRLF			; Output newline
040C0D C3 CA 04 04 0998   			JP      CLOOP			; Back to CLOOP
040C11             0999   ;
040C11             1000   ; SUBROUTINES:
040C11             1001   ;
040C11             1002   ; LEX - SEARCH FOR KEYWORDS
040C11             1003   ;   Inputs: HL = start of keyword table
040C11             1004   ;           IY = start of match text
040C11             1005   ;  Outputs: If found, Z-flag set, A=token.
040C11             1006   ;           If not found, Z-flag reset, A=(IY).
040C11             1007   ;           IY updated (if NZ, IY unchanged).
040C11             1008   ; Destroys: A,B,H,L,IY,F
040C11             1009   ;
040C11 21 B2 05 04 1010   LEX:			LD      HL,KEYWDS		; Address of the keywords table
040C15             1011   ;
040C15 FD 7E 00    1012   LEX0:			LD      A,(IY)			; Fetch the character to match
040C18 46          1013   			LD      B,(HL)			; B: The token from the keywords table
040C19 23          1014   			INC     HL			; Increment the pointer in the keywords table
040C1A BE          1015   			CP      (HL)			; Compare the first characters
040C1B 28 08       1016   			JR      Z,LEX2			; If there is a match, then skip to LEX2
040C1D D8          1017   			RET     C               	; No match, so fail
040C1E             1018   ;
040C1E             1019   ; This snippet of code skips to the next token in the KEYWDS table
040C1E             1020   ;
040C1E 23          1021   LEX1:			INC     HL			; Increment the pointer
040C1F CB 7E       1022   			BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
040C21 28 FB       1023   			JR      Z,LEX1			; No, so loop
040C23 18 F0       1024   			JR      LEX0			; At this point HL is pointing to the start of the next keyword
040C25             1025   ;
040C25 FD E5       1026   LEX2:			PUSH    IY              	; Save the input pointer
040C27 23          1027   LEX3:			INC     HL			; Increment the keyword pointer
040C28 CB 7E       1028   			BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
040C2A 20 1C       1029   			JR      NZ,LEX6         	; Jump to here as we've found a token
040C2C FD 23       1030   			INC     IY			; Increment the text pointer
040C2E FD 7E 00    1031   			LD      A,(IY)			; Fetch the character
040C31 FE 2E       1032   			CP      '.'			; Is it an abbreviated keyword?
040C33 28 13       1033   			JR      Z,LEX6          	; Yes, so we'll return with the token we've found
040C35 BE          1034   			CP      (HL)			; Compare with the keywords list
040C36 28 EF       1035   			JR      Z,LEX3			; It's a match, so continue checking this keyword
040C38 CD C5 10 04 1036   			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
040C3C 38 04       1037   			JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
040C3E             1038   ;
040C3E FD E1       1039   LEX4:			POP     IY              	; Restore the input pointer ready for the next search
040C40 18 DC       1040   			JR      LEX1			; And loop back to start again
040C42             1041   ;
040C42             1042   ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
040C42             1043   ; immediately delimited
040C42             1044   ;
040C42 7E          1045   LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
040C43 B7          1046   			OR      A			; If it is not zero, then...
040C44 20 F8       1047   			JR      NZ,LEX4			; Keep searching
040C46 FD 2B       1048   			DEC     IY			; If it is zero, then skip the input pointer back one byte
040C48             1049   ;
040C48             1050   ; We've found a token at this point
040C48             1051   ;
040C48 F1          1052   LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
040C49 AF          1053   			XOR     A			; Set the Z flag
040C4A 78          1054   			LD      A,B			; A: The token
040C4B C9          1055   			RET
040C4C             1056   ;
040C4C             1057   ; DEL - DELETE A PROGRAM LINE.
040C4C             1058   ;   Inputs: HL addresses program line.
040C4C             1059   ; Destroys: B,C,F
040C4C             1060   ;
040C4C             1061   ; This simply erases the line by moving all of the code after the line to be deleted back over
040C4C             1062   ; it using an LDIR
040C4C             1063   ;
040C4C D5          1064   DEL:			PUSH    DE
040C4D E5          1065   			PUSH    HL
040C4E E5          1066   			PUSH    HL			; HL: Address of the program line
040C4F 06 00       1067   			LD      B,0			; BC: Length of the line
040C51 4E          1068   			LD      C,(HL)
040C52 09          1069   			ADD     HL,BC			; HL: Advanced to the start of the next line
040C53 E5          1070   			PUSH    HL
040C54 EB          1071   			EX      DE,HL			; DE: Pointer to the next line
040C55 2A 17 03 04 1072   			LD      HL,(TOP)		; HL: Pointer to the end of the program
040C59 ED 52       1073   			SBC     HL,DE
040C5B 44          1074   			LD      B,H			; BC: Size of block to move
040C5C 4D          1075   			LD      C,L
040C5D E1          1076   			POP     HL			; HL: Pointer to next line
040C5E D1          1077   			POP     DE			; DE: Pointer to this line
040C5F ED B0       1078   			LDIR                    	; Delete the line
040C61 ED 53 17 03 1079   			LD      (TOP),DE		; Adjust TOP
       04          
040C66 E1          1080   			POP     HL
040C67 D1          1081   			POP     DE
040C68 C9          1082   			RET
040C69             1083   ;
040C69             1084   ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
040C69             1085   ;   Inputs: Filename in ACCS (term CR)
040C69             1086   ; Destroys: A,B,C,D,E,H,L,F
040C69             1087   ;
040C69             1088   ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
040C69             1089   ; AND WRITE FF FF, THEN LOAD (TOP).
040C69             1090   ; Destroys: A,B,C,H,L,F
040C69             1091   ;
040C69 ED 5B 14 03 1092   LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
       04          
040C6E 21 00 FF FF 1093   			LD      HL,-256
040C72 39          1094   			ADD     HL,SP
040C73 ED 52       1095   			SBC     HL,DE           	; Find available space
040C75 44          1096   			LD      B,H
040C76 4D          1097   			LD      C,L
040C77 21 00 00 04 1098   			LD      HL,ACCS
040C7B CD 6E 13 04 1099   			CALL    OSLOAD          	; Call the OSLOAD function in patch
040C7F D4 B6 0C 04 1100   			CALL    NC,NEWIT		; If NC then NEW
040C83 3E 00       1101   			LD      A,0
040C85 D2 AA 0B 04 1102   			JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
040C89             1103   ;
040C89 CD 95 0C 04 1104   CLEAN:			CALL    SETTOP			; Set TOP sysvar
040C8D 2B          1105   			DEC     HL			; Write out the end of program markers
040C8E 36 FF       1106   			LD      (HL),-1
040C90 2B          1107   			DEC     HL
040C91 36 FF       1108   			LD      (HL),-1
040C93 18 2B       1109   			JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
040C95             1110   ;
040C95             1111   ; Set the TOP sysvar; the first free location after the end of the current program
040C95             1112   ; Returns:
040C95             1113   ; - HL: TOP
040C95             1114   ;
040C95 2A 14 03 04 1115   SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
040C99 01 00 00 00 1116   			LD	BC, 0			; BC: 0
040C9D 3E 0D       1117   			LD      A,CR			; End of line marker
040C9F 4E          1118   SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
040CA0 0C          1119   			INC     C			; Check for zero
040CA1 0D          1120   			DEC     C
040CA2 28 0A       1121   			JR      Z,SETOP2		; If it is zero, we've reached the end
040CA4 09          1122   			ADD     HL,BC			; Skip to next line
040CA5 2B          1123   			DEC     HL			; Check end of previous line
040CA6 BE          1124   			CP      (HL)
040CA7 23          1125   			INC     HL
040CA8 28 F5       1126   			JR      Z,SETOP1		; If CR then loop
040CAA C3 42 0B 04 1127   			JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
040CAE             1128   ;
040CAE 23          1129   SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
040CAF 23          1130   			INC     HL			; NB: Called from NEWIT
040CB0 23          1131   			INC     HL
040CB1 22 17 03 04 1132   			LD      (TOP),HL		; Store in TOP sysvar
040CB5 C9          1133   			RET
040CB6             1134   ;
040CB6             1135   ; NEWIT - NEW PROGRAM THEN CLEAR
040CB6             1136   ;   Destroys: H,L
040CB6             1137   ;
040CB6             1138   ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
040CB6             1139   ; FUNCTION AND PROCEDURE POINTERS.
040CB6             1140   ;   Destroys: Nothing
040CB6             1141   ;
040CB6 2A 14 03 04 1142   NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
040CBA 36 00       1143   			LD      (HL),0			; Stick a 0 in there
040CBC CD AE 0C 04 1144   			CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
040CC0             1145   ;
040CC0 E5          1146   CLEAR:			PUSH    HL			; Stack the BASIC program pointer
040CC1 2A 17 03 04 1147   			LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
040CC5 22 1A 03 04 1148   			LD      (LOMEM),HL		; Set the LOMEM sysvar
040CC9 22 1D 03 04 1149   			LD      (FREE),HL		; And the FREE sysvar with that value
040CCD 21 6C 02 04 1150   			LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
040CD1 C5          1151   			PUSH    BC
040CD2             1152   			; LD      B,3*(54+2)		; Loop counter
040CD2 06 A8       1153   			LD      B,54+2*3		; ez80asm doesn't do () in expressions
040CD4 36 00       1154   CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
040CD6 23          1155   			INC     HL
040CD7 10 FB       1156   			DJNZ    CLEAR1
040CD9 C1          1157   			POP     BC
040CDA E1          1158   			POP     HL			; Restore the BASIC program pointer
040CDB C9          1159   			RET
040CDC             1160   ;
040CDC             1161   ;LISTIT - LIST A PROGRAM LINE.
040CDC             1162   ;    Inputs: HL addresses line
040CDC             1163   ;            DE = line number (binary)
040CDC             1164   ;            IX = Pointer to LISTON
040CDC             1165   ;             B = FOR/NEXT indent level
040CDC             1166   ;             C = REPEAT/UNTIL indent level
040CDC             1167   ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
040CDC             1168   ;
040CDC E5          1169   LISTIT:			PUSH    HL			; Stack the address of the line
040CDD EB          1170   			EX      DE,HL			; HL: Line number
040CDE C5          1171   			PUSH    BC
040CDF CD 45 0E 04 1172   			CALL    PBCD			; Print the line number
040CE3 C1          1173   			POP     BC
040CE4 E1          1174   			POP     HL			; HL: Address of the first token/character
040CE5 7E          1175   			LD      A,(HL)			; Fetch the token
040CE6 FE ED       1176   			CP      NEXT			; Is it NEXT...
040CE8 CC 72 0D 04 1177   			CALL    Z,INDENT		; Yes, so indent in
040CEC FE FD       1178   			CP      UNTIL			; Or is it UNTIL...
040CEE CC 72 0D 04 1179   			CALL    Z,INDENT		; Yes, so indent in
040CF2 D9          1180   			EXX
040CF3 3E 20       1181   			LD      A,' '
040CF5 DD CB 00 46 1182   			BIT     0,(IX)			; If BIT 0 of LISTON is set
040CF9 C4 99 0D 04 1183   			CALL    NZ,OUTCHR		; Then print a space after the line number
040CFD 78          1184   			LD      A,B			; Fetch the FOR/NEXT indent level
040CFE 87          1185   			ADD     A,A			; Multiply by 2
040CFF DD CB 00 4E 1186   			BIT     1,(IX)			; If BIT 1 of LISTON is set
040D03 C4 8B 13 04 1187   			CALL    NZ,FILL			; Then print the FOR/NEXT indent
040D07 79          1188   			LD      A,C			; Fetch the REPEAT/UNTIL indent level
040D08 87          1189   			ADD     A,A			; Multiply by 2
040D09 DD CB 00 56 1190   			BIT     2,(IX)			; If BIT 2 of LISTON is set
040D0D C4 8B 13 04 1191   			CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
040D11 D9          1192   			EXX
040D12 7E          1193   			LD      A,(HL)			; Fetch the token
040D13 FE E3       1194   			CP      FOR			; Is it FOR?
040D15 CC 72 0D 04 1195   			CALL    Z,INDENT		; Yes, so indent
040D19 FE F5       1196   			CP      REPEAT			; Is it REPEAT?
040D1B CC 72 0D 04 1197   			CALL    Z,INDENT		; Yes, so indent
040D1F 1E 00       1198   			LD      E,0			; E: The quote counter - reset to 0
040D21 7E          1199   LIST8:			LD      A,(HL)			; Fetch a character / token byte
040D22 23          1200   			INC     HL
040D23 FE 0D       1201   			CP      CR			; Is it end of line?
040D25 28 0B       1202   			JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
040D27 FE 22       1203   			CP      34			; Is it a quote character?
040D29 20 01       1204   			JR      NZ,LIST7		; No, so skip to next bit
040D2B 1C          1205   			INC     E			; Otherwise increment quote counter
040D2C CD 61 0D 04 1206   LIST7:			CALL    LOUT			; Output the character / token
040D30 18 EF       1207   			JR      LIST8			; And repeat
040D32             1208   ;
040D32             1209   ; DB: Modification for *EDIT
040D32             1210   ; Terminate the line with either a CRLF or a NUL character
040D32             1211   ;
040D32 DD CB 00 5E 1212   LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
040D36 28 59       1213   			JR	Z, CRLF			; Yes, so print a CRLF
040D38 AF          1214   			XOR	A			; Otherwise print a NUL (0)
040D39 C3 A6 13 04 1215   			JP	OSWRCH
040D3D             1216   ;
040D3D             1217   ; Decode the 3 byte GOTO type line number
040D3D             1218   ;
040D3D E5          1219   PRLINO:			PUSH    HL			; Swap HL and IY
040D3E FD E1       1220   			POP     IY			; IY: Pointer to the line number
040D40 C5          1221   			PUSH    BC
040D41 CD DF 12 04 1222   			CALL    DECODE			; Decode
040D45 C1          1223   			POP     BC
040D46 D9          1224   			EXX
040D47 C5          1225   			PUSH    BC
040D48 CD 41 0E 04 1226   			CALL    PBCDL			; Output the line number
040D4C C1          1227   			POP     BC
040D4D D9          1228   			EXX
040D4E FD E5       1229   			PUSH    IY			; Swap HL and IY
040D50 E1          1230   			POP     HL			; HL: Pointer to the next character in the line
040D51 C9          1231   			RET
040D52             1232   ;
040D52             1233   ; DB: Modification for internationalisation
040D52             1234   ;
040D52 CD B6 0D 04 1235   PRREM:			CALL	OUT_			; Output the REM token
040D56 7E          1236   @@:			LD	A, (HL)			; Fetch the character
040D57 FE 0D       1237   			CP	CR			; If it is end of line, then
040D59 C8          1238   			RET	Z			; we have finished
040D5A CD 99 0D 04 1239   			CALL	OUTCHR			; Ouput the character
040D5E 23          1240   			INC	HL
040D5F 18 F5       1241   			JR	@B			; And loop
040D61             1242   ;
040D61             1243   ; DB: End of modification
040D61             1244   ;
040D61 CB 43       1245   LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
040D63 20 34       1246   			JR      NZ,OUTCHR		; don't tokenise, just output the character
040D65 FE F4       1247   			CP	REM			; DB: Is it REM
040D67 28 E9       1248   			JR	Z, PRREM		; DB: Yes so jump to the special case for REM
040D69 FE 8D       1249   			CP      LINO			; Is it a line number (following GOTO/GOSUB etc)?
040D6B 28 D0       1250   			JR      Z,PRLINO		; Yes, so decode and print the line number
040D6D CD B6 0D 04 1251   			CALL    OUT_			; Output a character / keyword
040D71 7E          1252   			LD      A,(HL)			; Fetch the next character
040D72             1253   ;
040D72             1254   ; This block of code handles the indentation
040D72             1255   ; B: Counter for FOR/NEXT indent
040D72             1256   ; C: Counter for REPEAT/UNTIL indent
040D72             1257   ;
040D72 D9          1258   INDENT:			EXX
040D73 FE E3       1259   			CP      FOR			; If the token is FOR
040D75 28 09       1260   			JR      Z,IND1			; Then INC B
040D77 FE ED       1261   			CP      NEXT			; If it is NEXT
040D79 20 06       1262   			JR      NZ,IND2_		; Then...
040D7B 05          1263   			DEC     B			; DEC B
040D7C F2 81 0D 04 1264   			JP      P,IND2_			; If we have gone below 0 then
040D80 04          1265   IND1:			INC     B			; Increment back to 0
040D81             1266   ;
040D81 FE F5       1267   IND2_:			CP      REPEAT			; If the token is REPEAT
040D83 28 09       1268   			JR      Z,IND3			; Then INC C
040D85 FE FD       1269   			CP      UNTIL			; If it is UNTIL
040D87 20 06       1270   			JR      NZ,IND4			; Then...
040D89 0D          1271   			DEC     C			; DEC C
040D8A F2 8F 0D 04 1272   			JP      P,IND4			; If we have gone below 0 then
040D8E 0C          1273   IND3:			INC     C			; Incremet back to 0
040D8F D9          1274   IND4:			EXX
040D90 C9          1275   			RET
040D91             1276   ;
040D91             1277   ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
040D91             1278   ;  Destroys: A,F
040D91             1279   ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
040D91             1280   ;    Inputs: A = character
040D91             1281   ;  Destroys: A,F
040D91             1282   ;
040D91 3E 0D       1283   CRLF:			LD      A,CR			; Output CR
040D93 CD 99 0D 04 1284   			CALL    OUTCHR
040D97 3E 0A       1285   			LD      A,LF			; Output LF
040D99             1286   ;
040D99 CD A6 13 04 1287   OUTCHR:			CALL    OSWRCH			; Output the character in A
040D9D D6 0D       1288   			SUB     CR			; Check for CR
040D9F 28 06       1289   			JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
040DA1 D8          1290   			RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
040DA2 3A 3D 03 04 1291   			LD      A,(COUNT)		; Increment the count
040DA6 3C          1292   			INC     A
040DA7             1293   ;
040DA7 32 3D 03 04 1294   CARRET:			LD      (COUNT),A		; Store the new count value
040DAB C8          1295   			RET     Z			; Return if the count has wrapped to 0
040DAC E5          1296   			PUSH    HL			; Now check if count = print width
040DAD 2A 3E 03 04 1297   			LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
040DB1 BD          1298   			CP      L			; L is the width. Compare it with count.
040DB2 E1          1299   			POP     HL
040DB3 C0          1300   			RET     NZ			; If we've not hit print width, then just return
040DB4 18 DB       1301   			JR      CRLF			; Otherwise output CRLF
040DB6             1302   ;
040DB6             1303   ; OUT - SEND CHARACTER OR KEYWORD
040DB6             1304   ;   Inputs: A = character (>=10, <128)
040DB6             1305   ;           A = Token (<10, >=128)
040DB6             1306   ;  Destroys: A,F
040DB6             1307   ;
040DB6 FE 8A       1308   OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
040DB8 EA 99 0D 04 1309   			JP      PE,OUTCHR		; If so, then it's a character, so just output it
040DBC             1310   ;
040DBC             1311   ; This bit looks up the character in the KEYWDS token table and expands it
040DBC             1312   ; Note the CP 138; this sets the overflow flag as follows:
040DBC             1313   ;
040DBC             1314   ; NB:
040DBC             1315   ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
040DBC             1316   ;  2. CP is effectively a SUB; sets the flags without affecting A
040DBC             1317   ;  3. The operation n - -118 ~ n + 118
040DBC             1318   ;
040DBC             1319   ; So:
040DBC             1320   ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
040DBC             1321   ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
040DBC             1322   ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
040DBC             1323   ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
040DBC             1324   ;
040DBC C5          1325   			PUSH    BC			; Preserve BC and HL
040DBD E5          1326   			PUSH    HL
040DBE 21 B2 05 04 1327   			LD      HL,KEYWDS		; The list of tokens and keywords
040DC2 01 DF 02 00 1328   			LD      BC,KEYWDL		; The length of the keyword list
040DC6 ED B1       1329   			CPIR				; We can just do a straight CPIR as the token characters are unique in the list
040DC8             1330   ;							; At this point HL points to the next byte, the first character of the token
040DC8 7E          1331   TOKEN1:			LD      A,(HL)			; Fetch the character
040DC9 23          1332   			INC     HL			; Increment to the next byte in the token table
040DCA FE 8A       1333   			CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
040DCC F5          1334   			PUSH    AF			; Then...
040DCD EC 99 0D 04 1335   			CALL    PE,OUTCHR		; Output the character...
040DD1 F1          1336   			POP     AF			;
040DD2 EA C8 0D 04 1337   			JP      PE,TOKEN1		; And loop to the next character
040DD6 E1          1338   			POP     HL			; Done, so tidy up the stack and exit
040DD7 C1          1339   			POP     BC
040DD8 C9          1340   			RET
040DD9             1341   ;
040DD9             1342   ; FINDL - FIND PROGRAM LINE
040DD9             1343   ;   Inputs: HL = line number (binary)
040DD9             1344   ;  Outputs: HL addresses line (if found)
040DD9             1345   ;           DE = line number
040DD9             1346   ;           Z-flag set if found.
040DD9             1347   ; Destroys: A,B,C,D,E,H,L,F
040DD9             1348   ;
040DD9 EB          1349   FINDL:			EX      DE,HL			; DE: Line number (binary)
040DDA 2A 14 03 04 1350   			LD      HL,(PAGE_)		; HL: Top of BASIC program area
040DDE AF          1351   			XOR     A               	;  A: 0
040DDF BE          1352   			CP      (HL)			; Check for end of program marker
040DE0 3C          1353   			INC     A			;  A: 1
040DE1 D0          1354   			RET     NC			; Return with 1 if 0
040DE2 AF          1355   			XOR     A               	; Clear the carry flag
040DE3             1356   ;			LD      B,A			;  B: 0
040DE3 01 00 00 00 1357   			LD	BC, 0			; BC: 0
040DE7             1358   ;
040DE7 4E          1359   FINDL1:			LD      C,(HL)			;  C: The line length
040DE8 E5          1360   			PUSH    HL			; Stack the current program counter
040DE9 23          1361   			INC     HL			; Skip to the line number bytes
040DEA 7E          1362   			LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
040DEB 23          1363   			INC     HL
040DEC 66          1364   			LD      H,(HL)
040DED 6F          1365   			LD      L,A
040DEE 52 ED 52    1366   			SBC.S   HL,DE			; Compare with the line number we're searching for
040DF1 E1          1367   			POP     HL			; Get the current program counter
040DF2 D0          1368   			RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
040DF3 09          1369   			ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
040DF4 C3 E7 0D 04 1370   			JP      FINDL1			; And loop
040DF8             1371   ;
040DF8             1372   ; SETLIN - Search program for line containing address
040DF8             1373   ;          Update (LINENO)
040DF8             1374   ;   Inputs: Address in (ERRLIN)
040DF8             1375   ;  Outputs: Line number in HL and (LINENO)
040DF8             1376   ; Destroys: B,C,D,E,H,L,F
040DF8             1377   ;
040DF8 01 00 00 00 1378   SETLIN:			LD	BC, 0			; Zero BC for later
040DFC             1379   ;			LD      B, 0			; Zero B for later
040DFC ED 5B 35 03 1380   			LD      DE, (ERRLIN)		; DE: Address of line
       04          
040E01 2A 14 03 04 1381   			LD      HL, (PAGE_)		; HL: Start of user program area
040E05 B7          1382   			OR      A			; Do a 24 bit compare without destroying HL
040E06 ED 52       1383   			SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
040E08 19          1384   			ADD     HL, DE			;  C: DE > HL
040E09 30 1B       1385   			JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
040E0B             1386   ;
040E0B 4E          1387   SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
040E0C 0C          1388   			INC     C			; This is a way to check for zero without using the accumulator
040E0D 0D          1389   			DEC     C			; If it is zero, then...
040E0E 28 16       1390   			JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
040E10 09          1391   			ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
040E11 ED 52       1392   			SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
040E13 19          1393   			ADD     HL, DE
040E14 38 F5       1394   			JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
040E16 ED 42       1395   			SBC     HL, BC			; We've found it, so back up to the beginning of the line
040E18 23          1396   			INC     HL			; Skip the length counter
040E19 11 00 00 00 1397   			LD	DE, 0			; Zero DE
040E1D 5E          1398   			LD      E, (HL)          	; Fetch the line number
040E1E 23          1399   			INC     HL
040E1F 56          1400   			LD      D, (HL)
040E20 EB          1401   			EX      DE, HL			; HL: The line number
040E21 22 23 03 04 1402   SET2:			LD      (LINENO), HL		; Store in the variable LINENO
040E25 C9          1403   			RET
040E26             1404   ;
040E26 21 00 00 00 1405   SET3:			LD      HL, 0			; We've not found the line at this point so
040E2A 18 F5       1406   			JR      SET2			; Set LINENO to 0
040E2C             1407   ;
040E2C             1408   ;SAYLN - PRINT " at line nnnn" MESSAGE.
040E2C             1409   ;  Outputs: Carry=0 if line number is zero.
040E2C             1410   ;           Carry=1 if line number is non-zero.
040E2C             1411   ; Destroys: A,B,C,D,E,H,L,F
040E2C             1412   ;
040E2C 2A 23 03 04 1413   SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
040E30 7C          1414   			LD      A,H			; If it is zero then
040E31 B5          1415   			OR      L
040E32 C8          1416   			RET     Z			; Don't need to do anything; return with F:C set to 0
040E33 CD DA 11 04 1417   			CALL    TELL			; Output the error message
040E37 20 61 74 20 1418   			DB    	" at line ", 0
       6C 69 6E 65 
       20 00       
040E41 0E 00       1419   PBCDL:			LD      C,0			; C: Leading character (NUL)
040E43 18 02       1420   			JR      PBCD0			; Output the line number; return with F:C set to 1
040E45             1421   ;
040E45             1422   ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
040E45             1423   ;   Inputs: HL = number (binary).
040E45             1424   ;  Outputs: Carry = 1
040E45             1425   ; Destroys: A,B,C,D,E,H,L,F
040E45             1426   ;
040E45 0E 20       1427   PBCD:			LD      C,' '			; C: Leading character (" ")
040E47 06 05       1428   PBCD0:			LD      B,5			; Number of digits in result
040E49 11 10 27 00 1429   			LD      DE,10000		; Start off with the 10,000 column
040E4D AF          1430   PBCD1:			XOR     A			; Counter
040E4E ED 52       1431   PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
040E50 3C          1432   			INC     A
040E51 30 FB       1433   			JR      NC,PBCD2
040E53 19          1434   			ADD     HL,DE			; The loop overruns by one, so adjust here
040E54 3D          1435   			DEC     A			; A: Number of 10,000s
040E55 28 04       1436   			JR      Z,PBCD3			; If it is 0, then skip the next bit
040E57 CB E1       1437   			SET     4,C			; C: Set to '0' ASCII (30h)
040E59 CB E9       1438   			SET     5,C
040E5B B1          1439   PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
040E5C C4 99 0D 04 1440   			CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
040E60 78          1441   			LD      A,B			; If on first transition, skip this
040E61 FE 05       1442   			CP      5			; TODO: Need to find out why
040E63 28 06       1443   			JR      Z,PBCD4
040E65 29          1444   			ADD     HL,HL			; HL x  2 : We shift the number being tested left,
040E66 54          1445   			LD      D,H			;         : rather than shifting DE right
040E67 5D          1446   			LD      E,L			;         : This makes a lot of sense
040E68 29          1447   			ADD     HL,HL			; HL x  4
040E69 29          1448   			ADD     HL,HL			; HL x  8
040E6A 19          1449   			ADD     HL,DE			; HL x 10
040E6B 11 E8 03 00 1450   PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
040E6F 10 DC       1451   			DJNZ    PBCD1			; Loop until done
040E71 37          1452   			SCF				; SCF set for SAYLN in this module
040E72 C9          1453   			RET
040E73             1454   ;
040E73             1455   ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
040E73             1456   ;   Inputs: HL, IY as returned from GETVAR (NZ).
040E73             1457   ;  Outputs: As GETVAR.
040E73             1458   ; Destroys: everything
040E73             1459   ;
040E73 CD F8 0F 04 1460   PUTVAR:			CALL    CREATE			; Create the variable
040E77 FD 7E 00    1461   			LD      A,(IY)			; Fetch the next character
040E7A FE 28       1462   			CP      '('			; Check for bad use of array
040E7C 20 70       1463   			JR      NZ,GETVZ        	; It's fine, so set the exit conditions
040E7E 3E 0E       1464   ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
040E80 C3 AA 0B 04 1465   ERROR3:			JP      ERROR_
040E84             1466   ;
040E84             1467   ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
040E84             1468   ;   Inputs: IY addresses first character.
040E84             1469   ;  Outputs: Carry set and NZ if illegal character.
040E84             1470   ;           Z-flag set if variable found, then:
040E84             1471   ;            A = variable type (0,4,5,128 or 129)
040E84             1472   ;            HL = IX = variable pointer.
040E84             1473   ;            IY updated
040E84             1474   ;           If Z-flag & carry reset, then:
040E84             1475   ;            HL, IY set for subsequent PUTVAR call.
040E84             1476   ; Destroys: everything
040E84             1477   ;
040E84 FD 7E 00    1478   GETVAR:			LD      A,(IY)			; Get the first character
040E87 FE 24       1479   			CP      '$'			; Is it a string?
040E89 28 69       1480   			JR      Z,GETV4			; Yes, so branch here
040E8B FE 21       1481   			CP      '!'			; Is it indirection (32-bit)?
040E8D 28 69       1482   			JR      Z,GETV5			; Yes, so branch here
040E8F FE 3F       1483   			CP      '?'			; Is it indirection (8-bit)?
040E91 28 69       1484   			JR      Z,GETV6			; Yes, so branch here
040E93             1485   ;
040E93 CD 62 0F 04 1486   			CALL    LOCATE			; Locate the variable
040E97 C0          1487   			RET     NZ			; And exit here if not found
040E98             1488   ;
040E98             1489   ; At this point:
040E98             1490   ;  HL: Address of variable in memory
040E98             1491   ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
040E98             1492   ;
040E98 FD 7E 00    1493   			LD      A,(IY)			; Further checks
040E9B FE 28       1494   			CP      '('             	; Is it an array?
040E9D 20 47       1495   			JR      NZ,GETVX        	; No, so exit
040E9F             1496   ;
040E9F             1497   ; We are processing an array at this point
040E9F             1498   ;
040E9F D5          1499   			PUSH    DE              	; Save the variable type (in D)
040EA0 7E          1500   			LD      A,(HL)          	; Fetch the number of dimensions
040EA1 B7          1501   			OR      A
040EA2 28 DA       1502   			JR      Z,ARRAY			; If there are none, then Error: 'Array'
040EA4 23          1503   			INC     HL			;
040EA5 11 00 00 00 1504   			LD      DE,0            	; Accumulator
040EA9 F5          1505   			PUSH    AF
040EAA FD 23       1506   			INC     IY              	; Skip "("
040EAC 18 05       1507   			JR      GETV3
040EAE             1508   ;
040EAE F5          1509   GETV2:			PUSH    AF
040EAF CD C3 13 04 1510   			CALL    COMMA
040EB3 E5          1511   GETV3:			PUSH    HL
040EB4 D5          1512   			PUSH    DE
040EB5 CD 8A 12 04 1513   			CALL    EXPRI			; Get the subscript
040EB9 D9          1514   			EXX
040EBA D1          1515   			POP     DE
040EBB E3          1516   			EX      (SP),HL
040EBC 4E          1517   			LD      C,(HL)
040EBD 23          1518   			INC     HL
040EBE 46          1519   			LD      B,(HL)
040EBF 23          1520   			INC     HL
040EC0 E3          1521   			EX      (SP),HL
040EC1 EB          1522   			EX      DE,HL
040EC2 D5          1523   			PUSH    DE
040EC3 CD DF 13 04 1524   			CALL    MUL16			; HL=HL*BC
040EC7 D1          1525   			POP     DE
040EC8 19          1526   			ADD     HL,DE
040EC9 EB          1527   			EX      DE,HL
040ECA B7          1528   			OR      A
040ECB ED 42       1529   			SBC     HL,BC
040ECD 3E 0F       1530   			LD      A,15
040ECF 30 AF       1531   			JR      NC,ERROR3		; Throw a "Subscript" error
040ED1 E1          1532   			POP     HL
040ED2 F1          1533   			POP     AF
040ED3 3D          1534   			DEC     A               	; Dimension counter
040ED4 20 D8       1535   			JR      NZ,GETV2
040ED6 CD FB 13 04 1536   			CALL    BRAKET          	; Check for closing bracket
040EDA F1          1537   			POP     AF              	; Restore the type
040EDB E5          1538   			PUSH    HL
040EDC CD 18 14 04 1539   			CALL    X4OR5           	; DE=DE*n
040EE0 E1          1540   			POP     HL
040EE1 19          1541   			ADD     HL,DE
040EE2 57          1542   			LD      D,A             	; The type
040EE3 FD 7E 00    1543   			LD      A,(IY)
040EE6 FE 3F       1544   GETVX:			CP      '?'
040EE8 28 1E       1545   			JR      Z,GETV9
040EEA FE 21       1546   			CP      '!'
040EEC 28 16       1547   			JR      Z,GETV8
040EEE E5          1548   GETVZ:			PUSH    HL              	; Set exit conditions
040EEF DD E1       1549   			POP     IX
040EF1 7A          1550   			LD      A,D
040EF2 BF          1551   			CP      A
040EF3 C9          1552   			RET
040EF4             1553   ;
040EF4             1554   ; Process strings, unary & binary indirection:
040EF4             1555   ;
040EF4 3E 80       1556   GETV4:			LD      A,128           	; Static strings
040EF6 18 05       1557   			JR      GETV7
040EF8             1558   ;
040EF8 3E 04       1559   GETV5:			LD      A,4             	; Unary 32-bit indirection
040EFA 18 01       1560   			JR      GETV7
040EFC             1561   ;
040EFC AF          1562   GETV6:			XOR     A               	; Unary 8-bit indirection
040EFD             1563   ;
040EFD 21 00 00 00 1564   GETV7:			LD      HL,0
040F01 F5          1565   			PUSH    AF
040F02 18 24       1566   			JR      GETV0
040F04             1567   ;
040F04 06 04       1568   GETV8:			LD      B,4             	; Binary 32-bt indirection
040F06 18 02       1569   			JR      GETVA
040F08             1570   ;
040F08 06 00       1571   GETV9:			LD      B,0             	; Binary 8-bit indirection
040F0A             1572   ;
040F0A E5          1573   GETVA:			PUSH    HL
040F0B DD E1       1574   			POP     IX
040F0D 7A          1575   			LD      A,D            		; Fetch the variable type
040F0E FE 81       1576   			CP      129			; Is it a string?
040F10 C8          1577   			RET     Z               	; Yes, so exit here
040F11 C5          1578   			PUSH    BC
040F12 CD 34 14 04 1579   			CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
040F16 CD 50 14 04 1580   			CALL    SFIX
040F1A 7D          1581   			LD	A,L
040F1B D9          1582   			EXX
040F1C 22 4A 03 04 1583   			LD	(R0+0),HL
040F20 32 4C 03 04 1584   			LD	(R0+2),A
040F24 2A 4A 03 04 1585   			LD	HL,(R0)			; HL: 24-bit address of the variable in memory
040F28             1586   ;
040F28 E5          1587   GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
040F29 FD 23       1588   			INC     IY
040F2B CD 6B 14 04 1589   			CALL    ITEMI
040F2F 7D          1590   			LD	A,L			;  A: The MSB of the address
040F30 D9          1591   			EXX
040F31 22 4A 03 04 1592   			LD	(R0+0),HL		; HL: The LSW of the address
040F35 32 4C 03 04 1593   			LD	(R0+2),A		; R0: L'HL or the 24-bit address
040F39 D1          1594   			POP     DE
040F3A F1          1595   			POP     AF
040F3B 2A 4A 03 04 1596   			LD	HL,(R0)			; HL: L'HL
040F3F 19          1597   			ADD     HL,DE
040F40 E5          1598   			PUSH    HL
040F41 DD E1       1599   			POP     IX
040F43 BF          1600   			CP      A
040F44 C9          1601   			RET
040F45             1602   ;
040F45             1603   ;GETDEF - Find entry for FN or PROC in dynamic area.
040F45             1604   ;   Inputs: IY addresses byte following "DEF" token.
040F45             1605   ;  Outputs: Z flag set if found
040F45             1606   ;           Carry set if neither FN or PROC first.
040F45             1607   ;           If Z: HL points to entry
040F45             1608   ;                 IY addresses delimiter
040F45             1609   ; Destroys: A,D,E,H,L,IY,F
040F45             1610   ;
040F45 FD 7E 01    1611   GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
040F48 CD C5 10 04 1612   			CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
040F4C D8          1613   			RET     C			; No so return with C set
040F4D FD 7E 00    1614   			LD      A,(IY)			; Fetch the current character from the tokenised line
040F50 21 0E 03 04 1615   			LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
040F54 FE A4       1616   			CP      FN			; Is it the token FN?
040F56 28 4A       1617   			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
040F58 21 11 03 04 1618   			LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
040F5C FE F2       1619   			CP      PROC			; Is it the token PROC?
040F5E 28 42       1620   			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
040F60 37          1621   			SCF				; No, so just return with C set
040F61 C9          1622   			RET
040F62             1623   ;
040F62             1624   ; LOCATE - Try to locate variable name in static or dynamic variables.
040F62             1625   ; If illegal first character return carry, non-zero.
040F62             1626   ; If found, return no-carry, zero.
040F62             1627   ; If not found, return no-carry, non-zero.
040F62             1628   ;   Inputs: IY=Addresses first character of name.
040F62             1629   ;            A=(IY)
040F62             1630   ;  Outputs:  F=Z set if found, then:
040F62             1631   ;           IY=addresses terminator
040F62             1632   ;           HL=addresses location of variable
040F62             1633   ;            D=type of variable: 4 = integer
040F62             1634   ;                                5 = floating point
040F62             1635   ;                              129 = string
040F62             1636   ; Destroys: A,D,E,H,L,IY,F
040F62             1637   ;
040F62             1638   ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
040F62             1639   ; They can contain any alphanumeric character and underscore (_)
040F62             1640   ; String variables are postfixed with the dollar ($) character
040F62             1641   ; Integer variables are postfixed with the percent (%) character
040F62             1642   ; Static integer variables are named @%, A% to Z%
040F62             1643   ; All other variables are dynamic
040F62             1644   ;
040F62 D6 40       1645   LOCATE:			SUB     '@'			; Check for valid range
040F64 D8          1646   			RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
040F65 21 00 00 00 1647   			LD      HL, 0			; Clear HL
040F69 FE 1B       1648   			CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
040F6B 30 1E       1649   			JR      NC,LOC0         	; Then branch here
040F6D 6F          1650   			LD	L, A			; HL = A
040F6E FD 7E 01    1651   			LD      A,(IY+1)        	; Check the 2nd character
040F71 FE 25       1652   			CP      '%'			; If not "%" then it is not static...
040F73 20 21       1653   			JR      NZ,LOC1         	; Branch here
040F75 FD 7E 02    1654   			LD      A,(IY+2)		; Check the 3rd character
040F78 FE 28       1655   			CP      '('			; If it is "(" (array) then it is not static...
040F7A 28 1A       1656   			JR      Z,LOC1          	; Branch here
040F7C             1657   ;
040F7C             1658   ; At this point we're dealing with a static variable
040F7C             1659   ;
040F7C 29          1660   			ADD     HL,HL			; HL: Variable index * 4
040F7D 29          1661   			ADD	HL,HL
040F7E 11 00 02 04 1662   			LD      DE,STAVAR       	; The static variable area in memory
040F82 19          1663   			ADD     HL,DE			; HL: The address of the static variable
040F83 FD 23       1664   			INC     IY			; Skip the program pointer past the static variable name
040F85 FD 23       1665   			INC     IY
040F87 16 04       1666   			LD      D,4             	; Set the type to be integer
040F89 AF          1667   			XOR     A			; Set the Z flag
040F8A C9          1668   			RET
040F8B             1669   ;
040F8B             1670   ; At this point it's potentially a dynamic variable, just need to do a few more checks
040F8B             1671   ;
040F8B FE 1F       1672   LOC0:			CP      '_'-'@'			; Check the first character is in
040F8D D8          1673   			RET     C			; the range "_" to
040F8E FE 3B       1674   			CP      'z'-'@'+1		; "z" (lowercase characters only)
040F90 3F          1675   			CCF				; If it is not in range then
040F91 3D          1676   			DEC     A               	; Set NZ flag and
040F92 D8          1677   			RET     C			; Exit here
040F93 D6 03       1678   			SUB     3			; This brings it in the range of 27 upwards (need to confirm)
040F95 6F          1679   			LD	L, A			; HL = A
040F96             1680   ;
040F96             1681   ; Yes, it's definitely a dynamic variable at this point...
040F96             1682   ;
040F96 7D          1683   LOC1:			LD	A, L			; Fetch variable index
040F97 87          1684   			ADD	A, A			; x 2
040F98 85          1685   			ADD	A, L			; x 3
040F99 D6 03       1686   			SUB	3			; Subtract 2 TODO: Should be 3
040F9B 6F          1687   			LD	L, A
040F9C 11 6C 02 04 1688   			LD      DE, DYNVAR       	; The dynamic variable storage
040FA0 D8          1689   			RET	C			; Bounds check to trap for variable '@'
040FA1 19          1690   			ADD     HL, DE			; HL: Address of first entry
040FA2             1691   ;
040FA2             1692   ; Loop through the linked list of variables to find a match
040FA2             1693   ;
040FA2 ED 17       1694   LOC2:			LD	DE, (HL)		; Fetch the original pointer
040FA4 E5          1695   			PUSH	HL			; Need to preserve HL for LOC6
040FA5 AF          1696   			XOR	A			; Reset carry flag
040FA6 ED 62       1697   			SBC	HL, HL			; Set HL to 0
040FA8 ED 52       1698   			SBC	HL, DE			; Compare with 0
040FAA E1          1699   			POP	HL			; Restore the original pointer
040FAB 28 49       1700   			JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
040FAD             1701   			; LD	HL, DE			; Make a copy of this pointer in HL
040FAD D5          1702   			push de
040FAE E1          1703   			pop hl ; how was that even possible?
040FAF 23          1704   			INC     HL              	; Skip the link (24-bits)
040FB0 23          1705   			INC     HL
040FB1 23          1706   			INC	HL			; HL: Address of the variable name in DYNVARS
040FB2 FD E5       1707   			PUSH    IY			; IY: Address of the variable name in the program
040FB4             1708   ;
040FB4 7E          1709   LOC3:			LD      A,(HL)         		; Compare
040FB5 23          1710   			INC     HL
040FB6 FD 23       1711   			INC     IY
040FB8 FD BE 00    1712   			CP      (IY)
040FBB 28 F7       1713   			JR      Z, LOC3			; Keep looping whilst we've got a match...
040FBD B7          1714   			OR      A               	; Have we hit a terminator?
040FBE 28 07       1715   			JR      Z,LOC5          	; Yes, so maybe we've found a variable
040FC0             1716   ;
040FC0 FD E1       1717   LOC4:			POP     IY			; Restore the pointer in the program
040FC2 EB          1718   			EX      DE, HL			; HL: New pointer in DYNVARS
040FC3 C3 A2 0F 04 1719   			JP      LOC2            	; Loop round and try again
040FC7             1720   ;
040FC7             1721   ; We might have located a variable at this point, just need to do a few more tests
040FC7             1722   ;
040FC7 FD 2B       1723   LOC5:			DEC     IY
040FC9 FD 7E 00    1724   			LD      A,(IY)
040FCC FE 28       1725   			CP      '('
040FCE 28 15       1726   			JR      Z,LOC5A         	; FOUND
040FD0 FD 23       1727   			INC     IY
040FD2 CD B9 10 04 1728   			CALL    RANGE
040FD6 38 0D       1729   			JR      C,LOC5A         	; FOUND
040FD8 FE 28       1730   			CP      '('
040FDA 28 E4       1731   			JR      Z,LOC4          	; KEEP LOOKING
040FDC FD 7E FF    1732   			LD      A,(IY-1)
040FDF CD C5 10 04 1733   			CALL    RANGE1
040FE3 30 DB       1734   			JR      NC,LOC4         	; KEEP LOOKING
040FE5 D1          1735   LOC5A:			POP     DE
040FE6 FD 7E FF    1736   TYPE_:			LD      A,(IY-1)		; Check the string type postfix
040FE9 FE 24       1737   			CP      '$'			; Is it a string?
040FEB 16 81       1738   			LD      D,129			; Yes, so return D = 129
040FED C8          1739   			RET     Z
040FEE FE 25       1740   			CP      '%'			; Is it an integer?
040FF0 16 04       1741   			LD      D,4			; Yes, so return D = 4
040FF2 C8          1742   			RET     Z
040FF3 14          1743   			INC     D			; At this point it must be a float
040FF4 BF          1744   			CP      A			; Set the flags
040FF5 C9          1745   			RET
040FF6             1746   ;
040FF6             1747   ; The variable is undefined at this point; HL will be zero
040FF6             1748   ;
040FF6 3C          1749   LOC6:			INC     A               	; Set NZ flag
040FF7 C9          1750   			RET
040FF8             1751   ;
040FF8             1752   ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
040FF8             1753   ;   Inputs: HL, IY as returned from LOCATE (NZ).
040FF8             1754   ;  Outputs: As LOCATE, GETDEF.
040FF8             1755   ; Destroys: As LOCATE, GETDEF.
040FF8             1756   ;
040FF8 AF          1757   CREATE:			XOR     A
040FF9 ED 5B 1D 03 1758   			LD      DE,(FREE)		; Get the last byte of available RAM
       04          
040FFE ED 1F       1759   			LD	(HL), DE		; Store
041000 EB          1760   			EX      DE,HL
041001 77          1761   			LD      (HL),A			; Clear the link of the new entity
041002 23          1762   			INC     HL
041003 77          1763   			LD      (HL),A
041004 23          1764   			INC     HL
041005 77          1765   			LD      (HL),A
041006 23          1766   			INC     HL
041007 FD 23       1767   LOC7:			INC     IY
041009 CD B9 10 04 1768   			CALL    RANGE           	; END OF VARIABLE?
04100D 38 15       1769   			JR      C,LOC8
04100F 77          1770   			LD      (HL),A
041010 23          1771   			INC     HL
041011 CD C5 10 04 1772   			CALL    RANGE1
041015 30 F0       1773   			JR      NC,LOC7
041017 FE 28       1774   			CP      '('
041019 28 09       1775   			JR      Z,LOC8
04101B FD 7E 01    1776   			LD      A,(IY+1)
04101E FE 28       1777   			CP      '('
041020 28 E5       1778   			JR      Z,LOC7
041022 FD 23       1779   			INC     IY
041024 36 00       1780   LOC8:			LD      (HL),0          	; TERMINATOR
041026 23          1781   			INC     HL
041027 E5          1782   			PUSH    HL
041028 CD E6 0F 04 1783   			CALL    TYPE_			; Get the variable type in D
04102C 3E 04       1784   			LD      A,4			; If it is an integer then it takes up 4 bytes
04102E BA          1785   			CP      D
04102F 28 01       1786   			JR      Z,LOC9			; So skip the next bit
041031 3C          1787   			INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
041032 36 00       1788   LOC9:			LD      (HL),0          	; Initialise the memory to zero
041034 23          1789   			INC     HL
041035 3D          1790   			DEC     A
041036 20 FA       1791   			JR      NZ,LOC9
041038 22 1D 03 04 1792   			LD      (FREE),HL		; Adjust the stack
04103C CD 87 14 04 1793   			CALL    CHECK			; Check whether we are out of space
041040 E1          1794   			POP     HL
041041 AF          1795   			XOR     A
041042 C9          1796   			RET
041043             1797   ;
041043             1798   ; LINNUM - GET LINE NUMBER FROM TEXT STRING
041043             1799   ;   Inputs: IY = Text Pointer
041043             1800   ;  Outputs: HL = Line number (zero if none)
041043             1801   ;           IY updated
041043             1802   ; Destroys: A,D,E,H,L,IY,F
041043             1803   ;
041043             1804   ; This bit of code performs a BASE 10 shift to build up the number
041043             1805   ; So if the string passed is "345", the algorithm does this:
041043             1806   ;
041043             1807   ;    HL : Digit	: Operation
041043             1808   ; ----- : ----- : ---------
041043             1809   ; 00000 :	:
041043             1810   ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
041043             1811   ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
041043             1812   ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
041043             1813   ;
041043             1814   ; The multiply by 10 is done by an unrolled shift and add loop
041043             1815   ;
041043 CD 56 12 04 1816   LINNUM:			CALL    NXT			; Skip whitespace to the first character
041047 40 21 00 00 1817   			LD.SIS  HL,0			; The running total
04104B FD 7E 00    1818   LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
04104E D6 30       1819   			SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
041050 D8          1820   			RET     C			; And return if less than 0
041051 FE 0A       1821   			CP      10			; Or greater than or equal to 10
041053 D0          1822   			RET     NC			; As we've hit a non-numeric character (end of number) at this point
041054 FD 23       1823   			INC     IY			; Increment the string pointer
041056 54          1824   			LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
041057 5D          1825   			LD      E,L			; Store the original number in DE
041058 52 29       1826   			ADD.S   HL,HL           	; *2
04105A 38 13       1827   			JR      C,TOOBIG_MAIN		; At each point, error if > 65535 (carry flag set)
04105C 52 29       1828   			ADD.S   HL,HL           	; *4S
04105E 38 0F       1829   			JR      C,TOOBIG_MAIN
041060 52 19       1830   			ADD.S   HL,DE           	; *5
041062 38 0B       1831   			JR      C,TOOBIG_MAIN
041064 52 29       1832   			ADD.S   HL,HL           	; *10
041066 38 07       1833   			JR      C,TOOBIG_MAIN
041068 5F          1834   			LD      E,A			; A->DE: the digit to add in
041069 16 00       1835   			LD      D,0
04106B 52 19       1836   			ADD.S   HL,DE           	; Add in the digit to the running total
04106D 30 DC       1837   			JR      NC,LINNM1       	; And if it is still <= 65535, loop
04106F             1838   ;
04106F 3E 14       1839   TOOBIG_MAIN:			LD      A,20
041071 C3 AA 0B 04 1840   			JP      ERROR_           	; Error: "Too big"
041075             1841   ;
041075             1842   ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
041075             1843   ;   Inputs: IY = text pointer
041075             1844   ;  Outputs: HL = first number (10 by default)
041075             1845   ;           BC = second number (10 by default)
041075             1846   ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
041075             1847   ;
041075 CD 43 10 04 1848   PAIR:			CALL    LINNUM          	; Parse the first line number
041079 7C          1849   			LD      A,H			; If it is not zero, then...
04107A B5          1850   			OR      L
04107B 20 02       1851   			JR      NZ,PAIR1		; Skip...
04107D 2E 0A       1852   			LD      L,10			; HL: the default value (10)
04107F             1853   ;
04107F CD A3 14 04 1854   PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
041083 FD 23       1855   			INC     IY			; Skip to next character
041085 E5          1856   			PUSH    HL			; Stack the first line number
041086 21 0A 00 00 1857   			LD      HL,10			; HL: the second default (10)
04108A C4 43 10 04 1858   			CALL    NZ,LINNUM       	; Parse the second line number
04108E E3          1859   			EX      (SP),HL			; HL: The first line number (off the stack)
04108F C1          1860   			POP     BC			; BC: Second line number
041090 78          1861   			LD      A,B			; If the second line number is not zero then...
041091 B1          1862   			OR      C			; We're good...
041092 C0          1863   			RET     NZ			; Exit, otherwise...
041093 CD C1 0B 04 1864   			CALL    EXTERR			; Throw error: "Silly"
041097 53 69 6C 6C 1865   			DB    	"Silly", 0
       79 00       
04109D             1866   ;
04109D             1867   ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
04109D             1868   ;   Inputs: IY = text pointer
04109D             1869   ;  Outputs: HL = points to program text
04109D             1870   ;           BC = second number (0 by default)
04109D             1871   ; Destroys: A,B,C,D,E,H,L,IY,F
04109D             1872   ;
04109D CD 43 10 04 1873   DLPAIR:			CALL    LINNUM			; Parse the first line number
0410A1 E5          1874   			PUSH    HL			; Stack it
0410A2 CD A3 14 04 1875   			CALL    TERMQ			; Check for ELSE, : or CR
0410A6 28 0A       1876   			JR      Z,DLP1			; And exit if so
0410A8 FE E7       1877   			CP      TIF			; Is the token IF?
0410AA 28 06       1878   			JR      Z,DLP1			; Yes, so skip the next bit...
0410AC FD 23       1879   			INC     IY			; Otherwise...
0410AE CD 43 10 04 1880   			CALL    LINNUM			; Fetch the second line number
0410B2 E3          1881   DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
0410B3 CD D9 0D 04 1882   			CALL    FINDL			; HL: Find the address of the line
0410B7 C1          1883   			POP     BC			; BC: The second number
0410B8 C9          1884   			RET
0410B9             1885   ;
0410B9             1886   ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
0410B9             1887   ;   Inputs: IY addresses character
0410B9             1888   ;  Outputs: Carry set if out-of-range.
0410B9             1889   ; Destroys: A,F
0410B9             1890   ;
0410B9             1891   ; It is called here to check the following
0410B9             1892   ; In range: "$", "%" and "("
0410B9             1893   ;   Plus all characters in RANGE1 and RANGE2
0410B9             1894   ;
0410B9 FD 7E 00    1895   RANGE:			LD      A,(IY)			; Fetch the character
0410BC FE 24       1896   			CP      '$'			; Postfix for string variable is valid
0410BE C8          1897   			RET     Z
0410BF FE 25       1898   			CP      '%'			; Postfix for integer variable is valid
0410C1 C8          1899   			RET     Z
0410C2 FE 28       1900   			CP      '('			; Postfix for array is valid
0410C4 C8          1901   			RET     Z
0410C5             1902   ;
0410C5             1903   ; It is called here to check the following
0410C5             1904   ; In range: "0" to "9" and "@"
0410C5             1905   ;   Plus all characters in RANGE2
0410C5             1906   ;
0410C5 FE 30       1907   RANGE1:			CP      '0'			; If it is between '0'...
0410C7 D8          1908   			RET     C
0410C8 FE 3A       1909   			CP      '9'+1			; And '9'...
0410CA 3F          1910   			CCF
0410CB D0          1911   			RET     NC			; Then it is valid
0410CC FE 40       1912   			CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
0410CE C8          1913   			RET     Z
0410CF             1914   ;
0410CF             1915   ; It is called here to check the following
0410CF             1916   ; In range: "A" to "Z", "a' to "z", "_" and "`"
0410CF             1917   ;
0410CF FE 41       1918   RANGE2:			CP      'A'			; If it is between 'A'...
0410D1 D8          1919   			RET     C
0410D2 FE 5B       1920   			CP      'Z'+1			; And 'Z'...
0410D4 3F          1921   			CCF
0410D5 D0          1922   			RET     NC			; Then it is valid
0410D6 FE 5F       1923   			CP      '_'			; If it is underscore, grave, or between 'a'
0410D8 D8          1924   			RET     C
0410D9 FE 7B       1925   			CP      'z'+1			; And 'z'
0410DB 3F          1926   			CCF				; Then it is valid
0410DC C9          1927   			RET
0410DD             1928   ;
0410DD             1929   ; Throw a 'LINE space' error (line too long)
0410DD             1930   ; This is called from LEXAN
0410DD             1931   ;
0410DD AF          1932   SPACE_: 		XOR     A
0410DE CD C1 0B 04 1933   			CALL    EXTERR          	; "LINE space"
0410E2 86 08 00    1934   			DB    	LINE_, 8, 0
0410E5             1935   ;
0410E5             1936   ; LEXAN - LEXICAL ANALYSIS.
0410E5             1937   ;  Bit 0,C: 1=left, 0=right
0410E5             1938   ;  Bit 2,C: 1=in BINARY
0410E5             1939   ;  Bit 3,C: 1=in HEX
0410E5             1940   ;  Bit 4,C: 1=accept line number
0410E5             1941   ;  Bit 5,C: 1=in variable, FN, PROC
0410E5             1942   ;  Bit 6,C: 1=in REM, DATA, *
0410E5             1943   ;  Bit 7,C: 1=in quotes
0410E5             1944   ;   Inputs: IY addresses source string
0410E5             1945   ;           DE addresses destination string (must be page boundary)
0410E5             1946   ;            C sets initial mode
0410E5             1947   ;  Outputs: DE, IY updated
0410E5             1948   ;            A holds carriage return
0410E5             1949   ;
0410E5 12          1950   LEXAN1:			LD      (DE),A          	; Transfer to buffer
0410E6 13          1951   			INC     DE              	; Increment the pointers
0410E7 FD 23       1952   			INC     IY			; And fall through to the main function
0410E9             1953   ;
0410E9             1954   ; This is the main entry point
0410E9             1955   ;
0410E9 7B          1956   LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
0410EA FE FC       1957   			CP      252             	; If it is >= 252 bytes, then...
0410EC 30 EF       1958   			JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
0410EE FD 7E 00    1959   			LD      A,(IY)			; Fetch character from source string
0410F1 FE 0D       1960   			CP      CR			; If it is a CR
0410F3 C8          1961   			RET     Z               	; Then it is end of line; we're done parsing
0410F4 CD C5 10 04 1962   			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0410F8 30 06       1963   			JR      NC,LEXAN3		; Yes, so skip
0410FA CB A9       1964   			RES     5,C             	; FLAG: NOT IN VARIABLE
0410FC CB 99       1965   			RES     3,C             	; FLAG: NOT IN HEX
0410FE CB 91       1966   			RES	2,C			; FLAG: NOT IN BINARY
041100             1967   ;
041100 FE 20       1968   LEXAN3:			CP      ' '			; Ignore spaces
041102 28 E1       1969   			JR      Z,LEXAN1
041104 FE 2C       1970   			CP      ','			; Ignore commas
041106 28 DD       1971   			JR      Z,LEXAN1
041108 FE 32       1972   			CP	'2'			; If less than '2'
04110A 30 02       1973   			JR	NC, @F			; No, so skip
04110C CB 91       1974   			RES	2,C			; FLAG: NOT IN BINARY
04110E FE 47       1975   @@:			CP      'G'			; If less then 'G'
041110 38 02       1976   			JR      C,LEXAN4		; Yes, so skip
041112 CB 99       1977   			RES     3,C             	; FLAG: NOT IN HEX
041114             1978   ;
041114 FE 22       1979   LEXAN4:			CP      34			; Is it a quote character?
041116 20 05       1980   			JR      NZ,LEXAN5		; No, so skip
041118 CB 11       1981   			RL      C			; Toggle bit 7 of C by shifting it into carry flag
04111A 3F          1982   			CCF                     	; Toggle the carry
04111B CB 19       1983   			RR      C			; And then shifting it back into bit 7 of C
04111D             1984   ;
04111D CB 61       1985   LEXAN5:			BIT     4,C			; Accept line number?
04111F 28 12       1986   			JR      Z,LEXAN6		; No, so skip
041121 CB A1       1987   			RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
041123 C5          1988   			PUSH    BC
041124 D5          1989   			PUSH    DE
041125 CD 43 10 04 1990   			CALL    LINNUM         		; Parse the line number to HL
041129 D1          1991   			POP     DE
04112A C1          1992   			POP     BC
04112B 7C          1993   			LD      A,H			; If it is not zero
04112C B5          1994   			OR      L
04112D C4 A6 11 04 1995   			CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
041131 18 B6       1996   			JR      LEXAN2          	; And loop
041133             1997   ;
041133 0D          1998   LEXAN6:			DEC     C			; Check for C=1 (LEFT)
041134 28 0A       1999   			JR      Z,LEXAN7        	; If so, skip
041136 0C          2000   			INC     C			; Otherwise restore C
041137 20 AC       2001   			JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
041139 B7          2002   			OR      A			; Set the flags based on the character
04113A F4 11 0C 04 2003   			CALL    P,LEX           	; Tokenise if A < 128
04113E 18 13       2004   			JR      LEXAN8			; And skip
041140             2005   ;
041140             2006   ; Processing the LEFT hand side here
041140             2007   ;
041140 FE 2A       2008   LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
041142 28 17       2009   			JR      Z,LEXAN9		; Yes, so skip to quit tokenising
041144 B7          2010   			OR      A			; Set the flags based on the character
041145 F4 11 0C 04 2011   			CALL    P,LEX           	; Tokenise if A < 128
041149             2012   ;
041149             2013   ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
041149             2014   ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
041149             2015   ; Examples:
041149             2016   ;   LET A% = PAGE : REM This is the GET version
041149             2017   ;   PAGE = 40000  : REM This is the SET version
041149             2018   ;
041149 FE 8F       2019   			CP      TOKLO			; TOKLO is 8Fh
04114B 38 06       2020   			JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
04114D FE 94       2021   			CP      TOKHI+1			; TOKHI is 93h
04114F 30 02       2022   			JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
041151 C6 40       2023   			ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
041153             2024   ;
041153 FE F4       2025   LEXAN8:			CP      REM			; If the token is REM
041155 28 04       2026   			JR      Z,LEXAN9		; Then stop tokenising
041157 FE DC       2027   			CP      DATA_			; If it is not DATA then
041159 20 02       2028   			JR      NZ,LEXANA		; Skip
04115B CB F1       2029   LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
04115D             2030   ;
04115D FE A4       2031   LEXANA:			CP      FN			; If the token is FN
04115F 28 0A       2032   			JR      Z,LEXANB
041161 FE F2       2033   			CP      PROC			; Or the token is PROC
041163 28 06       2034   			JR      Z,LEXANB		; Then jump to here
041165 CD CF 10 04 2035   			CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
041169 38 02       2036   			JR      C,LEXANC		; Jump here if out of range
04116B             2037   ;
04116B CB E9       2038   LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
04116D FE 26       2039   LEXANC:			CP      '&'			; Check for hex prefix
04116F 20 02       2040   			JR      NZ,LEXAND		; If not, skip
041171 CB D9       2041   			SET     3,C             	; FLAG: IN HEX
041173             2042   ;
041173 FE 25       2043   LEXAND:			CP	'%'			; Check for binary prefix
041175 20 02       2044   			JR	NZ,LEXANE		; If not, skip
041177 CB D1       2045   			SET	2,C			; FLAG: IN BINARY
041179             2046   ;
041179 21 9D 11 04 2047   LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
04117D C5          2048   			PUSH    BC
04117E 01 06 00 00 2049   			LD      BC,LIST1L		; The list length
041182 ED B1       2050   			CPIR				; Check if the token is in this list
041184 C1          2051   			POP     BC
041185 20 02       2052   			JR      NZ,LEXANF		; If not, then skip
041187 CB E1       2053   			SET     4,C             	; FLAG: ACCEPT LINE NUMBER
041189             2054   ;
041189 21 A1 11 04 2055   LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
04118D C5          2056   			PUSH    BC
04118E 01 05 00 00 2057   			LD      BC,LIST2L		; The list length
041192 ED B1       2058   			CPIR				; Check if the token is in this list
041194 C1          2059   			POP     BC
041195 20 02       2060   			JR      NZ,LEXANG		; If not, then skip
041197 CB C1       2061   			SET     0,C             	; FLAG: ENTER LEFT MODE
041199 C3 E5 10 04 2062   LEXANG:			JP      LEXAN1			; And loop
04119D             2063   
04119D             2064   ;
04119D             2065   ; LIST1: List of tokens that must be followed by line numbers
04119D             2066   ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
04119D             2067   ;
04119D E5          2068   LIST1:			DB	GOTO
04119E E4          2069   			DB	GOSUB
04119F F7          2070   			DB	RESTOR
0411A0 FC          2071   			DB	TRACE
0411A1 8C          2072   LIST2:			DB	THEN
0411A2 8B          2073   			DB	ELSE_
0411A3             2074   LIST1L:			EQU     $-LIST1
0411A3 F5          2075   			DB	REPEAT
0411A4 85          2076   			DB	TERROR
0411A5 3A          2077   			DB    	':'
0411A6             2078   LIST2L:			EQU     $-LIST2
0411A6             2079   ;
0411A6             2080   ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
0411A6             2081   ;   Inputs: HL=line number, DE=string pointer
0411A6             2082   ;  Outputs: DE updated, BIT 4,C set.
0411A6             2083   ; Destroys: A,B,C,D,E,F
0411A6             2084   ;
0411A6             2085   ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
0411A6             2086   ;
0411A6             2087   ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
0411A6             2088   ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
0411A6             2089   ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
0411A6             2090   ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
0411A6             2091   ; each byte are then stored, in LO/HI order, ORred with 0x40.
0411A6             2092   ;
0411A6 CB E1       2093   ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
0411A8 EB          2094   			EX      DE, HL			; HL: string pointer, DE: line number
0411A9 36 8D       2095   			LD      (HL), LINO		; Store 8Dh first to flag next bytes as an encoded line number
0411AB 23          2096   			INC     HL
0411AC 7A          2097   			LD      A,D			; Get the high byte
0411AD E6 C0       2098   			AND     0C0H			; Get the top two bits	DD000000
0411AF 0F          2099   			RRCA				; Shift right		00DD0000
0411B0 0F          2100   			RRCA
0411B1 47          2101   			LD      B,A			; Store in B
0411B2 7B          2102   			LD      A,E			; Get the low byte
0411B3 E6 C0       2103   			AND     0C0H			; Get the top two bits	EE000000
0411B5 B0          2104   			OR      B			; Combine with D	EEDD0000
0411B6 0F          2105   			RRCA				; Shift right		00EEDD00
0411B7 0F          2106   			RRCA
0411B8 EE 54       2107   			XOR     01010100B		; XOR with 54h
0411BA 77          2108   			LD      (HL),A			; Store this as the second byte
0411BB 23          2109   			INC     HL
0411BC 7B          2110   			LD      A,E			; Get the low byte
0411BD E6 3F       2111   			AND     3FH			; Strip the top two bits off
0411BF F6 40       2112   			OR      '@'			; OR with 40h
0411C1 77          2113   			LD      (HL),A			; Store
0411C2 23          2114   			INC     HL
0411C3 7A          2115   			LD      A,D			; Get the high byte
0411C4 E6 3F       2116   			AND     3FH			; Strip the top two bits off
0411C6 F6 40       2117   			OR      '@'			; OR with 40h
0411C8 77          2118   			LD      (HL),A			; Store
0411C9 23          2119   			INC     HL
0411CA EB          2120   			EX      DE,HL			; DE: string pointer, HL: line number
0411CB C9          2121   			RET
0411CC             2122   ;
0411CC             2123   ; TEXT - OUTPUT MESSAGE.
0411CC             2124   ;   Inputs: HL addresses text (terminated by nul)
0411CC             2125   ;  Outputs: HL addresses character following nul.
0411CC             2126   ; Destroys: A,H,L,F
0411CC             2127   ;
0411CC 2A 2F 03 04 2128   REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
0411D0             2129   ;
0411D0 7E          2130   TEXT_:			LD      A, (HL)			; Fetch the character
0411D1 23          2131   			INC     HL			; Increment pointer to next character
0411D2 B7          2132   			OR      A			; Check for the nul (0) string terminator
0411D3 C8          2133   			RET     Z			; And return if so
0411D4 CD B6 0D 04 2134   			CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
0411D8 18 F6       2135   			JR      TEXT_			; And loop
0411DA             2136   ;
0411DA             2137   ; TELL - OUTPUT MESSAGE.
0411DA             2138   ;   Inputs: Text follows subroutine call (term=nul)
0411DA             2139   ; Destroys: A,F
0411DA             2140   ;
0411DA             2141   ; Example usage:
0411DA             2142   ;
0411DA             2143   ;	CALL	TELL			Call the function
0411DA             2144   ;	DB	"Hello World", 0	Followed by a zero terminated string
0411DA             2145   ;	LD	A, (1234H)		Program execution will carry on here after the message is output
0411DA             2146   ;
0411DA E3          2147   TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
0411DB CD D0 11 04 2148   			CALL    TEXT_			; first byte of the string that follows it. Print it, then
0411DF E3          2149   			EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
0411E0 C9          2150   			RET				; at this point we'll return to the first instruction after the message
0411E1             2151   
0411E1             2152   ; ========= STUB FUNCTIONS =========
0411E1             2153   printInline:
0411E1 C9          2154   	RET
0411E2             2155   
0411E2             2156   OSINIT:
0411E2 CD E1 11 04 2157   	call printInline
0411E6 6D 61 69 6E 2158   	asciz "main.asm called OSINIT!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 53 49 4E 
       49 54 21 00 
0411FE C9          2159   	ret
0411FF             2160   
0411FF             2161   CHAIN0:
0411FF CD E1 11 04 2162   	call printInline
041203 6D 61 69 6E 2163   	asciz "main.asm called CHAIN0!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       43 48 41 49 
       4E 30 21 00 
04121B C9          2164   	ret
04121C             2165   
04121C             2166   PROMPT:
04121C CD E1 11 04 2167   	call printInline
041220 6D 61 69 6E 2168   	asciz "main.asm called PROMPT!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       50 52 4F 4D 
       50 54 21 00 
041238 C9          2169   	ret
041239             2170   
041239             2171   OSLINE:
041239 CD E1 11 04 2172   	call printInline
04123D 6D 61 69 6E 2173   	asciz "main.asm called OSLINE!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 53 4C 49 
       4E 45 21 00 
041255 C9          2174   	ret
041256             2175   
041256             2176   NXT:
041256 CD E1 11 04 2177   	call printInline
04125A 6D 61 69 6E 2178   	asciz "main.asm called NXT!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4E 58 54 21 
       00          
04126F C9          2179   	ret
041270             2180   
041270             2181   XEQ:
041270 CD E1 11 04 2182   	call printInline
041274 6D 61 69 6E 2183   	asciz "main.asm called XEQ!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       58 45 51 21 
       00          
041289 C9          2184   	ret
04128A             2185   
04128A             2186   EXPRI:
04128A CD E1 11 04 2187   	call printInline
04128E 6D 61 69 6E 2188   	asciz "main.asm called EXPRI!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       45 58 50 52 
       49 21 00    
0412A5 C9          2189   	ret
0412A6             2190   
0412A6             2191   SEARCH:
0412A6 CD E1 11 04 2192   	call printInline
0412AA 6D 61 69 6E 2193   	asciz "main.asm called SEARCH!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       53 45 41 52 
       43 48 21 00 
0412C2 C9          2194   	ret
0412C3             2195   
0412C3             2196   LTRAP:
0412C3 CD E1 11 04 2197   	call printInline
0412C7 6D 61 69 6E 2198   	asciz "main.asm called LTRAP!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4C 54 52 41 
       50 21 00    
0412DE C9          2199   	ret
0412DF             2200   
0412DF             2201   DECODE:
0412DF CD E1 11 04 2202   	call printInline
0412E3 6D 61 69 6E 2203   	asciz "main.asm called DECODE!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       44 45 43 4F 
       44 45 21 00 
0412FB C9          2204   	ret
0412FC             2205   
0412FC             2206   EXPRS:
0412FC CD E1 11 04 2207   	call printInline
041300 6D 61 69 6E 2208   	asciz "main.asm called EXPRS!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       45 58 50 52 
       53 21 00    
041317 C9          2209   	ret
041318             2210   
041318             2211   OSSAVE:
041318 CD E1 11 04 2212   	call printInline
04131C 6D 61 69 6E 2213   	asciz "main.asm called OSSAVE!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 53 53 41 
       56 45 21 00 
041334 C9          2214   	ret
041335             2215   
041335             2216   RESET:
041335 CD E1 11 04 2217   	call printInline
041339 6D 61 69 6E 2218   	asciz "main.asm called RESET!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       52 45 53 45 
       54 21 00    
041350 C9          2219   	ret
041351             2220   
041351             2221   OSSHUT:
041351 CD E1 11 04 2222   	call printInline
041355 6D 61 69 6E 2223   	asciz "main.asm called OSSHUT!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 53 53 48 
       55 54 21 00 
04136D C9          2224   	ret
04136E             2225   
04136E             2226   OSLOAD:
04136E CD E1 11 04 2227   	call printInline
041372 6D 61 69 6E 2228   	asciz "main.asm called OSLOAD!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 53 4C 4F 
       41 44 21 00 
04138A C9          2229   	ret
04138B             2230   
04138B             2231   FILL:
04138B CD E1 11 04 2232   	call printInline
04138F 6D 61 69 6E 2233   	asciz "main.asm called FILL!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       46 49 4C 4C 
       21 00       
0413A5 C9          2234   	ret
0413A6             2235   
0413A6             2236   OSWRCH:
0413A6 CD E1 11 04 2237   	call printInline
0413AA 6D 61 69 6E 2238   	asciz "main.asm called OSWRCH!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 53 57 52 
       43 48 21 00 
0413C2 C9          2239   	ret
0413C3             2240   
0413C3             2241   COMMA:
0413C3 CD E1 11 04 2242   	call printInline
0413C7 6D 61 69 6E 2243   	asciz "main.asm called COMMA!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       43 4F 4D 4D 
       41 21 00    
0413DE C9          2244   	ret
0413DF             2245   
0413DF             2246   MUL16:
0413DF CD E1 11 04 2247   	call printInline
0413E3 6D 61 69 6E 2248   	asciz "main.asm called MUL16!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4D 55 4C 31 
       36 21 00    
0413FA C9          2249   	ret
0413FB             2250   
0413FB             2251   BRAKET:
0413FB CD E1 11 04 2252   	call printInline
0413FF 6D 61 69 6E 2253   	asciz "main.asm called BRAKET!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       42 52 41 4B 
       45 54 21 00 
041417 C9          2254   	ret
041418             2255   
041418             2256   X4OR5:
041418 CD E1 11 04 2257   	call printInline
04141C 6D 61 69 6E 2258   	asciz "main.asm called X4OR5!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       58 34 4F 52 
       35 21 00    
041433 C9          2259   	ret
041434             2260   
041434             2261   LOADN:
041434 CD E1 11 04 2262   	call printInline
041438 6D 61 69 6E 2263   	asciz "main.asm called LOADN!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4C 4F 41 44 
       4E 21 00    
04144F C9          2264   	ret
041450             2265   
041450             2266   SFIX:
041450 CD E1 11 04 2267   	call printInline
041454 6D 61 69 6E 2268   	asciz "main.asm called SFIX!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       53 46 49 58 
       21 00       
04146A C9          2269   	ret
04146B             2270   
04146B             2271   ITEMI:
04146B CD E1 11 04 2272   	call printInline
04146F 6D 61 69 6E 2273   	asciz "main.asm called ITEMI!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       49 54 45 4D 
       49 21 00    
041486 C9          2274   	ret
041487             2275   
041487             2276   CHECK:
041487 CD E1 11 04 2277   	call printInline
04148B 6D 61 69 6E 2278   	asciz "main.asm called CHECK!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       43 48 45 43 
       4B 21 00    
0414A2 C9          2279   	ret
0414A3             2280   
0414A3             2281   TERMQ:
0414A3 CD E1 11 04 2282   	call printInline
0414A7 6D 61 69 6E 2283   	asciz "main.asm called TERMQ!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       54 45 52 4D 
       51 21 00    
0414BE C9          2284   	ret
0414BF             2285   
0414BF             2286   STAR_VERSION:
0414BF CD E1 11 04 2287   	call printInline
0414C3 6D 61 69 6E 2288   	asciz "main.asm called STAR_VERSION!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       53 54 41 52 
       5F 56 45 52 
       53 49 4F 4E 
       21 00       
0414E1 C9          2289   	ret
0414E2             2290   
0414E2             2291   _end:
0414E2 CD E1 11 04 2292   	call printInline
0414E6 6D 61 69 6E 2293   	asciz "main.asm called _end!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       5F 65 6E 64 
       21 00       
0414FC C9          2294   	ret
