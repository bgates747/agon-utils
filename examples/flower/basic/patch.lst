PC     Output      Line
040000             0001   ;
040000             0002   ; Title:	BBC Basic for AGON
040000             0003   ; Author:	Dean Belfield
040000             0004   ; Created:	12/05/2023
040000             0005   ; Last Updated:	15/11/2023
040000             0006   ;
040000             0007   ; Modinfo:
040000             0008   ; 11/07/2023:	Fixed *BYE for ADL mode
040000             0009   ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
040000             0010   
040000             0011   			.ASSUME	ADL = 1
040000             0012   
040000             0013   			INCLUDE "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ; FFOBJID	.STRUCT
040000             0196*  ; 	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ; 	id:		DS	2	; Hosting volume mount ID
040000             0198*  ; 	attr:		DS	1	; Object attribute
040000             0199*  ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ; ;
040000             0204*  ; ; File object structure (FIL)
040000             0205*  ; ;
040000             0206*  ; FIL .STRUCT
040000             0207*  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ; 	flag:		DS	1	; File status flags
040000             0209*  ; 	err:		DS	1	; Abort flag (error code)
040000             0210*  ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ; 	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ; FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ; ;
040000             0217*  ; ; Directory object structure (DIR)
040000             0218*  ; ;
040000             0219*  ; DIR .STRUCT
040000             0220*  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0221*  ; 	dptr:		DS	4	; Current read/write offset
040000             0222*  ; 	clust:		DS	4	; Current cluster
040000             0223*  ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ; 	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ; DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ; ;
040000             0229*  ; ; File information structure (FILINFO)
040000             0230*  ; ;
040000             0231*  ; FILINFO .STRUCT
040000             0232*  ; 	fsize:		DS 	4	; File size
040000             0233*  ; 	fdate:		DS	2	; Modified date
040000             0234*  ; 	ftime:		DS	2	; Modified time
040000             0235*  ; 	fattrib:	DS	1	; File attribute
040000             0236*  ; 	altname:	DS	13	; Alternative file name
040000             0237*  ; 	fname:		DS	256	; Primary file name
040000             0238*  ; FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ; FFOBJID offsets
040000             0241*  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0242*  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0243*  FFOBJID.attr:     EQU 5    ; Object attribute
040000             0244*  FFOBJID.stat:     EQU 6    ; Object chain status
040000             0245*  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0246*  FFOBJID.objsize:  EQU 11   ; Object size
040000             0247*  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0248*  
040000             0249*  ; FIL offsets (including FFOBJID fields)
040000             0250*  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0251*  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0252*  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0253*  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0254*  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0255*  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0256*  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0257*  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0258*  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0259*  
040000             0260*  ; DIR offsets (including FFOBJID fields)
040000             0261*  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0262*  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0263*  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0264*  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0265*  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0266*  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0267*  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0268*  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0269*  
040000             0270*  ; FILINFO offsets
040000             0271*  FILINFO.fsize:    EQU 0    ; File size
040000             0272*  FILINFO.fdate:    EQU 4    ; Modified date
040000             0273*  FILINFO.ftime:    EQU 6    ; Modified time
040000             0274*  FILINFO.fattrib:  EQU 8    ; File attribute
040000             0275*  FILINFO.altname:  EQU 9    ; Alternative file name
040000             0276*  FILINFO.fname:    EQU 22   ; Primary file name
040000             0277*  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0278*  
040000             0279*  ;
040000             0280*  ; Macro for calling the API
040000             0281*  ; Parameters:
040000             0282*  ; - function: One of the function numbers listed above
040000             0283*  ;
040000             0284*  			MACRO MOSCALL	function
040000             0285*  			LD	A, function
040000             0286*  			RST.LIS	08h
040000             0287*  			ENDMACRO
040000             0014   			INCLUDE "macros.inc"
040000             0001*  	; Title:	BBC Basic Interpreter - Z80 version
040000             0002*  	;		Useful macros
040000             0003*  	; Author:	Dean Belfield
040000             0004*  	; Created:	12/05/2023
040000             0005*  	; Last Updated:	11/06/2023
040000             0006*  	;
040000             0007*  	; Modinfo:
040000             0008*  	; 11/06/2023:	Modified to run in ADL mode
040000             0009*  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040000             0010*  
040000             0011*  	MACRO EXREG	rp1, rp2
040000             0012*  		PUSH	rp1
040000             0013*  		POP	rp2
040000             0014*  	ENDMACRO
040000             0015*  
040000             0016*  	; MACRO ADD8U_DE	reg
040000             0017*  		MACRO ADD8U_DE
040000             0018*  		ADD	A, E
040000             0019*  		LD	E, A
040000             0020*  		ADC	A, D
040000             0021*  		SUB	E
040000             0022*  		LD	D, A
040000             0023*  	ENDMACRO
040000             0024*  
040000             0025*  	; MACRO ADD8U_HL	reg
040000             0026*  	MACRO ADD8U_HL
040000             0027*  		ADD	A, L
040000             0028*  		LD	L, A
040000             0029*  		ADC	A, H
040000             0030*  		SUB	L
040000             0031*  		LD	H, A
040000             0032*  	ENDMACRO
040000             0033*  
040000             0034*  	MACRO VDU	val
040000             0035*  		LD	A, val
040000             0036*  		CALL	OSWRCH
040000             0037*  	ENDMACRO
040000             0038*  
040000             0039*  	MACRO SET_GPIO	reg, val
040000             0040*  		IN0	A, (reg)
040000             0041*  		OR	val
040000             0042*  		OUT0	(reg), A
040000             0043*  	ENDMACRO
040000             0044*  
040000             0045*  	MACRO RES_GPIO	reg, val
040000             0046*  		PUSH	BC
040000             0047*  		LD	A, val
040000             0048*  		CPL
040000             0049*  		LD	C, A
040000             0050*  		IN0	A, (reg)
040000             0051*  		AND	C
040000             0052*  		OUT0	(reg), A
040000             0053*  		POP	BC
040000             0054*  	ENDMACRO
040000             0015   			INCLUDE "ram.asm"
040000             0001*  ;
040000             0002*  ; Title:	BBC Basic Interpreter - Z80 version
040000             0003*  ;		RAM Module for BBC Basic Interpreter
040000             0004*  ;		For use with Version 2.0 of BBC BASIC
040000             0005*  ;		Standard CP/M Distribution Version
040000             0006*  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
040000             0007*  ; Modified By:	Dean Belfield
040000             0008*  ; Created:	12/05/2023
040000             0009*  ; Last Updated:	26/06/2023
040000             0010*  ;
040000             0011*  ; Modinfo:
040000             0012*  ; 06/06/2023:	Modified to run in ADL mode
040000             0013*  ; 26/06/2023:	Added temporary stores R0 and R1
040000             0014*  
040000             0015*  			.ASSUME	ADL = 1
040000             0016*  
040000             0017*  			; DEFINE	LORAM, SPACE = ROM
040000             0018*  			; SEGMENT LORAM
040000             0019*  
040000             0020*  			; XDEF	ACCS
040000             0021*  			; XDEF	BUFFER
040000             0022*  			; XDEF	STAVAR
040000             0023*  			; XDEF	DYNVAR
040000             0024*  			; XDEF	FNPTR
040000             0025*  			; XDEF	PROPTR
040000             0026*  			; XDEF	PAGE_
040000             0027*  			; XDEF	TOP
040000             0028*  			; XDEF	LOMEM
040000             0029*  			; XDEF 	FREE
040000             0030*  			; XDEF	HIMEM
040000             0031*  			; XDEF	LINENO
040000             0032*  			; XDEF	TRACEN
040000             0033*  			; XDEF	AUTONO
040000             0034*  			; XDEF	ERRTRP
040000             0035*  			; XDEF	ERRTXT
040000             0036*  			; XDEF	DATPTR
040000             0037*  			; XDEF	ERL
040000             0038*  			; XDEF	ERRLIN
040000             0039*  			; XDEF	RANDOM
040000             0040*  			; XDEF	COUNT
040000             0041*  			; XDEF	WIDTH
040000             0042*  			; XDEF	ERR
040000             0043*  			; XDEF	LISTON
040000             0044*  			; XDEF	INCREM
040000             0045*  
040000             0046*  			; XDEF	FLAGS
040000             0047*  			; XDEF	OSWRCHPT
040000             0048*  			; XDEF	OSWRCHCH
040000             0049*  			; XDEF	OSWRCHFH
040000             0050*  			; XDEF	KEYDOWN
040000             0051*  			; XDEF	KEYASCII
040000             0052*  			; XDEF	KEYCOUNT
040000             0053*  
040000             0054*  			; XDEF	R0
040000             0055*  			; XDEF	R1
040000             0056*  
040000             0057*  			; XDEF	RAM_START
040000             0058*  			; XDEF	RAM_END
040000             0059*  			; XDEF	USER
040000             0060*  
040000             0061*  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
040000             0062*  RAM_START:
040000             0063*  ;
040000             0064*  ACCS:			DS		256             ; String Accumulator
040100             0065*  BUFFER:			DS		256             ; String Input Buffer
040200             0066*  STAVAR:			DS	 	27*4            ; Static Variables
04026C             0067*  DYNVAR: 		DS 		54*3            ; Dynamic Variable Pointers
04030E             0068*  FNPTR:  		DS    		3               ; Dynamic Function Pointers
040311             0069*  PROPTR: 		DS		3               ; Dynamic Procedure Pointers
040314             0070*  ;
040314             0071*  PAGE_:   		DS		3               ; Start of User Program
040317             0072*  TOP:    		DS		3               ; First Location after User Program
04031A             0073*  LOMEM:  		DS		3               ; Start of Dynamic Storage
04031D             0074*  FREE:   		DS		3               ; First Free Space Byte
040320             0075*  HIMEM:  		DS		3               ; First Protected Byte
040323             0076*  ;
040323             0077*  LINENO: 		DS		3               ; Line Number
040326             0078*  TRACEN:			DS		3               ; Trace Flag
040329             0079*  AUTONO:			DS		3               ; Auto Flag
04032C             0080*  ERRTRP:			DS		3               ; Error Trap
04032F             0081*  ERRTXT:			DS		2               ; Error Message Pointer
040331             0082*  DATPTR:			DS		2               ; Data Pointer
040333             0083*  ERL:			DS		2               ; Error Line
040335             0084*  ERRLIN:			DS		3               ; The "ON ERROR" Line
040338             0085*  RANDOM:			DS		5               ; Random Number
04033D             0086*  COUNT:			DS		1               ; Print Position
04033E             0087*  WIDTH:			DS		1               ; Print Width
04033F             0088*  ERR:			DS		1               ; Error Number
040340             0089*  LISTON:			DS		1               ; LISTO (bottom nibble)
040341             0090*  							; - BIT 0: If set, output a space after the line number
040341             0091*  							; - BIT 1: If set, then indent FOR/NEXT loops
040341             0092*  							; - BIT 2: If set, then indent REPEAT/UNTIL loops
040341             0093*  							; - BIT 3: If set, then output to buffer for *EDIT
040341             0094*  							; OPT FLAG (top nibble)
040341             0095*  							; - BIT 4: If set, then list whilst assembling
040341             0096*  							; - BIT 5: If set, then assembler errors are reported
040341             0097*  							; - BIT 6: If set, then place the code starting at address pointed to by O%
040341             0098*  							; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
040341             0099*  INCREM:			DS		1               ; Auto-Increment Value
040342             0100*  ;
040342             0101*  ; Extra Agon-implementation specific system variables
040342             0102*  ;
040342             0103*  FLAGS:			DS		1		; Miscellaneous flags
040343             0104*  							; - BIT 7: Set if ESC pressed
040343             0105*  							; - BIT 6: Set to disable ESC
040343             0106*  OSWRCHPT:		DS		2		; Pointer for *EDIT
040345             0107*  OSWRCHCH:		DS		1		; Channel of OSWRCH
040346             0108*  							; - 0: Console
040346             0109*  							; - 1: File
040346             0110*  OSWRCHFH:		DS		1		; File handle for OSWRCHCHN
040347             0111*  KEYDOWN:		DS		1		; Keydown flag
040348             0112*  KEYASCII:		DS		1		; ASCII code of pressed key
040349             0113*  KEYCOUNT:		DS		1		; Counts every time a key is pressed
04034A             0114*  R0:			DS		3		; General purpose storage for 8/16 to 24 bit operations
04034D             0115*  R1:			DS		3		;
040350             0116*  ;
040350             0117*  ; This must be at the end
040350             0118*  ;
040350             0119*  RAM_END:
040350 FF FF FF FF 0120*  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040400             0121*  USER:							; Must be aligned on a page boundary
040400             0122*  
040400             0016   			INCLUDE	"equs.inc"
040400             0001*  ;
040400             0002*  ; Title:	BBC Basic for AGON - Equs
040400             0003*  ; Author:	Dean Belfield
040400             0004*  ; Created:	12/05/2023
040400             0005*  ; Last Updated:	08/06/2023
040400             0006*  ;
040400             0007*  ; Modinfo:
040400             0008*  ; 08/06/2023:	Added SIZEW
040400             0009*  
040400             0010*  			; XREF		STAVAR
040400             0011*  			; XREF		ACCS
040400             0012*  
040400             0013*  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
040400             0014*  ;Stack_Top:		EQU		0000h	; Stack at top
040400             0015*  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
040400             0016*  
040400             0017*  ; For GPIO
040400             0018*  ; PA not available on eZ80L92
040400             0019*  ;
040400             0020*  PA_DR:			EQU		96h
040400             0021*  PA_DDR:			EQU		97h
040400             0022*  PA_ALT1:		EQU		98h
040400             0023*  PA_ALT2:		EQU		99h
040400             0024*  PB_DR:          	EQU		9Ah
040400             0025*  PB_DDR:        	 	EQU		9Bh
040400             0026*  PB_ALT1:        	EQU		9Ch
040400             0027*  PB_ALT2:        	EQU		9Dh
040400             0028*  PC_DR:          	EQU		9Eh
040400             0029*  PC_DDR:         	EQU		9Fh
040400             0030*  PC_ALT1:        	EQU		A0h
040400             0031*  PC_ALT2:        	EQU		A1h
040400             0032*  PD_DR:          	EQU		A2h
040400             0033*  PD_DDR:			EQU		A3h
040400             0034*  PD_ALT1:		EQU		A4h
040400             0035*  PD_ALT2:		EQU		A5h
040400             0036*  
040400             0037*  GPIOMODE_OUT:		EQU		0	; Output
040400             0038*  GPIOMODE_IN:		EQU		1	; Input
040400             0039*  GPIOMODE_DIO:		EQU		2	; Open Drain IO
040400             0040*  GPIOMODE_SIO:		EQU		3	; Open Source IO
040400             0041*  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040400             0042*  GPIOMODE_ALTF:		EQU		5;	; Alt Function
040400             0043*  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040400             0044*  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040400             0045*  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040400             0046*  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040400             0047*  
040400             0048*  ; Originally in ram.asm
040400             0049*  ;
040400             0050*  OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
040400             0051*  PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
040400             0052*  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
040400             0053*  
040400             0054*  ; Originally in main.asm
040400             0055*  ;
040400             0056*  CR:			EQU     0DH
040400             0057*  LF:			EQU     0AH
040400             0058*  ESC:			EQU     1BH
040400             0017   
040400             0018   			; SEGMENT CODE
040400             0019   
040400             0020   			; XDEF	OSWRCH
040400             0021   			; XDEF	OSLINE
040400             0022   			; XDEF	ESCSET
040400             0023   			; XDEF	PUTIME
040400             0024   			; XDEF	GETIME
040400             0025   			; XDEF	PUTCSR
040400             0026   			; XDEF 	GETCSR
040400             0027   			; XDEF	OSRDCH
040400             0028   			; XDEF	PROMPT
040400             0029   			; XDEF	OSKEY
040400             0030   			; XDEF	TRAP
040400             0031   			; XDEF	LTRAP
040400             0032   			; XDEF	OSINIT
040400             0033   			; XDEF	OSCLI
040400             0034   			; XDEF	OSBPUT
040400             0035   			; XDEF	OSBGET
040400             0036   			; XDEF	OSSTAT
040400             0037   			; XDEF	OSSHUT
040400             0038   			; XDEF	OSOPEN
040400             0039   			; XDEF	OSCALL
040400             0040   			; XDEF	GETPTR
040400             0041   			; XDEF	PUTPTR
040400             0042   			; XDEF	GETEXT
040400             0043   			; XDEF	GETIMS
040400             0044   			; XDEF	RESET
040400             0045   			; XDEF	OSLOAD
040400             0046   			; XDEF	OSSAVE
040400             0047   			; XDEF	EXPR_W2
040400             0048   			; XDEF	STAR_VERSION
040400             0049   
040400             0050   			; XREF	_end			; In init.asm
040400             0051   
040400             0052   			; XREF	ASC_TO_NUMBER
040400             0053   			; XREF	RAM_START
040400             0054   			; XREF	RAM_END
040400             0055   			; XREF	FLAGS
040400             0056   			; XREF	ESCAPE
040400             0057   			; XREF	USER
040400             0058   			; XREF	RAM_Top
040400             0059   			; XREF	EXTERR
040400             0060   			; XREF	COUNT0
040400             0061   			; XREF	EXPRI
040400             0062   			; XREF	COMMA
040400             0063   			; XREF	XEQ
040400             0064   			; XREF	NXT
040400             0065   			; XREF	NULLTOCR
040400             0066   			; XREF	CRLF
040400             0067   			; XREF	CSTR_FNAME
040400             0068   			; XREF	CSTR_LINE
040400             0069   			; XREF	CSTR_FINDCH
040400             0070   			; XREF	CSTR_ENDSWITH
040400             0071   			; XREF	CSTR_CAT
040400             0072   			; XREF	FINDL
040400             0073   			; XREF	OUT_
040400             0074   			; XREF	ERROR_
040400             0075   			; XREF	ONEDIT
040400             0076   			; XREF	TELL
040400             0077   			; XREF	OSWRCHPT
040400             0078   			; XREF	OSWRCHCH
040400             0079   			; XREF	OSWRCHFH
040400             0080   			; XREF	LISTON
040400             0081   			; XREF	LISTIT
040400             0082   			; XREF	PAGE_
040400             0083   			; XREF	ONEDIT1
040400             0084   			; XREF	CLEAN
040400             0085   			; XREF	NEWIT
040400             0086   			; XREF	BAD
040400             0087   			; XREF	VBLANK_INIT
040400             0088   			; XREF	VBLANK_STOP
040400             0089   			; XREF	KEYDOWN
040400             0090   			; XREF	KEYASCII
040400             0091   			; XREF	WIDTH
040400             0092   			; XREF	ASSEM
040400             0093   
040400             0094   ; OSLINE: Invoke the line editor
040400             0095   ;
040400 1E 01       0096   OSLINE:			LD 	E, 1			; Default is to clear the buffer
040402             0097   
040402             0098   ; Entry point to line editor that does not clear the buffer
040402             0099   ;
040402 FD E5       0100   OSLINE1:		PUSH	IY
040404 E5          0101   			PUSH	HL			; Buffer address
040405 01 00 01 00 0102   			LD	BC, 256			; Buffer length
040409             0103   			MOSCALL	mos_editline		; Call the MOS line editor
040409 3E 09       0001M  			LD	A, function
04040B 49 CF       0002M  			RST.LIS	08h
04040D E1          0104   			POP	HL			; Pop the address
04040E FD E1       0105   			POP	IY
040410 F5          0106   			PUSH	AF			; Stack the return value (key pressed)
040411 CD B5 0B 04 0107   			CALL	NULLTOCR		; Turn the 0 character to a CR
040415 CD 1F 0A 04 0108   			CALL	CRLF			; Display CRLF
040419 F1          0109   			POP	AF
04041A FE 1B       0110   			CP	1Bh 			; Check if ESC terminated the input
04041C CA 18 05 04 0111   			JP	Z, LTRAP1 		; Yes, so do the ESC thing
040420 3A 42 03 04 0112   			LD	A, (FLAGS)		; Otherwise
040424 CB BF       0113   			RES	7, A 			; Clear the escape flag
040426 32 42 03 04 0114   			LD	(FLAGS), A
04042A CD EF 06 04 0115   			CALL	WAIT_VBLANK 		; Wait a frame
04042E AF          0116    			XOR	A			; Return A = 0
04042F 32 47 03 04 0117   			LD	(KEYDOWN), A
040433 32 48 03 04 0118   			LD	(KEYASCII), A
040437 C9          0119   			RET
040438             0120   
040438             0121   ; PUTIME: set current time to DE:HL, in centiseconds.
040438             0122   ;
040438 DD E5       0123   PUTIME:			PUSH 	IX
04043A             0124   			MOSCALL	mos_sysvars
04043A 3E 08       0001M  			LD	A, function
04043C 49 CF       0002M  			RST.LIS	08h
04043E DD 75 00    0125   			LD	(IX + sysvar_time + 0), L
040441 DD 74 01    0126   			LD	(IX + sysvar_time + 1), H
040444 DD 73 02    0127   			LD	(IX + sysvar_time + 2), E
040447 DD 72 03    0128   			LD	(IX + sysvar_time + 3), D
04044A DD E1       0129   			POP	IX
04044C C9          0130   			RET
04044D             0131   
04044D             0132   ; GETIME: return current time in DE:HL, in centiseconds
04044D             0133   ;
04044D DD E5       0134   GETIME:			PUSH 	IX
04044F             0135   			MOSCALL	mos_sysvars
04044F 3E 08       0001M  			LD	A, function
040451 49 CF       0002M  			RST.LIS	08h
040453 DD 6E 00    0136   			LD	L, (IX + sysvar_time + 0)
040456 DD 66 01    0137   			LD	H, (IX + sysvar_time + 1)
040459 DD 5E 02    0138   			LD	E, (IX + sysvar_time + 2)
04045C DD 56 03    0139   			LD	D, (IX + sysvar_time + 3)
04045F DD E1       0140   			POP	IX
040461 C9          0141   			RET
040462             0142   
040462             0143   ; PUTCSR: move to cursor to x=DE, y=HL
040462             0144   ;
040462 3E 1F       0145   PUTCSR:			LD	A, 1Fh			; TAB
040464 5B D7       0146   			RST.LIL	10h
040466 7B          0147   			LD	A, E			; X
040467 5B D7       0148   			RST.LIL 10h
040469 7D          0149   			LD	A, L			; Y
04046A 5B D7       0150   			RST.LIL 10h
04046C C9          0151   			RET
04046D             0152   
04046D             0153   ; GETCSR: return cursor position in x=DE, y=HL
04046D             0154   ;
04046D DD E5       0155   GETCSR:			PUSH	IX			; Get the system vars in IX
04046F             0156   			MOSCALL	mos_sysvars		; Reset the semaphore
04046F 3E 08       0001M  			LD	A, function
040471 49 CF       0002M  			RST.LIS	08h
040473 DD CB 04 86 0157   			RES	0, (IX+sysvar_vpd_pflags)
040477             0158   			VDU	23
040477 3E 17       0001M  		LD	A, val
040479 CD A1 04 04 0002M  		CALL	OSWRCH
04047D             0159   			VDU	0
04047D 3E 00       0001M  		LD	A, val
04047F CD A1 04 04 0002M  		CALL	OSWRCH
040483             0160   			VDU	vdp_cursor
040483 3E 82       0001M  		LD	A, val
040485 CD A1 04 04 0002M  		CALL	OSWRCH
040489 DD CB 04 46 0161   @@:			BIT	0, (IX+sysvar_vpd_pflags)
04048D 28 FA       0162   			JR	Z, @B			; Wait for the result
04048F 16 00       0163   			LD 	D, 0
040491 62          0164   			LD	H, D
040492 DD 5E 07    0165   			LD	E, (IX + sysvar_cursorX)
040495 DD 6E 08    0166   			LD	L, (IX + sysvar_cursorY)
040498 DD E1       0167   			POP	IX
04049A C9          0168   			RET
04049B             0169   
04049B             0170   ; PROMPT: output the input prompt
04049B             0171   ;
04049B 3E 3E       0172   PROMPT: 		LD	A,'>'
04049D C3 A1 04 04 0173   			JP	OSWRCH
0404A1             0174   
0404A1             0175   ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
0404A1             0176   ; A: Character to write
0404A1             0177   ;
0404A1 E5          0178   OSWRCH:			PUSH	HL
0404A2 21 40 03 04 0179   			LD	HL, LISTON		; Fetch the LISTON variable
0404A6 CB 5E       0180   			BIT	3, (HL)			; Check whether we are in *EDIT mode
0404A8 20 0B       0181   			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
0404AA             0182   ;
0404AA 2A 45 03 04 0183   			LD	HL, (OSWRCHCH)		; L: Channel #
0404AE 2D          0184   			DEC	L			; If it is 1
0404AF 28 10       0185   			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
0404B1             0186   ;
0404B1 E1          0187   			POP	HL			; Otherwise
0404B2 5B D7       0188   			RST.LIL	10h			; Output the character to MOS
0404B4 C9          0189   			RET
0404B5             0190   ;
0404B5 2A 43 03 04 0191   OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
0404B9 77          0192   			LD	(HL), A			; Echo the character into the buffer
0404BA 23          0193   			INC	HL			; Increment pointer
0404BB 22 43 03 04 0194   			LD	(OSWRCHPT), HL		; Write pointer back
0404BF E1          0195   			POP	HL
0404C0 C9          0196   			RET
0404C1             0197   ;
0404C1 D5          0198   OSWRCH_FILE:		PUSH	DE
0404C2 5C          0199   			LD	E, H			; Filehandle to E
0404C3 CD ED 08 04 0200   			CALL	OSBPUT			; Write the byte out
0404C7 D1          0201   			POP	DE
0404C8 E1          0202   			POP	HL
0404C9 C9          0203   			RET
0404CA             0204   
0404CA             0205   ; OSRDCH: Read a character in from the ESP32 keyboard handler
0404CA             0206   ; This is only called in GETS (eval.asm)
0404CA             0207   ;
0404CA             0208   OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
0404CA 3E 00       0001M  			LD	A, function
0404CC 49 CF       0002M  			RST.LIS	08h
0404CE FE 1B       0209   			CP	1Bh
0404D0 28 46       0210   			JR	Z, LTRAP1
0404D2 C9          0211   			RET
0404D3             0212   
0404D3             0213   
0404D3             0214   ;OSKEY - Read key with time-limit, test for ESCape.
0404D3             0215   ;Main function is carried out in user patch.
0404D3             0216   ;   Inputs: HL = time limit (centiseconds)
0404D3             0217   ;  Outputs: Carry reset if time-out
0404D3             0218   ;           If carry set A = character
0404D3             0219   ; Destroys: A,H,L,F
0404D3             0220   ;
0404D3 CD 04 05 04 0221   OSKEY:			CALL	READKEY			; Read the keyboard
0404D7 28 0A       0222   			JR	Z, @F 			; Skip if we have a key
0404D9 7C          0223   			LD	A, H 			; Check loop counter
0404DA B5          0224   			OR 	L
0404DB C8          0225   			RET 	Z 			; Return, we've not got a key at this point
0404DC CD EF 06 04 0226   			CALL	WAIT_VBLANK 		; Wait a frame
0404E0 2B          0227   			DEC 	HL			; Decrement
0404E1 18 F0       0228   			JR	OSKEY 			; And loop
0404E3             0229   ;
0404E3 21 47 03 04 0230   @@:			LD	HL, KEYDOWN		; We have a key, so
0404E7 36 00       0231   			LD	(HL), 0			; clear the keydown flag
0404E9 FE 1B       0232   			CP	1BH			; If we are not pressing ESC,
0404EB 37          0233   			SCF 				; then flag we've got a character
0404EC C0          0234   			RET	NZ
0404ED             0235   ;
0404ED             0236   ; ESCSET
0404ED             0237   ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
0404ED             0238   ;
0404ED E5          0239   ESCSET: 		PUSH    HL
0404EE 21 42 03 04 0240           		LD      HL,FLAGS		; Pointer to FLAGS
0404F2 CB 76       0241           		BIT     6,(HL)			; If bit 6 is set, then
0404F4 20 02       0242           		JR      NZ,ESCDIS		; escape is disabled, so skip
0404F6 CB FE       0243           		SET     7,(HL)			; Set bit 7, the escape flag
0404F8 E1          0244   ESCDIS: 		POP     HL
0404F9 C9          0245           		RET
0404FA             0246   ;
0404FA             0247   ; ESCTEST
0404FA             0248   ; Test for ESC key
0404FA             0249   ;
0404FA CD 04 05 04 0250   ESCTEST:		CALL	READKEY			; Read the keyboard
0404FE C0          0251   			RET	NZ			; Skip if no key is pressed
0404FF FE 1B       0252   			CP	1BH			; If ESC pressed then
040501 28 EA       0253   			JR	Z,ESCSET		; jump to the escape set routine
040503 C9          0254   			RET
040504             0255   
040504             0256   ; Read the keyboard
040504             0257   ; Returns:
040504             0258   ; - A: ASCII of the pressed key
040504             0259   ; - F: Z if the key is pressed, otherwise NZ
040504             0260   ;
040504 3A 47 03 04 0261   READKEY:		LD	A, (KEYDOWN)		; Get key down
040508 3D          0262   			DEC	A 			; Set Z flag if keydown is 1
040509 3A 48 03 04 0263   			LD	A, (KEYASCII)		; Get key ASCII value
04050D C9          0264   			RET
04050E             0265   ;
04050E             0266   ; TRAP
04050E             0267   ; This is called whenever BASIC needs to check for ESC
04050E             0268   ;
04050E CD FA 04 04 0269   TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
040512             0270   ;
040512 3A 42 03 04 0271   LTRAP:			LD	A,(FLAGS)		; Get FLAGS
040516 B7          0272   			OR	A			; This checks for bit 7; if it is not set then the result will
040517 F0          0273   			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
040518 21 42 03 04 0274   LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
04051C CB BE       0275   			RES	7,(HL)			; Clear the escape pressed flag and
04051E C3 04 0B 04 0276   			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
040522             0277   
040522             0278   ;OSINIT - Initialise RAM mapping etc.
040522             0279   ;If BASIC is entered by BBCBASIC FILENAME then file
040522             0280   ;FILENAME.BBC is automatically CHAINed.
040522             0281   ;   Outputs: DE = initial value of HIMEM (top of RAM)
040522             0282   ;            HL = initial value of PAGE (user program)
040522             0283   ;            Z-flag reset indicates AUTO-RUN.
040522             0284   ;  Destroys: A,D,E,H,L,F
040522             0285   ;
040522 CD 65 0C 04 0286   OSINIT:			CALL	VBLANK_INIT
040526 AF          0287   			XOR	A
040527 21 00 04 04 0288   			LD 	HL, USER
04052B 11 00 00 0B 0289   			LD	DE, RAM_Top
04052F 5F          0290   			LD	E, A			; Page boundary
040530 C9          0291   			RET
040531             0292   
040531             0293   ;
040531             0294   ;OSCLI - Process a MOS command
040531             0295   ;
040531 CD A5 05 04 0296   OSCLI: 			CALL    SKIPSP
040535 FE 0D       0297   			CP      CR
040537 C8          0298   			RET     Z
040538 FE 7C       0299   			CP      '|'
04053A C8          0300   			RET     Z
04053B EB          0301   			EX      DE,HL
04053C 21 B4 05 04 0302   			LD      HL,COMDS
040540 1A          0303   OSCLI0:			LD      A,(DE)
040541 CD AC 05 04 0304   			CALL    UPPRC
040545 BE          0305   			CP      (HL)
040546 28 0B       0306   			JR      Z,OSCLI2
040548 38 30       0307   			JR      C,OSCLI6
04054A CB 7E       0308   OSCLI1:			BIT     7,(HL)
04054C 23          0309   			INC     HL
04054D 28 FB       0310   			JR      Z,OSCLI1
04054F 23          0311   			INC     HL
040550 23          0312   			INC     HL
040551 18 ED       0313   			JR      OSCLI0
040553             0314   ;
040553 D5          0315   OSCLI2:			PUSH    DE
040554 13          0316   OSCLI3:			INC     DE
040555 23          0317   			INC     HL
040556 1A          0318   			LD      A,(DE)
040557 CD AC 05 04 0319   			CALL    UPPRC
04055B FE 2E       0320   			CP      '.'			; ABBREVIATED?
04055D 28 0A       0321   			JR      Z,OSCLI4
04055F AE          0322   			XOR     (HL)
040560 28 F2       0323   			JR      Z,OSCLI3
040562 FE 80       0324   			CP      80H
040564 28 03       0325   			JR      Z,OSCLI4
040566 D1          0326   			POP     DE
040567 18 E1       0327   			JR      OSCLI1
040569             0328   ;
040569 F1          0329   OSCLI4:			POP     AF
04056A 13          0330   		        INC     DE
04056B CB 7E       0331   OSCLI5:			BIT     7,(HL)
04056D 23          0332   			INC     HL
04056E 28 FB       0333   			JR      Z,OSCLI5
040570 7E          0334   			LD      A,(HL)
040571 23          0335   			INC     HL
040572 66          0336   			LD      H,(HL)
040573 6F          0337   			LD      L,A
040574 E5          0338   			PUSH    HL
040575 EB          0339   			EX      DE,HL
040576 C3 A5 05 04 0340   			JP      SKIPSP
04057A             0341   ;
04057A EB          0342   OSCLI6:			EX	DE, HL			; HL: Buffer for command
04057B 11 00 00 04 0343   			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
04057F D5          0344   			PUSH	DE			; Store buffer address
040580 CD C5 0A 04 0345   			CALL	CSTR_LINE		; Fetch the line
040584 E1          0346   			POP	HL			; HL: Pointer to command string in ACCS
040585 FD E5       0347   			PUSH	IY
040587             0348   			MOSCALL	mos_oscli		; Returns OSCLI error in A
040587 3E 10       0001M  			LD	A, function
040589 49 CF       0002M  			RST.LIS	08h
04058B FD E1       0349   			POP	IY
04058D B7          0350   			OR	A			; 0 means MOS returned OK
04058E C8          0351   			RET	Z			; So don't do anything
04058F C3 C9 07 04 0352   			JP 	OSERROR			; Otherwise it's a MOS error
040593             0353   
040593 3E FE       0354   HUH:    		LD      A,254			; Bad command error
040595 CD 3F 0B 04 0355           		CALL    EXTERR
040599 42 61 64 20 0356           		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
0405A4 00          0357           		DEFB    0
0405A5             0358   
0405A5 7E          0359   SKIPSP:			LD      A,(HL)
0405A6 FE 20       0360           		CP      ' '
0405A8 C0          0361           		RET     NZ
0405A9 23          0362           		INC     HL
0405AA 18 F9       0363           		JR      SKIPSP
0405AC             0364   
0405AC E6 7F       0365   UPPRC:  		AND     7FH
0405AE FE 60       0366   			CP      '`'
0405B0 D8          0367   			RET     C
0405B1 E6 5F       0368   			AND     5FH			; CONVERT TO UPPER CASE
0405B3 C9          0369   			RET
0405B4             0370   
0405B4             0371   ; Each command has bit 7 of the last character set, and is followed by the address of the handler
0405B4             0372   ; These must be in alphabetical order
0405B4             0373   ;
0405B4 41 53 4D    0374   COMDS:  		DB	"AS","M"+80h		; ASM
0405B7 D2 05       0375   			DW	STAR_ASM
0405B9 42 59 45    0376   			DB	"BY","E"+80h		; BYE
0405BC DE 05       0377   			DW	STAR_BYE
0405BE 45 44 49 54 0378   			DB	"EDI","T"+80h		; EDIT
0405C2 13 06       0379   			DW	STAR_EDIT
0405C4 46 58       0380   			DB	"F","X"+80h		; FX
0405C6 53 06       0381   			DW	STAR_FX
0405C8 56 45 52 53 0382   			DB	"VERSIO","N"+80h	; VERSION
       49 4F 4E    
0405CF EA 05       0383   			DW	STAR_VERSION
0405D1 FF          0384   			DB	FFh
0405D2             0385   
0405D2             0386   ; *ASM string
0405D2             0387   ;
0405D2 FD E5       0388   STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
0405D4 E5          0389   			PUSH	HL			; HL = IY
0405D5 FD E1       0390   			POP	IY
0405D7 CD 8F 09 04 0391   			CALL	ASSEM			; Invoke the assembler
0405DB FD E1       0392   			POP	IY
0405DD C9          0393   			RET
0405DE             0394   
0405DE             0395   ; *BYE
0405DE             0396   ;
0405DE CD 88 0C 04 0397   STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
0405E2 21 00 00 00 0398   			LD	HL, 0			; The return value
0405E6 C3 C6 0C 04 0399   			JP	_end 			; Jump back to the end routine in init.asm
0405EA             0400   
0405EA             0401   ; *VERSION
0405EA             0402   ;
0405EA CD 49 0C 04 0403   STAR_VERSION:		CALL    TELL			; Output the welcome message
0405EE 42 42 43 20 0404   			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
040612 C9          0405   			RET
040613             0406   
040613             0407   ; *EDIT linenum
040613             0408   ;
040613 CD 6A 09 04 0409   STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
040617 EB          0410   			EX	DE, HL			; HL: Line number
040618 CD 5D 0B 04 0411   			CALL	FINDL			; HL: Address in RAM of tokenised line
04061C 3E 29       0412   			LD	A, 41			; F:NZ If the line is not found
04061E C2 E6 0A 04 0413   			JP	NZ, ERROR_		; Do error 41: No such line in that case
040622             0414   ;
040622             0415   ; Use LISTIT to output the line to the ACCS buffer
040622             0416   ;
040622 23          0417   			INC	HL			; Skip the length byte
040623 5E          0418   			LD	E, (HL)			; Fetch the line number
040624 23          0419   			INC	HL
040625 56          0420   			LD	D, (HL)
040626 23          0421   			INC	HL
040627 DD 21 00 00 0422   			LD	IX, ACCS		; Pointer to where the copy is to be stored
       04          
04062C DD 22 43 03 0423   			LD	(OSWRCHPT), IX
       04          
040631 DD 21 40 03 0424   			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       04          
040636 DD 7E 00    0425   			LD	A, (IX)			; Store that variable
040639 F5          0426   			PUSH	AF
04063A DD 36 00 09 0427   			LD	(IX), 09h		; Set to echo to buffer
04063E CD 7A 0B 04 0428   			CALL	LISTIT
040642 F1          0429   			POP	AF
040643 DD 77 00    0430   			LD	(IX), A			; Restore the original LISTON variable
040646 21 00 00 04 0431   			LD	HL, ACCS		; HL: ACCS
04064A 5D          0432   			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
04064B CD 02 04 04 0433   			CALL	OSLINE1			; Invoke the editor
04064F C3 F0 0B 04 0434   			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
040653             0435   
040653             0436   ; OSCLI FX n
040653             0437   ;
040653 CD 6A 09 04 0438   STAR_FX:		CALL	ASC_TO_NUMBER
040657 4B          0439   			LD	C, E			; C: Save FX #
040658 CD 6A 09 04 0440   			CALL	ASC_TO_NUMBER
04065C 7A          0441   			LD	A, D  			; Is first parameter > 255?
04065D B7          0442   			OR 	A
04065E 28 03       0443   			JR	Z, STAR_FX1		; Yes, so skip next bit
040660 EB          0444   			EX	DE, HL 			; Parameter is 16-bit
040661 18 07       0445   			JR	STAR_FX2
040663             0446   ;
040663 43          0447   STAR_FX1:		LD	B, E 			; B: Save First parameter
040664 CD 6A 09 04 0448   			CALL	ASC_TO_NUMBER		; Fetch second parameter
040668 68          0449   			LD	L, B 			; L: First parameter
040669 63          0450   			LD	H, E 			; H: Second parameter
04066A             0451   ;
04066A 79          0452   STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
04066B             0453   ;
04066B             0454   ; OSBYTE
04066B             0455   ;  A: FX #
04066B             0456   ;  L: First parameter
04066B             0457   ;  H: Second parameter
04066B             0458   ;
04066B FE 0B       0459   OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
04066D 28 18       0460   			JR	Z, OSBYTE_0B
04066F FE 0C       0461   			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
040671 28 43       0462   			JR	Z, OSBYTE_0C
040673 FE 13       0463   			CP	13H			; *FX 19: Wait for vblank
040675 28 6E       0464   			JR	Z, OSBYTE_13
040677 FE 76       0465   			CP	76H			; *FX 118, n: Set keyboard LED
040679 CA 00 07 04 0466   			JP	Z, OSBYTE_76
04067D FE A0       0467   			CP	A0H
04067F CA 30 07 04 0468   			JP	Z, OSBYTE_A0
040683 C3 93 05 04 0469   			JP	HUH			; Anything else trips an error
040687             0470   
040687             0471   ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
040687             0472   ; Parameters:
040687             0473   ; - HL: Repeat delay
040687             0474   ;
040687             0475   OSBYTE_0B:		VDU	23
040687 3E 17       0001M  		LD	A, val
040689 CD A1 04 04 0002M  		CALL	OSWRCH
04068D             0476   			VDU	0
04068D 3E 00       0001M  		LD	A, val
04068F CD A1 04 04 0002M  		CALL	OSWRCH
040693             0477   			VDU	vdp_keystate
040693 3E 88       0001M  		LD	A, val
040695 CD A1 04 04 0002M  		CALL	OSWRCH
040699             0478   			VDU	L
040699 7D          0001M  		LD	A, val
04069A CD A1 04 04 0002M  		CALL	OSWRCH
04069E             0479   			VDU	H
04069E 7C          0001M  		LD	A, val
04069F CD A1 04 04 0002M  		CALL	OSWRCH
0406A3             0480   			VDU	0
0406A3 3E 00       0001M  		LD	A, val
0406A5 CD A1 04 04 0002M  		CALL	OSWRCH
0406A9             0481   			VDU 	0
0406A9 3E 00       0001M  		LD	A, val
0406AB CD A1 04 04 0002M  		CALL	OSWRCH
0406AF             0482   			VDU	255
0406AF 3E FF       0001M  		LD	A, val
0406B1 CD A1 04 04 0002M  		CALL	OSWRCH
0406B5 C9          0483   			RET
0406B6             0484   
0406B6             0485   ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
0406B6             0486   ; Parameters:
0406B6             0487   ; - HL: Repeat rate
0406B6             0488   ;
0406B6             0489   OSBYTE_0C:		VDU	23
0406B6 3E 17       0001M  		LD	A, val
0406B8 CD A1 04 04 0002M  		CALL	OSWRCH
0406BC             0490   			VDU	0
0406BC 3E 00       0001M  		LD	A, val
0406BE CD A1 04 04 0002M  		CALL	OSWRCH
0406C2             0491   			VDU	vdp_keystate
0406C2 3E 88       0001M  		LD	A, val
0406C4 CD A1 04 04 0002M  		CALL	OSWRCH
0406C8             0492   			VDU	0
0406C8 3E 00       0001M  		LD	A, val
0406CA CD A1 04 04 0002M  		CALL	OSWRCH
0406CE             0493   			VDU 	0
0406CE 3E 00       0001M  		LD	A, val
0406D0 CD A1 04 04 0002M  		CALL	OSWRCH
0406D4             0494   			VDU	L
0406D4 7D          0001M  		LD	A, val
0406D5 CD A1 04 04 0002M  		CALL	OSWRCH
0406D9             0495   			VDU	H
0406D9 7C          0001M  		LD	A, val
0406DA CD A1 04 04 0002M  		CALL	OSWRCH
0406DE             0496   			VDU	255
0406DE 3E FF       0001M  		LD	A, val
0406E0 CD A1 04 04 0002M  		CALL	OSWRCH
0406E4 C9          0497   			RET
0406E5             0498   
0406E5             0499   ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
0406E5             0500   ;
0406E5 CD EF 06 04 0501   OSBYTE_13:		CALL	WAIT_VBLANK
0406E9 2E 00       0502   			LD	L, 0			; Returns 0
0406EB C3 01 0A 04 0503   			JP	COUNT0
0406EF             0504   ;
0406EF DD E5       0505   WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
0406F1             0506   			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0406F1 3E 08       0001M  			LD	A, function
0406F3 49 CF       0002M  			RST.LIS	08h
0406F5 DD 7E 00    0507   			LD	A, (IX + sysvar_time + 0)
0406F8 DD BE 00    0508   @@:			CP 	A, (IX + sysvar_time + 0)
0406FB 28 FB       0509   			JR	Z, @B
0406FD DD E1       0510   			POP	IX
0406FF C9          0511   			RET
040700             0512   
040700             0513   ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
040700             0514   ; Parameters:
040700             0515   ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
040700             0516   ;
040700             0517   OSBYTE_76:		VDU	23
040700 3E 17       0001M  		LD	A, val
040702 CD A1 04 04 0002M  		CALL	OSWRCH
040706             0518   			VDU	0
040706 3E 00       0001M  		LD	A, val
040708 CD A1 04 04 0002M  		CALL	OSWRCH
04070C             0519   			VDU	vdp_keystate
04070C 3E 88       0001M  		LD	A, val
04070E CD A1 04 04 0002M  		CALL	OSWRCH
040712             0520   			VDU	0
040712 3E 00       0001M  		LD	A, val
040714 CD A1 04 04 0002M  		CALL	OSWRCH
040718             0521   			VDU 	0
040718 3E 00       0001M  		LD	A, val
04071A CD A1 04 04 0002M  		CALL	OSWRCH
04071E             0522   			VDU	0
04071E 3E 00       0001M  		LD	A, val
040720 CD A1 04 04 0002M  		CALL	OSWRCH
040724             0523   			VDU	0
040724 3E 00       0001M  		LD	A, val
040726 CD A1 04 04 0002M  		CALL	OSWRCH
04072A             0524   			VDU	L
04072A 7D          0001M  		LD	A, val
04072B CD A1 04 04 0002M  		CALL	OSWRCH
04072F C9          0525   			RET
040730             0526   
040730             0527   ; OSBYTE 0xA0: Fetch system variable
040730             0528   ; Parameters:
040730             0529   ; - L: The system variable to fetch
040730             0530   ;
040730 DD E5       0531   OSBYTE_A0:		PUSH	IX
040732             0532   			MOSCALL	mos_sysvars		; Fetch pointer to system variables
040732 3E 08       0001M  			LD	A, function
040734 49 CF       0002M  			RST.LIS	08h
040736 01 00 00 00 0533   			LD	BC, 0
04073A 4D          0534   			LD	C, L			; BCU = L
04073B DD 09       0535   			ADD	IX, BC			; Add to IX
04073D DD 6E 00    0536   			LD	L, (IX + 0)		; Fetch the return value
040740 DD E1       0537   			POP	IX
040742 C3 01 0A 04 0538   			JP 	COUNT0
040746             0539   
040746             0540   ;OSLOAD - Load an area of memory from a file.
040746             0541   ;   Inputs: HL addresses filename (CR terminated)
040746             0542   ;           DE = address at which to load
040746             0543   ;           BC = maximum allowed size (bytes)
040746             0544   ;  Outputs: Carry reset indicates no room for file.
040746             0545   ; Destroys: A,B,C,D,E,H,L,F
040746             0546   ;
040746 C5          0547   OSLOAD:			PUSH	BC			; Stack the size
040747 D5          0548   			PUSH	DE			; Stack the load address
040748 11 00 00 04 0549   			LD	DE, ACCS		; Buffer address for filename
04074C CD A3 0A 04 0550   			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
040750 21 00 00 04 0551   			LD	HL, ACCS		; HL: Filename
040754 CD 46 08 04 0552   			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
040758 CD 5A 08 04 0553   			CALL	EXT_HANDLER		; Get the default handler
04075C D1          0554   			POP	DE			; Restore the load address
04075D C1          0555   			POP	BC			; Restore the size
04075E B7          0556   			OR	A
04075F 28 60       0557   			JR 	Z, OSLOAD_BBC
040761             0558   ;
040761             0559   ; Load the file in as a text file
040761             0560   ;
040761 AF          0561   OSLOAD_TXT:		XOR	A			; Set file attributes to read
040762 CD CE 08 04 0562   			CALL	OSOPEN			; Open the file
040766 5F          0563   			LD 	E, A 			; The filehandle
040767 B7          0564   			OR	A
040768 3E 04       0565   			LD	A, 4			; File not found error
04076A 28 5D       0566   			JR	Z, OSERROR		; Jump to error handler
04076C CD 98 0B 04 0567   			CALL	NEWIT			; Call NEW to clear the program space
040770             0568   ;
040770 21 00 00 04 0569   OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
040774             0570   ;
040774             0571   ; First skip any whitespace (indents) at the beginning of the input
040774             0572   ;
040774 CD E5 08 04 0573   @@:			CALL	OSBGET			; Read the byte into A
040778 38 1E       0574   			JR	C, OSLOAD_TXT3		; Is it EOF?
04077A FE 0A       0575   			CP	LF 			; Is it LF?
04077C 28 1A       0576   			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
04077E FE 21       0577   			CP	21h			; Is it less than or equal to ASCII space?
040780 38 F2       0578   			JR	C, @B 			; Yes, so keep looping
040782 77          0579   			LD	(HL), A 		; Store the first character
040783 2C          0580   			INC	L
040784             0581   ;
040784             0582   ; Now read the rest of the line in
040784             0583   ;
040784 CD E5 08 04 0584   OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
040788 38 2B       0585   			JR	C, OSLOAD_TXT4		; Is it EOF?
04078A FE 20       0586   			CP	20h			; Skip if not an ASCII character
04078C 38 06       0587   			JR	C, @F
04078E 77          0588   			LD	(HL), A 		; Store in the input buffer
04078F 2C          0589   			INC	L			; Increment the buffer pointer
040790 CA AC 09 04 0590   			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
040794 FE 0A       0591   @@:			CP	LF			; Check for LF
040796 20 EC       0592   			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
040798             0593   ;
040798             0594   ; Finally, handle EOL/EOF
040798             0595   ;
040798 36 0D       0596   OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
04079A 7D          0597   			LD	A, L			; Check for minimum line length
04079B FE 02       0598   			CP	2			; If it is 2 characters or less (including CR)
04079D 38 0A       0599   			JR	C, @F			; Then don't bother entering it
04079F D5          0600   			PUSH	DE			; Preserve the filehandle
0407A0 CD 0E 0C 04 0601   			CALL	ONEDIT1			; Enter the line in memory
0407A4 DC C7 09 04 0602   			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
0407A8 D1          0603   			POP	DE
0407A9 CD F6 08 04 0604   @@:			CALL	OSSTAT			; End of file?
0407AD 20 C1       0605   			JR	NZ, OSLOAD_TXT1		; No, so loop
0407AF CD DD 08 04 0606   			CALL	OSSHUT			; Close the file
0407B3 37          0607   			SCF				; Flag to BASIC that we're good
0407B4 C9          0608   			RET
0407B5             0609   ;
0407B5             0610   ; Special case for BASIC programs with no blank line at the end
0407B5             0611   ;
0407B5 FE 20       0612   OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
0407B7 38 06       0613   			JR	C, @F
0407B9 77          0614   			LD	(HL), A			; Store the character
0407BA 2C          0615   			INC	L
0407BB CA AC 09 04 0616   			JP	Z, BAD
0407BF 18 D7       0617   @@:			JR	OSLOAD_TXT3
0407C1             0618   
0407C1             0619   ;
0407C1             0620   ; Load the file in as a tokenised binary blob
0407C1             0621   ;
0407C1             0622   OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
0407C1 3E 01       0001M  			LD	A, function
0407C3 49 CF       0002M  			RST.LIS	08h
0407C5 D0          0623   			RET	NC			; If load returns with carry reset - NO ROOM
0407C6 B7          0624   			OR	A			; If there is no error (A=0)
0407C7 37          0625   			SCF				; Need to set carry indicating there was room
0407C8 C8          0626   			RET	Z			; Return
0407C9             0627   ;
0407C9 F5          0628   OSERROR:		PUSH	AF			; Handle the MOS error
0407CA 21 00 00 04 0629   			LD	HL, ACCS		; Address of the buffer
0407CE 01 00 01 00 0630   			LD	BC, 256			; Length of the buffer
0407D2 5F          0631   			LD	E, A			; The error code
0407D3             0632   			MOSCALL	mos_getError		; Copy the error message into the buffer
0407D3 3E 0F       0001M  			LD	A, function
0407D5 49 CF       0002M  			RST.LIS	08h
0407D7 F1          0633   			POP	AF
0407D8 E5          0634   			PUSH	HL			; Stack the address of the error (now in ACCS)
0407D9 C6 7F       0635   			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
0407DB C3 3F 0B 04 0636   			JP	EXTERR			; Trigger an external error
0407DF             0637   
0407DF             0638   ;OSSAVE - Save an area of memory to a file.
0407DF             0639   ;   Inputs: HL addresses filename (term CR)
0407DF             0640   ;           DE = start address of data to save
0407DF             0641   ;           BC = length of data to save (bytes)
0407DF             0642   ; Destroys: A,B,C,D,E,H,L,F
0407DF             0643   ;
0407DF C5          0644   OSSAVE:			PUSH	BC			; Stack the size
0407E0 D5          0645   			PUSH	DE			; Stack the save address
0407E1 11 00 00 04 0646   			LD	DE, ACCS		; Buffer address for filename
0407E5 CD A3 0A 04 0647   			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0407E9 21 00 00 04 0648   			LD	HL, ACCS		; HL: Filename
0407ED CD 46 08 04 0649   			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0407F1 CD 5A 08 04 0650   			CALL	EXT_HANDLER		; Get the default handler
0407F5 D1          0651   			POP	DE			; Restore the save address
0407F6 C1          0652   			POP	BC			; Restore the size
0407F7 B7          0653   			OR	A			; Is the extension .BBC
0407F8 28 44       0654   			JR	Z, OSSAVE_BBC		; Yes, so use that
0407FA             0655   ;
0407FA             0656   ; Save the file out as a text file
0407FA             0657   ;
0407FA 3A 45 03 04 0658   OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
0407FE F5          0659   			PUSH	AF
0407FF AF          0660   			XOR	A
040800 3C          0661   			INC	A			; Make sure C is clear, A is 1, for OPENOUT
040801 32 45 03 04 0662   			LD	(OSWRCHCH), A
040805 CD CE 08 04 0663   			CALL	OSOPEN			; Open the file
040809 32 46 03 04 0664   			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
04080D DD 21 40 03 0665   			LD	IX, LISTON		; Required for LISTIT
       04          
040812 2A 14 03 04 0666   			LD	HL, (PAGE_)		; Get start of program area
040816 D9          0667   			EXX
040817 01 00 00 00 0668   			LD	BC, 0			; Set the initial indent counters
04081B D9          0669   			EXX
04081C 7E          0670   OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
04081D B7          0671   			OR	A
04081E 28 0F       0672   			JR	Z, OSSAVE_TXT2
040820 23          0673   			INC	HL			; Skip the length byte
040821 11 00 00 00 0674   			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
040825 5E          0675   			LD	E, (HL)			; Get the line number
040826 23          0676   			INC	HL
040827 56          0677   			LD	D, (HL)
040828 23          0678   			INC	HL
040829 CD 7A 0B 04 0679   			CALL	LISTIT			; List the line
04082D 18 ED       0680   			JR	OSSAVE_TXT1
04082F 3A 46 03 04 0681   OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
040833 5F          0682   			LD	E, A
040834 CD DD 08 04 0683   			CALL	OSSHUT			; Close it
040838 F1          0684   			POP	AF			; Restore the channel
040839 32 45 03 04 0685   			LD	(OSWRCHCH), A
04083D C9          0686   			RET
04083E             0687   ;
04083E             0688   ; Save the file out as a tokenised binary blob
04083E             0689   ;
04083E             0690   OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
04083E 3E 02       0001M  			LD	A, function
040840 49 CF       0002M  			RST.LIS	08h
040842 B7          0691   			OR	A			; If there is no error (A=0)
040843 C8          0692   			RET	Z			; Just return
040844 18 83       0693   			JR	OSERROR			; Trip an error
040846             0694   
040846             0695   ; Check if an extension is specified in the filename
040846             0696   ; Add a default if not specified
040846             0697   ; HL: Filename (CSTR format)
040846             0698   ;
040846 E5          0699   EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
040847 0E 2E       0700   			LD	C, '.'			; Search for dot (marks start of extension)
040849 CD 80 0A 04 0701   			CALL	CSTR_FINDCH
04084D B7          0702   			OR	A			; Check for end of string marker
04084E 20 08       0703   			JR	NZ, @F			; No, so skip as we have an extension at this point
040850 11 8A 08 04 0704   			LD	DE, EXT_LOOKUP		; Get the first (default extension)
040854 CD 3B 0A 04 0705   			CALL	CSTR_CAT		; Concat it to string pointed to by HL
040858 E1          0706   @@:			POP	HL			; Restore the filename pointer
040859 C9          0707   			RET
04085A             0708   
04085A             0709   ; Check if an extension is valid and, if so, provide a pointer to a handler
04085A             0710   ; HL: Filename (CSTR format)
04085A             0711   ; Returns:
04085A             0712   ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
04085A             0713   ;
04085A E5          0714   EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
04085B 0E 2E       0715   			LD	C, '.'			; Find the '.'
04085D CD 80 0A 04 0716   			CALL	CSTR_FINDCH
040861 11 8A 08 04 0717   			LD	DE, EXT_LOOKUP		; The lookup table
040865             0718   ;
040865 E5          0719   EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
040866 CD 5B 0A 04 0720   			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
04086A E1          0721   			POP	HL			; Restore the pointer to the extension
04086B 28 19       0722   			JR	Z, EXT_HANDLER_2	; We have a match!
04086D             0723   ;
04086D 1A          0724   @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
04086E 13          0725   			INC	DE
04086F B7          0726   			OR	A
040870 20 FB       0727   			JR	NZ, @B
040872 13          0728   			INC	DE			; Skip the file extension # byte
040873             0729   ;
040873 1A          0730   			LD	A, (DE)			; Are we at the end of the table?
040874 B7          0731   			OR	A
040875 20 EE       0732   			JR	NZ, EXT_HANDLER_1	; No, so loop
040877             0733   ;
040877 3E CC       0734   			LD      A,204			; Throw a "Bad name" error
040879 CD 3F 0B 04 0735           		CALL    EXTERR
04087D 42 61 64 20 0736           		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
040886             0737   ;
040886 13          0738   EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
040887 1A          0739   			LD	A, (DE)
040888 E1          0740   			POP	HL			; Restore the filename pointer
040889 C9          0741   			RET
04088A             0742   ;
04088A             0743   
04088A             0744   
04088A             0745   ; Extension lookup table
04088A             0746   ; CSTR, TYPE
04088A             0747   ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
04088A             0748   ; 	- 1: Human readable plain text
04088A             0749   ;
04088A 2E 42 42 43 0750   EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
040890 2E 54 58 54 0751   			DB	".TXT", 0, 1
       00 01       
040896 2E 41 53 43 0752   			DB	".ASC", 0, 1
       00 01       
04089C 2E 42 41 53 0753   			DB	".BAS", 0, 1
       00 01       
0408A2 00          0754   			DB	0			; End of table
0408A3             0755   
0408A3             0756   ;OSCALL - Intercept page &FF calls and provide an alternative address
0408A3             0757   ;
0408A3             0758   ;&FFF7:	OSCLI	Execute *command.
0408A3             0759   ;&FFF4:	OSBYTE	Various byte-wide functions.
0408A3             0760   ;&FFF1:	OSWORD	Various control block functions.
0408A3             0761   ;&FFEE:	OSWRCH	Write character to output stream.
0408A3             0762   ;&FFE7:	OSNEWL	Write NewLine to output stream.
0408A3             0763   ;&FFE3:	OSASCI	Write character or NewLine to output stream.
0408A3             0764   ;&FFE0:	OSRDCH	Wait for character from input stream.
0408A3             0765   ;&FFDD:	OSFILE	Perform actions on whole files or directories.
0408A3             0766   ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
0408A3             0767   ;&FFD7:	OSBGET	Read a byte from an a channel.
0408A3             0768   ;&FFD4:	OSBPUT	Write a byte to a channel.
0408A3             0769   ;&FFD1:	OSGBPB	Read and write blocks of data.
0408A3             0770   ;&FFCE:	OSFIND	Open or close a file.
0408A3             0771   ;
0408A3 21 B9 08 04 0772   OSCALL:			LD	HL, OSCALL_TABLE
0408A7 7E          0773   OSCALL_1:		LD	A, (HL)
0408A8 23          0774   			INC	HL
0408A9 FE FF       0775   			CP	FFh
0408AB C8          0776   			RET	Z
0408AC FD BD       0777   			CP	A, IYL
0408AE 28 06       0778   			JR	Z, OSCALL_2
0408B0 D0          0779   			RET	NC
0408B1 23          0780   			INC	HL
0408B2 23          0781   			INC	HL
0408B3 23          0782   			INC	HL
0408B4 18 F1       0783   			JR	OSCALL_1
0408B6 ED 31       0784   OSCALL_2:		LD	IY,(HL)
0408B8 C9          0785   			RET
0408B9 D4          0786   OSCALL_TABLE:		DB 	D4h
0408BA ED 08 04    0787   			DW24 	OSBPUT
0408BD D7          0788   			DB 	D7h
0408BE E5 08 04    0789   			DW24 	OSBGET
0408C1 EE          0790   			DB 	EEh
0408C2 A1 04 04    0791   			DW24 	OSWRCH
0408C5 F4          0792   			DB	F4h
0408C6 6B 06 04    0793   			DW24 	OSBYTE
0408C9 F7          0794   			DB	F7h
0408CA 31 05 04    0795   			DW24	OSCLI
0408CD FF          0796   			DB	FFh
0408CE             0797   
0408CE             0798   ; OSOPEN
0408CE             0799   ; HL: Pointer to path
0408CE             0800   ;  F: C Z
0408CE             0801   ;     x x OPENIN
0408CE             0802   ; 	  OPENOUT
0408CE             0803   ;     x	  OPENUP
0408CE             0804   ; Returns:
0408CE             0805   ;  A: Filehandle, 0 if cannot open
0408CE             0806   ;
0408CE 0E 01       0807   OSOPEN:			LD	C, fa_read
0408D0 28 06       0808   			JR	Z, @F
0408D2 0E 32       0809   			LD	C, fa_write | fa_open_append
0408D4 38 02       0810   			JR	C, @F
0408D6 0E 0A       0811   			LD	C, fa_write | fa_create_always
0408D8             0812   @@:			MOSCALL	mos_fopen
0408D8 3E 0A       0001M  			LD	A, function
0408DA 49 CF       0002M  			RST.LIS	08h
0408DC C9          0813   			RET
0408DD             0814   
0408DD             0815   ;OSSHUT - Close disk file(s).
0408DD             0816   ; E = file channel
0408DD             0817   ;  If E=0 all files are closed (except SPOOL)
0408DD             0818   ; Destroys: A,B,C,D,E,H,L,F
0408DD             0819   ;
0408DD C5          0820   OSSHUT:			PUSH	BC
0408DE 4B          0821   			LD	C, E
0408DF             0822   			MOSCALL	mos_fclose
0408DF 3E 0B       0001M  			LD	A, function
0408E1 49 CF       0002M  			RST.LIS	08h
0408E3 C1          0823   			POP	BC
0408E4 C9          0824   			RET
0408E5             0825   
0408E5             0826   ; OSBGET - Read a byte from a random disk file.
0408E5             0827   ;  E = file channel
0408E5             0828   ; Returns
0408E5             0829   ;  A = byte read
0408E5             0830   ;  Carry set if LAST BYTE of file
0408E5             0831   ; Destroys: A,B,C,F
0408E5             0832   ;
0408E5 C5          0833   OSBGET:			PUSH	BC
0408E6 4B          0834   			LD	C, E
0408E7             0835   			MOSCALL	mos_fgetc
0408E7 3E 0C       0001M  			LD	A, function
0408E9 49 CF       0002M  			RST.LIS	08h
0408EB C1          0836   			POP	BC
0408EC C9          0837   			RET
0408ED             0838   
0408ED             0839   ; OSBPUT - Write a byte to a random disk file.
0408ED             0840   ;  E = file channel
0408ED             0841   ;  A = byte to write
0408ED             0842   ; Destroys: A,B,C,F
0408ED             0843   ;
0408ED C5          0844   OSBPUT:			PUSH	BC
0408EE 4B          0845   			LD	C, E
0408EF 47          0846   			LD	B, A
0408F0             0847   			MOSCALL	mos_fputc
0408F0 3E 0D       0001M  			LD	A, function
0408F2 49 CF       0002M  			RST.LIS	08h
0408F4 C1          0848   			POP	BC
0408F5 C9          0849   			RET
0408F6             0850   
0408F6             0851   ; OSSTAT - Read file status
0408F6             0852   ;  E = file channel
0408F6             0853   ; Returns
0408F6             0854   ;  F: Z flag set - EOF
0408F6             0855   ;  A: If Z then A = 0
0408F6             0856   ; Destroys: A,D,E,H,L,F
0408F6             0857   ;
0408F6 C5          0858   OSSTAT:			PUSH	BC
0408F7 4B          0859   			LD	C, E
0408F8             0860   			MOSCALL	mos_feof
0408F8 3E 0E       0001M  			LD	A, function
0408FA 49 CF       0002M  			RST.LIS	08h
0408FC C1          0861   			POP	BC
0408FD FE 01       0862   			CP	1
0408FF C9          0863   			RET
040900             0864   
040900             0865   ; GETPTR - Return file pointer.
040900             0866   ;    E = file channel
040900             0867   ; Returns:
040900             0868   ; DEHL = pointer (0-&7FFFFF)
040900             0869   ; Destroys: A,B,C,D,E,H,L,F
040900             0870   ;
040900 FD E5       0871   GETPTR:			PUSH		IY
040902 4B          0872   			LD		C, E
040903             0873   			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
040903 3E 19       0001M  			LD	A, function
040905 49 CF       0002M  			RST.LIS	08h
040907 E5          0874   			PUSH		HL
040908 FD E1       0875   			POP		IY		; IYU: Pointer to FIL structure
04090A FD 6E 11    0876   			LD		L, (IY + FIL.fptr + 0)
04090D FD 66 12    0877   			LD		H, (IY + FIL.fptr + 1)
040910 FD 5E 13    0878   			LD		E, (IY + FIL.fptr + 2)
040913 FD 56 14    0879   			LD		D, (IY + FIL.fptr + 3)
040916 FD E1       0880   			POP		IY
040918 C9          0881   			RET
040919             0882   
040919             0883   ; PUTPTR - Update file pointer.
040919             0884   ;    A = file channel
040919             0885   ; DEHL = new pointer (0-&7FFFFF)
040919             0886   ; Destroys: A,B,C,D,E,H,L,F
040919             0887   ;
040919 FD E5       0888   PUTPTR:			PUSH		IY
04091B 4F          0889   			LD		C, A  		; C: Filehandle
04091C E5          0890   			PUSH		HL
04091D 21 02 00 00 0891   			LD		HL, 2
040921 39          0892   			ADD		HL, SP
040922 73          0893   			LD		(HL), E 	; 3rd byte of DWORD set to E
040923 E1          0894   			POP		HL
040924 5A          0895   			LD		E, D  		; 4th byte passed as E
040925             0896   			MOSCALL		mos_flseek
040925 3E 1C       0001M  			LD	A, function
040927 49 CF       0002M  			RST.LIS	08h
040929 FD E1       0897   			POP		IY
04092B C9          0898   			RET
04092C             0899   
04092C             0900   ; GETEXT - Find file size.
04092C             0901   ;    E = file channel
04092C             0902   ; Returns:
04092C             0903   ; DEHL = file size (0-&800000)
04092C             0904   ; Destroys: A,B,C,D,E,H,L,F
04092C             0905   ;
04092C FD E5       0906   GETEXT:         PUSH    IY
04092E 4B          0907                   LD      C, E
04092F             0908                   MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
04092F 3E 19       0001M  			LD	A, function
040931 49 CF       0002M  			RST.LIS	08h
040933 E5          0909                   PUSH    HL
040934 FD E1       0910                   POP     IY          ; IYU: Pointer to FIL structure
040936             0911                   ; Access the obj.objsize field using the offset values
040936 FD 6E 0B    0912                   LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
040939 FD 66 0C    0913                   LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
04093C FD 5E 0D    0914                   LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
04093F FD 56 0E    0915                   LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
040942             0916   
040942 FD E1       0917                   POP     IY
040944 C9          0918                   RET
040945             0919   
040945             0920   ; GETIMS - Get time from RTC
040945             0921   ;
040945 FD E5       0922   GETIMS:			PUSH	IY
040947 21 00 00 04 0923   			LD	HL, ACCS 		; Where to store the time string
04094B             0924   			MOSCALL	mos_getrtc
04094B 3E 12       0001M  			LD	A, function
04094D 49 CF       0002M  			RST.LIS	08h
04094F 11 00 00 04 0925   			LD	DE, ACCS		; DE: pointer to start of string accumulator
040953 5F          0926   			LD	E, A 			;  E: now points to the end of the string
040954 FD E1       0927   			POP	IY
040956 C9          0928   			RET
040957             0929   
040957             0930   ; Get two word values from EXPR in DE, HL
040957             0931   ; IY: Pointer to expression string
040957             0932   ; Returns:
040957             0933   ; DE: P1
040957             0934   ; HL: P2
040957             0935   ;
040957 CD 22 0B 04 0936   EXPR_W2:		CALL	EXPRI			; Get first parameter
04095B D9          0937   			EXX
04095C E5          0938   			PUSH	HL
04095D CD E4 09 04 0939   			CALL	COMMA
040961 CD 22 0B 04 0940   			CALL	EXPRI			; Get second parameter
040965 D9          0941   			EXX
040966 D1          0942   			POP	DE
040967 C9          0943   			RET
040968             0944   
040968             0945   ; Stuff not implemented yet
040968             0946   ;
040968 C9          0947   RESET:			RET
040969             0948   
040969             0949   ; ===== STUB FUNCTIONS =====
040969             0950   printInline:
040969 C9          0951       ret
04096A             0952   
04096A             0953   ASC_TO_NUMBER:
04096A CD 69 09 04 0954   	call printInline
04096E 70 61 74 63 0955   	asciz "patch.asm called ASC_TO_NUMBER!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 41 53 43 
       5F 54 4F 5F 
       4E 55 4D 42 
       45 52 21 00 
04098E C9          0956   	ret
04098F             0957   
04098F             0958   ASSEM:
04098F CD 69 09 04 0959   	call printInline
040993 70 61 74 63 0960   	asciz "patch.asm called ASSEM!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 41 53 53 
       45 4D 21 00 
0409AB C9          0961   	ret
0409AC             0962   
0409AC             0963   BAD:
0409AC CD 69 09 04 0964   	call printInline
0409B0 70 61 74 63 0965   	asciz "patch.asm called BAD!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 42 41 44 
       21 00       
0409C6 C9          0966   	ret
0409C7             0967   
0409C7             0968   CLEAN:
0409C7 CD 69 09 04 0969   	call printInline
0409CB 70 61 74 63 0970   	asciz "patch.asm called CLEAN!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 43 4C 45 
       41 4E 21 00 
0409E3 C9          0971   	ret
0409E4             0972   
0409E4             0973   COMMA:
0409E4 CD 69 09 04 0974   	call printInline
0409E8 70 61 74 63 0975   	asciz "patch.asm called COMMA!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 43 4F 4D 
       4D 41 21 00 
040A00 C9          0976   	ret
040A01             0977   
040A01             0978   COUNT0:
040A01 CD 69 09 04 0979   	call printInline
040A05 70 61 74 63 0980   	asciz "patch.asm called COUNT0!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 43 4F 55 
       4E 54 30 21 
       00          
040A1E C9          0981   	ret
040A1F             0982   
040A1F             0983   CRLF:
040A1F CD 69 09 04 0984   	call printInline
040A23 70 61 74 63 0985   	asciz "patch.asm called CRLF!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 43 52 4C 
       46 21 00    
040A3A C9          0986   	ret
040A3B             0987   
040A3B             0988   CSTR_CAT:
040A3B CD 69 09 04 0989   	call printInline
040A3F 70 61 74 63 0990   	asciz "patch.asm called CSTR_CAT!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 43 53 54 
       52 5F 43 41 
       54 21 00    
040A5A C9          0991   	ret
040A5B             0992   
040A5B             0993   CSTR_ENDSWITH:
040A5B CD 69 09 04 0994   	call printInline
040A5F 70 61 74 63 0995   	asciz "patch.asm called CSTR_ENDSWITH!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 43 53 54 
       52 5F 45 4E 
       44 53 57 49 
       54 48 21 00 
040A7F C9          0996   	ret
040A80             0997   
040A80             0998   CSTR_FINDCH:
040A80 CD 69 09 04 0999   	call printInline
040A84 70 61 74 63 1000   	asciz "patch.asm called CSTR_FINDCH!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 43 53 54 
       52 5F 46 49 
       4E 44 43 48 
       21 00       
040AA2 C9          1001   	ret
040AA3             1002   
040AA3             1003   CSTR_FNAME:
040AA3 CD 69 09 04 1004   	call printInline
040AA7 70 61 74 63 1005   	asciz "patch.asm called CSTR_FNAME!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 43 53 54 
       52 5F 46 4E 
       41 4D 45 21 
       00          
040AC4 C9          1006   	ret
040AC5             1007   
040AC5             1008   CSTR_LINE:
040AC5 CD 69 09 04 1009   	call printInline
040AC9 70 61 74 63 1010   	asciz "patch.asm called CSTR_LINE!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 43 53 54 
       52 5F 4C 49 
       4E 45 21 00 
040AE5 C9          1011   	ret
040AE6             1012   
040AE6             1013   ERROR_:
040AE6 CD 69 09 04 1014   	call printInline
040AEA 70 61 74 63 1015   	asciz "patch.asm called ERROR_!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 45 52 52 
       4F 52 5F 21 
       00          
040B03 C9          1016   	ret
040B04             1017   
040B04             1018   ESCAPE:
040B04 CD 69 09 04 1019   	call printInline
040B08 70 61 74 63 1020   	asciz "patch.asm called ESCAPE!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 45 53 43 
       41 50 45 21 
       00          
040B21 C9          1021   	ret
040B22             1022   
040B22             1023   EXPRI:
040B22 CD 69 09 04 1024   	call printInline
040B26 70 61 74 63 1025   	asciz "patch.asm called EXPRI!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 45 58 50 
       52 49 21 00 
040B3E C9          1026   	ret
040B3F             1027   
040B3F             1028   EXTERR:
040B3F CD 69 09 04 1029   	call printInline
040B43 70 61 74 63 1030   	asciz "patch.asm called EXTERR!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 45 58 54 
       45 52 52 21 
       00          
040B5C C9          1031   	ret
040B5D             1032   
040B5D             1033   FINDL:
040B5D CD 69 09 04 1034   	call printInline
040B61 70 61 74 63 1035   	asciz "patch.asm called FINDL!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 46 49 4E 
       44 4C 21 00 
040B79 C9          1036   	ret
040B7A             1037   
040B7A             1038   LISTIT:
040B7A CD 69 09 04 1039   	call printInline
040B7E 70 61 74 63 1040   	asciz "patch.asm called LISTIT!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 4C 49 53 
       54 49 54 21 
       00          
040B97 C9          1041   	ret
040B98             1042   
040B98             1043   NEWIT:
040B98 CD 69 09 04 1044   	call printInline
040B9C 70 61 74 63 1045   	asciz "patch.asm called NEWIT!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 4E 45 57 
       49 54 21 00 
040BB4 C9          1046   	ret
040BB5             1047   
040BB5             1048   NULLTOCR:
040BB5 CD 69 09 04 1049   	call printInline
040BB9 70 61 74 63 1050   	asciz "patch.asm called NULLTOCR!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 4E 55 4C 
       4C 54 4F 43 
       52 21 00    
040BD4 C9          1051   	ret
040BD5             1052   
040BD5             1053   NXT:
040BD5 CD 69 09 04 1054   	call printInline
040BD9 70 61 74 63 1055   	asciz "patch.asm called NXT!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 4E 58 54 
       21 00       
040BEF C9          1056   	ret
040BF0             1057   
040BF0             1058   ONEDIT:
040BF0 CD 69 09 04 1059   	call printInline
040BF4 70 61 74 63 1060   	asciz "patch.asm called ONEDIT!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 4F 4E 45 
       44 49 54 21 
       00          
040C0D C9          1061   	ret
040C0E             1062   
040C0E             1063   ONEDIT1:
040C0E CD 69 09 04 1064   	call printInline
040C12 70 61 74 63 1065   	asciz "patch.asm called ONEDIT1!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 4F 4E 45 
       44 49 54 31 
       21 00       
040C2C C9          1066   	ret
040C2D             1067   
040C2D             1068   OUT_:
040C2D CD 69 09 04 1069   	call printInline
040C31 70 61 74 63 1070   	asciz "patch.asm called OUT_!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 4F 55 54 
       5F 21 00    
040C48 C9          1071   	ret
040C49             1072   
040C49             1073   TELL:
040C49 CD 69 09 04 1074   	call printInline
040C4D 70 61 74 63 1075   	asciz "patch.asm called TELL!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 54 45 4C 
       4C 21 00    
040C64 C9          1076   	ret
040C65             1077   
040C65             1078   VBLANK_INIT:
040C65 CD 69 09 04 1079   	call printInline
040C69 70 61 74 63 1080   	asciz "patch.asm called VBLANK_INIT!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 56 42 4C 
       41 4E 4B 5F 
       49 4E 49 54 
       21 00       
040C87 C9          1081   	ret
040C88             1082   
040C88             1083   VBLANK_STOP:
040C88 CD 69 09 04 1084   	call printInline
040C8C 70 61 74 63 1085   	asciz "patch.asm called VBLANK_STOP!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 56 42 4C 
       41 4E 4B 5F 
       53 54 4F 50 
       21 00       
040CAA C9          1086   	ret
040CAB             1087   
040CAB             1088   XEQ:
040CAB CD 69 09 04 1089   	call printInline
040CAF 70 61 74 63 1090   	asciz "patch.asm called XEQ!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 58 45 51 
       21 00       
040CC5 C9          1091   	ret
040CC6             1092   
040CC6             1093   _end:
040CC6 CD 69 09 04 1094   	call printInline
040CCA 70 61 74 63 1095   	asciz "patch.asm called _end!"
       68 2E 61 73 
       6D 20 63 61 
       6C 6C 65 64 
       20 5F 65 6E 
       64 21 00    
040CE1 C9          1096   	ret
