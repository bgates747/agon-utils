PC     Output      Line
040000             0001   ;
040000             0002   ; Title:	BBC Basic Interpreter - Z80 version
040000             0003   ;		Statement Execution & Assembler Module - "EXEC"
040000             0004   ; Author:	(C) Copyright  R.T.Russell  1984
040000             0005   ; Modified By:	Dean Belfield
040000             0006   ; Created:	12/05/2023
040000             0007   ; Last Updated:	26/06/2023
040000             0008   ;
040000             0009   ; Modinfo:
040000             0010   ; 27/01/1984:	Version 2.1
040000             0011   ; 02/03/1987:	Version 3.0
040000             0012   ; 11/06/1987:	Version 3.1
040000             0013   ; 12/05/2023:	Modified by Dean Belfield
040000             0014   ; 07/06/2023:	Modified to run in ADL mode
040000             0015   ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
040000             0016   
040000             0017   			.ASSUME	ADL = 1
040000             0018   
040000             0019   			INCLUDE "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ; ;
040000             0190*  ; ; FatFS structures
040000             0191*  ; ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ; ;
040000             0193*  ; ; Object ID and allocation information (FFOBJID)
040000             0194*  ; ;
040000             0195*  ; FFOBJID	.STRUCT
040000             0196*  ; 	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ; 	id:		DS	2	; Hosting volume mount ID
040000             0198*  ; 	attr:		DS	1	; Object attribute
040000             0199*  ; 	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ; 	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ; 	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ; FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ; ;
040000             0204*  ; ; File object structure (FIL)
040000             0205*  ; ;
040000             0206*  ; FIL .STRUCT
040000             0207*  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ; 	flag:		DS	1	; File status flags
040000             0209*  ; 	err:		DS	1	; Abort flag (error code)
040000             0210*  ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ; 	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ; FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ; ;
040000             0217*  ; ; Directory object structure (DIR)
040000             0218*  ; ;
040000             0219*  ; DIR .STRUCT
040000             0220*  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0221*  ; 	dptr:		DS	4	; Current read/write offset
040000             0222*  ; 	clust:		DS	4	; Current cluster
040000             0223*  ; 	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ; 	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ; 	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ; 	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ; DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ; ;
040000             0229*  ; ; File information structure (FILINFO)
040000             0230*  ; ;
040000             0231*  ; FILINFO .STRUCT
040000             0232*  ; 	fsize:		DS 	4	; File size
040000             0233*  ; 	fdate:		DS	2	; Modified date
040000             0234*  ; 	ftime:		DS	2	; Modified time
040000             0235*  ; 	fattrib:	DS	1	; File attribute
040000             0236*  ; 	altname:	DS	13	; Alternative file name
040000             0237*  ; 	fname:		DS	256	; Primary file name
040000             0238*  ; FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  			MACRO MOSCALL	function
040000             0246*  			LD	A, function
040000             0247*  			RST.LIS	08h
040000             0248*  			ENDMACRO
040000             0020   			INCLUDE "macros.inc"
040000             0001*  	; Title:	BBC Basic Interpreter - Z80 version
040000             0002*  	;		Useful macros
040000             0003*  	; Author:	Dean Belfield
040000             0004*  	; Created:	12/05/2023
040000             0005*  	; Last Updated:	11/06/2023
040000             0006*  	;
040000             0007*  	; Modinfo:
040000             0008*  	; 11/06/2023:	Modified to run in ADL mode
040000             0009*  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040000             0010*  
040000             0011*  	MACRO EXREG	rp1, rp2
040000             0012*  		PUSH	rp1
040000             0013*  		POP	rp2
040000             0014*  	ENDMACRO
040000             0015*  
040000             0016*  	; MACRO ADD8U_DE	reg
040000             0017*  		MACRO ADD8U_DE
040000             0018*  		ADD	A, E
040000             0019*  		LD	E, A
040000             0020*  		ADC	A, D
040000             0021*  		SUB	E
040000             0022*  		LD	D, A
040000             0023*  	ENDMACRO
040000             0024*  
040000             0025*  	; MACRO ADD8U_HL	reg
040000             0026*  	MACRO ADD8U_HL
040000             0027*  		ADD	A, L
040000             0028*  		LD	L, A
040000             0029*  		ADC	A, H
040000             0030*  		SUB	L
040000             0031*  		LD	H, A
040000             0032*  	ENDMACRO
040000             0033*  
040000             0034*  	MACRO VDU	val
040000             0035*  		LD	A, val
040000             0036*  		CALL	OSWRCH
040000             0037*  	ENDMACRO
040000             0038*  
040000             0039*  	MACRO SET_GPIO	reg, val
040000             0040*  		IN0	A, (reg)
040000             0041*  		OR	val
040000             0042*  		OUT0	(reg), A
040000             0043*  	ENDMACRO
040000             0044*  
040000             0045*  	MACRO RES_GPIO	reg, val
040000             0046*  		PUSH	BC
040000             0047*  		LD	A, val
040000             0048*  		CPL
040000             0049*  		LD	C, A
040000             0050*  		IN0	A, (reg)
040000             0051*  		AND	C
040000             0052*  		OUT0	(reg), A
040000             0053*  		POP	BC
040000             0054*  	ENDMACRO
040000             0021   			INCLUDE "ram.asm"
040000             0001*  ;
040000             0002*  ; Title:	BBC Basic Interpreter - Z80 version
040000             0003*  ;		RAM Module for BBC Basic Interpreter
040000             0004*  ;		For use with Version 2.0 of BBC BASIC
040000             0005*  ;		Standard CP/M Distribution Version
040000             0006*  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
040000             0007*  ; Modified By:	Dean Belfield
040000             0008*  ; Created:	12/05/2023
040000             0009*  ; Last Updated:	26/06/2023
040000             0010*  ;
040000             0011*  ; Modinfo:
040000             0012*  ; 06/06/2023:	Modified to run in ADL mode
040000             0013*  ; 26/06/2023:	Added temporary stores R0 and R1
040000             0014*  
040000             0015*  			.ASSUME	ADL = 1
040000             0016*  
040000             0017*  			; DEFINE	LORAM, SPACE = ROM
040000             0018*  			; SEGMENT LORAM
040000             0019*  
040000             0020*  			; XDEF	ACCS
040000             0021*  			; XDEF	BUFFER
040000             0022*  			; XDEF	STAVAR
040000             0023*  			; XDEF	DYNVAR
040000             0024*  			; XDEF	FNPTR
040000             0025*  			; XDEF	PROPTR
040000             0026*  			; XDEF	PAGE_
040000             0027*  			; XDEF	TOP
040000             0028*  			; XDEF	LOMEM
040000             0029*  			; XDEF 	FREE
040000             0030*  			; XDEF	HIMEM
040000             0031*  			; XDEF	LINENO
040000             0032*  			; XDEF	TRACEN
040000             0033*  			; XDEF	AUTONO
040000             0034*  			; XDEF	ERRTRP
040000             0035*  			; XDEF	ERRTXT
040000             0036*  			; XDEF	DATPTR
040000             0037*  			; XDEF	ERL
040000             0038*  			; XDEF	ERRLIN
040000             0039*  			; XDEF	RANDOM
040000             0040*  			; XDEF	COUNT
040000             0041*  			; XDEF	WIDTH
040000             0042*  			; XDEF	ERR
040000             0043*  			; XDEF	LISTON
040000             0044*  			; XDEF	INCREM
040000             0045*  
040000             0046*  			; XDEF	FLAGS
040000             0047*  			; XDEF	OSWRCHPT
040000             0048*  			; XDEF	OSWRCHCH
040000             0049*  			; XDEF	OSWRCHFH
040000             0050*  			; XDEF	KEYDOWN
040000             0051*  			; XDEF	KEYASCII
040000             0052*  			; XDEF	KEYCOUNT
040000             0053*  
040000             0054*  			; XDEF	R0
040000             0055*  			; XDEF	R1
040000             0056*  
040000             0057*  			; XDEF	RAM_START
040000             0058*  			; XDEF	RAM_END
040000             0059*  			; XDEF	USER
040000             0060*  
040000             0061*  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
040000             0062*  RAM_START:
040000             0063*  ;
040000             0064*  ACCS:			DS		256             ; String Accumulator
040100             0065*  BUFFER:			DS		256             ; String Input Buffer
040200             0066*  STAVAR:			DS	 	27*4            ; Static Variables
04026C             0067*  DYNVAR: 		DS 		54*3            ; Dynamic Variable Pointers
04030E             0068*  FNPTR:  		DS    		3               ; Dynamic Function Pointers
040311             0069*  PROPTR: 		DS		3               ; Dynamic Procedure Pointers
040314             0070*  ;
040314             0071*  PAGE_:   		DS		3               ; Start of User Program
040317             0072*  TOP:    		DS		3               ; First Location after User Program
04031A             0073*  LOMEM:  		DS		3               ; Start of Dynamic Storage
04031D             0074*  FREE:   		DS		3               ; First Free Space Byte
040320             0075*  HIMEM:  		DS		3               ; First Protected Byte
040323             0076*  ;
040323             0077*  LINENO: 		DS		3               ; Line Number
040326             0078*  TRACEN:			DS		3               ; Trace Flag
040329             0079*  AUTONO:			DS		3               ; Auto Flag
04032C             0080*  ERRTRP:			DS		3               ; Error Trap
04032F             0081*  ERRTXT:			DS		2               ; Error Message Pointer
040331             0082*  DATPTR:			DS		2               ; Data Pointer
040333             0083*  ERL:			DS		2               ; Error Line
040335             0084*  ERRLIN:			DS		3               ; The "ON ERROR" Line
040338             0085*  RANDOM:			DS		5               ; Random Number
04033D             0086*  COUNT:			DS		1               ; Print Position
04033E             0087*  WIDTH:			DS		1               ; Print Width
04033F             0088*  ERR:			DS		1               ; Error Number
040340             0089*  LISTON:			DS		1               ; LISTO (bottom nibble)
040341             0090*  							; - BIT 0: If set, output a space after the line number
040341             0091*  							; - BIT 1: If set, then indent FOR/NEXT loops
040341             0092*  							; - BIT 2: If set, then indent REPEAT/UNTIL loops
040341             0093*  							; - BIT 3: If set, then output to buffer for *EDIT
040341             0094*  							; OPT FLAG (top nibble)
040341             0095*  							; - BIT 4: If set, then list whilst assembling
040341             0096*  							; - BIT 5: If set, then assembler errors are reported
040341             0097*  							; - BIT 6: If set, then place the code starting at address pointed to by O%
040341             0098*  							; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
040341             0099*  INCREM:			DS		1               ; Auto-Increment Value
040342             0100*  ;
040342             0101*  ; Extra Agon-implementation specific system variables
040342             0102*  ;
040342             0103*  FLAGS:			DS		1		; Miscellaneous flags
040343             0104*  							; - BIT 7: Set if ESC pressed
040343             0105*  							; - BIT 6: Set to disable ESC
040343             0106*  OSWRCHPT:		DS		2		; Pointer for *EDIT
040345             0107*  OSWRCHCH:		DS		1		; Channel of OSWRCH
040346             0108*  							; - 0: Console
040346             0109*  							; - 1: File
040346             0110*  OSWRCHFH:		DS		1		; File handle for OSWRCHCHN
040347             0111*  KEYDOWN:		DS		1		; Keydown flag
040348             0112*  KEYASCII:		DS		1		; ASCII code of pressed key
040349             0113*  KEYCOUNT:		DS		1		; Counts every time a key is pressed
04034A             0114*  R0:			DS		3		; General purpose storage for 8/16 to 24 bit operations
04034D             0115*  R1:			DS		3		;
040350             0116*  ;
040350             0117*  ; This must be at the end
040350             0118*  ;
040350             0119*  RAM_END:
040350 FF FF FF FF 0120*  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040400             0121*  USER:							; Must be aligned on a page boundary
040400             0122*  
040400             0022   			INCLUDE	"equs.inc"
040400             0001*  ;
040400             0002*  ; Title:	BBC Basic for AGON - Equs
040400             0003*  ; Author:	Dean Belfield
040400             0004*  ; Created:	12/05/2023
040400             0005*  ; Last Updated:	08/06/2023
040400             0006*  ;
040400             0007*  ; Modinfo:
040400             0008*  ; 08/06/2023:	Added SIZEW
040400             0009*  
040400             0010*  			; XREF		STAVAR
040400             0011*  			; XREF		ACCS
040400             0012*  
040400             0013*  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
040400             0014*  ;Stack_Top:		EQU		0000h	; Stack at top
040400             0015*  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
040400             0016*  
040400             0017*  ; For GPIO
040400             0018*  ; PA not available on eZ80L92
040400             0019*  ;
040400             0020*  PA_DR:			EQU		96h
040400             0021*  PA_DDR:			EQU		97h
040400             0022*  PA_ALT1:		EQU		98h
040400             0023*  PA_ALT2:		EQU		99h
040400             0024*  PB_DR:          	EQU		9Ah
040400             0025*  PB_DDR:        	 	EQU		9Bh
040400             0026*  PB_ALT1:        	EQU		9Ch
040400             0027*  PB_ALT2:        	EQU		9Dh
040400             0028*  PC_DR:          	EQU		9Eh
040400             0029*  PC_DDR:         	EQU		9Fh
040400             0030*  PC_ALT1:        	EQU		A0h
040400             0031*  PC_ALT2:        	EQU		A1h
040400             0032*  PD_DR:          	EQU		A2h
040400             0033*  PD_DDR:			EQU		A3h
040400             0034*  PD_ALT1:		EQU		A4h
040400             0035*  PD_ALT2:		EQU		A5h
040400             0036*  
040400             0037*  GPIOMODE_OUT:		EQU		0	; Output
040400             0038*  GPIOMODE_IN:		EQU		1	; Input
040400             0039*  GPIOMODE_DIO:		EQU		2	; Open Drain IO
040400             0040*  GPIOMODE_SIO:		EQU		3	; Open Source IO
040400             0041*  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040400             0042*  GPIOMODE_ALTF:		EQU		5;	; Alt Function
040400             0043*  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040400             0044*  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040400             0045*  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040400             0046*  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040400             0047*  
040400             0048*  ; Originally in ram.asm
040400             0049*  ;
040400             0050*  OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
040400             0051*  PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
040400             0052*  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
040400             0053*  
040400             0054*  ; Originally in main.asm
040400             0055*  ;
040400             0056*  CR:			EQU     0DH
040400             0057*  LF:			EQU     0AH
040400             0058*  ESC:			EQU     1BH
040400             0023   
040400             0024   ; 			SEGMENT CODE
040400             0025   
040400             0026   ; 			XDEF	XEQ
040400             0027   ; 			XDEF	CHAIN0
040400             0028   ; 			XDEF	RUN
040400             0029   ; 			XDEF	SYNTAX
040400             0030   ; 			XDEF	ESCAPE
040400             0031   ; 			XDEF	FN
040400             0032   ; 			XDEF	USR
040400             0033   ; 			XDEF	STORE5
040400             0034   ; 			XDEF	STORE4
040400             0035   ; 			XDEF	CHECK
040400             0036   ; 			XDEF	TERMQ
040400             0037   ; 			XDEF	FILL
040400             0038   ; 			XDEF	X4OR5
040400             0039   ; 			XDEF	MUL16
040400             0040   ; 			XDEF	CHANEL
040400             0041   ; 			XDEF	ASSEM
040400             0042   
040400             0043   ; 			XREF	AUTO
040400             0044   ; 			XREF	DELETE
040400             0045   ; 			XREF	LOAD
040400             0046   ; 			XREF	LIST_
040400             0047   ; 			XREF	NEW
040400             0048   ; 			XREF	OLD
040400             0049   ; 			XREF	RENUM
040400             0050   ; 			XREF	SAVE
040400             0051   ; 			XREF	SOUND
040400             0052   ; 			XREF	CLG
040400             0053   ; 			XREF	DRAW
040400             0054   ; 			XREF	ENVEL
040400             0055   ; 			XREF	GCOL
040400             0056   ; 			XREF	MODE
040400             0057   ; 			XREF	MOVE
040400             0058   ; 			XREF	PLOT
040400             0059   ; 			XREF	COLOUR
040400             0060   ; 			XREF	EXPRS
040400             0061   ; 			XREF	HIMEM
040400             0062   ; 			XREF	LOAD0
040400             0063   ; 			XREF	RANDOM
040400             0064   ; 			XREF	CLEAR
040400             0065   ; 			XREF	ERRTRP
040400             0066   ; 			XREF	PAGE_
040400             0067   ; 			XREF	DATAPTR
040400             0068   ; 			XREF	ERRLIN
040400             0069   ; 			XREF	TRAP
040400             0070   ; 			XREF	NXT
040400             0071   ; 			XREF	SETLIN
040400             0072   ; 			XREF	CLOOP
040400             0073   ; 			XREF	OSSHUT
040400             0074   ; 			XREF	WARM
040400             0075   ; 			XREF	TRACEN
040400             0076   ; 			XREF	OUTCHR
040400             0077   ; 			XREF	PBCDL
040400             0078   ; 			XREF	OSCLI
040400             0079   ; 			XREF	LISTON
040400             0080   ; 			XREF	GETVAR
040400             0081   ; 			XREF	PUTVAR
040400             0082   ; 			XREF	DATPTR
040400             0083   ; 			XREF	ERROR_
040400             0084   ; 			XREF	EXPR
040400             0085   ; 			XREF	CREATE
040400             0086   ; 			XREF	EXPRI
040400             0087   ; 			XREF	BRAKET
040400             0088   ; 			XREF	FREE
040400             0089   ; 			XREF	OSBPUT
040400             0090   ; 			XREF	COUNT
040400             0091   ; 			XREF	STR
040400             0092   ; 			XREF	HEXSTR
040400             0093   ; 			XREF	CRLF
040400             0094   ; 			XREF	ITEMI
040400             0095   ; 			XREF	FINDL
040400             0096   ; 			XREF	TEST
040400             0097   ; 			XREF	EXPRN
040400             0098   ; 			XREF	DLOAD5
040400             0099   ; 			XREF	DLOAD5_SPL
040400             0100   ; 			XREF	LOADN
040400             0101   ; 			XREF	FPP
040400             0102   ; 			XREF	SWAP
040400             0103   ; 			XREF	GETDEF
040400             0104   ; 			XREF	ZERO
040400             0105   ; 			XREF	OSBGET
040400             0106   ; 			XREF	BUFFER
040400             0107   ; 			XREF	CONS
040400             0108   ; 			XREF	VAL0
040400             0109   ; 			XREF	OSLINE
040400             0110   ; 			XREF	CLRSCN
040400             0111   ; 			XREF	TELL
040400             0112   ; 			XREF	SAYLN
040400             0113   ; 			XREF	REPORT
040400             0114   ; 			XREF	PUTPTR
040400             0115   ; 			XREF	PUTIME
040400             0116   ; 			XREF	PUTIMS
040400             0117   ; 			XREF	LOMEM
040400             0118   ; 			XREF	WIDTH
040400             0119   ; 			XREF	OSWRCH
040400             0120   ; 			XREF	COMMA
040400             0121   ; 			XREF	OSCALL
040400             0122   ; 			XREF	SFIX
040400             0123   ; 			XREF	LOAD4
040400             0124   ; 			XREF	PUSHS
040400             0125   ; 			XREF	POPS
040400             0126   ; 			XREF	LOADS
040400             0127   ; 			XREF	PUTCSR
040400             0128   ; 			XREF	OUT_
040400             0129   ; 			XREF	R0
040400             0130   ; ;
040400             0131   ; List of token values used in this module
040400             0132   ;
040400             0133   TAND:			EQU     80H
040400             0134   TOR:			EQU     84H
040400             0135   TERROR_EX:			EQU     85H
040400             0136   LINE_:			EQU     86H
040400             0137   OFF_:			EQU     87H
040400             0138   STEP:			EQU     88H
040400             0139   SPC:			EQU     89H
040400             0140   TAB:			EQU     8AH
040400             0141   ELSE_:			EQU     8BH
040400             0142   THEN:			EQU     8CH
040400             0143   LINO:			EQU     8DH
040400             0144   TO:			EQU     B8H
040400             0145   TCMD:			EQU     C6H
040400             0146   TCALL:			EQU     D6H
040400             0147   DATA_:			EQU     DCH
040400             0148   DEF_:			EQU     DDH
040400             0149   TGOSUB:			EQU     E4H
040400             0150   TGOTO:			EQU     E5H
040400             0151   TON:			EQU     EEH
040400             0152   TPROC:			EQU     F2H
040400             0153   TSTOP:			EQU     FAH
040400             0154   
040400             0155   ; The command table
040400             0156   ; Commands are tokens from C6H onwards; this lookup table is used to
040400             0157   ; run the corresponding function; Note that DATA and DEF both use the same
040400             0158   ; code as REM
040400             0159   ;
040400 03 1A 04    0160   CMDTAB:			DW24  AUTO			; C6H
040403 54 1B 04    0161   			DW24  DELETE			; C7H
040406 52 1D 04    0162   			DW24  LOAD			; C8H
040409 36 1D 04    0163   			DW24  LIST_			; C9H
04040C 13 1E 04    0164   			DW24  NEW			; CAH
04040F 47 1E 04    0165   			DW24  OLD			; CBH
040412 62 20 04    0166   			DW24  RENUM			; CCH
040415 9B 20 04    0167   			DW24  SAVE			; CDH
040418 3A 0F 04    0168   			DW24  PUT			; CEH
04041B 30 0D 04    0169   			DW24  PTR			; CFH
04041E 4A 0D 04    0170   			DW24  PAGEV			; D0H
040421 5D 0D 04    0171   			DW24  TIMEV			; D1H
040424 86 0D 04    0172   			DW24  LOMEMV			; D2H
040427 9F 0D 04    0173   			DW24  HIMEMV			; D3H
04042A 0A 21 04    0174   			DW24  SOUND			; D4H
04042D 54 0E 04    0175   			DW24  BPUT			; D5H
040430 6C 0E 04    0176   			DW24  CALL_			; D6H
040433 B4 04 04    0177   			DW24  CHAIN			; D7H
040436 FF 0C 04    0178   			DW24  CLR			; D8H
040439 48 0E 04    0179   			DW24  CLOSE			; D9H
04043C 57 1A 04    0180   			DW24  CLG			; DAH
04043F D2 0C 04    0181   			DW24  CLS			; DBH
040442 93 05 04    0182   			DW24  REM             		; DCH: DATA
040445 93 05 04    0183   			DW24  REM             		; DDH: DEF
040448 59 06 04    0184   			DW24  DIM			; DEH
04044B AF 1B 04    0185   			DW24  DRAW			; DFH
04044E 2E 05 04    0186   			DW24  END_			; E0H
040451 EA 0A 04    0187   			DW24  ENDPRO			; E1H
040454 CA 1B 04    0188   			DW24  ENVEL			; E2H
040457 FF 08 04    0189   			DW24  FOR			; E3H
04045A AF 08 04    0190   			DW24  GOSUB			; E4H
04045D 93 08 04    0191   			DW24  GOTO			; E5H
040460 A8 1C 04    0192   			DW24  GCOL			; E6H
040463 9E 0C 04    0193   			DW24  IF_			; E7H
040466 8C 0B 04    0194   			DW24  INPUT			; E8H
040469 B4 05 04    0195   			DW24  LET			; E9H
04046C 8F 0A 04    0196   			DW24  LOCAL_			; EAH
04046F DD 1D 04    0197   			DW24  MODE			; EBH
040472 F8 1D 04    0198   			DW24  MOVE			; ECH
040475 4D 09 04    0199   			DW24  NEXT			; EDH
040478 26 08 04    0200   			DW24  ON_			; EEH
04047B 09 0E 04    0201   			DW24  VDU			; EFH
04047E 7F 1F 04    0202   			DW24  PLOT			; F0H
040481 2F 07 04    0203   			DW24  PRINT_			; F1H
040484 EC 09 04    0204   			DW24  PROC			; F2H
040487 3E 0C 04    0205   			DW24  READ			; F3H
04048A 93 05 04    0206   			DW24  REM			; F4H
04048D CF 08 04    0207   			DW24  REPEAT			; F5H
040490 F7 0C 04    0208   			DW24  REPOR			; F6H
040493 09 0D 04    0209   			DW24  RESTOR			; F7H
040496 BD 08 04    0210   			DW24  RETURN			; F8H
040499 AE 04 04    0211   			DW24  RUN			; F9H
04049C DF 0C 04    0212   			DW24  STOP			; FAH
04049F AA 1A 04    0213   			DW24  COLOUR			; FBH
0404A2 EB 0D 04    0214   			DW24  TRACE			; FCH
0404A5 D9 08 04    0215   			DW24  UNTIL			; FDH
0404A8 DD 0D 04    0216   			DW24  WIDTHV			; FEH
0404AB 79 05 04    0217   			DW24  CLI             		; FFH: OSCLI
0404AE             0218   
0404AE             0219   ; RUN
0404AE             0220   ; RUN "filename"
0404AE             0221   ;
0404AE CD 0C 11 04 0222   RUN:			CALL    TERMQ			; Standalone RUN command?
0404B2 28 10       0223   			JR      Z,RUN0			; Yes, so just RUN the code
0404B4             0224   
0404B4             0225   ; CHAIN "filename"
0404B4             0226   ;
0404B4 CD 56 1C 04 0227   CHAIN:			CALL    EXPRS			; Get the filename
0404B8 3E 0D       0228   			LD      A,CR			; Terminate it with a CR
0404BA 12          0229   			LD      (DE),A
0404BB ED 7B 20 03 0230   CHAIN0:			LD      SP,(HIMEM)		; Reset SP
       04          
0404C0 CD 6D 1D 04 0231   			CALL    LOAD0			; And load the file in
0404C4             0232   ;
0404C4 ED 7B 20 03 0233   RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
       04          
0404C9 DD 21 38 03 0234   			LD      IX,RANDOM		; Pointer to the RANDOM sysvar
       04          
0404CE ED 5F       0235   @@:			LD      A, R			; Use the R register to seed the random number generator
0404D0 28 FC       0236   			JR      Z, @B			; Loop unti we get a non-zero value in A
0404D2 07          0237   			RLCA				; Rotate it
0404D3 07          0238   			RLCA
0404D4 DD 77 03    0239   			LD      (IX+3),A		; And store
0404D7 9F          0240   			SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
0404D8 DD 77 04    0241   			LD      (IX+4),A		; And store
0404DB CD 3B 1A 04 0242   			CALL    CLEAR
0404DF 21 00 00 00 0243   			LD      HL,0			; Clear the error trap sysvar
0404E3 22 2C 03 04 0244   			LD      (ERRTRP),HL
0404E7 2A 14 03 04 0245   			LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
0404EB 3E DC       0246   			LD      A,DATA_			; The DATA token value
0404ED CD E0 11 04 0247   			CALL    SEARCH          	; Search for the first DATA token in the tokenised listing
0404F1 22 31 03 04 0248   			LD      (DATPTR),HL     	; Set data pointer
0404F5 FD 2A 14 03 0249   			LD      IY,(PAGE_)		; Load IY with the start of program memory
       04          
0404FA             0250   ;
0404FA CD 42 05 04 0251   XEQ0:			CALL    NEWLIN
0404FE FD 22 35 03 0252   XEQ:			LD      (ERRLIN),IY     	; Error pointer
       04          
040503 CD 91 21 04 0253   			CALL    TRAP           		; Check keyboard
040507 CD 2D 1E 04 0254   XEQ1:			CALL    NXT
04050B FD 23       0255   			INC     IY
04050D FE 3A       0256   			CP      ':'             	; Seperator
04050F 28 F6       0257   			JR      Z,XEQ1
040511 FE 0D       0258   			CP      CR
040513 28 E5       0259   			JR      Z,XEQ0          	; New program line
040515 D6 C6       0260   			SUB     TCMD
040517 DA A2 05 04 0261   			JP      C,LET0          	; Implied "LET"
04051B             0262   
04051B 01 03 00 00 0263   			LD	BC, 3
04051F 47          0264   			LD	B, A
040520 ED 4C       0265   			MLT	BC
040522 21 00 04 04 0266   			LD	HL,CMDTAB
040526 09          0267   			ADD	HL, BC
040527 ED 27       0268   			LD	HL, (HL)		; Table entry
040529             0269   
040529             0270   ;			ADD     A,A
040529             0271   ;			LD      C,A
040529             0272   ;			LD      B,0
040529             0273   ;			LD      HL,CMDTAB
040529             0274   ;			ADD     HL,BC
040529             0275   ;			LD      A,(HL)          	; Table entry
040529             0276   ;			INC     HL
040529             0277   ;			LD      H,(HL)
040529             0278   ;			LD      L,A
040529             0279   
040529 CD 2D 1E 04 0280   			CALL    NXT
04052D E9          0281   			JP      (HL)            	; Execute the statement
04052E             0282   
04052E             0283   ;END
04052E             0284   ;
04052E CD D2 20 04 0285   END_:			CALL    SETLIN          ;FIND CURRENT LINE
040532 7C          0286   			LD      A,H
040533 B5          0287   			OR      L               ;DIRECT?
040534 CA 71 1A 04 0288   			JP      Z,CLOOP
040538 1E 00       0289   			LD      E,0
04053A CD F1 1E 04 0290   			CALL    OSSHUT          ;CLOSE ALL FILES
04053E C3 C7 21 04 0291   			JP      WARM            ;"Ready"
040542             0292   ;
040542 FD 7E 00    0293   NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
040545 01 03 00 00 0294   			LD      BC,3
040549 FD 09       0295   			ADD     IY,BC
04054B B7          0296   			OR      A
04054C 28 E0       0297   			JR      Z,END_           ;LENGTH=0, EXIT
04054E 2A 26 03 04 0298   			LD      HL,(TRACEN)
040552 7C          0299   			LD      A,H
040553 B5          0300   			OR      L
040554 C8          0301   			RET     Z
040555 11 00 00 00 0302   			LD	DE, 0		;Clear DE
040559 FD 56 FF    0303   			LD      D,(IY-1)        ;DE = LINE NUMBER
04055C FD 5E FE    0304   			LD      E,(IY-2)
04055F ED 52       0305   			SBC     HL,DE
040561 D8          0306   			RET     C
040562 EB          0307   			EX      DE,HL
040563 3E 5B       0308   			LD      A,'['           ;TRACE
040565 CD 2B 1F 04 0309   			CALL    OUTCHR
040569 CD 63 1F 04 0310   			CALL    PBCDL
04056D 3E 5D       0311   			LD      A,']'
04056F CD 2B 1F 04 0312   			CALL    OUTCHR
040573 3E 20       0313   			LD      A,' '
040575 C3 2B 1F 04 0314   			JP      OUTCHR
040579             0315   
040579             0316   ; Routines for each statement -------------------------------------------------
040579             0317   
040579             0318   ; OSCLI
040579             0319   ;
040579 CD 56 1C 04 0320   CLI:			CALL    EXPRS
04057D 3E 0D       0321   			LD      A,CR
04057F 12          0322   			LD      (DE),A
040580 21 00 00 04 0323   			LD      HL,ACCS
040584 CD B8 1E 04 0324   			CALL    OSCLI
040588 C3 FE 04 04 0325   			JP      XEQ
04058C             0326   
04058C             0327   ; REM, *
04058C             0328   ;
04058C FD E5       0329   EXT:			PUSH    IY
04058E E1          0330   			POP     HL
04058F CD B8 1E 04 0331   			CALL    OSCLI
040593 FD E5       0332   REM:			PUSH    IY
040595 E1          0333   			POP     HL
040596 3E 0D       0334   			LD      A,CR
040598 47          0335   			LD      B,A
040599 ED B1       0336   			CPIR                    ;FIND LINE END
04059B E5          0337   			PUSH    HL
04059C FD E1       0338   			POP     IY
04059E C3 FA 04 04 0339   			JP      XEQ0
0405A2             0340   
0405A2             0341   ; [LET] var = expr
0405A2             0342   ;
0405A2 FE C5       0343   LET0:			CP      ELSE_-TCMD
0405A4 28 ED       0344   			JR      Z,REM
0405A6             0345   			; CP      ('*'-TCMD) & 0FFH
0405A6             0346   			; JR      Z,EXT
0405A6             0347   			; CP      ('='-TCMD) & 0FFH
0405A6             0348   			; JR      Z,FNEND
0405A6             0349   			; CP      ('['-TCMD) & 0FFH
0405A6             0350   			; ez80asm doesn't like () in expressions
0405A6 FE 64       0351   			CP      '*'-TCMD & 0FFH
0405A8 28 E2       0352   			JR      Z,EXT
0405AA FE 77       0353   			CP      '='-TCMD & 0FFH
0405AC 28 5B       0354   			JR      Z,FNEND
0405AE FE 95       0355   			CP      '['-TCMD & 0FFH
0405B0 28 25       0356   			JR      Z,ASM
0405B2 FD 2B       0357   			DEC     IY
0405B4 CD 50 0F 04 0358   LET:			CALL    ASSIGN			; Assign the variable
0405B8 CA FE 04 04 0359   			JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
0405BC 38 41       0360   			JR      C,SYNTAX        	; Return if C as it is an illegal variable
0405BE             0361   ;
0405BE F5          0362   			PUSH    AF              	; At this point we're dealing with a string type (A=81h)
0405BF CD 22 11 04 0363   			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0405C3 E5          0364   			PUSH    HL			; HL: Address of the variable
0405C4 CD 56 1C 04 0365   			CALL    EXPRS
0405C8 DD E1       0366   			POP     IX			; IX: Address of the variable
0405CA F1          0367   			POP     AF			; AF: The variable type
0405CB CD 92 0F 04 0368   			CALL    STACCS			; Copy the string from ACCS to the variable area
0405CF C3 FE 04 04 0369   XEQR:			JP      XEQ
0405D3             0370   ;
0405D3 CD 42 05 04 0371   ASM0:			CALL    NEWLIN
0405D7 FD 22 35 03 0372   ASM:			LD      (ERRLIN),IY
       04          
0405DC CD 91 21 04 0373   			CALL    TRAP
0405E0 CD 2D 12 04 0374   			CALL    ASSEM
0405E4 38 19       0375   			JR      C,SYNTAX
0405E6 FE 0D       0376   			CP      CR
0405E8 28 E9       0377   			JR      Z,ASM0
0405EA 21 40 03 04 0378   			LD      HL,LISTON
0405EE 7E          0379   			LD      A,(HL)
0405EF E6 0F       0380   			AND     0FH
0405F1 F6 B0       0381   			OR      B0H
0405F3 77          0382   			LD      (HL),A
0405F4 18 D9       0383   			JR      XEQR
0405F6             0384   ;
0405F6 CD E0 1C 04 0385   VAR_:			CALL    GETVAR
0405FA C8          0386   			RET     Z
0405FB D2 45 20 04 0387   			JP      NC,PUTVAR
0405FF 3E 10       0388   SYNTAX:			LD      A,16            ;"Syntax error"
040601 18 02       0389   			JR	ERROR0
040603 3E 11       0390   ESCAPE:			LD      A,17            ;"Escape"
040605 C3 E6 1B 04 0391   ERROR0:			JP      ERROR_
040609             0392   
040609             0393   ; =
040609             0394   ;
040609 CD 03 1C 04 0395   FNEND:			CALL    EXPR            ;FUNCTION RESULT
04060D 43          0396   			LD      B,E
04060E EB          0397   			EX      DE,HL
04060F D9          0398   			EXX                     ;SAVE RESULT
040610 EB          0399   			EX      DE,HL           ; IN DEB'C'D'E'
040611 C1          0400   FNEND5:			POP     BC
040612 21 EA 10 04 0401   			LD      HL,LOCCHK
040616 B7          0402   			OR      A
040617 ED 42       0403   			SBC     HL,BC
040619 28 1C       0404   			JR      Z,FNEND0        ;LOCAL VARIABLE
04061B 21 EC 09 04 0405   			LD      HL,FNCHK
04061F B7          0406   			OR      A
040620 ED 42       0407   			SBC     HL,BC
040622 3E 07       0408   			LD      A,7
040624 20 DF       0409   			JR      NZ,ERROR0       ;"No FN"
040626 FD E1       0410   			POP     IY
040628 FD 22 35 03 0411   			LD      (ERRLIN),IY     ;IN CASE OF ERROR
       04          
04062D EB          0412   			EX      DE,HL
04062E D9          0413   			EXX
04062F EB          0414   			EX      DE,HL
040630 11 00 00 04 0415   			LD      DE,ACCS
040634 58          0416   			LD      E,B
040635 08          0417   			EX      AF,AF'
040636 C9          0418   			RET
040637             0419   ;
040637 DD E1       0420   FNEND0:			POP     IX
040639 C1          0421   			POP     BC
04063A 78          0422   			LD      A,B
04063B B7          0423   			OR      A
04063C FA 4A 06 04 0424   			JP      M,FNEND1        ;STRING
040640 E1          0425   			POP     HL
040641 D9          0426   			EXX
040642 E1          0427   			POP     HL
040643 D9          0428   			EXX
040644 CD 68 0F 04 0429   			CALL    STORE
040648 18 C7       0430   			JR      FNEND5
04064A 21 00 00 00 0431   FNEND1:			LD      HL,0
04064E 39          0432   			ADD     HL,SP
04064F D5          0433   			PUSH    DE
040650 59          0434   			LD      E,C
040651 CD 96 0F 04 0435   			CALL    STORES
040655 D1          0436   			POP     DE
040656 F9          0437   			LD      SP,HL
040657 18 B8       0438   			JR      FNEND5
040659             0439   
040659             0440   ; DIM var(dim1[,dim2[,...]])[,var(...]
040659             0441   ; DIM var expr[,var expr...]
040659             0442   ;
040659 CD E0 1C 04 0443   DIM:			CALL    GETVAR          	; Get the variable
04065D DA E9 06 04 0444   			JP      C,BADDIM		; Throw a "Bad Dim" error
040661 CA F3 06 04 0445   			JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
040665 CD FE 1A 04 0446   			CALL    CREATE			; Create a new entity
040669 E5          0447   			PUSH    HL			; HL: Address of the entity
04066A DD E1       0448   			POP     IX			; IX: Address of the entity
04066C FD 7E 00    0449   			LD      A,(IY)			; Fetch the next character from the tokenised string
04066F FE 28       0450   			CP      '('			; Check for opening brackets
040671 7A          0451   			LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
040672 20 7F       0452   			JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
040674             0453   ;
040674             0454   ; At this point we're reserving a variable array
040674             0455   ;
040674 E5          0456   			PUSH    HL			; HL: Address of the entity
040675 F5          0457   			PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
040676 11 01 00 00 0458   			LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
04067A 42          0459   			LD      B,D			;  B: The number of dimensions in the array
04067B             0460   ;
04067B FD 23       0461   DIM1:			INC     IY			; Skip to the next token
04067D C5          0462   			PUSH    BC			; Stack the dimension counter
04067E D5          0463   			PUSH    DE			; Stack the total size of array accumulator
04067F DD E5       0464   			PUSH    IX			; Stack the entity address
040681 CD 1E 1C 04 0465   			CALL    EXPRI           	; Fetch the size of this dimension
040685 CB 7C       0466   			BIT     7,H			; If it is negative then
040687 20 60       0467   			JR      NZ,BADDIM		; Throw a "Bad Dim" error
040689 D9          0468   			EXX
04068A 23          0469   			INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
04068B DD E1       0470   			POP     IX			; IX: The entity address
04068D DD 23       0471   			INC     IX
04068F DD 75 00    0472   			LD      (IX),L          	; Save the size of this dimension in the entity
040692 DD 23       0473   			INC     IX
040694 DD 74 00    0474   			LD      (IX),H
040697 C1          0475   			POP     BC
040698 CD 04 12 04 0476   			CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
04069C 38 4F       0477   			JR      C,NOROOM        	; Throw a "No Room" error if overflow
04069E EB          0478   			EX      DE,HL           	; DE: The new total size of array accumulator
04069F C1          0479   			POP     BC
0406A0 04          0480   			INC     B               	;  B: The dimension counter; increment
0406A1 FD 7E 00    0481   			LD      A,(IY)			; Fetch the nex token
0406A4 FE 2C       0482   			CP      ','             	; Check for another dimension in the array
0406A6 28 D3       0483   			JR      Z,DIM1			; And loop
0406A8             0484   ;
0406A8 CD 1E 1A 04 0485   			CALL    BRAKET          	; Check for closing bracket
0406AC F1          0486   			POP     AF              	; Restore the type
0406AD DD 23       0487   			INC     IX
0406AF DD E3       0488   			EX      (SP),IX
0406B1 DD 70 00    0489   			LD      (IX),B          	; Number of dimensions
0406B4 CD F7 11 04 0490   			CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
0406B8 E1          0491   			POP     HL			; Restore the entity address
0406B9 38 32       0492   			JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
0406BB             0493   ;
0406BB             0494   ; We now allocate the memory for the array
0406BB             0495   ;
0406BB 19          0496   DIM3:			ADD     HL,DE
0406BC 38 2F       0497   			JR      C,NOROOM
0406BE E5          0498   			PUSH    HL
0406BF 24          0499   			INC     H
0406C0 28 2B       0500   			JR      Z,NOROOM
0406C2 ED 72       0501   			SBC     HL,SP
0406C4 30 27       0502   			JR      NC,NOROOM       	; Throw an "Out of Space" error
0406C6 E1          0503   			POP     HL
0406C7 22 1D 03 04 0504   			LD      (FREE),HL
0406CB 7A          0505   DIM2:			LD      A,D
0406CC B3          0506   			OR      E
0406CD 28 06       0507   			JR      Z,DIM5
0406CF 2B          0508   			DEC     HL
0406D0 36 00       0509   			LD      (HL),0         		; Initialise the array
0406D2 1B          0510   			DEC     DE
0406D3 18 F6       0511   			JR      DIM2
0406D5 CD 2D 1E 04 0512   DIM5:			CALL    NXT
0406D9 FE 2C       0513   			CP      ','            		; Another variable?
0406DB C2 FE 04 04 0514   			JP      NZ,XEQ
0406DF FD 23       0515   			INC     IY
0406E1 CD 2D 1E 04 0516   			CALL    NXT
0406E5 C3 59 06 04 0517   			JP      DIM
0406E9             0518   ;
0406E9             0519   ; DIM errors
0406E9             0520   ;
0406E9 3E 0A       0521   BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
0406EB 18 02       0522   			JR	ERROR1
0406ED 3E 0B       0523   NOROOM:			LD      A,11            	; Throw a "DIM space" error
0406EF C3 E6 1B 04 0524   ERROR1:			JP      ERROR_
0406F3             0525   ;
0406F3             0526   ; At this point we're reserving a block of memory, i.e.
0406F3             0527   ; DIM var expr[,var expr...]
0406F3             0528   ;
0406F3 B7          0529   DIM4:			OR      A			;  A: The dimension variable type
0406F4 28 F3       0530   			JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
0406F6 FA E9 06 04 0531   			JP      M,BADDIM        	; or a string
0406FA 47          0532   			LD      B,A			; Temporarily store the dimension variable type in B
0406FB FD 7E FF    0533   			LD      A,(IY-1)		; Get the last character but one
0406FE FE 29       0534   			CP      ')'			; Check if it is a trailing bracket
040700 28 E7       0535   			JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
040702             0536   ;
040702 21 00 00 00 0537   			LD	HL,0			; Clear HL
040706 3A 1D 03 04 0538   			LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
04070A 6F          0539   			LD	L,A
04070B 3A 1E 03 04 0540   			LD	A,(FREE+1)
04070F 67          0541   			LD	H,A
040710 78          0542   			LD	A,B			; Restore the dimension variable type
040711 D9          0543   			EXX
040712 21 00 00 00 0544   			LD	HL,0			; Clear HL
040716 47          0545   			LD	B,A			; Temporarily store the dimension variable type in B
040717 3A 1F 03 04 0546   			LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
04071B 6F          0547   			LD	L,A
04071C 78          0548   			LD	A,B			; Restore the dimension variable type
04071D 4C          0549   			LD	C,H
04071E CD 68 0F 04 0550   			CALL    STORE           	; Store the address
040722 CD 1E 1C 04 0551   			CALL    EXPRI			; Get the number of bytes to store
040726 D9          0552   			EXX
040727 23          0553   			INC     HL			; Add one to it
040728 EB          0554   			EX      DE,HL
040729 2A 1D 03 04 0555   			LD      HL,(FREE)
04072D 18 8C       0556   			JR      DIM3			; Continue with the DIM
04072F             0557   
04072F             0558   ; PRINT list...
04072F             0559   ; PRINT #channel,list...
04072F             0560   ;
04072F FE 23       0561   PRINT_:			CP      '#'
040731 20 7C       0562   			JR      NZ,PRINT0
040733 CD 24 12 04 0563   			CALL    CHNL            ;CHANNEL NO. = E
040737 CD 2D 1E 04 0564   PRNTN1:			CALL    NXT
04073B FE 2C       0565   			CP      ','
04073D C2 FE 04 04 0566   			JP      NZ,XEQ
040741 FD 23       0567   			INC     IY
040743 D5          0568   			PUSH    DE
040744 CD 03 1C 04 0569   			CALL    EXPR            ;ITEM TO PRINT
040748 08          0570   			EX      AF,AF'
040749 FA 6F 07 04 0571   			JP      M,PRNTN2        ;STRING
04074D D1          0572   			POP     DE
04074E C5          0573   			PUSH    BC
04074F D9          0574   			EXX
040750 7D          0575   			LD      A,L
040751 D9          0576   			EXX
040752 CD 7E 1E 04 0577   			CALL    OSBPUT
040756 D9          0578   			EXX
040757 7C          0579   			LD      A,H
040758 D9          0580   			EXX
040759 CD 7E 1E 04 0581   			CALL    OSBPUT
04075D 7D          0582   			LD      A,L
04075E CD 7E 1E 04 0583   			CALL    OSBPUT
040762 7C          0584   			LD      A,H
040763 CD 7E 1E 04 0585   			CALL    OSBPUT
040767 C1          0586   			POP     BC
040768 79          0587   			LD      A,C
040769 CD 7E 1E 04 0588   			CALL    OSBPUT
04076D 18 C8       0589   			JR      PRNTN1
04076F 4B          0590   PRNTN2:			LD      C,E
040770 D1          0591   			POP     DE
040771 21 00 00 04 0592   			LD      HL,ACCS
040775 0C          0593   			INC     C
040776 0D          0594   PRNTN3:			DEC     C
040777 28 0A       0595   			JR      Z,PRNTN4
040779 7E          0596   			LD      A,(HL)
04077A 23          0597   			INC     HL
04077B C5          0598   			PUSH    BC
04077C CD 7E 1E 04 0599   			CALL    OSBPUT
040780 C1          0600   			POP     BC
040781 18 F3       0601   			JR      PRNTN3
040783 3E 0D       0602   PRNTN4:			LD      A,CR
040785 CD 7E 1E 04 0603   			CALL    OSBPUT
040789 18 AC       0604   			JR      PRNTN1
04078B             0605   ;
04078B 06 02       0606   PRINT6:			LD      B,2
04078D 18 27       0607   			JR      PRINTC
04078F 01 00 01 00 0608   PRINT8:			LD      BC,100H
040793 18 21       0609   			JR      PRINTC
040795 21 00 02 04 0610   PRINT9:			LD      HL,STAVAR
040799 AF          0611   			XOR     A
04079A BE          0612   			CP      (HL)
04079B 28 12       0613   			JR      Z,PRINT0
04079D 3A 3D 03 04 0614   			LD      A,(COUNT)
0407A1 B7          0615   			OR      A
0407A2 28 0B       0616   			JR      Z,PRINT0
0407A4 96          0617   PRINTA:			SUB     (HL)
0407A5 28 08       0618   			JR      Z,PRINT0
0407A7 30 FB       0619   			JR      NC,PRINTA
0407A9 ED 44       0620   			NEG
0407AB CD 81 11 04 0621   			CALL    FILL
0407AF 3A 00 02 04 0622   PRINT0:			LD      A,(STAVAR)
0407B3 4F          0623   			LD      C,A             ;PRINTS
0407B4 06 00       0624   			LD      B,0             ;PRINTF
0407B6 CD 0C 11 04 0625   PRINTC:			CALL    TERMQ
0407BA 28 3F       0626   			JR      Z,PRINT4
0407BC CB 80       0627   			RES     0,B
0407BE FD 23       0628   			INC     IY
0407C0 FE 7E       0629   			CP      '~'
0407C2 28 C7       0630   			JR      Z,PRINT6
0407C4 FE 3B       0631   			CP      ';'
0407C6 28 C7       0632   			JR      Z,PRINT8
0407C8 FE 2C       0633   			CP      ','
0407CA 28 C9       0634   			JR      Z,PRINT9
0407CC CD 31 11 04 0635   			CALL    FORMAT          ;SPC, TAB, '
0407D0 28 E4       0636   			JR      Z,PRINTC
0407D2 FD 2B       0637   			DEC     IY
0407D4 C5          0638   			PUSH    BC
0407D5 CD 03 1C 04 0639   			CALL    EXPR            ;VARIABLE TYPE
0407D9 08          0640   			EX      AF,AF'
0407DA FA F4 07 04 0641   			JP      M,PRINT3        ;STRING
0407DE D1          0642   			POP     DE
0407DF D5          0643   			PUSH    DE
0407E0 CB 4A       0644   			BIT     1,D
0407E2 F5          0645   			PUSH    AF
0407E3 CC 26 21 04 0646   			CALL    Z,STR           ;DECIMAL
0407E7 F1          0647   			POP     AF
0407E8 C4 FD 1C 04 0648   			CALL    NZ,HEXSTR       ;HEX
0407EC C1          0649   			POP     BC
0407ED C5          0650   			PUSH    BC
0407EE 79          0651   			LD      A,C
0407EF 93          0652   			SUB     E
0407F0 D4 81 11 04 0653   			CALL    NC,FILL         ;RIGHT JUSTIFY
0407F4 C1          0654   PRINT3:			POP     BC
0407F5 CD 90 11 04 0655   			CALL    PTEXT           ;PRINT
0407F9 18 BB       0656   			JR      PRINTC
0407FB CB 40       0657   PRINT4:			BIT     0,B
0407FD CC 1B 1B 04 0658   			CALL    Z,CRLF
040801 C3 FE 04 04 0659   			JP      XEQ
040805             0660   
040805             0661   ; ON ERROR statement [:statement...]
040805             0662   ; ON ERROR OFF
040805             0663   ;
040805 FD 23       0664   ONERR:			INC     IY              ;SKIP "ERROR"
040807 21 00 00 00 0665   			LD      HL,0
04080B 22 2C 03 04 0666   			LD      (ERRTRP),HL
04080F CD 2D 1E 04 0667   			CALL    NXT
040813 FE 87       0668   			CP      OFF_
040815 FD 23       0669   			INC     IY
040817 CA FE 04 04 0670   			JP      Z,XEQ
04081B FD 2B       0671   			DEC     IY
04081D FD 22 2C 03 0672   			LD      (ERRTRP),IY
       04          
040822 C3 93 05 04 0673   			JP      REM
040826             0674   
040826             0675   ; ON expr GOTO line[,line...] [ELSE statement]
040826             0676   ; ON expr GOTO line[,line...] [ELSE line]
040826             0677   ; ON expr GOSUB line[,line...] [ELSE statement]
040826             0678   ; ON expr GOSUB line[,line...] [ELSE line]
040826             0679   ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
040826             0680   ;
040826 FE 85       0681   ON_:			CP      TERROR_EX
040828 28 DB       0682   			JR      Z,ONERR         ;"ON ERROR"
04082A CD 1E 1C 04 0683   			CALL    EXPRI
04082E FD 7E 00    0684   			LD      A,(IY)
040831 FD 23       0685   			INC     IY
040833 1E 2C       0686   			LD      E,','           ;SEPARATOR
040835 FE E5       0687   			CP      TGOTO
040837 28 0B       0688   			JR      Z,ON1
040839 FE E4       0689   			CP      TGOSUB
04083B 28 07       0690   			JR      Z,ON1
04083D 1E F2       0691   			LD      E,TPROC
04083F BB          0692   			CP      E
040840 3E 27       0693   			LD      A,39
040842 20 45       0694   			JR      NZ,ERROR2       ;"ON syntax"
040844 57          0695   ON1:			LD      D,A
040845 D9          0696   			EXX
040846 E5          0697   			PUSH    HL
040847 D9          0698   			EXX
040848 C1          0699   			POP     BC              ;ON INDEX
040849 78          0700   			LD      A,B
04084A B4          0701   			OR      H
04084B B5          0702   			OR      L
04084C 20 2A       0703   			JR      NZ,ON4          ;OUT OF RANGE
04084E B1          0704   			OR      C
04084F 28 27       0705   			JR      Z,ON4
040851 0D          0706   			DEC     C
040852 28 0E       0707   			JR      Z,ON3           ;INDEX=1
040854 CD 0C 11 04 0708   ON2:			CALL    TERMQ
040858 28 1E       0709   			JR      Z,ON4           ;OUT OF RANGE
04085A FD 23       0710   			INC     IY              ;SKIP DELIMITER
04085C BB          0711   			CP      E
04085D 20 F5       0712   			JR      NZ,ON2
04085F 0D          0713   			DEC     C
040860 20 F2       0714   			JR      NZ,ON2
040862 7B          0715   ON3:			LD      A,E
040863 FE F2       0716   			CP      TPROC
040865 28 26       0717   			JR      Z,ONPROC
040867 D5          0718   			PUSH    DE
040868 CD 1A 1D 04 0719   			CALL    ITEMI           ;LINE NUMBER
04086C D1          0720   			POP     DE
04086D 7A          0721   			LD      A,D
04086E FE E5       0722   			CP      TGOTO
040870 28 2D       0723   			JR      Z,GOTO2
040872 CD 19 11 04 0724   			CALL    SPAN            ;SKIP REST OF LIST
040876 18 3B       0725   			JR      GOSUB1
040878             0726   ;
040878 FD 7E 00    0727   ON4:			LD      A,(IY)
04087B FD 23       0728   			INC     IY
04087D FE 8B       0729   			CP      ELSE_
04087F CA B3 0C 04 0730   			JP      Z,IF1           ;ELSE CLAUSE
040883 FE 0D       0731   			CP      CR
040885 20 F1       0732   			JR      NZ,ON4
040887 3E 28       0733   			LD      A,40
040889 C3 E6 1B 04 0734   ERROR2:			JP      ERROR_           ;"ON range"
04088D             0735   ;
04088D 3E EE       0736   ONPROC:			LD      A,TON
04088F C3 EC 09 04 0737   			JP      PROC
040893             0738   
040893             0739   ; GOTO line
040893             0740   ;
040893 CD 1A 1D 04 0741   GOTO:			CALL    ITEMI           	; Fetch the line number
040897 CD 0C 11 04 0742   GOTO1:			CALL    TERMQ			; Check for terminator
04089B C2 FF 05 04 0743   			JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
04089F D9          0744   GOTO2:			EXX
0408A0 CD 72 1C 04 0745   			CALL    FINDL			; HL: Line number - Find the line
0408A4 E5          0746   			PUSH    HL			; HL: Address of the line
0408A5 FD E1       0747   			POP     IY			; IY = HL
0408A7 CA FA 04 04 0748   			JP      Z,XEQ0			; If the line is found, then continue execution at that point
0408AB 3E 29       0749   			LD      A,41			; Otherwise throw a "No such line" error
0408AD 18 DA       0750   			JR      ERROR2
0408AF             0751   
0408AF             0752   ; GOSUB line
0408AF             0753   ; This pushes the following data onto the execution stack
0408AF             0754   ; - 3 bytes: Current execution address
0408AF             0755   ; - 3 bytes: Marker (the address of label GOSCHK)
0408AF             0756   ;
0408AF CD 1A 1D 04 0757   GOSUB:			CALL    ITEMI			; Fetch the line number
0408B3 FD E5       0758   GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
0408B5 CD E1 0F 04 0759   			CALL    CHECK           	; Check there is enough room
0408B9 CD 97 08 04 0760   			CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
0408BD             0761   GOSCHK:			EQU     $
0408BD             0762   
0408BD             0763   ; RETURN
0408BD             0764   ; This pops the following data off the execution stack as pushed by GOSUB
0408BD             0765   ; - 3 bytes: Marker (should be the address of label GOSCHK)
0408BD             0766   ; - 3 bytes: The return execution address
0408BD             0767   ;
0408BD D1          0768   RETURN:			POP     DE			; Pop the marker off the execution stack
0408BE 21 BD 08 04 0769   			LD      HL,GOSCHK		; Compare with GOSCHK
0408C2 B7          0770   			OR      A
0408C3 ED 52       0771   			SBC     HL,DE
0408C5 FD E1       0772   			POP     IY			; Pop the return address off the execution stack
0408C7 CA FE 04 04 0773   			JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
0408CB 3E 26       0774   			LD      A,38			; Otherwise throw a "No GOSUB" error
0408CD 18 BA       0775   			JR      ERROR2
0408CF             0776   
0408CF             0777   ; REPEAT
0408CF             0778   ; This pushes the following data onto the execution stack
0408CF             0779   ; - 3 bytes: Current execution address
0408CF             0780   ; - 3 bytes: Marker (the address of label REPCHK)
0408CF             0781   ;
0408CF FD E5       0782   REPEAT:			PUSH    IY			; Push the current execution address onto the execution stack
0408D1 CD E1 0F 04 0783   			CALL    CHECK			; Check if there is enough room
0408D5 CD FE 04 04 0784   			CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
0408D9             0785   REPCHK:			EQU     $
0408D9             0786   
0408D9             0787   ; UNTIL expr
0408D9             0788   ; This pops the following data off the execution stack
0408D9             0789   ; - 3 bytes: Marker (should be the address of label REPCHK)
0408D9             0790   ; - 3 bytes: The address of the REPEAT instruction
0408D9             0791   ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
0408D9             0792   ;
0408D9 C1          0793   UNTIL:			POP     BC			; Fetch the marker
0408DA C5          0794   			PUSH    BC			; And push it back onto the execution stack
0408DB 21 D9 08 04 0795   			LD      HL,REPCHK		; Compare with REPCHK
0408DF B7          0796   			OR      A
0408E0 ED 42       0797   			SBC     HL,BC
0408E2 3E 2B       0798   			LD      A,43
0408E4 20 A3       0799   			JR      NZ,ERROR2		; Throw a "No REPEAT" if this value does not match
0408E6 CD 1E 1C 04 0800   			CALL    EXPRI			; Fetch the expression
0408EA CD 76 21 04 0801   			CALL    TEST			; Test if the expression evaluates to zero
0408EE C1          0802   			POP     BC			; Pop the marker
0408EF D1          0803   			POP     DE			; Pop the address of the REPEAT instruction
0408F0 20 05       0804   			JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
0408F2 D5          0805   			PUSH    DE			; Push the address of the REPEAT instruction back on the stack
0408F3 C5          0806   			PUSH    BC			; Push the marker back on the stack
0408F4 D5          0807   			PUSH    DE			; IY = DE
0408F5 FD E1       0808   			POP     IY			; This sets the execution address back to the REPEAT instruction
0408F7 C3 FE 04 04 0809   XEQ2:			JP      XEQ			; Continue execution
0408FB             0810   
0408FB             0811   ; FOR var = expr TO expr [STEP expr]
0408FB             0812   ; This pushes the following data onto the execution stack
0408FB             0813   ; - 3 bytes: The limit value
0408FB             0814   ; - 3 bytes: The step value
0408FB             0815   ; - 3 bytes: The current execution address
0408FB             0816   ; - 3 bytes: The address of the loop variable
0408FB             0817   ; - 3 bytes: Marker (the address of FORCHK)
0408FB             0818   ;
0408FB 3E 22       0819   FORVAR:			LD      A,34
0408FD 18 8A       0820   			JR      ERROR2          	; Throw "FOR variable" error
0408FF             0821   ;
0408FF CD 50 0F 04 0822   FOR:			CALL    ASSIGN			; Assign the START expression value to a variable
040903 20 F6       0823   			JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
040905 F5          0824   			PUSH    AF              	; Save the variable type
040906 FD 7E 00    0825   			LD      A,(IY)			; Check the next token
040909 FE B8       0826   			CP      TO			; Compare with the token value for "TO"
04090B 3E 24       0827   			LD      A,36			; Set the error code to 36 ("No TO")
04090D C2 89 08 04 0828   			JP      NZ,ERROR2       	; And throw the error if that token is missing
040911 FD 23       0829   			INC     IY			; Skip to the next token
040913             0830   ;
040913 DD E5       0831   			PUSH    IX
040915 CD 3A 1C 04 0832   			CALL    EXPRN           	; Fetch the LIMIT expression value
040919 DD E1       0833   			POP     IX
04091B F1          0834   			POP     AF
04091C 47          0835   			LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
04091D C5          0836   			PUSH    BC              	; Stack the LIMIT value
04091E E5          0837   			PUSH    HL
04091F 21 00 00 00 0838   			LD      HL,0
040923 4C          0839   			LD      C,H
040924 D9          0840   			EXX
040925 E5          0841   			PUSH    HL
040926             0842   ;
040926 21 01 00 00 0843   			LD      HL,1            	; The preset STEP value is 1
04092A D9          0844   			EXX
04092B FD 7E 00    0845   			LD      A,(IY)			; Fetch the next token
04092E FE 88       0846   			CP      STEP			; Compare with the token value for "STEP"
040930 20 0A       0847   			JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
040932             0848   ;
040932 FD 23       0849   			INC     IY			; Skip past the STEP token
040934 DD E5       0850   			PUSH    IX
040936 CD 3A 1C 04 0851   			CALL    EXPRN          		; Fetch the STEP expression value
04093A DD E1       0852   			POP     IX
04093C             0853   ;
04093C C5          0854   FOR1:			PUSH    BC			; Stack the STEP value
04093D E5          0855   			PUSH    HL
04093E D9          0856   			EXX
04093F E5          0857   			PUSH    HL
040940 D9          0858   			EXX
040941             0859   ;
040941 FD E5       0860   			PUSH    IY              	; Stack the current execution address
040943 DD E5       0861   			PUSH    IX              	; Stack the loop variable
040945 CD E1 0F 04 0862   			CALL    CHECK
040949 CD FE 04 04 0863   			CALL    XEQ
04094D             0864   FORCHK:			EQU     $
04094D             0865   
04094D             0866   ; NEXT [var[,var...]]
04094D             0867   ; This pops the following data off the execution stack
04094D             0868   ; - 3 bytes: Marker (the address of FORCHK)
04094D             0869   ; - 3 bytes: The address of the loop variable
04094D             0870   ; - 3 bytes: The current execution address
04094D             0871   ; - 3 bytes: The step value
04094D             0872   ; - 3 bytes: The limit value
04094D             0873   ; It also ensures that the data is pushed back on for subsequent NEXT instructions
04094D             0874   ;
04094D C1          0875   NEXT:			POP     BC              	; Pop the marker off the execution stack
04094E 21 4D 09 04 0876   			LD      HL,FORCHK		; Compare with FORCHK
040952 B7          0877   			OR      A
040953 ED 42       0878   			SBC     HL,BC
040955 3E 20       0879   			LD      A,32
040957 C2 E3 09 04 0880   			JP      NZ,ERROR3      		; If this does not match, throw a "No FOR" error
04095B CD 0C 11 04 0881   			CALL    TERMQ			; Check for terminator (a NEXT without a variable)
04095F E1          0882   			POP     HL			; Pop the address of the loop variable off the execution stack
040960 E5          0883   			PUSH    HL			; Push it back onto the execution stack
040961 C5          0884   			PUSH    BC			; Push the marker back onto the execution stack
040962 E5          0885   			PUSH    HL			; HL: Address of the loop variable off the stack
040963 C4 E0 1C 04 0886   			CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
040967 D1          0887   			POP     DE			; DE: Address of the loop variable off the stack
040968 EB          0888   			EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
040969 B7          0889   			OR      A
04096A ED 52       0890   NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
04096C 20 61       0891   			JR      NZ,NEXT1		; They don't, so jump to NEXT1
04096E D5          0892   			PUSH    DE
04096F DD 21 0C 00 0893   			LD      IX,9+3			; IX: Address of the STEP value on the execution stack
       00          
040974 DD 39       0894   			ADD     IX,SP
040976 CD 8E 1B 04 0895   			CALL    DLOAD5_SPL      	; Load the STEP value
04097A DD 7E 10    0896   			LD      A,(IX+16)       	; Get the STEP type
04097D DD E1       0897   			POP     IX
04097F CD A5 1D 04 0898   			CALL    LOADN           	; Load the LOOP variable
040983 CB 7A       0899   			BIT     7,D             	; Check the sign
040985 F5          0900   			PUSH    AF
040986 3E 0B       0901   			LD      A,'+' & 0FH
040988 CD 8E 1C 04 0902   			CALL    FPP             	; Add the STEP
04098C 38 55       0903   			JR      C,ERROR3
04098E F1          0904   			POP     AF              	; Restore TYPE
04098F F5          0905   			PUSH    AF
040990 CD 68 0F 04 0906   			CALL    STORE           	; Update the variable
040994 DD 21 15 00 0907   			LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
       00          
040999 DD 39       0908   			ADD     IX,SP
04099B CD 8E 1B 04 0909   			CALL    DLOAD5_SPL      	; Load the LIMIT value
04099F F1          0910   			POP     AF
0409A0 CC 40 21 04 0911   			CALL    Z,SWAP			; Swap the arguments if the sign is ?
0409A4             0912   			; LD      A,0+('<'-4) & 0FH
0409A4 3E 08       0913   			LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
0409A6 CD 8E 1C 04 0914   			CALL    FPP             	; Test against the limit
0409AA 38 37       0915   			JR      C,ERROR3		; Throw an error if FPP returns bad
0409AC 24          0916   			INC     H
0409AD 20 14       0917   			JR      NZ,LOOP_        	; Keep looping
0409AF 21 1B 00 00 0918   			LD      HL,27			; Adjust the stack
0409B3 39          0919   			ADD     HL,SP
0409B4 F9          0920   			LD      SP,HL
0409B5 CD 2D 1E 04 0921   			CALL    NXT
0409B9 FE 2C       0922   			CP      ','			; Check for multiple variables
0409BB C2 FE 04 04 0923   			JP      NZ,XEQ			; No, so we are done at ths point
0409BF FD 23       0924   			INC     IY			; Increment to the next variable
0409C1 18 8A       0925   			JR      NEXT			; And continue
0409C3             0926   ;
0409C3 C1          0927   LOOP_:			POP     BC
0409C4 D1          0928   			POP     DE
0409C5 FD E1       0929   			POP     IY
0409C7 FD E5       0930   			PUSH    IY
0409C9 D5          0931   			PUSH    DE
0409CA C5          0932   			PUSH    BC
0409CB C3 FE 04 04 0933   			JP      XEQ
0409CF             0934   ;
0409CF 21 1B 00 00 0935   NEXT1:			LD      HL,27			; TODO: What does this do?
0409D3 39          0936   			ADD     HL,SP
0409D4 F9          0937   			LD      SP,HL			; Adjust the stack
0409D5 C1          0938   			POP     BC
0409D6 21 4D 09 04 0939   			LD      HL,FORCHK
0409DA ED 42       0940   			SBC     HL,BC
0409DC E1          0941   			POP     HL              	; Variable pointer
0409DD E5          0942   			PUSH    HL
0409DE C5          0943   			PUSH    BC
0409DF 28 89       0944   			JR      Z,NEXT0
0409E1             0945   ;
0409E1 3E 21       0946   			LD      A,33
0409E3 C3 E6 1B 04 0947   ERROR3:			JP      ERROR_           	; Throw the error "Can't match FOR"
0409E7             0948   
0409E7             0949   ; FNname
0409E7             0950   ; N.B. ENTERED WITH A <> TON
0409E7             0951   ;
0409E7 F5          0952   FN:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
0409E8 CD F1 09 04 0953   			CALL    PROC1
0409EC             0954   FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
0409EC             0955   
0409EC             0956   ; PROCname
0409EC             0957   ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
0409EC             0958   ; This pushes the following data onto the execution stack
0409EC             0959   ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
0409EC             0960   ; - 3 bytes: Marker (the address of PROCHK)
0409EC             0961   ;
0409EC F5          0962   PROC:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
0409ED CD F1 09 04 0963   			CALL    PROC1			; and is also space reserved on the stack for the return address
0409F1             0964   PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
0409F1             0965   ;
0409F1 CD E1 0F 04 0966   PROC1:			CALL    CHECK			; Check there is space for this
0409F5 FD 2B       0967   			DEC     IY			; Decrement IY to the PROC token
0409F7 FD E5       0968   			PUSH    IY			; Stack the pointer
0409F9 CD C3 1C 04 0969   			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0409FD C1          0970   			POP     BC			; BC = IY
0409FE 28 41       0971   			JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
040A00 3E 1E       0972   			LD      A,30
040A02 38 DF       0973   			JR      C,ERROR3        	; Throw error "Bad call" if invalid PROC/FN call
040A04             0974   ;
040A04             0975   ; At this point the PROC/FN has not yet been registered in the dynamic area
040A04             0976   ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
040A04             0977   ;
040A04 C5          0978   			PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
040A05 2A 14 03 04 0979   			LD      HL,(PAGE_)		; HL: Start of program memory
040A09             0980   ;
040A09 3E DD       0981   PROC2:			LD      A,DEF_			;  A: The token to search for
040A0B CD E0 11 04 0982   			CALL    SEARCH          	; Look for "DEF" as the first token in a program line
040A0F 38 26       0983   			JR      C,PROC3			; Not found, so jump to PROC3
040A11 E5          0984   			PUSH    HL			; HL: Points to the DEF token in the DEFPROC
040A12 FD E1       0985   			POP     IY			; IY = HL
040A14 FD 23       0986   			INC     IY              	; Skip the DEF token
040A16 CD 2D 1E 04 0987   			CALL    NXT			; And any whitespace
040A1A CD C3 1C 04 0988   			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
040A1E FD E5       0989   			PUSH    IY
040A20 D1          0990   			POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
040A21 38 09       0991   			JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
040A23 C4 FE 1A 04 0992   			CALL    NZ,CREATE		; Create an entity in the dynamic area
040A27 FD E5       0993   			PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
040A29 D1          0994   			POP     DE			; DE = IY
040A2A ED 1F       0995   			LD	(HL),DE			; Save address
040A2C             0996   ;
040A2C EB          0997   PROC6:			EX      DE,HL			; HL: Address of the procedure
040A2D 3E 0D       0998   			LD      A,CR			; The character to search for
040A2F 01 00 01 00 0999   			LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
040A33 ED B1       1000   			CPIR                    	; Skip to next line
040A35 18 D2       1001   			JR      PROC2			; Rinse, lather and repeat
040A37             1002   ;
040A37             1003   ; At this point a DEF has not been found for the PROC/FN
040A37             1004   ;
040A37 FD E1       1005   PROC3:			POP     IY              	; Restore the execution address
040A39 CD C3 1C 04 1006   			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
040A3D 3E 1D       1007   			LD      A,29
040A3F 20 A2       1008   			JR      NZ,ERROR3      		; Throw error "No such FN/PROC" if not found
040A41             1009   ;
040A41             1010   ; At this point we have a PROC/FN entry in the dynamic area
040A41             1011   ;
040A41 ED 17       1012   PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
040A43 21 03 00 00 1013   			LD	HL,3
040A47 39          1014   			ADD     HL,SP
040A48 CD 2D 1E 04 1015   			CALL    NXT             	; Allow space before "("
040A4C D5          1016   			PUSH    DE              	; Exchange DE and IY
040A4D FD E3       1017   			EX      (SP),IY
040A4F FE 28       1018   			CP      '('             	; Arguments?
040A51 D1          1019   			POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
040A52 20 20       1020   			JR      NZ,PROC5
040A54 CD 2D 1E 04 1021   			CALL    NXT             	; Allow space before "("
040A58 FE 28       1022   			CP      '('
040A5A C2 FF 05 04 1023   			JP      NZ,SYNTAX       	; Throw "Syntax error"
040A5E FD E5       1024   			PUSH    IY
040A60 C1          1025   			POP     BC              	; Save IY in BC
040A61 D9          1026   			EXX
040A62 CD 8C 10 04 1027   			CALL    SAVLOC          	; Save local parameters
040A66 CD 1E 1A 04 1028   			CALL    BRAKET          	; Closing bracket
040A6A D9          1029   			EXX
040A6B C5          1030   			PUSH    BC
040A6C FD E1       1031   			POP     IY              	; Restore IY
040A6E E5          1032   			PUSH    HL
040A6F CD 08 10 04 1033   			CALL    ARGUE           	; Transfer arguments
040A73 E1          1034   			POP     HL
040A74             1035   ;
040A74 23          1036   PROC5:			INC	HL			; Increment to the ON PROC flag address
040A75 7E          1037   			LD	A, (HL)			; And fetch the value
040A76 2B          1038   			DEC 	HL
040A77 ED 1F       1039   			LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
040A79 FE EE       1040   			CP	TON			; Was it "ON PROC"?
040A7B C2 FE 04 04 1041   			JP	NZ, XEQ			; No, so back to XEQ
040A7F D5          1042   			PUSH    DE			; Exchange DE and IY
040A80 FD E3       1043   			EX      (SP),IY
040A82 CD 19 11 04 1044   			CALL    SPAN            	; Skip rest of ON list
040A86 FD E3       1045   			EX      (SP),IY			; Exchange DE and IY
040A88 D1          1046   			POP     DE
040A89 ED 1F       1047   			LD	(HL), DE		; Save the return address
040A8B C3 FE 04 04 1048   			JP      XEQ
040A8F             1049   
040A8F             1050   ; LOCAL var[,var...]
040A8F             1051   ;
040A8F C1          1052   LOCAL_:			POP     BC			; BC: The current check marker (on the stack)
040A90 C5          1053   			PUSH    BC
040A91 21 EC 09 04 1054   			LD      HL,FNCHK		; Check if we are in a FN
040A95 B7          1055   			OR      A
040A96 ED 42       1056   			SBC     HL,BC
040A98 28 16       1057   			JR      Z,LOCAL1		; Yes, so all good, we can use local
040A9A 21 F1 09 04 1058   			LD      HL,PROCHK		; Now check if we are in a PROC
040A9E B7          1059   			OR      A
040A9F ED 42       1060   			SBC     HL,BC
040AA1 28 0D       1061   			JR      Z,LOCAL1		; Again, all good, we can use local
040AA3 21 EA 10 04 1062   			LD      HL,LOCCHK		; Finally check for the local parameters marker
040AA7 B7          1063   			OR      A
040AA8 ED 42       1064   			SBC     HL,BC			; If it is not present, then
040AAA 3E 0C       1065   			LD      A,12
040AAC C2 E6 1B 04 1066   			JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
040AB0             1067   ;
040AB0             1068   ; At this point we are adding a local variable into a PROC or FN
040AB0             1069   ;
040AB0 FD E5       1070   LOCAL1:			PUSH    IY			; IY: BASIC pointer
040AB2 C1          1071   			POP     BC			; BC: Copy of the BASIC pointer
040AB3 D9          1072   			EXX
040AB4 FD 2B       1073   			DEC     IY
040AB6 CD 8C 10 04 1074   			CALL    SAVLOC
040ABA D9          1075   			EXX
040ABB C5          1076   			PUSH    BC
040ABC FD E1       1077   			POP     IY
040ABE             1078   ;
040ABE CD E0 1C 04 1079   LOCAL2:			CALL    GETVAR			; Get the variable location
040AC2 C2 FF 05 04 1080   			JP      NZ,SYNTAX
040AC6 B7          1081   			OR      A               	; Check the variable type (80h = string)
040AC7 08          1082   			EX      AF,AF'
040AC8 CD E2 21 04 1083   			CALL    ZERO			; Zero the variable anyway
040ACC 08          1084   			EX      AF,AF'
040ACD F5          1085   			PUSH    AF
040ACE F4 68 0F 04 1086   			CALL    P,STORE         	; Call STORE if it is not a string
040AD2 F1          1087   			POP     AF
040AD3 59          1088   			LD      E,C
040AD4 FC 96 0F 04 1089   			CALL    M,STORES		; Call STORES if it is a string
040AD8 CD 2D 1E 04 1090   			CALL    NXT			; Skip to the next character in the expression
040ADC FE 2C       1091   			CP      ','			; Is it a comma?
040ADE C2 FE 04 04 1092   			JP      NZ,XEQ			; No, so we're done, carry on executing
040AE2 FD 23       1093   			INC     IY			; Yes, so skip the comma
040AE4 CD 2D 1E 04 1094   			CALL    NXT			; And any whitespace
040AE8 18 D4       1095   			JR      LOCAL2			; Then loop back and handle any further local variables
040AEA             1096   
040AEA             1097   ; ENDPROC
040AEA             1098   ;
040AEA C1          1099   ENDPRO:			POP     BC			; Pop the check value off the stack
040AEB 21 EA 10 04 1100   			LD      HL,LOCCHK		; Check if it is the LOCAL Marker
040AEF B7          1101   			OR      A
040AF0 ED 42       1102   			SBC     HL,BC
040AF2 28 13       1103   			JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
040AF4             1104   ;
040AF4 21 F1 09 04 1105   			LD      HL,PROCHK       	; Check if it is the PROC marker
040AF8 B7          1106   			OR      A
040AF9 ED 42       1107   			SBC     HL,BC
040AFB FD E1       1108   			POP     IY
040AFD CA FE 04 04 1109   			JP      Z,XEQ			; Yes, it is, so carry on, all is good
040B01 3E 0D       1110   			LD      A,13			; Otherwise throw the "No PROC" error
040B03 C3 E6 1B 04 1111   			JP      ERROR_
040B07             1112   ;
040B07 DD E1       1113   UNSTK:			POP     IX			; Unstack a single local variable
040B09 C1          1114   			POP     BC
040B0A 78          1115   			LD      A,B
040B0B B7          1116   			OR      A
040B0C FA 1A 0B 04 1117   			JP      M,UNSTK1        	; Jump here if it is a string? (80h)
040B10 E1          1118   			POP     HL			; Unstack a normal variable
040B11 D9          1119   			EXX
040B12 E1          1120   			POP     HL
040B13 D9          1121   			EXX
040B14 CD 68 0F 04 1122   			CALL    STORE			; TODO: Not sure why or where it is being stored at this point
040B18 18 D0       1123   			JR      ENDPRO			; And loop back to ENDPRO
040B1A             1124   ;
040B1A 21 00 00 00 1125   UNSTK1:			LD      HL,0			; Unstack a string
040B1E 39          1126   			ADD     HL,SP
040B1F 59          1127   			LD      E,C
040B20 CD 96 0F 04 1128   			CALL    STORES			; TODO: Not sure why or where it is being stored at this point
040B24 F9          1129   			LD      SP,HL
040B25 18 C3       1130   			JR      ENDPRO
040B27             1131   
040B27             1132   ; INPUT #channel,var,var...
040B27             1133   ;
040B27 CD 24 12 04 1134   INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
040B2B CD 2D 1E 04 1135   INPN1:			CALL    NXT
040B2F FE 2C       1136   			CP      ','
040B31 C2 FE 04 04 1137   			JP      NZ,XEQ
040B35 FD 23       1138   			INC     IY
040B37 CD 2D 1E 04 1139   			CALL    NXT
040B3B D5          1140   			PUSH    DE
040B3C CD F6 05 04 1141   			CALL    VAR_
040B40 D1          1142   			POP     DE
040B41 F5          1143   			PUSH    AF              ;SAVE TYPE
040B42 E5          1144   			PUSH    HL              ;VARPTR
040B43 B7          1145   			OR      A
040B44 FA 70 0B 04 1146   			JP      M,INPN2         ;STRING
040B48 CD 61 1E 04 1147   			CALL    OSBGET
040B4C D9          1148   			EXX
040B4D 6F          1149   			LD      L,A
040B4E D9          1150   			EXX
040B4F CD 61 1E 04 1151   			CALL    OSBGET
040B53 D9          1152   			EXX
040B54 67          1153   			LD      H,A
040B55 D9          1154   			EXX
040B56 CD 61 1E 04 1155   			CALL    OSBGET
040B5A 6F          1156   			LD      L,A
040B5B CD 61 1E 04 1157   			CALL    OSBGET
040B5F 67          1158   			LD      H,A
040B60 CD 61 1E 04 1159   			CALL    OSBGET
040B64 4F          1160   			LD      C,A
040B65 DD E1       1161   			POP     IX
040B67 F1          1162   			POP     AF              ;RESTORE TYPE
040B68 D5          1163   			PUSH    DE              ;SAVE CHANNEL
040B69 CD 68 0F 04 1164   			CALL    STORE
040B6D D1          1165   			POP     DE
040B6E 18 BB       1166   			JR      INPN1
040B70 21 00 00 04 1167   INPN2:			LD      HL,ACCS
040B74 CD 61 1E 04 1168   INPN3:			CALL    OSBGET
040B78 FE 0D       1169   			CP      CR
040B7A 28 04       1170   			JR      Z,INPN4
040B7C 77          1171   			LD      (HL),A
040B7D 2C          1172   			INC     L
040B7E 20 F4       1173   			JR      NZ,INPN3
040B80 DD E1       1174   INPN4:			POP     IX
040B82 F1          1175   			POP     AF
040B83 D5          1176   			PUSH    DE
040B84 EB          1177   			EX      DE,HL
040B85 CD 92 0F 04 1178   			CALL    STACCS
040B89 D1          1179   			POP     DE
040B8A 18 9F       1180   			JR      INPN1
040B8C             1181   
040B8C             1182   ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
040B8C             1183   ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
040B8C             1184   ;
040B8C FE 23       1185   INPUT:			CP      '#'
040B8E 28 97       1186   			JR      Z,INPUTN
040B90 0E 00       1187   			LD      C,0             ;FLAG PROMPT
040B92 FE 86       1188   			CP      LINE_
040B94 20 04       1189   			JR      NZ,INPUT0
040B96 FD 23       1190   			INC     IY              ;SKIP "LINE"
040B98 0E 80       1191   			LD      C,80H
040B9A 21 00 01 04 1192   INPUT0:			LD      HL,BUFFER
040B9E 36 0D       1193   			LD      (HL),CR         ;INITIALISE EMPTY
040BA0 CD 0C 11 04 1194   INPUT1:			CALL    TERMQ
040BA4 CA FE 04 04 1195   			JP      Z,XEQ           ;DONE
040BA8 FD 23       1196   			INC     IY
040BAA FE 2C       1197   			CP      ','
040BAC 28 5C       1198   			JR      Z,INPUT3        ;SKIP COMMA
040BAE FE 3B       1199   			CP      ';'
040BB0 28 58       1200   			JR      Z,INPUT3
040BB2 E5          1201   			PUSH    HL              ;SAVE BUFFER POINTER
040BB3 FE 22       1202   			CP      34		;ASCII ""
040BB5 20 0C       1203   			JR      NZ,INPUT6
040BB7 C5          1204   			PUSH    BC
040BB8 CD E3 1A 04 1205   			CALL    CONS
040BBC C1          1206   			POP     BC
040BBD CD 90 11 04 1207   			CALL    PTEXT           ;PRINT PROMPT
040BC1 18 06       1208   			JR      INPUT9
040BC3 CD 31 11 04 1209   INPUT6:			CALL    FORMAT          ;SPC, TAB, '
040BC7 20 05       1210   			JR      NZ,INPUT2
040BC9 E1          1211   INPUT9:			POP     HL
040BCA CB C1       1212   			SET     0,C             ;FLAG NO PROMPT
040BCC 18 CC       1213   			JR      INPUT0
040BCE FD 2B       1214   INPUT2:			DEC     IY
040BD0 C5          1215   			PUSH    BC
040BD1 CD F6 05 04 1216   			CALL    VAR_
040BD5 C1          1217   			POP     BC
040BD6 E1          1218   			POP     HL
040BD7 F5          1219   			PUSH    AF              ;SAVE TYPE
040BD8 7E          1220   			LD      A,(HL)
040BD9 23          1221   			INC     HL
040BDA FE 0D       1222   			CP      CR              ;BUFFER EMPTY?
040BDC CC 0E 0C 04 1223   			CALL    Z,REFILL
040BE0 CB 79       1224   			BIT     7,C
040BE2 F5          1225   			PUSH    AF
040BE3 C4 B2 11 04 1226   			CALL    NZ,LINES
040BE7 F1          1227   			POP     AF
040BE8 CC 9F 11 04 1228   			CALL    Z,FETCHS
040BEC F1          1229   			POP     AF              ;RESTORE TYPE
040BED C5          1230   			PUSH    BC
040BEE E5          1231   			PUSH    HL
040BEF B7          1232   			OR      A
040BF0 FA 04 0C 04 1233   			JP      M,INPUT4        ;STRING
040BF4 F5          1234   			PUSH    AF
040BF5 DD E5       1235   			PUSH    IX
040BF7 CD AC 21 04 1236   			CALL    VAL0
040BFB DD E1       1237   			POP     IX
040BFD F1          1238   			POP     AF
040BFE CD 68 0F 04 1239   			CALL    STORE
040C02 18 04       1240   			JR      INPUT5
040C04 CD 92 0F 04 1241   INPUT4:			CALL    STACCS
040C08 E1          1242   INPUT5:			POP     HL
040C09 C1          1243   			POP     BC
040C0A CB 81       1244   INPUT3:			RES     0,C
040C0C 18 92       1245   			JR      INPUT1
040C0E             1246   ;
040C0E CB 41       1247   REFILL:			BIT     0,C
040C10 20 0C       1248   			JR      NZ,REFIL0       ;NO PROMPT
040C12 3E 3F       1249   			LD      A,'?'
040C14 CD 2B 1F 04 1250   			CALL    OUTCHR          ;PROMPT
040C18 3E 20       1251   			LD      A,' '
040C1A CD 2B 1F 04 1252   			CALL    OUTCHR
040C1E 21 00 01 04 1253   REFIL0:			LD      HL,BUFFER
040C22 C5          1254   			PUSH    BC
040C23 E5          1255   			PUSH    HL
040C24 DD E5       1256   			PUSH    IX
040C26 CD D4 1E 04 1257   			CALL    OSLINE
040C2A DD E1       1258   			POP     IX
040C2C E1          1259   			POP     HL
040C2D C1          1260   			POP     BC
040C2E 47          1261   			LD      B,A             ;POS AT ENTRY
040C2F AF          1262   			XOR     A
040C30 32 3D 03 04 1263   			LD      (COUNT),A
040C34 B8          1264   			CP      B
040C35 C8          1265   			RET     Z
040C36 7E          1266   REFIL1:			LD      A,(HL)
040C37 FE 0D       1267   			CP      CR
040C39 C8          1268   			RET     Z
040C3A 23          1269   			INC     HL
040C3B 10 F9       1270   			DJNZ    REFIL1
040C3D C9          1271   			RET
040C3E             1272   
040C3E             1273   ; READ var[,var...]
040C3E             1274   ;
040C3E FE 23       1275   READ:			CP      '#'
040C40 CA 27 0B 04 1276   			JP      Z,INPUTN
040C44 2A 31 03 04 1277   			LD      HL,(DATPTR)
040C48 7E          1278   READ0:			LD      A,(HL)
040C49 23          1279   			INC     HL              ;SKIP COMMA OR "DATA"
040C4A FE 0D       1280   			CP      CR              ;END OF DATA STMT?
040C4C CC 90 0C 04 1281   			CALL    Z,GETDAT
040C50 E5          1282   			PUSH    HL
040C51 CD F6 05 04 1283   			CALL    VAR_
040C55 E1          1284   			POP     HL
040C56 B7          1285   			OR      A
040C57 FA 70 0C 04 1286   			JP      M,READ1         ;STRING
040C5B E5          1287   			PUSH    HL
040C5C FD E3       1288   			EX      (SP),IY
040C5E F5          1289   			PUSH    AF              ;SAVE TYPE
040C5F DD E5       1290   			PUSH    IX
040C61 CD 3A 1C 04 1291   			CALL    EXPRN
040C65 DD E1       1292   			POP     IX
040C67 F1          1293   			POP     AF
040C68 CD 68 0F 04 1294   			CALL    STORE
040C6C FD E3       1295   			EX      (SP),IY
040C6E 18 09       1296   			JR      READ2
040C70 CD 9F 11 04 1297   READ1:			CALL    FETCHS
040C74 E5          1298   			PUSH    HL
040C75 CD 92 0F 04 1299   			CALL    STACCS
040C79 E1          1300   READ2:			POP     HL
040C7A 22 31 03 04 1301   			LD      (DATPTR),HL
040C7E CD 2D 1E 04 1302   			CALL    NXT
040C82 FE 2C       1303   			CP      ','
040C84 C2 FE 04 04 1304   			JP      NZ,XEQ
040C88 FD 23       1305   			INC     IY
040C8A CD 2D 1E 04 1306   			CALL    NXT
040C8E 18 B8       1307   			JR      READ0
040C90             1308   ;
040C90 3E DC       1309   GETDAT:			LD      A,DATA_
040C92 CD E0 11 04 1310   			CALL    SEARCH
040C96 23          1311   			INC     HL
040C97 D0          1312   			RET     NC
040C98 3E 2A       1313   			LD      A,42
040C9A C3 E6 1B 04 1314   ERROR4:			JP      ERROR_           ;"Out of DATA"
040C9E             1315   
040C9E             1316   ; IF expr statement
040C9E             1317   ; IF expr THEN statement [ELSE statement]
040C9E             1318   ; IF expr THEN line [ELSE line]
040C9E             1319   ;
040C9E CD 1E 1C 04 1320   IF_:			CALL    EXPRI
040CA2 CD 76 21 04 1321   			CALL    TEST
040CA6 28 19       1322   			JR      Z,IFNOT         ;FALSE
040CA8 FD 7E 00    1323   			LD      A,(IY)
040CAB FE 8C       1324   			CP      THEN
040CAD C2 FE 04 04 1325   			JP      NZ,XEQ
040CB1 FD 23       1326   			INC     IY              ;SKIP "THEN"
040CB3 CD 2D 1E 04 1327   IF1:			CALL    NXT
040CB7 FE 8D       1328   			CP      LINO
040CB9 C2 FE 04 04 1329   			JP      NZ,XEQ          ;STATEMENT FOLLOWS
040CBD C3 93 08 04 1330   			JP      GOTO            ;LINE NO. FOLLOWS
040CC1 FD 7E 00    1331   IFNOT:			LD      A,(IY)
040CC4 FE 0D       1332   			CP      CR
040CC6 FD 23       1333   			INC     IY
040CC8 CA FA 04 04 1334   			JP      Z,XEQ0          ;END OF LINE
040CCC FE 8B       1335   			CP      ELSE_
040CCE 20 F1       1336   			JR      NZ,IFNOT
040CD0 18 E1       1337   			JR      IF1
040CD2             1338   
040CD2             1339   ; CLS
040CD2             1340   ;
040CD2 CD 8D 1A 04 1341   CLS:		CALL    CLRSCN
040CD6 AF          1342   			XOR     A
040CD7 32 3D 03 04 1343   			LD      (COUNT),A
040CDB C3 FE 04 04 1344   			JP      XEQ
040CDF             1345   
040CDF             1346   ; STOP
040CDF             1347   ;
040CDF CD 5B 21 04 1348   STOP:			CALL    TELL
040CE3 0D          1349   			DB	CR
040CE4 0A          1350   			DB	LF
040CE5 FA          1351   			DB	TSTOP
040CE6 00          1352   			DB	0
040CE7 CD D2 20 04 1353   			CALL    SETLIN          ;FIND CURRENT LINE
040CEB CD B6 20 04 1354   			CALL    SAYLN
040CEF CD 1B 1B 04 1355   			CALL    CRLF
040CF3 C3 71 1A 04 1356   			JP      CLOOP
040CF7             1357   
040CF7             1358   ; REPORT
040CF7             1359   ;
040CF7 CD 7E 20 04 1360   REPOR:			CALL    REPORT
040CFB C3 FE 04 04 1361   			JP      XEQ
040CFF             1362   
040CFF             1363   ; CLEAR
040CFF             1364   ;
040CFF CD 3B 1A 04 1365   CLR:			CALL    CLEAR
040D03 2A 14 03 04 1366   			LD      HL,(PAGE_)
040D07 18 19       1367   			JR      RESTR1
040D09             1368   
040D09             1369   ; RESTORE [line]
040D09             1370   ;
040D09 2A 14 03 04 1371   RESTOR:			LD      HL,(PAGE_)
040D0D CD 0C 11 04 1372   			CALL    TERMQ
040D11 28 0F       1373   			JR      Z,RESTR1
040D13 CD 1A 1D 04 1374   			CALL    ITEMI
040D17 D9          1375   			EXX
040D18 CD 72 1C 04 1376   			CALL    FINDL           ;SEARCH FOR LINE
040D1C 3E 29       1377   			LD      A,41
040D1E C2 9A 0C 04 1378   			JP      NZ,ERROR4       ;"No such line"
040D22 3E DC       1379   RESTR1:			LD      A,DATA_
040D24 CD E0 11 04 1380   			CALL    SEARCH
040D28 22 31 03 04 1381   			LD      (DATPTR),HL
040D2C C3 FE 04 04 1382   			JP      XEQ
040D30             1383   
040D30             1384   ; PTR#channel=expr
040D30             1385   ; PAGE=expr
040D30             1386   ; TIME=expr
040D30             1387   ; LOMEM=expr
040D30             1388   ; HIMEM=expr
040D30             1389   ;
040D30 CD 18 12 04 1390   PTR:			CALL    CHANEL
040D34 CD 22 11 04 1391   			CALL    EQUALS
040D38 7B          1392   			LD      A,E
040D39 F5          1393   			PUSH    AF
040D3A CD 1E 1C 04 1394   			CALL    EXPRI
040D3E E5          1395   			PUSH    HL
040D3F D9          1396   			EXX
040D40 D1          1397   			POP     DE
040D41 F1          1398   			POP     AF
040D42 CD 28 20 04 1399   			CALL    PUTPTR
040D46 C3 FE 04 04 1400   			JP      XEQ
040D4A             1401   ;
040D4A CD 22 11 04 1402   PAGEV:			CALL    EQUALS
040D4E CD 1E 1C 04 1403   			CALL    EXPRI
040D52 D9          1404   			EXX
040D53 2E 00       1405   			LD      L,0
040D55 22 14 03 04 1406   			LD      (PAGE_),HL
040D59 C3 FE 04 04 1407   			JP      XEQ
040D5D             1408   ;
040D5D FE 24       1409   TIMEV:			CP      '$'
040D5F 28 13       1410   			JR      Z,TIMEVS
040D61 CD 22 11 04 1411   			CALL    EQUALS
040D65 CD 1E 1C 04 1412   			CALL    EXPRI
040D69 E5          1413   			PUSH    HL
040D6A D9          1414   			EXX
040D6B D1          1415   			POP     DE
040D6C CD EE 1F 04 1416   			CALL    PUTIME
040D70 C3 FE 04 04 1417   			JP      XEQ
040D74             1418   ;
040D74 FD 23       1419   TIMEVS:			INC     IY              ;SKIP '$'
040D76 CD 22 11 04 1420   			CALL    EQUALS
040D7A CD 56 1C 04 1421   			CALL    EXPRS
040D7E CD 0B 20 04 1422   			CALL    PUTIMS
040D82 C3 FE 04 04 1423   			JP      XEQ
040D86             1424   ;
040D86 CD 22 11 04 1425   LOMEMV:			CALL    EQUALS
040D8A CD 1E 1C 04 1426   			CALL    EXPRI
040D8E CD 3B 1A 04 1427   			CALL    CLEAR
040D92 D9          1428   			EXX
040D93 22 1A 03 04 1429   			LD      (LOMEM),HL
040D97 22 1D 03 04 1430   			LD      (FREE),HL
040D9B C3 FE 04 04 1431   			JP      XEQ
040D9F             1432   ;
040D9F CD 22 11 04 1433   HIMEMV:			CALL    EQUALS			; Check for '=' and throw an error if not found
040DA3 CD 1E 1C 04 1434   			CALL    EXPRI			; Load the expression into registers
040DA7 7D          1435   			LD	A,L			;  A: The MSB of the 24-bit value
040DA8 D9          1436   			EXX				; HL: The LSW of the 24-bit value
040DA9 22 4A 03 04 1437   			LD	(R0),HL
040DAD 32 4C 03 04 1438   			LD	(R0+2),A
040DB1 2A 1D 03 04 1439   			LD	HL,(FREE)
040DB5 11 00 01 00 1440   			LD      DE,256
040DB9 19          1441   			ADD	HL,DE
040DBA EB          1442   			EX	DE,HL			; DE: FREE + 256
040DBB 2A 4A 03 04 1443   			LD	HL,(R0)			; HL: The passed expression
040DBF AF          1444   			XOR     A
040DC0 ED 52       1445   			SBC     HL,DE
040DC2 19          1446   			ADD     HL,DE			; Do a bounds check
040DC3 DA E6 1B 04 1447   			JP      C,ERROR_         	; Throw the error: "No room"
040DC7 ED 5B 20 03 1448   			LD      DE,(HIMEM)
       04          
040DCC 22 20 03 04 1449   			LD      (HIMEM),HL
040DD0 EB          1450   			EX      DE,HL
040DD1 ED 72       1451   			SBC     HL,SP			; Adjust the stack
040DD3 C2 FE 04 04 1452   			JP      NZ,XEQ
040DD7 EB          1453   			EX      DE,HL
040DD8 F9          1454   			LD      SP,HL           	; Load the SP
040DD9 C3 FE 04 04 1455   			JP      XEQ
040DDD             1456   
040DDD             1457   ; WIDTH expr
040DDD             1458   ;
040DDD CD 1E 1C 04 1459   WIDTHV:			CALL    EXPRI
040DE1 D9          1460   			EXX
040DE2 7D          1461   			LD      A,L
040DE3 32 3E 03 04 1462   			LD      (WIDTH),A
040DE7 C3 FE 04 04 1463   			JP      XEQ
040DEB             1464   
040DEB             1465   ; TRACE ON
040DEB             1466   ; TRACE OFF
040DEB             1467   ; TRACE line
040DEB             1468   ;
040DEB FD 23       1469   TRACE:			INC     IY
040DED 21 00 00 00 1470   			LD      HL,0
040DF1 FE EE       1471   			CP      TON
040DF3 28 0B       1472   			JR      Z,TRACE0
040DF5 FE 87       1473   			CP      OFF_
040DF7 28 08       1474   			JR      Z,TRACE1
040DF9 FD 2B       1475   			DEC     IY
040DFB CD 1E 1C 04 1476   			CALL    EXPRI
040DFF D9          1477   			EXX
040E00 2B          1478   TRACE0:			DEC     HL
040E01 22 26 03 04 1479   TRACE1:			LD      (TRACEN),HL
040E05 C3 FE 04 04 1480   			JP      XEQ
040E09             1481   
040E09             1482   ; VDU expr,expr;....
040E09             1483   ;
040E09 DD 21 00 01 1484   VDU:			LD	IX,BUFFER		; Storage for the VDU stream
       04          
040E0E DD E5       1485   VDU1:			PUSH	IX
040E10 CD 1E 1C 04 1486   			CALL    EXPRI			; Fetch the VDU character
040E14 DD E1       1487   			POP	IX
040E16 D9          1488   			EXX
040E17 DD 75 00    1489   			LD	(IX+0),L		; Write out the character to the buffer
040E1A DD 23       1490   			INC	IX
040E1C FD 7E 00    1491   			LD      A,(IY)			;  A: The separator character
040E1F FE 2C       1492   			CP      ','			; Is it a comma?
040E21 28 09       1493   			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
040E23 FE 3B       1494   			CP      ';'			; Is it a semicolon?
040E25 20 07       1495   			JR      NZ,VDU3			; No, so skip to the next expression
040E27 DD 74 00    1496   			LD	(IX+0),H		; Write out the high byte to the buffer
040E2A DD 23       1497   			INC	IX
040E2C FD 23       1498   VDU2:			INC     IY			; Skip to the next character
040E2E CD 0C 11 04 1499   VDU3:			CALL    TERMQ			; Skip past white space
040E32 20 DA       1500   			JR      NZ,VDU1			; Loop unti reached end of the VDU command
040E34 DD 7D       1501   			LD	A,IXL			;  A: Number of bytes to write out
040E36 B7          1502   			OR	A
040E37 28 0B       1503   			JR 	Z,VDU4			; No bytes to write, so skip the next bit
040E39 21 00 01 04 1504   			LD	HL,BUFFER		; HL: Start of stream
040E3D 01 00 00 00 1505   			LD	BC,0
040E41 4F          1506   			LD	C,A			; BC: Number of bytes to write out
040E42 5B DF       1507   			RST.LIL	18h			; Output the buffer to MOS
040E44 C3 FE 04 04 1508   VDU4:			JP      XEQ
040E48             1509   
040E48             1510   ; CLOSE channel number
040E48             1511   ;
040E48 CD 18 12 04 1512   CLOSE:			CALL    CHANEL			; Fetch the channel number
040E4C CD F1 1E 04 1513   			CALL    OSSHUT			; Close the channel
040E50 C3 FE 04 04 1514   			JP      XEQ
040E54             1515   
040E54             1516   ; BPUT channel,byte
040E54             1517   ;
040E54 CD 18 12 04 1518   BPUT:			CALL    CHANEL          	; Fetch the channel number
040E58 D5          1519   			PUSH    DE			; DE: Channel number
040E59 CD C7 1A 04 1520   			CALL    COMMA			; Skip to the next expression
040E5D CD 1E 1C 04 1521   			CALL    EXPRI           	; Feth the data
040E61 D9          1522   			EXX
040E62 7D          1523   			LD      A,L			; A: The byte to write
040E63 D1          1524   			POP     DE
040E64 CD 7E 1E 04 1525   			CALL    OSBPUT			; Write the byte out
040E68 C3 FE 04 04 1526   			JP      XEQ
040E6C             1527   
040E6C             1528   ; CALL address[,var[,var...]]
040E6C             1529   ;
040E6C             1530   ; Note that the parameter table differs from the Z80 version
040E6C             1531   ; Each entry now takes up 4 bytes, not 3, so the table is now:
040E6C             1532   ;  -1 byte:  Number of parameters
040E6C             1533   ; Then, for each parameter:
040E6C             1534   ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
040E6C             1535   ;  -3 bytes: Parameter address
040E6C             1536   ;
040E6C             1537   ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
040E6C             1538   ;
040E6C CD 1E 1C 04 1539   CALL_:			CALL    EXPRI           	; Fetch the address
040E70 7D          1540   			LD	A,L			;  A: MSB of address
040E71 D9          1541   			EXX
040E72 22 4A 03 04 1542   			LD	(R0+0),HL		; HL: LSW of address
040E76 32 4C 03 04 1543   			LD	(R0+2),A
040E7A 06 00       1544   			LD      B,0             	;  B: The parameter counter
040E7C 11 00 01 04 1545   			LD      DE,BUFFER       	; DE: Vector
040E80             1546   ;
040E80 CD 2D 1E 04 1547   CALL1:			CALL    NXT			; Skip whitespace
040E84 FE 2C       1548   			CP      ','			; Check for comma
040E86 20 1B       1549   			JR      NZ,CALL2		; If no more parameters, then jump here
040E88 FD 23       1550   			INC     IY			; Skip to the next character
040E8A 04          1551   			INC     B			; Increment the parameter count
040E8B CD 2D 1E 04 1552   			CALL    NXT			; Skip whitespace
040E8F C5          1553   			PUSH    BC
040E90 D5          1554   			PUSH    DE
040E91 CD F6 05 04 1555   			CALL    VAR_
040E95 D1          1556   			POP     DE
040E96 C1          1557   			POP     BC
040E97 13          1558   			INC     DE
040E98 12          1559   			LD      (DE),A			; Save the parameter type
040E99 13          1560   			INC     DE
040E9A EB          1561   			EX      DE,HL
040E9B ED 1F       1562   			LD	(HL),DE			; Save the parameter address (3 bytes)
040E9D 23          1563   			INC	HL
040E9E 23          1564   			INC	HL
040E9F 23          1565   			INC	HL
040EA0 EB          1566   			EX      DE,HL
040EA1 18 DD       1567   			JR      CALL1
040EA3             1568   ;
040EA3 78          1569   CALL2:			LD      A,B
040EA4 32 00 01 04 1570   			LD      (BUFFER),A      	; Save the parameter count
040EA8 2A 4A 03 04 1571   			LD	HL,(R0)			; HL: Address of the code
040EAC CD C6 0E 04 1572   			CALL    USR1			; And call it
040EB0 C3 FE 04 04 1573   			JP      XEQ
040EB4             1574   
040EB4             1575   ; USR(address)
040EB4             1576   ;
040EB4 CD 1A 1D 04 1577   USR:			CALL    ITEMI			; Evaluate the expression
040EB8 7D          1578   			LD	A,L			;  A: MSB of address
040EB9 D9          1579   			EXX
040EBA 22 4A 03 04 1580   			LD	(R0+0),HL		; HL: LSW of address
040EBE 32 4C 03 04 1581   			LD	(R0+2),A
040EC2 2A 4A 03 04 1582   			LD	HL,(R0)			; Get the 24-bit address in HL
040EC6             1583   ;
040EC6 E5          1584   USR1:			PUSH    HL              	; Address on stack
040EC7 FD E3       1585   			EX      (SP),IY
040EC9 24          1586   			INC     H               	; Check for PAGE &00FFxx
040ECA B4          1587   			OR	H
040ECB 21 35 0F 04 1588   			LD      HL,USR2         	; Return address
040ECF E5          1589   			PUSH    HL
040ED0 DD 21 00 02 1590   			LD      IX,STAVAR
       04          
040ED5 CC 9B 1E 04 1591   			CALL    Z,OSCALL        	; Intercept &00FFxx
040ED9             1592   ;
040ED9 DD 4E 18    1593   			LD      C, (IX+24)		; F%
040EDC C5          1594   			PUSH    BC
040EDD             1595   ;
040EDD DD 7E 08    1596   			LD	A, (IX+8)		; B% -> MSW
040EE0 32 4B 03 04 1597   			LD	(R0+1), A
040EE4 DD 7E 09    1598   			LD	A, (IX+9)
040EE7 32 4C 03 04 1599   			LD	(R0+2), A
040EEB DD 7E 0C    1600   			LD	A, (IX+12)		; C% -> LSB
040EEE 32 4A 03 04 1601   			LD	(R0+0), A
040EF2 ED 4B 4A 03 1602   			LD	BC, (R0)
       04          
040EF7             1603   ;
040EF7 DD 7E 10    1604   			LD	A, (IX+16)		; D% -> MSW
040EFA 32 4B 03 04 1605   			LD	(R0+1), A
040EFE DD 7E 11    1606   			LD	A, (IX+17)
040F01 32 4C 03 04 1607   			LD	(R0+2), A
040F05 DD 7E 14    1608   			LD	A, (IX+20)		; E% -> LSB
040F08 32 4A 03 04 1609   			LD	(R0+0), A
040F0C ED 5B 4A 03 1610   			LD	DE, (R0)
       04          
040F11             1611   ;
040F11 DD 7E 20    1612   			LD	A, (IX+32)		; H% -> MSW
040F14 32 4B 03 04 1613   			LD	(R0+1), A
040F18 DD 7E 21    1614   			LD	A, (IX+33)
040F1B 32 4C 03 04 1615   			LD	(R0+2), A
040F1F DD 7E 30    1616   			LD	A, (IX+48)		; L% -> LSB
040F22 32 4A 03 04 1617   			LD	(R0+0), A
040F26 2A 4A 03 04 1618   			LD	HL, (R0)
040F2A             1619   ;
040F2A F1          1620   			POP     AF			; F%
040F2B DD 7E 04    1621   			LD      A, (IX+4)        	; A%
040F2E             1622   
040F2E DD 21 00 01 1623   			LD      IX,BUFFER
       04          
040F33 FD E9       1624   			JP      (IY)            	; Off to user routine
040F35             1625   ;
040F35 FD E1       1626   USR2:			POP     IY
040F37 AF          1627   			XOR     A
040F38 4F          1628   			LD      C,A
040F39 C9          1629   			RET
040F3A             1630   
040F3A             1631   ; PUT port,data
040F3A             1632   ;
040F3A CD 1E 1C 04 1633   PUT:			CALL    EXPRI           ;PORT ADDRESS
040F3E D9          1634   			EXX
040F3F E5          1635   			PUSH    HL
040F40 CD C7 1A 04 1636   			CALL    COMMA
040F44 CD 1E 1C 04 1637   			CALL    EXPRI           ;DATA
040F48 D9          1638   			EXX
040F49 C1          1639   			POP     BC
040F4A ED 69       1640   			OUT     (C),L           ;OUTPUT TO PORT BC
040F4C C3 FE 04 04 1641   			JP      XEQ
040F50             1642   
040F50             1643   ; SUBROUTINES -----------------------------------------------------------------
040F50             1644   
040F50             1645   ; ASSIGN - Assign a numeric value to a variable.
040F50             1646   ; Outputs: NC,  Z - OK, numeric.
040F50             1647   ;          NC, NZ - OK, string.
040F50             1648   ;           C, NZ - illegal
040F50             1649   ;
040F50 CD E0 1C 04 1650   ASSIGN:			CALL    GETVAR          	; Try to get the variable
040F54 D8          1651   			RET     C               	; Return with C if it is an illegal variable
040F55 C4 45 20 04 1652   			CALL    NZ,PUTVAR		; If it does not exist, then create the variable
040F59 B7          1653   			OR      A
040F5A F8          1654   			RET     M               	; Return if type is string (81h)
040F5B F5          1655   			PUSH    AF              	; It's a numeric type from this point on
040F5C CD 22 11 04 1656   			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
040F60 E5          1657   			PUSH    HL
040F61 CD 3A 1C 04 1658   			CALL    EXPRN
040F65 DD E1       1659   			POP     IX
040F67 F1          1660   			POP     AF
040F68 CB 47       1661   STORE:			BIT     0,A
040F6A 28 13       1662   			JR      Z,STOREI
040F6C BF          1663   			CP      A               	; Set the variable to 0
040F6D DD 71 04    1664   STORE5:			LD      (IX+4),C
040F70 D9          1665   STORE4:			EXX
040F71 DD 75 00    1666   			LD      (IX+0),L
040F74 DD 74 01    1667   			LD      (IX+1),H
040F77 D9          1668   			EXX
040F78 DD 75 02    1669   			LD      (IX+2),L
040F7B DD 74 03    1670   			LD      (IX+3),H
040F7E C9          1671   			RET
040F7F F5          1672   STOREI:			PUSH    AF
040F80 0C          1673   			INC     C               ;SPEED - & PRESERVE F'
040F81 0D          1674   			DEC     C               ; WHEN CALLED BY FNEND0
040F82 C4 EF 20 04 1675   			CALL    NZ,SFIX         ;CONVERT TO INTEGER
040F86 F1          1676   			POP     AF
040F87 FE 04       1677   			CP      4
040F89 28 E5       1678   			JR      Z,STORE4
040F8B BF          1679   			CP      A               ;SET ZERO
040F8C D9          1680   STORE1:			EXX
040F8D DD 75 00    1681   			LD      (IX+0),L
040F90 D9          1682   			EXX
040F91 C9          1683   			RET
040F92             1684   ;
040F92             1685   ; Copy a string from the string accumulator to variable storage on the stack
040F92             1686   ; Parameters:
040F92             1687   ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
040F92             1688   ; - IX: Address of the variable storage on the stack
040F92             1689   ;
040F92 21 00 00 04 1690   STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
040F96             1691   ;
040F96             1692   ; Parameters:
040F96             1693   ; As above, but:
040F96             1694   ; - HL: Address of the string to be stored
040F96             1695   ; -  E: The string length
040F96             1696   ; NB:
040F96             1697   ; Strings are mutable
040F96             1698   ; Strings are stored in the following format in the variable:
040F96             1699   ; - Address of the next variable (3 bytes)
040F96             1700   ; - The rest of the variable name - this is zero terminated
040F96             1701   ; - Current string length (byte)
040F96             1702   ; - Maximum (original) string length (byte)
040F96             1703   ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
040F96             1704   ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
040F96             1705   ;
040F96 1F          1706   STORES:			RRA				; Rotate right to shift bit 0 into carry
040F97 30 5D       1707   			JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
040F99 E5          1708   			PUSH    HL			; Stack ACCS
040F9A             1709   ;
040F9A             1710   ; Load the string pointer and lengths into registers - these are all zeroed for new strings
040F9A             1711   ;
040F9A D9          1712   			EXX				; This block was a call to LOAD4
040F9B DD 6E 00    1713   			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
040F9E DD 66 01    1714   			LD      H,(IX+1)		; The maximum original string length
040FA1 D9          1715   			EXX
040FA2 DD 27 02    1716   			LD	HL,(IX+2)		; Address of the string (24-bit)
040FA5             1717   ;
040FA5 7B          1718   			LD      A,E             	; E : Length of string in ACCS (as passed to the function)
040FA6 D9          1719   			EXX
040FA7 6F          1720   			LD      L,A			; L': Length of string currently stored on the stack
040FA8 7C          1721   			LD      A,H             	; H': The maximum (original) string length
040FA9 D9          1722   			EXX
040FAA BB          1723   			CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
040FAB 30 17       1724   			JR      NC,STORS1       	; Yes there is, so skip the next bit
040FAD             1725   ;
040FAD             1726   ; At this point we're either initialising a new string or assigning more memory to an existing string
040FAD             1727   ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
040FAD             1728   ; then the existing and new strings may both exist in memory.
040FAD             1729   ;
040FAD D9          1730   			EXX
040FAE 65          1731   			LD      H,L			; H: Set the maximum string length to the string length
040FAF D9          1732   			EXX
040FB0 E5          1733   			PUSH    HL
040FB1 01 00 00 00 1734   			LD	BC, 0
040FB5 4F          1735   			LD      C,A			; BC: The maximum (original) string length
040FB6 09          1736   			ADD     HL,BC			; Work out whether this is the last string in memory
040FB7 ED 4B 1D 03 1737   			LD      BC,(FREE)
       04          
040FBC ED 42       1738   			SBC     HL,BC			; Is string last?
040FBE E1          1739   			POP     HL
040FBF 37          1740   			SCF
040FC0 28 02       1741   			JR      Z,STORS1
040FC2             1742   			; LD	HL, BC			; HL=BC
040FC2 C5          1743   			push bc
040FC3 E1          1744   			pop hl
040FC4             1745   ;
040FC4             1746   ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
040FC4             1747   ; - H': The maximum (original) string length
040FC4             1748   ; - L': The actual string length (must be less than H')
040FC4             1749   ; - HL: Address of the string in memory
040FC4             1750   ;
040FC4 D9          1751   STORS1:			EXX				; This block was a call to STORE4
040FC5 DD 75 00    1752   			LD      (IX+0),L		; The actual string length (must be less then H')
040FC8 DD 74 01    1753   			LD      (IX+1),H		; The maximum (original) string length
040FCB D9          1754   			EXX
040FCC DD 2F 02    1755   			LD	(IX+2),HL		; The pointer to the original string
040FCF             1756   ;
040FCF 01 00 00 00 1757   			LD	BC, 0
040FD3 4B          1758   			LD      C,E			; BC: The new string length
040FD4 EB          1759   			EX      DE,HL
040FD5 E1          1760   			POP     HL
040FD6 0D          1761   			DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
040FD7 0C          1762   			INC     C			; check whether BC is 0 without affecting the carry flag
040FD8 C8          1763   			RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
040FD9 ED B0       1764   			LDIR				; Replace the string in memory
040FDB D0          1765   			RET     NC
040FDC ED 53 1D 03 1766   			LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
       04          
040FE1             1767   ;
040FE1             1768   ; Check whether the stack is full
040FE1             1769   ;
040FE1 E5          1770   CHECK:			PUSH    HL
040FE2 C5          1771   			PUSH	BC
040FE3 2A 1D 03 04 1772   			LD      HL,(FREE)		; HL: Address of first free space byte
040FE7 01 00 01 00 1773   			LD	BC,100h			; BC: One page of memory
040FEB 09          1774   			ADD	HL,BC			; Add a page to FREE
040FEC ED 72       1775   			SBC     HL,SP			; And subtract the current SP
040FEE C1          1776   			POP	BC
040FEF E1          1777   			POP     HL
040FF0 D8          1778   			RET     C			; The SP is not in the same page, so just return
040FF1 AF          1779   			XOR     A			; Otherwise
040FF2 C3 E6 1B 04 1780   			JP      ERROR_			; Throw error "No room"
040FF6             1781   ;
040FF6 01 00 00 00 1782   STORS3:			LD	BC,0
040FFA 4B          1783   			LD      C,E			; BC: String length
040FFB DD E5       1784   			PUSH    IX
040FFD D1          1785   			POP     DE			; DE: Destination
040FFE AF          1786   			XOR     A			; Check if string length is 0
040FFF B9          1787   			CP      C
041000 28 02       1788   			JR      Z,STORS5		; Yes, so don't copy
041002 ED B0       1789   			LDIR
041004 3E 0D       1790   STORS5:			LD      A,CR			; Finally add the terminator
041006 12          1791   			LD      (DE),A
041007 C9          1792   			RET
041008             1793   
041008             1794   ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
041008             1795   ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
041008             1796   ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
041008             1797   ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
041008             1798   ;    Inputs: DE addresses parameter list
041008             1799   ;            IY addresses dummy variable list
041008             1800   ;   Outputs: DE,IY updated
041008             1801   ;  Destroys: Everything
041008             1802   ;
041008 3E FF       1803   ARGUE:			LD      A,-1
04100A F5          1804   			PUSH    AF              	; Put marker on the stack
04100B FD 23       1805   ARGUE1:			INC     IY              	; Bump past '(' or ',''
04100D 13          1806   			INC     DE
04100E D5          1807   			PUSH    DE
04100F CD 2D 1E 04 1808   			CALL    NXT			; Skip any whitespace
041013 CD E0 1C 04 1809   			CALL    GETVAR			; Get the location of the variable in HL/IX
041017 38 3F       1810   			JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
041019 C4 45 20 04 1811   			CALL    NZ,PUTVAR
04101D D1          1812   			POP     DE
04101E E5          1813   			PUSH    HL              	; VARPTR
04101F B7          1814   			OR      A               	; Check the variable type
041020 F5          1815   			PUSH    AF
041021 D5          1816   			PUSH    DE
041022 FD E3       1817   			EX      (SP),IY
041024 FA 3C 10 04 1818   			JP      M,ARGUE2        	; Jump here if it is a string
041028             1819   ;
041028 CD 3A 1C 04 1820   			CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
04102C FD E3       1821   			EX      (SP),IY
04102E D1          1822   			POP     DE
04102F F1          1823   			POP     AF
041030 D9          1824   			EXX
041031 E5          1825   			PUSH    HL
041032 D9          1826   			EXX
041033 E5          1827   			PUSH    HL
041034 47          1828   			LD      B,A
041035 C5          1829   			PUSH    BC
041036 CD E1 0F 04 1830   			CALL    CHECK           	; Check room
04103A 18 0F       1831   			JR      ARGUE4
04103C             1832   ;
04103C CD 56 1C 04 1833   ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
041040 FD E3       1834   			EX      (SP),IY
041042 D9          1835   			EXX
041043 D1          1836   			POP     DE
041044 D9          1837   			EXX
041045 F1          1838   			POP     AF
041046 CD B5 1F 04 1839   			CALL    PUSHS
04104A D9          1840   			EXX
04104B             1841   ;
04104B CD 2D 1E 04 1842   ARGUE4:			CALL    NXT			; Skip whitespace
04104F FE 2C       1843   			CP      ','			; Check to see if the next value is a comma
041051 20 0B       1844   			JR      NZ,ARGUE5		; No, so jump here
041053 1A          1845   			LD      A,(DE)
041054 FE 2C       1846   			CP      ','			; Are there any more arguments?
041056 28 B3       1847   			JR      Z,ARGUE1        	; Yes, so loop
041058             1848   ;
041058 3E 1F       1849   ARGERR:			LD      A,31
04105A C3 E6 1B 04 1850   			JP      ERROR_           	; Throw error "Arguments"
04105E             1851   ;
04105E CD 1E 1A 04 1852   ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
041062 1A          1853   			LD      A,(DE)
041063 FE 29       1854   			CP      ')'
041065 20 F1       1855   			JR      NZ,ARGERR
041067 13          1856   			INC     DE
041068 D9          1857   			EXX
041069 C1          1858   ARGUE6:			POP     BC
04106A 78          1859   			LD      A,B
04106B 3C          1860   			INC     A
04106C D9          1861   			EXX
04106D C8          1862   			RET     Z               	; Marker popped
04106E D9          1863   			EXX
04106F 3D          1864   			DEC     A
041070 FA 80 10 04 1865   			JP      M,ARGUE7        	; If it is a string, then jump here
041074 E1          1866   			POP     HL
041075 D9          1867   			EXX
041076 E1          1868   			POP     HL
041077 D9          1869   			EXX
041078 DD E1       1870   			POP     IX
04107A CD 68 0F 04 1871   			CALL    STORE	           	; Write to dummy variable
04107E 18 E9       1872   			JR      ARGUE6
041080             1873   ;
041080 CD 9A 1F 04 1874   ARGUE7:			CALL    POPS
041084 DD E1       1875   			POP     IX
041086 CD 92 0F 04 1876   			CALL    STACCS
04108A 18 DD       1877   			JR      ARGUE6
04108C             1878   
04108C             1879   ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
04108C             1880   ;   OF A FUNCTION OR PROCEDURE.
04108C             1881   ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
04108C             1882   ;    Inputs: IY is parameters pointer
04108C             1883   ;   Outputs: IY updated
04108C             1884   ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
04108C             1885   ;
04108C D1          1886   SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
04108D             1887   ;
04108D FD 23       1888   SAVLO1:			INC     IY              	; Bump past '(' or ','
04108F CD 2D 1E 04 1889   			CALL    NXT			; And also any whitespace
041093 D5          1890   			PUSH    DE			; Push the return address back onto the stack
041094 D9          1891   			EXX
041095 C5          1892   			PUSH    BC
041096 D5          1893   			PUSH    DE
041097 E5          1894   			PUSH    HL
041098 D9          1895   			EXX
041099 CD F6 05 04 1896   			CALL    VAR_             	; Dummy variable
04109D D9          1897   			EXX
04109E E1          1898   			POP     HL
04109F D1          1899   			POP     DE
0410A0 C1          1900   			POP     BC
0410A1 D9          1901   			EXX
0410A2 D1          1902   			POP     DE
0410A3 B7          1903   			OR      A               	; Check the variable type
0410A4 FA B7 10 04 1904   			JP      M,SAVLO2        	; 80h = string, so jump to save a local string
0410A8 D9          1905   			EXX
0410A9 E5          1906   			PUSH    HL              	; Save H'L'
0410AA D9          1907   			EXX
0410AB 47          1908   			LD      B,A             	;  B: Variable type
0410AC CD A5 1D 04 1909   			CALL    LOADN
0410B0 D9          1910   			EXX
0410B1 E3          1911   			EX      (SP),HL
0410B2 D9          1912   			EXX
0410B3 E5          1913   			PUSH    HL
0410B4 C5          1914   			PUSH    BC
0410B5 18 2D       1915   			JR      SAVLO4
0410B7             1916   ;
0410B7 F5          1917   SAVLO2:			PUSH    AF              	; Save the type (string)
0410B8 D5          1918   			PUSH    DE
0410B9 D9          1919   			EXX
0410BA E5          1920   			PUSH    HL
0410BB D9          1921   			EXX
0410BC CD C1 1D 04 1922   			CALL    LOADS
0410C0 D9          1923   			EXX
0410C1 E1          1924   			POP     HL
0410C2 D9          1925   			EXX
0410C3 01 00 00 00 1926   			LD	BC,0
0410C7 4B          1927   			LD      C,E			; BC: String length
0410C8 D1          1928   			POP     DE
0410C9 CD E1 0F 04 1929   			CALL    CHECK			; Check if there is space on the stack
0410CD F1          1930   			POP     AF              	; Level stack
0410CE 21 00 00 00 1931   			LD      HL,0
0410D2 ED 42       1932   			SBC     HL,BC			; HL: Number of bytes required on the stack for the string
0410D4 39          1933   			ADD     HL,SP			; Make space for the string on the stack
0410D5 F9          1934   			LD      SP,HL
0410D6 47          1935   			LD      B,A             	;  B: Variable type
0410D7 C5          1936   			PUSH    BC
0410D8 28 0A       1937   			JR      Z,SAVLO4
0410DA D5          1938   			PUSH    DE
0410DB 11 00 00 04 1939   			LD      DE,ACCS
0410DF EB          1940   			EX      DE,HL
0410E0 45          1941   			LD      B,L
0410E1 ED B0       1942   			LDIR                    	; Save the string onto the stack
0410E3 D1          1943   			POP     DE
0410E4             1944   ;
0410E4 DD E5       1945   SAVLO4:			PUSH    IX			; VARPTR
0410E6 CD EA 10 04 1946   			CALL    SAVLO5
0410EA             1947   LOCCHK:			EQU     $
0410EA CD E1 0F 04 1948   SAVLO5:			CALL    CHECK
0410EE CD 2D 1E 04 1949   			CALL    NXT
0410F2 FE 2C       1950   			CP      ','             	; Are there any more local variables?
0410F4 28 97       1951   			JR      Z,SAVLO1		; Yes, so loop
0410F6 EB          1952   			EX      DE,HL			; DE -> HL: The return address
0410F7 E9          1953   			JP      (HL)            	; And effectvely return
0410F8             1954   ;
0410F8 FD 7E 00    1955   DELIM:			LD      A,(IY)          	; Assembler delimiter
0410FB FE 20       1956   			CP      ' '
0410FD C8          1957   			RET     Z
0410FE FE 2C       1958   			CP      ','
041100 C8          1959   			RET     Z
041101 FE 29       1960   			CP      ')'
041103 C8          1961   			RET     Z
041104 FE 3B       1962   TERM:			CP      ';'             	; Assembler terminator
041106 C8          1963   			RET     Z
041107 FE 5C       1964   			CP      '\'
041109 C8          1965   			RET     Z
04110A 18 07       1966   			JR      TERM0
04110C             1967   ;
04110C CD 2D 1E 04 1968   TERMQ:			CALL    NXT
041110 FE 8B       1969   			CP      ELSE_
041112 D0          1970   			RET     NC
041113 FE 3A       1971   TERM0:			CP      ':'             	; Assembler seperator
041115 D0          1972   			RET     NC
041116 FE 0D       1973   			CP      CR
041118 C9          1974   			RET
041119             1975   ;
041119 CD 0C 11 04 1976   SPAN:			CALL    TERMQ
04111D C8          1977   			RET     Z
04111E FD 23       1978   			INC     IY
041120 18 F7       1979   			JR      SPAN
041122             1980   ;
041122             1981   ; This snippet is used to check whether an expression is followed by an '=' symbol
041122             1982   ;
041122 CD 2D 1E 04 1983   EQUALS:			CALL    NXT			; Skip whitespace
041126 FD 23       1984   			INC     IY			; Skip past the character in question
041128 FE 3D       1985   			CP      '='			; Is it '='
04112A C8          1986   			RET     Z			; Yes, so return
04112B 3E 04       1987   			LD      A,4			; Otherwise
04112D C3 E6 1B 04 1988   			JP      ERROR_           	; Throw error "Mistake"
041131             1989   ;
041131 FE 8A       1990   FORMAT:			CP      TAB
041133 28 0D       1991   			JR      Z,DOTAB
041135 FE 89       1992   			CP      SPC
041137 28 40       1993   			JR      Z,DOSPC
041139 FE 27       1994   			CP      '''
04113B C0          1995   			RET     NZ
04113C CD 1B 1B 04 1996   			CALL    CRLF
041140 AF          1997   			XOR     A
041141 C9          1998   			RET
041142             1999   ;
041142 C5          2000   DOTAB:			PUSH    BC
041143 CD 1E 1C 04 2001   			CALL    EXPRI
041147 D9          2002   			EXX
041148 C1          2003   			POP     BC
041149 FD 7E 00    2004   			LD      A,(IY)
04114C FE 2C       2005   			CP      ','
04114E 28 14       2006   			JR      Z,DOTAB1
041150 CD 1E 1A 04 2007   			CALL    BRAKET
041154 7D          2008   			LD      A,L
041155 21 3D 03 04 2009   TABIT:			LD      HL,COUNT
041159 BE          2010   			CP      (HL)
04115A C8          2011   			RET     Z
04115B F5          2012   			PUSH    AF
04115C DC 1B 1B 04 2013   			CALL    C,CRLF
041160 F1          2014   			POP     AF
041161 96          2015   			SUB     (HL)
041162 18 1D       2016   			JR      FILL
041164 FD 23       2017   DOTAB1:			INC     IY
041166 C5          2018   			PUSH    BC
041167 E5          2019   			PUSH    HL
041168 CD 1E 1C 04 2020   			CALL    EXPRI
04116C D9          2021   			EXX
04116D D1          2022   			POP     DE
04116E C1          2023   			POP     BC
04116F CD 1E 1A 04 2024   			CALL    BRAKET
041173 CD D1 1F 04 2025   			CALL    PUTCSR
041177 AF          2026   			XOR     A
041178 C9          2027   			RET
041179             2028   ;
041179 C5          2029   DOSPC:			PUSH    BC
04117A CD 1A 1D 04 2030   			CALL    ITEMI
04117E D9          2031   			EXX
04117F 7D          2032   			LD      A,L
041180 C1          2033   			POP     BC
041181 B7          2034   FILL:			OR      A
041182 C8          2035   			RET     Z
041183 C5          2036   			PUSH    BC
041184 47          2037   			LD      B,A
041185 3E 20       2038   FILL1:			LD      A,' '
041187 CD 2B 1F 04 2039   			CALL    OUTCHR
04118B 10 F8       2040   			DJNZ    FILL1
04118D C1          2041   			POP     BC
04118E AF          2042   			XOR     A
04118F C9          2043   			RET
041190             2044   ;
041190 21 00 00 04 2045   PTEXT:			LD      HL,ACCS
041194 1C          2046   			INC     E
041195 1D          2047   PTEXT1:			DEC     E
041196 C8          2048   			RET     Z
041197 7E          2049   			LD      A,(HL)
041198 23          2050   			INC     HL
041199 CD 2B 1F 04 2051   			CALL    OUTCHR
04119D 18 F6       2052   			JR      PTEXT1
04119F             2053   ;
04119F F5          2054   FETCHS:			PUSH    AF
0411A0 C5          2055   			PUSH    BC
0411A1 E5          2056   			PUSH    HL
0411A2 FD E3       2057   			EX      (SP),IY
0411A4 CD BF 11 04 2058   			CALL    XTRACT
0411A8 CD 2D 1E 04 2059   			CALL    NXT
0411AC FD E3       2060   			EX      (SP),IY
0411AE E1          2061   			POP     HL
0411AF C1          2062   			POP     BC
0411B0 F1          2063   			POP     AF
0411B1 C9          2064   			RET
0411B2             2065   ;
0411B2 11 00 00 04 2066   LINES:			LD      DE,ACCS
0411B6 7E          2067   LINE1S:			LD      A,(HL)
0411B7 12          2068   			LD      (DE),A
0411B8 FE 0D       2069   			CP      CR
0411BA C8          2070   			RET     Z
0411BB 23          2071   			INC     HL
0411BC 1C          2072   			INC     E
0411BD 18 F7       2073   			JR      LINE1S
0411BF             2074   ;
0411BF CD 2D 1E 04 2075   XTRACT:			CALL    NXT
0411C3 FE 22       2076   			CP      '"'
0411C5 FD 23       2077   			INC     IY
0411C7 CA E3 1A 04 2078   			JP      Z,CONS
0411CB FD 2B       2079   			DEC     IY
0411CD 11 00 00 04 2080   			LD      DE,ACCS
0411D1 FD 7E 00    2081   XTRAC1:			LD      A,(IY)
0411D4 12          2082   			LD      (DE),A
0411D5 FE 2C       2083   			CP      ','
0411D7 C8          2084   			RET     Z
0411D8 FE 0D       2085   			CP      CR
0411DA C8          2086   			RET     Z
0411DB FD 23       2087   			INC     IY
0411DD 1C          2088   			INC     E
0411DE 18 F1       2089   			JR      XTRAC1
0411E0             2090   
0411E0             2091   ; Search for a token at the start of a program line
0411E0             2092   ; - HL: Pointer to the start of a tokenised line in the program area
0411E0             2093   ; Returns:
0411E0             2094   ; - HL: Pointer to the
0411E0             2095   ; -  F: Carry set if not found
0411E0             2096   ; Corrupts:
0411E0             2097   ; - BC
0411E0             2098   ;
0411E0 01 00 00 00 2099   SEARCH:			LD      BC,0			; Clear BC
0411E4             2100   ;
0411E4 4E          2101   SRCH1:			LD      C,(HL)			;  C: Fetch the line length
0411E5 0C          2102   			INC     C			; Check for 0, i.e. end of program marker
0411E6 0D          2103   			DEC     C
0411E7 28 0B       2104   			JR      Z,SRCH2         	; Not found the token, so end
0411E9 23          2105   			INC     HL			; Skip the line length and line number
0411EA 23          2106   			INC     HL
0411EB 23          2107   			INC     HL
0411EC BE          2108   			CP      (HL)			; Compare with the token
0411ED C8          2109   			RET     Z			; Found it, so return with carry not set
0411EE 0D          2110   			DEC     C			; Skip to the next line
0411EF 0D          2111   			DEC     C
0411F0 0D          2112   			DEC     C
0411F1 09          2113   			ADD     HL,BC
0411F2 18 F0       2114   			JR      SRCH1			; Rinse, lather and repeat
0411F4             2115   ;
0411F4 2B          2116   SRCH2:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
0411F5 37          2117   			SCF				; And set the carry flag
0411F6 C9          2118   			RET
0411F7             2119   
0411F7             2120   ; Multiply by 4 or 5
0411F7             2121   ; This function is used to allocate space for dimensioned variables
0411F7             2122   ; This is a 24-bit operation
0411F7             2123   ; - DE: Number to multiple
0411F7             2124   ; -  A: 04h (Integer) - takes up 4 bytes
0411F7             2125   ;       05h (Float)   - takes up 5 bytes
0411F7             2126   ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
0411F7             2127   ; Returns:
0411F7             2128   ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
0411F7             2129   ; -  F: Carry if overflow
0411F7             2130   ; Corrupts:
0411F7             2131   ; - HL
0411F7 FE 04       2132   X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
0411F9             2133   			; LD	HL,DE
0411F9 D5          2134   			push de
0411FA E1          2135   			pop hl
0411FB 29          2136   			ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
0411FC D8          2137   			RET     C			; Exit if overflow
0411FD 29          2138   			ADD     HL,HL			; Multiply by 2 again
0411FE D8          2139   			RET     C			; Exit if overflow
0411FF EB          2140   			EX      DE,HL			; DE: Product
041200 C8          2141   			RET     Z			; Exit if A = 4
041201 19          2142   			ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
041202 EB          2143   			EX      DE,HL			; DE: Product
041203 C9          2144   			RET
041204             2145   
041204             2146   ; 16-bit unsigned multiply
041204             2147   ; - HL: Operand 1
041204             2148   ; - BC: Operand 2
041204             2149   ; Returns:
041204             2150   ; - HL: Result
041204             2151   ; -  F: C if overflow
041204             2152   ;
041204 C5          2153   MUL16:			PUSH	BC
041205 51          2154   			LD	D, C			; Set up the registers for the multiplies
041206 5D          2155   			LD	E, L
041207 69          2156   			LD	L, C
041208 4B          2157   			LD	C, E
041209 ED 6C       2158   			MLT	HL			; HL = H * C (*256)
04120B ED 5C       2159   			MLT	DE			; DE = L * C
04120D ED 4C       2160   			MLT	BC			; BC = B * L (*256)
04120F 09          2161   			ADD	HL, BC			; HL = The sum of the two most significant multiplications
041210 C1          2162   			POP	BC
041211 AF          2163   			XOR	A
041212 9C          2164   			SBC	H			; If H is not zero then it's an overflow
041213 D8          2165   			RET	C
041214 65          2166   			LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
041215 6F          2167   			LD	L, A
041216 19          2168   			ADD	HL, DE
041217 C9          2169   			RET
041218             2170   ;
041218 CD 2D 1E 04 2171   CHANEL:			CALL    NXT			; Skip whitespace
04121C FE 23       2172   			CP      '#'			; Check for the '#' symbol
04121E 3E 2D       2173   			LD      A,45
041220 C2 E6 1B 04 2174   			JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
041224 FD 23       2175   CHNL:			INC     IY             		; Bump past the '#'
041226 CD 1A 1D 04 2176   			CALL    ITEMI			; Get the channel number
04122A D9          2177   			EXX
04122B EB          2178   			EX      DE,HL			; DE: The channel number
04122C C9          2179   			RET
04122D             2180   
04122D             2181   ; ASSEMBLER -------------------------------------------------------------------
04122D             2182   
04122D             2183   ; Language independant control section:
04122D             2184   ;  Outputs: A=delimiter, carry set if syntax error.
04122D             2185   ;
04122D CD 4D 17 04 2186   ASSEM:			CALL    SKIP
041231 FD 23       2187   			INC     IY
041233 FE 3A       2188   			CP      ':'
041235 28 F6       2189   			JR      Z,ASSEM
041237 FE 5D       2190   			CP      ']'
041239 C8          2191   			RET     Z
04123A FE 0D       2192   			CP      CR
04123C C8          2193   			RET     Z
04123D FD 2B       2194   			DEC     IY
04123F DD 2A 40 08 2195   			LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
       10          
041244 21 40 03 04 2196   			LD      HL,LISTON
041248 CB 76       2197   			BIT     6,(HL)
04124A 28 05       2198   			JR      Z,ASSEM0
04124C DD 2A 3C 08 2199   			LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
       10          
041251 DD E5       2200   ASSEM0:			PUSH    IX
041253 FD E5       2201   			PUSH    IY
041255 CD 05 13 04 2202   			CALL    ASMB
041259 C1          2203   			POP     BC
04125A D1          2204   			POP     DE
04125B D8          2205   			RET     C
04125C CD 4D 17 04 2206   			CALL    SKIP
041260 37          2207   			SCF
041261 C0          2208   			RET     NZ
041262 FD 2B       2209   			DEC     IY
041264 FD 23       2210   ASSEM3:			INC     IY
041266 FD 7E 00    2211   			LD      A,(IY)
041269 CD 13 11 04 2212   			CALL    TERM0
04126D 20 F5       2213   			JR      NZ,ASSEM3
04126F 3A 40 03 04 2214   			LD      A,(LISTON)
041273 DD E5       2215   			PUSH    IX
041275 E1          2216   			POP     HL
041276 B7          2217   			OR      A
041277 ED 52       2218   			SBC     HL,DE
041279 EB          2219   			EX      DE,HL           	; DE: Number of bytes
04127A E5          2220   			PUSH    HL
04127B 2A 40 08 10 2221   			LD      HL,(PC)
04127F E5          2222   			PUSH    HL
041280 19          2223   			ADD     HL,DE
041281 22 40 08 10 2224   			LD      (PC),HL         	; Update PC
041285 CB 77       2225   			BIT     6,A
041287 28 09       2226   			JR      Z,ASSEM5
041289 2A 3C 08 10 2227   			LD      HL,(OC)
04128D 19          2228   			ADD     HL,DE
04128E 22 3C 08 10 2229   			LD      (OC),HL         	; Update OC
041292 E1          2230   ASSEM5:			POP     HL              	; Old PC
041293 DD E1       2231   			POP     IX              	; Code here
041295 CB 67       2232   			BIT     4,A
041297 28 94       2233   			JR      Z,ASSEM
041299 22 4A 03 04 2234   			LD	(R0),HL			; Store HL in R0 so we can access the MSB
04129D 3A 4C 03 04 2235   			LD	A,(R0+2)		; Print out the address
0412A1 CD EF 12 04 2236   			CALL	HEX
0412A5 7C          2237   			LD      A,H
0412A6 CD EF 12 04 2238   			CALL    HEX
0412AA 7D          2239   			LD      A,L
0412AB CD E7 12 04 2240   			CALL    HEXSP
0412AF AF          2241   			XOR     A
0412B0 BB          2242   			CP      E
0412B1 28 18       2243   			JR      Z,ASSEM2
0412B3             2244   ;
0412B3 3A 3D 03 04 2245   ASSEM1:			LD      A,(COUNT)
0412B7 FE 14       2246   			CP      20
0412B9 3E 07       2247   			LD      A,7
0412BB D4 55 11 04 2248   			CALL    NC,TABIT        	; Next line
0412BF DD 7E 00    2249   			LD      A,(IX)
0412C2 CD E7 12 04 2250   			CALL    HEXSP
0412C6 DD 23       2251   			INC     IX
0412C8 1D          2252   			DEC     E
0412C9 20 E8       2253   			JR      NZ,ASSEM1
0412CB             2254   ;
0412CB 3E 16       2255   ASSEM2:			LD      A,22			; Tab to the disassembly field
0412CD CD 55 11 04 2256   			CALL    TABIT
0412D1 FD E5       2257   			PUSH    IY
0412D3 E1          2258   			POP     HL
0412D4 ED 42       2259   			SBC     HL,BC
0412D6 0A          2260   ASSEM4:			LD      A,(BC)
0412D7 CD 48 1F 04 2261   			CALL    OUT_
0412DB 03          2262   			INC     BC
0412DC 2D          2263   			DEC     L
0412DD 20 F7       2264   			JR      NZ,ASSEM4
0412DF CD 1B 1B 04 2265   			CALL    CRLF
0412E3 C3 2D 12 04 2266   			JP      ASSEM
0412E7             2267   ;
0412E7 CD EF 12 04 2268   HEXSP:			CALL    HEX
0412EB 3E 20       2269   			LD      A,' '
0412ED 18 12       2270   			JR      OUTCH1
0412EF F5          2271   HEX:			PUSH    AF
0412F0 0F          2272   			RRCA
0412F1 0F          2273   			RRCA
0412F2 0F          2274   			RRCA
0412F3 0F          2275   			RRCA
0412F4 CD F9 12 04 2276   			CALL    HEXOUT
0412F8 F1          2277   			POP     AF
0412F9 E6 0F       2278   HEXOUT:			AND     0FH
0412FB C6 90       2279   			ADD     A,90H
0412FD 27          2280   			DAA
0412FE CE 40       2281   			ADC     A,40H
041300 27          2282   			DAA
041301 C3 48 1F 04 2283   OUTCH1:			JP      OUT_
041305             2284   
041305             2285   ; Processor Specific Translation Section:
041305             2286   ;
041305             2287   ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
041305             2288   ;                 C: Opcode beig built
041305             2289   ;                 D: Flags
041305             2290   ;			Bit 7: Set to 1 if the instruction uses long addressing
041305             2291   ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
041305             2292   ;                 E: Offset from IX or IY
041305             2293   ;                HL: Numeric operand value
041305             2294   ;                IX: Code destination pointer
041305             2295   ;                IY: Source text pointer
041305             2296   ;    Inputs: A = initial character
041305             2297   ;   Outputs: Carry set if syntax error.
041305             2298   ;
041305 FE 2E       2299   ASMB:			CP      '.'			; Check for a dot; this indicates a label
041307 20 1F       2300   			JR      NZ,ASMB1		; No, so just process the instruction
041309 FD 23       2301   			INC     IY			; Skip past the dot to the label name
04130B DD E5       2302   			PUSH    IX			; Store the code destination pointer
04130D CD F6 05 04 2303   			CALL    VAR_			; Create a variable
041311 F5          2304   			PUSH    AF
041312 CD E2 21 04 2305   			CALL    ZERO			; Zero it
041316 3A 42 08 10 2306   			LD	A,(PC+2)
04131A 6F          2307   			LD	L,A			; The MSB of the 24-bit address
04131B D9          2308   			EXX
04131C 2A 40 08 10 2309   			LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
041320 D9          2310   			EXX
041321 F1          2311   			POP     AF
041322 CD 68 0F 04 2312   			CALL    STORE			; Store the program counter
041326 DD E1       2313   			POP     IX			; Restore the code destination pointer
041328             2314   ;
041328 3A 40 03 04 2315   ASMB1:			LD	A,(LISTON)		; Get the OPT flags
04132C E6 80       2316   			AND	80H
04132E 57          2317   			LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
04132F CD 4D 17 04 2318   			CALL    SKIP			; Skip any whitespace
041333 C8          2319   			RET     Z			; And return if there is nothing further to process
041334 FE D6       2320   			CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
041336 0E C4       2321   			LD      C,0C4H			;  A: The base operand
041338 FD 23       2322   			INC     IY			; Skip past the token
04133A CA 82 14 04 2323   			JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
04133E FD 2B       2324   			DEC     IY			; Skip back, as we're not doing the above at this point
041340 21 64 17 04 2325   			LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
041344 CD FC 16 04 2326   			CALL    FIND			; Find the opcode
041348 D8          2327   			RET     C			; If not found, then return; carry indicates an error condition
041349 48          2328   			LD      C,B     		;  C: A copy of the opcode
04134A             2329   ;
04134A             2330   ; GROUP 0: Trivial cases requiring no computation
04134A             2331   ; GROUP 1: As Group 0, but with "ED" prefix
04134A             2332   ;
04134A D6 44       2333   			SUB     68			; The number of opcodes in GROUP0 and GROUP1
04134C 30 08       2334   			JR      NC,GROUP02		; If not in that range, then check GROUP2
04134E FE CB       2335   			CP      15-68			; Anything between 15 and 68 (neat compare trick here)
041350 D4 55 16 04 2336   			CALL    NC,ED			; Needs to be prefixed with ED
041354 18 76       2337   			JR      BYTE0			; Then write the opcode byte
041356             2338   ;
041356             2339   ; GROUP 2: BIT, RES, SET
041356             2340   ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
041356             2341   ;
041356 D6 0A       2342   GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
041358 30 12       2343   			JR      NC,GROUP04		; If not in that range, then check GROUP4
04135A FE F9       2344   			CP      3-10			;
04135C DC EA 16 04 2345   			CALL    C,BIT_
041360 D8          2346   			RET     C
041361 CD BB 16 04 2347   			CALL    REGLO
041365 D8          2348   			RET     C
041366 CD 59 16 04 2349   			CALL    CB
04136A 18 60       2350   			JR      BYTE0
04136C             2351   ;
04136C             2352   ; GROUP 4 - PUSH, POP, EX (SP)
04136C             2353   ;
04136C D6 03       2354   GROUP04:		SUB     3			; The number of opcodes in GROUP4
04136E 30 07       2355   			JR      NC,GROUP05		; If not in that range, then check GROUP5
041370 CD DD 16 04 2356   GROUP04_1:		CALL    PAIR
041374 D8          2357   			RET     C
041375 18 55       2358   			JR      BYTE0
041377             2359   ;
041377             2360   ; GROUP 5 - SUB, AND, XOR, OR, CP
041377             2361   ; GROUP 6 - ADD, ADC, SBC
041377             2362   ;
041377 D6 0A       2363   GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
041379 30 39       2364   			JR      NC,GROUP07
04137B FE FD       2365   			CP      5-8
04137D 06 07       2366   			LD      B,7
04137F D4 69 16 04 2367   			CALL    NC,OPND			; Get the first operand
041383 78          2368   			LD      A,B
041384 FE 07       2369   			CP      7			; Is the operand 'A'?
041386 20 15       2370   			JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
041388             2371   ;
041388 CD BB 16 04 2372   GROUP05_1:		CALL    REGLO			; Handle ADD A,?
04138C 79          2373   			LD      A,C
04138D 30 2E       2374   			JR      NC,BIND1		; If it is a register, then write that out
04138F EE 46       2375   			XOR     46H			; Handle ADD A,n
041391 CD 5B 16 04 2376   			CALL    BIND
041395 CD 9B 16 04 2377   DB_:			CALL    NUMBER
041399 C3 54 14 04 2378   			JP      VAL8
04139D             2379   ;
04139D E6 3F       2380   GROUP05_HL:		AND     3FH
04139F FE 0C       2381   			CP      12
0413A1 37          2382   			SCF
0413A2 C0          2383   			RET     NZ
0413A3 79          2384   			LD      A,C
0413A4 FE 80       2385   			CP      80H
0413A6 0E 09       2386   			LD      C,9
0413A8 28 C6       2387   			JR      Z,GROUP04_1
0413AA EE 1C       2388   			XOR     1CH
0413AC 0F          2389   			RRCA
0413AD 4F          2390   			LD      C,A
0413AE CD 55 16 04 2391   			CALL    ED
0413B2 18 BC       2392   			JR      GROUP04_1
0413B4             2393   ;
0413B4             2394   ; GROUP 7 - INC, DEC
0413B4             2395   ;
0413B4 D6 02       2396   GROUP07:		SUB     2			; The number of opcodes in GROUP7
0413B6 30 19       2397   			JR      NC,GROUP08
0413B8 CD C2 16 04 2398   			CALL    REGHI
0413BC 79          2399   			LD      A,C
0413BD D2 5B 16 04 2400   BIND1:			JP      NC,BIND
0413C1 EE 64       2401   			XOR     64H
0413C3 07          2402   			RLCA
0413C4 07          2403   			RLCA
0413C5 07          2404   			RLCA
0413C6 4F          2405   			LD      C,A
0413C7 CD E2 16 04 2406   			CALL    PAIR1
0413CB D8          2407   			RET     C
0413CC 79          2408   BYTE0:			LD      A,C
0413CD C3 8A 16 04 2409   			JP      BYTE_
0413D1             2410   ;
0413D1             2411   ; Group 8: IN0, OUT0
0413D1             2412   ;
0413D1 D6 02       2413   GROUP08:		SUB	2			; The number of opcodes in GROUP8
0413D3 30 2C       2414   			JR	NC,GROUP09
0413D5 FE FF       2415   			CP	1-2
0413D7 CC 9B 16 04 2416   			CALL    Z,NUMBER		; Fetch number first if OUT
0413DB 08          2417   			EX      AF,AF'			; Save flags
0413DC CD AF 16 04 2418   			CALL    REG			; Get the register value regardless
0413E0 D8          2419   			RET     C			; Return if not a register
0413E1 08          2420   			EX      AF,AF'			; Restore the flags
0413E2 DC 9B 16 04 2421   			CALL    C,NUMBER		; Fetch number last if IN
0413E6 78          2422   			LD	A,B			; Get the register number
0413E7 FE 06       2423   			CP	6			; Fail on (HL)
0413E9 37          2424   			SCF
0413EA C8          2425   			RET	Z
0413EB FE 08       2426   			CP	8			; Check it is just single pairs only
0413ED 3F          2427   			CCF
0413EE D8          2428   			RET	C			; And return if it is an invalid register
0413EF 07          2429   			RLCA				; Bind with the operand
0413F0 07          2430   			RLCA
0413F1 07          2431   			RLCA
0413F2 81          2432   			ADD	A,C
0413F3 4F          2433   			LD	C,A
0413F4 CD 55 16 04 2434   			CALL	ED			; Prefix with ED
0413F8 79          2435   			LD	A,C
0413F9 CD 8A 16 04 2436   			CALL	BYTE_			; Write out the operand
0413FD C3 54 14 04 2437   			JP	VAL8			; Write out the value
041401             2438   ;
041401             2439   ; GROUP 9 - IN
041401             2440   ; GROUP 10 - OUT
041401             2441   ;
041401 D6 02       2442   GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
041403 30 25       2443   			JR      NC,GROUP11
041405 FE FF       2444   			CP      1-2			; Check if Group 9 or Group 1
041407 CC 49 16 04 2445   			CALL    Z,CORN			; Call CORN if Group 10 (OUT)
04140B 08          2446   			EX      AF,AF'			; Save flags
04140C CD C2 16 04 2447   			CALL    REGHI			; Get the register value regardless
041410 D8          2448   			RET     C			; Return if not a register
041411 08          2449   			EX      AF,AF'			; Restore the flags
041412 DC 49 16 04 2450   			CALL    C,CORN			; Call CORN if Group 9 (IN)
041416 24          2451   			INC     H			; If it is IN r,(C) or OUT (C),r then
041417 28 B3       2452   			JR      Z,BYTE0			; Just write the operand out
041419             2453   ;
041419 78          2454   			LD      A,B			; Check the register
04141A FE 07       2455   			CP      7
04141C 37          2456   			SCF
04141D C0          2457   			RET     NZ			; If it is not A, then return
04141E             2458   ;
04141E 79          2459   			LD      A,C			; Bind the register with the operand
04141F EE 03       2460   			XOR     3
041421 07          2461   			RLCA
041422 07          2462   			RLCA
041423 07          2463   			RLCA
041424 CD 8A 16 04 2464   			CALL    BYTE_			; Write out the operand
041428 18 2A       2465   			JR      VAL8			; And the value
04142A             2466   ;
04142A             2467   ; GROUP 11 - JR, DJNZ
04142A             2468   ;
04142A D6 02       2469   GROUP11:		SUB     2			; The number of opcodes in GROUP11
04142C 30 2B       2470   			JR      NC,GROUP12
04142E FE FF       2471   			CP      1-2
041430 C4 C9 16 04 2472   			CALL    NZ,COND_
041434 79          2473   			LD      A,C
041435 30 02       2474   			JR      NC,@F
041437 3E 18       2475   			LD      A,18H
041439 CD 8A 16 04 2476   @@:			CALL    BYTE_
04143D CD 9B 16 04 2477   			CALL    NUMBER
041441 ED 5B 40 08 2478   			LD      DE,(PC)
       10          
041446 13          2479   			INC     DE
041447 37          2480   			SCF
041448 ED 52       2481   			SBC     HL,DE
04144A 7D          2482   			LD      A,L
04144B 17          2483   			RLA
04144C 9F          2484   			SBC     A,A
04144D BC          2485   			CP      H
04144E 3E 01       2486   TOOFAR:			LD      A,1
041450 C2 E6 1B 04 2487   			JP      NZ,ERROR_		; Throw an "Out of range" error
041454 7D          2488   VAL8:			LD      A,L
041455 C3 8A 16 04 2489   			JP      BYTE_
041459             2490   ;
041459             2491   ; GROUP 12 - JP
041459             2492   ;
041459 D6 01       2493   GROUP12:		SUB	1			; The number of opcodes in GROUP12
04145B 30 21       2494   			JR	NC,GROUP13
04145D CD AF 15 04 2495   			CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
041461 D8          2496   			RET	C			; Exit if an invalid suffix is provided
041462 CD C9 16 04 2497   			CALL    COND_			; Evaluate the conditions
041466 79          2498   			LD      A,C
041467 30 0D       2499   			JR      NC,GROUP12_1
041469 78          2500   			LD      A,B
04146A E6 3F       2501   			AND     3FH
04146C FE 06       2502   			CP      6
04146E 3E E9       2503   			LD      A,0E9H
041470 CA 8A 16 04 2504   			JP      Z,BYTE_
041474 3E C3       2505   			LD      A,0C3H
041476 CD 8A 16 04 2506   GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
04147A C3 04 16 04 2507   			JP	ADDR_			; Output the address
04147E             2508   ;
04147E             2509   ; GROUP 13 - CALL
04147E             2510   ;
04147E D6 01       2511   GROUP13:		SUB	1			; The number of opcodes in GROUP13
041480 30 0C       2512   			JR	NC,GROUP14
041482 CD C7 15 04 2513   GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
041486 CD A9 14 04 2514   			CALL    GROUP15_1		; Output the opcode (with conditions)
04148A C3 04 16 04 2515   			JP	ADDR_			; Output the address
04148E             2516   ;
04148E             2517   ; GROUP 14 - RST
04148E             2518   ;
04148E D6 01       2519   GROUP14:		SUB	1			; The number of opcodes in GROUP14
041490 30 13       2520   			JR	NC,GROUP15
041492 CD C7 15 04 2521   			CALL	EZ80SF_FULL		; Evaluate the suffix
041496 D8          2522   			RET	C			; Exit if an invalid suffix provided
041497 CD 9B 16 04 2523   			CALL    NUMBER
04149B A1          2524   			AND     C
04149C B4          2525   			OR      H
04149D 20 AF       2526   			JR      NZ,TOOFAR
04149F 7D          2527   			LD      A,L
0414A0 B1          2528   			OR      C
0414A1 C3 8A 16 04 2529   	  		JP      BYTE_
0414A5             2530   ;
0414A5             2531   ; GROUP 15 - RET
0414A5             2532   ;
0414A5 D6 01       2533   GROUP15:		SUB	1			; The number of opcodes in GROUP15
0414A7 30 0F       2534   			JR	NC,GROUP16
0414A9 CD C9 16 04 2535   GROUP15_1:		CALL    COND_
0414AD 79          2536   			LD      A,C
0414AE D2 8A 16 04 2537   			JP      NC,BYTE_
0414B2 F6 09       2538   			OR      9
0414B4 C3 8A 16 04 2539   			JP      BYTE_
0414B8             2540   ;
0414B8             2541   ; GROUP 16 - LD
0414B8             2542   ;
0414B8 D6 01       2543   GROUP16:		SUB	1			; The number of opcodes in GROUP16
0414BA 30 74       2544   			JR	NC,GROUP17
0414BC CD C7 15 04 2545   			CALL	EZ80SF_FULL		; Evaluate the suffix
0414C0 CD F8 16 04 2546   			CALL    LDOP			; Check for accumulator loads
0414C4 D2 24 16 04 2547   			JP      NC,LDA			; Yes, so jump here
0414C8 CD C2 16 04 2548   			CALL    REGHI
0414CC 08          2549   			EX      AF,AF'
0414CD CD 4D 17 04 2550   			CALL    SKIP
0414D1 FE 28       2551   			CP      '('			; Check for bracket
0414D3 28 24       2552   			JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
0414D5 08          2553   			EX      AF,AF'
0414D6 D2 88 13 04 2554   			JP      NC,GROUP05_1		; Load single register direct; go here
0414DA 0E 01       2555   			LD      C,1
0414DC CD E2 16 04 2556   			CALL    PAIR1
0414E0 D8          2557   			RET     C
0414E1 3E 0E       2558   			LD      A,14
0414E3 B8          2559   			CP      B
0414E4 47          2560   			LD      B,A
0414E5 CC DD 16 04 2561   			CALL    Z,PAIR
0414E9 78          2562   			LD      A,B
0414EA E6 3F       2563   			AND     3FH
0414EC FE 0C       2564   			CP      12
0414EE 79          2565   			LD      A,C
0414EF C2 76 14 04 2566   			JP      NZ,GROUP12_1		; Load register pair direct; go here
0414F3 3E F9       2567   			LD      A,0F9H
0414F5 C3 8A 16 04 2568   			JP      BYTE_
0414F9             2569   ;
0414F9 08          2570   LDIN:			EX      AF,AF'
0414FA C5          2571   			PUSH    BC
0414FB D4 BB 16 04 2572   			CALL    NC,REGLO
0414FF 79          2573   			LD      A,C
041500 C1          2574   			POP     BC
041501 D2 5B 16 04 2575   			JP      NC,BIND
041505 0E 0A       2576   			LD      C,0AH
041507 CD E2 16 04 2577   			CALL    PAIR1
04150B CD 2F 16 04 2578   			CALL    LD16
04150F D2 76 14 04 2579   			JP      NC,GROUP12_1
041513 CD 9B 16 04 2580   			CALL    NUMBER
041517 0E 02       2581   			LD      C,2
041519 CD DD 16 04 2582   			CALL    PAIR
04151D CD 2F 16 04 2583   			CALL    LD16
041521 D8          2584   			RET     C
041522 CD 8A 16 04 2585   			CALL    BYTE_
041526 CB 7A       2586   			BIT	7,D			; Check the ADL flag
041528 C2 19 16 04 2587   			JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
04152C C3 0C 16 04 2588   			JP      VAL16			; Otherwise use 16-bit addresses
041530             2589   ;
041530             2590   ; Group 17 - TST
041530             2591   ;
041530 D6 01       2592   GROUP17:		SUB	1			; The number of opcodes in GROUP17
041532 30 25       2593   			JR	NC,OPTS
041534 CD 55 16 04 2594   			CALL	ED			; Needs to be prefixed with ED
041538 CD AF 16 04 2595   			CALL	REG			; Fetch the register
04153C 30 0E       2596   			JR	NC,GROUP17_1		; It's just a register
04153E             2597   ;
04153E 3E 64       2598   			LD	A,64H			; Opcode for TST n
041540 CD 8A 16 04 2599   			CALL	BYTE_			; Write out the opcode
041544 CD 9B 16 04 2600   			CALL	NUMBER			; Get the number
041548 C3 54 14 04 2601   			JP	VAL8			; And write that out
04154C             2602   ;
04154C 78          2603   GROUP17_1:		LD	A,B			; Check the register rangs
04154D FE 08       2604   			CP	8
04154F 3F          2605   			CCF
041550 D8          2606   			RET	C			; Ret with carry flag set for error if out of range
041551 07          2607   			RLCA				; Get the opcode value
041552 07          2608   			RLCA
041553 07          2609   			RLCA
041554 81          2610   			ADD	A,C			; Add the opcode base in
041555 C3 8A 16 04 2611   			JP	BYTE_
041559             2612   
041559             2613   ;
041559             2614   ; Assembler directives - OPT, ADL
041559             2615   ;
041559 D6 02       2616   OPTS:			SUB	2
04155B 30 2B       2617   			JR	NC, DEFS
04155D FE FF       2618   			CP	1-2			; Check for ADL opcode
04155F 28 13       2619   			JR	Z, ADL_
041561             2620   ;
041561 CD 9B 16 04 2621   OPT:			CALL    NUMBER			; Fetch the OPT value
041565 21 40 03 04 2622   			LD      HL,LISTON		; Address of the LISTON/OPT flag
041569 E6 07       2623   			AND	7			; Only interested in the first three bits
04156B 4F          2624   			LD      C,A			; Store the new OPT value in C
04156C ED 6F       2625   			RLD				; Shift the top nibble of LISTON (OPT) into A
04156E E6 08       2626   			AND	8			; Clear the bottom three bits, preserving the ADL bit
041570 B1          2627   			OR	C			; OR in the new value
041571 ED 67       2628   			RRD				; And shift the nibble back in
041573 C9          2629   			RET
041574             2630   ;
041574 CD 9B 16 04 2631   ADL_:			CALL	NUMBER			; Fetch the ADL value
041578 E6 01       2632   			AND	1			; Only interested if it is 0 or 1
04157A 0F          2633   			RRCA				; Rotate to bit 7
04157B 4F          2634   			LD	C,A			; Store in C
04157C 3A 40 03 04 2635   			LD	A,(LISTON)		; Get the LISTON system variable
041580 E6 7F       2636   			AND	7Fh			; Clear bit 7
041582 B1          2637   			OR	C			; OR in the ADL value
041583 32 40 03 04 2638   			LD	(LISTON),A		; Store
041587 C9          2639   			RET
041588             2640   ;
041588             2641   ; DEFB, DEFW, DEFL, DEFM
041588             2642   ;
041588 B7          2643   DEFS:			OR	A			; Handle DEFB
041589 CA 95 13 04 2644   			JP	Z, DB_
04158D 3D          2645   			DEC	A			; Handle DEFW
04158E CA 08 16 04 2646   			JP	Z, ADDR16
041592 3D          2647   			DEC	A			; Handle DEFL
041593 CA 15 16 04 2648   			JP	Z, ADDR24
041597             2649   ;
041597 DD E5       2650   			PUSH    IX			; Handle DEFM
041599 CD 56 1C 04 2651   			CALL    EXPRS
04159D DD E1       2652   			POP     IX
04159F 21 00 00 04 2653   			LD      HL,ACCS
0415A3 AF          2654   @@:			XOR     A
0415A4 BB          2655   			CP      E
0415A5 C8          2656   			RET     Z
0415A6 7E          2657   			LD      A,(HL)
0415A7 23          2658   			INC     HL
0415A8 CD 8A 16 04 2659   			CALL    BYTE_
0415AC 1D          2660   			DEC     E
0415AD 18 F4       2661   			JR      @B
0415AF             2662   
0415AF             2663   ;
0415AF             2664   ;SUBROUTINES:
0415AF             2665   ;
0415AF FD 7E 00    2666   EZ80SF_PART:		LD	A,(IY)			; Check for a dot
0415B2 FE 2E       2667   			CP	'.'
0415B4 28 02       2668   			JR	Z, @F			; If present, then carry on processing the eZ80 suffix
0415B6 B7          2669   			OR	A			; Reset the carry flag (no error)
0415B7 C9          2670   			RET				; And return
0415B8 FD 23       2671   @@:			INC	IY			; Skip the dot
0415BA C5          2672   			PUSH	BC			; Push the operand
0415BB 21 E3 19 04 2673   			LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
0415BF CD FC 16 04 2674   			CALL	FIND			; Look up the operand
0415C3 30 24       2675   			JR	NC,EZ80SF_OK
0415C5 C1          2676   			POP	BC			; Not found at this point, so will return with a C (error)
0415C6 C9          2677   			RET
0415C7             2678   ;
0415C7 FD 7E 00    2679   EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
0415CA FE 2E       2680   			CP	'.'
0415CC 28 02       2681   			JR	Z,@F			; If present, then carry on processing the eZ80 suffix
0415CE B7          2682   			OR	A			; Reset the carry flag (no error)
0415CF C9          2683   			RET				; And return
0415D0 FD 23       2684   @@:			INC	IY 			; Skip the dot
0415D2 C5          2685   			PUSH	BC			; Push the operand
0415D3 21 DB 19 04 2686   			LD	HL,EZ80SFS_1		; First check the fully qualified table
0415D7 CD FC 16 04 2687   			CALL	FIND 			; Look up the operand
0415DB 30 0C       2688   			JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
0415DD CD F8 15 04 2689   			CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
0415E1 CD FC 16 04 2690   			CALL	FIND
0415E5 30 02       2691   			JR	NC,EZ80SF_OK
0415E7 C1          2692   			POP	BC			; Not found at this point, so will return with a C (error)
0415E8 C9          2693   			RET
0415E9             2694   ;
0415E9 78          2695   EZ80SF_OK:		LD	A,B			; The operand value
0415EA D4 8A 16 04 2696   			CALL	NC,BYTE_ 		; Write it out if found
0415EE CB BA       2697   			RES	7,D			; Clear the default ADL mode from the flags
0415F0 E6 02       2698   			AND	2			; Check the second half of the suffix (.xxL)
0415F2 0F          2699   			RRCA				; Shift into bit 7
0415F3 0F          2700   			RRCA
0415F4 B2          2701   			OR	D			; Or into bit 7 of D
0415F5 57          2702   			LD	D,A
0415F6 C1          2703   			POP	BC 			; Restore the operand
0415F7 C9          2704   			RET
0415F8             2705   ;
0415F8 21 EC 19 04 2706   EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
0415FC CB 7A       2707   			BIT 	7,D			; if bit 7 of D is 0
0415FE C8          2708   			RET	Z
0415FF 21 F7 19 04 2709   			LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
041603 C9          2710   			RET
041604             2711   ;
041604 CB 7A       2712   ADDR_:			BIT	7,D			; Check the ADL flag
041606 20 0D       2713   			JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
041608             2714   ;
041608 CD 9B 16 04 2715   ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
04160C CD 54 14 04 2716   VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
041610 7C          2717   			LD      A,H
041611 C3 8A 16 04 2718   			JP      BYTE_
041615             2719   ;
041615 CD 9B 16 04 2720   ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
041619 CD 0C 16 04 2721   VAL24:			CALL	VAL16			; Lower 16-bits are in HL
04161D D9          2722   			EXX
04161E 7D          2723   			LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
04161F D9          2724   			EXX
041620 C3 8A 16 04 2725   			JP	BYTE_
041624             2726   ;
041624 FE 04       2727   LDA:			CP      4
041626 DC 55 16 04 2728   			CALL    C,ED
04162A 78          2729   			LD      A,B
04162B C3 8A 16 04 2730   			JP      BYTE_
04162F             2731   ;
04162F 78          2732   LD16:			LD      A,B
041630 38 0F       2733   			JR      C,LD8
041632 78          2734   			LD      A,B
041633 E6 3F       2735   			AND     3FH
041635 FE 0C       2736   			CP      12
041637 79          2737   			LD      A,C
041638 C8          2738   			RET     Z
041639 CD 55 16 04 2739   			CALL    ED
04163D 79          2740   			LD      A,C
04163E F6 43       2741   			OR      43H
041640 C9          2742   			RET
041641             2743   ;
041641 FE 07       2744   LD8:			CP      7
041643 37          2745   			SCF
041644 C0          2746   			RET     NZ
041645 79          2747   			LD      A,C
041646 F6 30       2748   			OR      30H
041648 C9          2749   			RET
041649             2750   ;
041649             2751   ; Used in IN and OUT to handle whether the operand is C or a number
041649             2752   ;
041649 C5          2753   CORN:			PUSH    BC
04164A CD 69 16 04 2754   			CALL    OPND			; Get the operand
04164E CB 68       2755   			BIT     5,B
041650 C1          2756   			POP     BC
041651 28 48       2757   			JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
041653 26 FF       2758   			LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
041655             2759   ;
041655 3E ED       2760   ED:			LD      A,0EDH			; Write an ED prefix out
041657 18 31       2761   			JR      BYTE_
041659             2762   ;
041659 3E CB       2763   CB:			LD      A,0CBH
04165B FE 76       2764   BIND:			CP      76H
04165D 37          2765   			SCF
04165E C8          2766   			RET     Z               	; Reject LD (HL),(HL)
04165F CD 8A 16 04 2767   			CALL    BYTE_
041663 CB 72       2768   			BIT	6,D			; Check the index bit in flags
041665 C8          2769   			RET     Z
041666 7B          2770   			LD      A,E			; If there is an index, output the offset
041667 18 21       2771   			JR      BYTE_
041669             2772   ;
041669             2773   ; Search through the operand table
041669             2774   ; Returns:
041669             2775   ; - B: The operand type
041669             2776   ; - D: Bit 7: 0 = no prefix, 1 = prefix
041669             2777   ; - E: The IX/IY offset
041669             2778   ; - F: Carry if not found
041669             2779   ;
041669 E5          2780   OPND:			PUSH    HL			; Preserve HL
04166A 21 6D 19 04 2781   			LD      HL,OPRNDS		; The operands table
04166E CD FC 16 04 2782   			CALL    FIND			; Find the operand
041672 E1          2783   			POP     HL
041673 D8          2784   			RET     C			; Return if not found
041674 CB 78       2785   			BIT     7,B			; Check if it is an index register (IX, IY)
041676 C8          2786   			RET     Z			; Return if it isn't
041677 CB F2       2787   			SET	6,D			; Set flag to indicate we've got an index
041679 CB 58       2788   			BIT     3,B			; Check if an offset is required
04167B E5          2789   			PUSH    HL
04167C CC 91 16 04 2790   			CALL    Z,OFFSET		; If bit 3 of B is zero, then get the offset
041680 5D          2791   			LD      E,L			; E: The offset
041681 E1          2792   			POP     HL
041682 3E DD       2793   			LD	A,DDH			; IX prefix
041684 CB 70       2794   			BIT     6,B			; If bit 6 is reset then
041686 28 02       2795   			JR      Z,BYTE_			; It's an IX instruction, otherwise set
041688 3E FD       2796   			LD	A,FDH			; IY prefix
04168A             2797   ;
04168A DD 77 00    2798   BYTE_:			LD      (IX),A			; Write a byte out
04168D DD 23       2799   			INC     IX
04168F B7          2800   			OR      A
041690 C9          2801   			RET
041691             2802   ;
041691 FD 7E 00    2803   OFFSET:			LD      A,(IY)
041694 FE 29       2804   			CP      ')'
041696 21 00 00 00 2805   			LD      HL,0
04169A C8          2806   			RET     Z
04169B CD 4D 17 04 2807   NUMBER:			CALL    SKIP
04169F C5          2808   			PUSH    BC
0416A0 D5          2809   			PUSH    DE
0416A1 DD E5       2810   			PUSH    IX
0416A3 CD 1E 1C 04 2811   			CALL    EXPRI
0416A7 DD E1       2812   			POP     IX
0416A9 D9          2813   			EXX
0416AA D1          2814   			POP     DE
0416AB C1          2815   			POP     BC
0416AC 7D          2816   			LD      A,L
0416AD B7          2817   			OR      A
0416AE C9          2818   			RET
0416AF             2819   ;
0416AF CD 69 16 04 2820   REG:			CALL    OPND
0416B3 D8          2821   			RET     C
0416B4 78          2822   			LD      A,B
0416B5 E6 3F       2823   			AND     3FH
0416B7 FE 08       2824   			CP      8
0416B9 3F          2825   			CCF
0416BA C9          2826   			RET
0416BB             2827   ;
0416BB CD AF 16 04 2828   REGLO:			CALL    REG
0416BF D8          2829   			RET     C
0416C0 18 33       2830   			JR      ORC
0416C2             2831   ;
0416C2 CD AF 16 04 2832   REGHI:			CALL    REG
0416C6 D8          2833   			RET     C
0416C7 18 29       2834   			JR      SHL3
0416C9             2835   ;
0416C9 CD 69 16 04 2836   COND_:			CALL    OPND
0416CD D8          2837   			RET     C
0416CE 78          2838   			LD      A,B
0416CF E6 1F       2839   			AND     1FH
0416D1 D6 10       2840   			SUB     16
0416D3 30 1D       2841   			JR      NC,SHL3
0416D5 FE F1       2842   			CP      -15
0416D7 37          2843   			SCF
0416D8 C0          2844   			RET     NZ
0416D9 3E 03       2845   			LD      A,3
0416DB 18 15       2846   			JR      SHL3
0416DD             2847   ;
0416DD CD 69 16 04 2848   PAIR:			CALL    OPND
0416E1 D8          2849   			RET     C
0416E2 78          2850   PAIR1:			LD      A,B
0416E3 E6 0F       2851   			AND     0FH
0416E5 D6 08       2852   			SUB     8
0416E7 D8          2853   			RET     C
0416E8 18 08       2854   			JR      SHL3
0416EA             2855   ;
0416EA CD 9B 16 04 2856   BIT_:			CALL    NUMBER
0416EE FE 08       2857   			CP      8
0416F0 3F          2858   			CCF
0416F1 D8          2859   			RET     C
0416F2 07          2860   SHL3:			RLCA
0416F3 07          2861   			RLCA
0416F4 07          2862   			RLCA
0416F5 B1          2863   ORC:			OR      C
0416F6 4F          2864   			LD      C,A
0416F7 C9          2865   			RET
0416F8             2866   ;
0416F8 21 B2 19 04 2867   LDOP:			LD      HL,LDOPS
0416FC             2868   
0416FC             2869   ;
0416FC             2870   ; Look up a value in a table
0416FC             2871   ; Parameters:
0416FC             2872   ; - IY: Address of the assembly language line in the BASIC program area
0416FC             2873   ; - HL: Address of the table
0416FC             2874   ; Returns:
0416FC             2875   ; - B: The operand code
0416FC             2876   ; - F: Carry set if not found
0416FC             2877   ;
0416FC CD 4D 17 04 2878   FIND:			CALL    SKIP			; Skip delimiters
041700             2879   ;
041700 06 00       2880   EXIT_:			LD      B,0			; Set B to 0
041702 37          2881   			SCF				; Set the carry flag
041703 C8          2882   			RET     Z			; Returns if Z
041704             2883   ;
041704 FE DD       2884   			CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
041706 28 04       2885   			JR      Z,FIND0
041708 FE 85       2886   			CP      TOR+1			; Special case for tokens AND and OR
04170A 3F          2887   			CCF
04170B D8          2888   			RET     C
04170C 7E          2889   FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
04170D B7          2890   			OR      A
04170E 28 F0       2891   			JR      Z,EXIT_			; Exit
041710 FD AE 00    2892   			XOR     (IY)
041713 E6 5F       2893   			AND     01011111B
041715 28 09       2894   			JR      Z,FIND2
041717 CB 7E       2895   FIND1:			BIT     7,(HL)
041719 23          2896   			INC     HL
04171A 28 FB       2897   			JR      Z,FIND1
04171C 23          2898   			INC     HL
04171D 04          2899   			INC     B
04171E 18 EC       2900   			JR      FIND0
041720             2901   ;
041720 FD E5       2902   FIND2:			PUSH    IY
041722 CB 7E       2903   FIND3:			BIT     7,(HL)			; Is this the end of token marker?
041724 FD 23       2904   			INC     IY
041726 23          2905   			INC     HL
041727 20 11       2906   			JR      NZ,FIND5		; Yes
041729 BE          2907   			CP      (HL)
04172A CC 4C 17 04 2908   			CALL    Z,SKIP0
04172E 7E          2909   			LD      A,(HL)
04172F FD AE 00    2910   			XOR     (IY)
041732 E6 5F       2911   			AND     01011111B
041734 28 EC       2912   			JR      Z,FIND3
041736 FD E1       2913   FIND4:			POP     IY
041738 18 DD       2914   			JR      FIND1
04173A             2915   ;
04173A CD F8 10 04 2916   FIND5:			CALL    DELIM			; Is it a delimiter?
04173E C4 61 17 04 2917   			CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
041742 C4 5B 17 04 2918   			CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
041746 20 EE       2919   			JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
041748             2920   ;
041748 78          2921   FIND6:			LD      A,B			; At this point we have a token
041749 46          2922   			LD      B,(HL)			; Fetch the token type code
04174A E1          2923   			POP     HL			; Restore the stack
04174B C9          2924   			RET
04174C             2925   ;
04174C 23          2926   SKIP0:			INC     HL
04174D CD F8 10 04 2927   SKIP:			CALL    DELIM			; Is it a delimiter?
041751 C0          2928   			RET     NZ			; No, so return
041752 CD 04 11 04 2929   			CALL    TERM			; Is it a terminator?
041756 C8          2930   			RET     Z			; Yes, so return
041757 FD 23       2931   			INC     IY			; Increment the basic program counter
041759 18 F2       2932   			JR      SKIP			; And loop
04175B             2933   ;
04175B FE 2B       2934   SIGN:			CP      '+'			; Check whether the character is a sign symbol
04175D C8          2935   			RET     Z
04175E FE 2D       2936   			CP      '-'
041760 C9          2937   			RET
041761             2938   ;
041761 FE 2E       2939   DOT:			CP	'.'			; Check if it is a dot character
041763 C9          2940   			RET
041764             2941   ; Z80 opcode list
041764             2942   ;
041764             2943   ; Group 0: (15 opcodes)
041764             2944   ; Trivial cases requiring no computation
041764             2945   ;
041764 4E 4F 50 00 2946   OPCODS:			DB	"NO","P"+80H,00h	; # 00h
041768 52 4C 43 41 2947   			DB	"RLC","A"+80H,07h
       07          
04176D 45 58 00 41 2948   			DB	"EX",0,"AF",0,"AF","'"+80H,08h
       46 00 41 46 
       27 08       
041777 52 52 43 41 2949   			DB	"RRC","A"+80H,0FH
       0F          
04177C 52 4C 41 17 2950   			DB	"RL","A"+80H,17H
041780 52 52 41 1F 2951   			DB	"RR","A"+80H,1FH
041784 44 41 41 27 2952   			DB	"DA","A"+80H,27H
041788 43 50 4C 2F 2953   			DB	"CP","L"+80H,2FH
04178C 53 43 46 37 2954   			DB	"SC","F"+80H,37H
041790 43 43 46 3F 2955   			DB	"CC","F"+80H,3FH
041794 48 41 4C 54 2956   			DB	"HAL","T"+80H,76H
       76          
041799 45 58 58 D9 2957   			DB	"EX","X"+80H,D9H
04179D 45 58 00 44 2958   			DB	"EX",0,"DE",0,"H","L"+80H,EBH
       45 00 48 4C 
       EB          
0417A6 44 49 F3    2959   			DB	"D","I"+80H,F3H
0417A9 45 49 FB    2960   			DB	"E","I"+80H,FBH
0417AC             2961   ;
0417AC             2962   ; Group 1: (53 opcodes)
0417AC             2963   ; As Group 0, but with an ED prefix
0417AC             2964   ;
0417AC 4E 45 47 44 2965   			DB	"NE","G"+80H,44H	; 0Fh
0417B0 49 4D 00 30 2966   			DB	"IM",0,"0"+80H,46H
       46          
0417B5 52 45 54 4E 2967   			DB	"RET","N"+80H,45H
       45          
0417BA 4D 4C 54 00 2968   			DB	"MLT",0,"B","C"+80H,4CH
       42 43 4C    
0417C1 52 45 54 49 2969   			DB	"RET","I"+80H,4DH
       4D          
0417C6 49 4D 00 31 2970   			DB	"IM",0,"1"+80H,56H
       56          
0417CB 4D 4C 54 00 2971   			DB	"MLT",0,"D","E"+80H,5CH
       44 45 5C    
0417D2 49 4D 00 32 2972   			DB	"IM",0,"2"+80H,5EH
       5E          
0417D7 52 52 44 67 2973   			DB	"RR","D"+80H,67H
0417DB 4D 4C 54 00 2974   			DB	"MLT",0,"H","L"+80H,6CH
       48 4C 6C    
0417E2 4C 44 00 4D 2975   			DB	"LD",0,"MB",0,"A"+80H,6DH
       42 00 41 6D 
0417EA 4C 44 00 41 2976   			DB	"LD",0,"A",0,"M","B"+80H,6EH
       00 4D 42 6E 
0417F2 52 4C 44 6F 2977   			DB	"RL","D"+80H,6FH
0417F6 53 4C 50 76 2978   			DB	"SL","P"+80H,76H
0417FA 4D 4C 54 00 2979   			DB	"MLT",0,"S","P"+80H,7CH
       53 50 7C    
041801 53 54 4D 49 2980   			DB	"STMI","X"+80H,7DH
       58 7D       
041807 52 53 4D 49 2981   			DB	"RSMI","X"+80H,7EH
       58 7E       
04180D 49 4E 49 4D 2982   			DB	"INI","M"+80H,82H
       82          
041812 4F 54 49 4D 2983   			DB	"OTI","M"+80H,83H
       83          
041817 49 4E 49 32 2984   			DB	"INI","2"+80H,84H
       84          
04181C 49 4E 44 4D 2985   			DB	"IND","M"+80H,8AH
       8A          
041821 4F 54 44 4D 2986   			DB	"OTD","M"+80H,8BH
       8B          
041826 49 4E 44 32 2987   			DB	"IND","2"+80H,8CH
       8C          
04182B 49 4E 49 4D 2988   			DB	"INIM","R"+80H,92H
       52 92       
041831 4F 54 49 4D 2989   			DB	"OTIM","R"+80H,93H
       52 93       
041837 49 4E 49 32 2990   			DB	"INI2","R"+80H,94H
       52 94       
04183D 49 4E 44 4D 2991   			DB	"INDM","R"+80H,9AH
       52 9A       
041843 4F 54 44 4D 2992   			DB	"OTDM","R"+80H,9BH
       52 9B       
041849 49 4E 44 32 2993   			DB	"IND2","R"+80H,9CH
       52 9C       
04184F 4C 44 49 A0 2994   			DB	"LD","I"+80H,A0H
041853 43 50 49 A1 2995   			DB	"CP","I"+80H,A1H
041857 49 4E 49 A2 2996   			DB	"IN","I"+80H,A2H
04185B 4F 55 54 49 2997   			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
       32 A4       
041861 4F 55 54 49 2998   			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
       A3          
041866 4C 44 44 A8 2999   			DB	"LD","D"+80H,A8H
04186A 43 50 44 A9 3000   			DB	"CP","D"+80H,A9H
04186E 49 4E 44 AA 3001   			DB	"IN","D"+80H,AAH
041872 4F 55 54 44 3002   			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
       32 AC       
041878 4F 55 54 44 3003   			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
       AB          
04187D 4C 44 49 52 3004   			DB	"LDI","R"+80H,B0H
       B0          
041882 43 50 49 52 3005   			DB	"CPI","R"+80H,B1H
       B1          
041887 49 4E 49 52 3006   			DB	"INI","R"+80H,B2H
       B2          
04188C 4F 54 49 52 3007   			DB	"OTI","R"+80H,B3H
       B3          
041891 4F 54 49 32 3008   			DB	"OTI2","R"+80H,B4H
       52 B4       
041897 4C 44 44 52 3009   			DB	"LDD","R"+80H,B8H
       B8          
04189C 43 50 44 52 3010   			DB	"CPD","R"+80H,B9H
       B9          
0418A1 49 4E 44 52 3011   			DB	"IND","R"+80H,BAH
       BA          
0418A6 4F 54 44 52 3012   			DB	"OTD","R"+80H,BBH
       BB          
0418AB 4F 54 44 32 3013   			DB	"OTD2","R"+80H,BCH
       52 BC       
0418B1 49 4E 49 52 3014   			DB	"INIR","X"+80H,C2H
       58 C2       
0418B7 4F 54 49 52 3015   			DB	"OTIR","X"+80H,C3H
       58 C3       
0418BD 49 4E 44 52 3016   			DB	"INDR","X"+80H,CAH
       58 CA       
0418C3 4F 54 44 52 3017   			DB	"OTDR","X"+80H,CBH
       58 CB       
0418C9             3018   ;
0418C9             3019   ; Group 2: (3 opcodes)
0418C9             3020   ;
0418C9 42 49 54 40 3021   			DB	"BI","T"+80H,40H	; 44h
0418CD 52 45 53 80 3022   			DB	"RE","S"+80H,80H
0418D1 53 45 54 C0 3023   			DB	"SE","T"+80H,C0H
0418D5             3024   ;
0418D5             3025   ; Group 3: (7 opcodes)
0418D5             3026   ;
0418D5 52 4C 43 00 3027   			DB	"RL","C"+80H,00H	; 47h
0418D9 52 52 43 08 3028   			DB	"RR","C"+80H,08H
0418DD 52 4C 10    3029   			DB	"R","L"+80H,10H
0418E0 52 52 18    3030   			DB	"R","R"+80H,18H
0418E3 53 4C 41 20 3031   			DB	"SL","A"+80H,20H
0418E7 53 52 41 28 3032   			DB	"SR","A"+80H,28H
0418EB 53 52 4C 38 3033   			DB	"SR","L"+80H,38H
0418EF             3034   ;
0418EF             3035   ; Group 4: (3 opcodes)
0418EF             3036   ;
0418EF 50 4F 50 C1 3037   			DB	"PO","P"+80H,C1H	; 4Eh
0418F3 50 55 53 48 3038   			DB	"PUS","H"+80H,C5H
       C5          
0418F8 45 58 00 28 3039   			DB	"EX",0,"(S","P"+80H,E3H
       53 50 E3    
0418FF             3040   ;
0418FF             3041   ; Group 5: (7 opcodes)
0418FF             3042   ;
0418FF 53 55 42 90 3043   			DB	"SU","B"+80H,90H	; 51h
041903 41 4E 44 A0 3044   			DB	"AN","D"+80H,A0H
041907 58 4F 52 A8 3045   			DB	"XO","R"+80H,A8H
04190B 4F 52 B0    3046   			DB	"O","R"+80H,B0H
04190E 43 50 B8    3047   			DB	"C","P"+80H,B8H
041911 80 A0       3048   			DB	TAND,A0H		; 56h TAND: Tokenised AND
041913 84 B0       3049   			DB	TOR,B0H			; 57h TOR: Tokenised OR
041915             3050   ;
041915             3051   ; Group 6 (3 opcodes)
041915             3052   ;
041915 41 44 44 80 3053   			DB	"AD","D"+80H,80H	; 58h
041919 41 44 43 88 3054   			DB	"AD","C"+80H,88H
04191D 53 42 43 98 3055   			DB	"SB","C"+80H,98H
041921             3056   ;
041921             3057   ; Group 7: (2 opcodes)
041921             3058   ;
041921 49 4E 43 04 3059   			DB	"IN","C"+80H,04H	; 5Bh
041925 44 45 43 05 3060   			DB	"DE","C"+80H,05H
041929             3061   ;
041929             3062   ; Group 8: (2 opcodes)
041929             3063   ;
041929 49 4E 30 00 3064   			DB	"IN","0"+80H,00H	; 5Dh
04192D 4F 55 54 30 3065   			DB	"OUT","0"+80H,01H
       01          
041932             3066   ;
041932             3067   ; Group 9: (1 opcode)
041932             3068   ;
041932 49 4E 40    3069   			DB	"I","N"+80H,40H		; 5Fh
041935             3070   ;
041935             3071   ; Group 10: (1 opcode)
041935             3072   ;
041935 4F 55 54 41 3073   			DB	"OU","T"+80H,41H	; 60h
041939             3074   ;
041939             3075   ; Group 11: (2 opcodes)
041939             3076   ;
041939 4A 52 20    3077   			DB	"J","R"+80H,20H		; 61h
04193C 44 4A 4E 5A 3078   			DB	"DJN","Z"+80H,10H
       10          
041941             3079   ;
041941             3080   ; Group 12: (1 opcode)
041941             3081   ;
041941 4A 50 C2    3082   			DB	"J","P"+80H,C2H		; 63h
041944             3083   ;
041944             3084   ; Group 13: (1 opcode)
041944             3085   ;
041944 43 41 4C 4C 3086   			DB	"CAL","L"+80H,C4H	; 64h
       C4          
041949             3087   ;
041949             3088   ; Group 14: (1 opcode)
041949             3089   ;
041949 52 53 54 C7 3090   			DB	"RS","T"+80H,C7H	; 65h
04194D             3091   ;
04194D             3092   ; Group 15: (1 opcode)
04194D             3093   ;
04194D 52 45 54 C0 3094   			DB	"RE","T"+80H,C0H	; 66h
041951             3095   ;
041951             3096   ; Group 16: (1 opcode)
041951             3097   ;
041951 4C 44 40    3098   			DB	"L","D"+80H,40H		; 67h
041954             3099   ;
041954             3100   ; Group 17: (1 opcode)
041954             3101   ;
041954 54 53 54 04 3102   			DB	"TS","T"+80H,04H	; 68h
041958             3103   
041958             3104   ;
041958             3105   ; Assembler Directives
041958             3106   ;
041958 4F 50 54 00 3107   			DB	"OP","T"+80H,00H	; 69h OPT
04195C 41 44 4C 00 3108   			DB	"AD","L"+80H,00H	; 6Ah ADL
041960             3109   ;
041960 5D 42 00    3110   			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
041963 5D 57 00    3111   			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
041966 5D 4C 00    3112   			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
041969 5D 4D 00    3113   			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
04196C             3114   ;
04196C 00          3115   			DB	0
04196D             3116   ;
04196D             3117   ; Operands
04196D             3118   ;
04196D 42 00       3119   OPRNDS:			DB	"B"+80H, 00H
04196F 43 01       3120   			DB	"C"+80H, 01H
041971 44 02       3121   			DB	"D"+80H, 02H
041973 45 03       3122   			DB	"E"+80H, 03H
041975 48 04       3123   			DB	"H"+80H, 04H
041977 4C 05       3124   			DB	"L"+80H, 05H
041979 28 48 4C 06 3125   			DB	"(H","L"+80H,06H
04197D 41 07       3126   			DB	"A"+80H, 07H
04197F 28 49 58 86 3127   			DB	"(I","X"+80H,86H
041983 28 49 59 C6 3128   			DB	"(I","Y"+80H,C6H
041987             3129   ;
041987 42 43 08    3130   			DB	"B","C"+80H,08H
04198A 44 45 0A    3131   			DB	"D","E"+80H,0AH
04198D 48 4C 0C    3132   			DB	"H","L"+80H,0CH
041990 49 58 8C    3133   			DB	"I","X"+80H,8CH
041993 49 59 CC    3134   			DB	"I","Y"+80H,CCH
041996 41 46 0E    3135   			DB	"A","F"+80H,0EH
041999 53 50 0E    3136   			DB	"S","P"+80H,0EH
04199C             3137   ;
04199C 4E 5A 10    3138   			DB	"N","Z"+80H,10H
04199F 5A 11       3139   			DB	"Z"+80H,11H
0419A1 4E 43 12    3140   			DB	"N","C"+80H,12H
0419A4 50 4F 14    3141   			DB	"P","O"+80H,14H
0419A7 50 45 15    3142   			DB	"P","E"+80H,15H
0419AA 50 16       3143   			DB	"P"+80H,16H
0419AC 4D 17       3144   			DB	"M"+80H,17H
0419AE             3145   ;
0419AE 28 43 20    3146   			DB	"(","C"+80H,20H
0419B1             3147   ;
0419B1 00          3148   			DB	0
0419B2             3149   ;
0419B2             3150   ; Load operations
0419B2             3151   ;
0419B2 49 00 41 47 3152   LDOPS:			DB	"I",0,"A"+80H,47H
0419B6 52 00 41 4F 3153   			DB	"R",0,"A"+80H,4FH
0419BA 41 00 49 57 3154   			DB	"A",0,"I"+80H,57H
0419BE 41 00 52 5F 3155   			DB	"A",0,"R"+80H,5FH
0419C2 28 42 43 00 3156   			DB	"(BC",0,"A"+80H,02h
       41 02       
0419C8 28 44 45 00 3157   			DB	"(DE",0,"A"+80H,12H
       41 12       
0419CE 41 00 28 42 3158   			DB	"A",0,"(B","C"+80H,0AH
       43 0A       
0419D4 41 00 28 44 3159   			DB	"A",0,"(D","E"+80H,1AH
       45 1A       
0419DA             3160   ;
0419DA 00          3161   			DB	0
0419DB             3162   ;
0419DB             3163   ; eZ80 addressing mode suffixes
0419DB             3164   ;
0419DB             3165   ; Fully qualified suffixes
0419DB             3166   ;
0419DB 4C 49 53 49 3167   EZ80SFS_1:		DB	"LI","S"+80H,49H
0419DF 53 49 4C 52 3168   			DB	"SI","L"+80H,52H
0419E3 53 49 53 40 3169   EZ80SFS_2:		DB	"SI","S"+80H,40H
0419E7 4C 49 4C 5B 3170   			DB	"LI","L"+80H,5BH
0419EB             3171   ;
0419EB 00          3172   			DB	0
0419EC             3173   ;
0419EC             3174   ; Shortcuts when ADL mode is 0
0419EC             3175   ;
0419EC 53 40       3176   EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
0419EE 4C 49       3177   			DB	"L"+80H,49H		; Equivalent to .LIS
0419F0 49 53 40    3178   			DB	"I","S"+80H,40H		; Equivalent to .SIS
0419F3 49 4C 52    3179   			DB	"I","L"+80H,52H		; Equivalent to .SIL
0419F6             3180   ;
0419F6 00          3181   			DB	0
0419F7             3182   ;
0419F7             3183   ; Shortcuts when ADL mode is 1
0419F7             3184   ;
0419F7 53 52       3185   EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
0419F9 4C 5B       3186   			DB	"L"+80H,5BH		; Equivalent to .LIL
0419FB 49 53 49    3187   			DB	"I","S"+80H,49H		; Equivalent to .LIS
0419FE 49 4C 5B    3188   			DB	"I","L"+80H,5BH		; Equivalent to .LIL
041A01             3189   ;
041A01 00          3190   			DB	0
041A02             3191   ;
041A02             3192   ; .LIST
041A02             3193   ;
041A02             3194   ; already defined in equs.inc
041A02             3195   ; LF:			EQU     0AH
041A02             3196   ; CR:			EQU     0DH
041A02             3197   
041A02             3198   ; ===== STUB FUNCTIONS =====
041A02             3199   printInline:
041A02 C9          3200       ret
041A03             3201   
041A03             3202   AUTO:
041A03 CD 02 1A 04 3203   	call printInline
041A07 65 78 65 63 3204   	asciz "exec.asm called AUTO!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       41 55 54 4F 
       21 00       
041A1D C9          3205   	ret
041A1E             3206   
041A1E             3207   BRAKET:
041A1E CD 02 1A 04 3208   	call printInline
041A22 65 78 65 63 3209   	asciz "exec.asm called BRAKET!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       42 52 41 4B 
       45 54 21 00 
041A3A C9          3210   	ret
041A3B             3211   
041A3B             3212   CLEAR:
041A3B CD 02 1A 04 3213   	call printInline
041A3F 65 78 65 63 3214   	asciz "exec.asm called CLEAR!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       43 4C 45 41 
       52 21 00    
041A56 C9          3215   	ret
041A57             3216   
041A57             3217   CLG:
041A57 CD 02 1A 04 3218   	call printInline
041A5B 65 78 65 63 3219   	asciz "exec.asm called CLG!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       43 4C 47 21 
       00          
041A70 C9          3220   	ret
041A71             3221   
041A71             3222   CLOOP:
041A71 CD 02 1A 04 3223   	call printInline
041A75 65 78 65 63 3224   	asciz "exec.asm called CLOOP!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       43 4C 4F 4F 
       50 21 00    
041A8C C9          3225   	ret
041A8D             3226   
041A8D             3227   CLRSCN:
041A8D CD 02 1A 04 3228   	call printInline
041A91 65 78 65 63 3229   	asciz "exec.asm called CLRSCN!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       43 4C 52 53 
       43 4E 21 00 
041AA9 C9          3230   	ret
041AAA             3231   
041AAA             3232   COLOUR:
041AAA CD 02 1A 04 3233   	call printInline
041AAE 65 78 65 63 3234   	asciz "exec.asm called COLOUR!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       43 4F 4C 4F 
       55 52 21 00 
041AC6 C9          3235   	ret
041AC7             3236   
041AC7             3237   COMMA:
041AC7 CD 02 1A 04 3238   	call printInline
041ACB 65 78 65 63 3239   	asciz "exec.asm called COMMA!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       43 4F 4D 4D 
       41 21 00    
041AE2 C9          3240   	ret
041AE3             3241   
041AE3             3242   CONS:
041AE3 CD 02 1A 04 3243   	call printInline
041AE7 65 78 65 63 3244   	asciz "exec.asm called CONS!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       43 4F 4E 53 
       21 00       
041AFD C9          3245   	ret
041AFE             3246   
041AFE             3247   CREATE:
041AFE CD 02 1A 04 3248   	call printInline
041B02 65 78 65 63 3249   	asciz "exec.asm called CREATE!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       43 52 45 41 
       54 45 21 00 
041B1A C9          3250   	ret
041B1B             3251   
041B1B             3252   CRLF:
041B1B CD 02 1A 04 3253   	call printInline
041B1F 65 78 65 63 3254   	asciz "exec.asm called CRLF!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       43 52 4C 46 
       21 00       
041B35 C9          3255   	ret
041B36             3256   
041B36             3257   DATAPTR:
041B36 CD 02 1A 04 3258   	call printInline
041B3A 65 78 65 63 3259   	asciz "exec.asm called DATAPTR!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       44 41 54 41 
       50 54 52 21 
       00          
041B53 C9          3260   	ret
041B54             3261   
041B54             3262   DELETE:
041B54 CD 02 1A 04 3263   	call printInline
041B58 65 78 65 63 3264   	asciz "exec.asm called DELETE!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       44 45 4C 45 
       54 45 21 00 
041B70 C9          3265   	ret
041B71             3266   
041B71             3267   DLOAD5:
041B71 CD 02 1A 04 3268   	call printInline
041B75 65 78 65 63 3269   	asciz "exec.asm called DLOAD5!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       44 4C 4F 41 
       44 35 21 00 
041B8D C9          3270   	ret
041B8E             3271   
041B8E             3272   DLOAD5_SPL:
041B8E CD 02 1A 04 3273   	call printInline
041B92 65 78 65 63 3274   	asciz "exec.asm called DLOAD5_SPL!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       44 4C 4F 41 
       44 35 5F 53 
       50 4C 21 00 
041BAE C9          3275   	ret
041BAF             3276   
041BAF             3277   DRAW:
041BAF CD 02 1A 04 3278   	call printInline
041BB3 65 78 65 63 3279   	asciz "exec.asm called DRAW!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       44 52 41 57 
       21 00       
041BC9 C9          3280   	ret
041BCA             3281   
041BCA             3282   ENVEL:
041BCA CD 02 1A 04 3283   	call printInline
041BCE 65 78 65 63 3284   	asciz "exec.asm called ENVEL!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       45 4E 56 45 
       4C 21 00    
041BE5 C9          3285   	ret
041BE6             3286   
041BE6             3287   ERROR_:
041BE6 CD 02 1A 04 3288   	call printInline
041BEA 65 78 65 63 3289   	asciz "exec.asm called ERROR_!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       45 52 52 4F 
       52 5F 21 00 
041C02 C9          3290   	ret
041C03             3291   
041C03             3292   EXPR:
041C03 CD 02 1A 04 3293   	call printInline
041C07 65 78 65 63 3294   	asciz "exec.asm called EXPR!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       45 58 50 52 
       21 00       
041C1D C9          3295   	ret
041C1E             3296   
041C1E             3297   EXPRI:
041C1E CD 02 1A 04 3298   	call printInline
041C22 65 78 65 63 3299   	asciz "exec.asm called EXPRI!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       45 58 50 52 
       49 21 00    
041C39 C9          3300   	ret
041C3A             3301   
041C3A             3302   EXPRN:
041C3A CD 02 1A 04 3303   	call printInline
041C3E 65 78 65 63 3304   	asciz "exec.asm called EXPRN!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       45 58 50 52 
       4E 21 00    
041C55 C9          3305   	ret
041C56             3306   
041C56             3307   EXPRS:
041C56 CD 02 1A 04 3308   	call printInline
041C5A 65 78 65 63 3309   	asciz "exec.asm called EXPRS!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       45 58 50 52 
       53 21 00    
041C71 C9          3310   	ret
041C72             3311   
041C72             3312   FINDL:
041C72 CD 02 1A 04 3313   	call printInline
041C76 65 78 65 63 3314   	asciz "exec.asm called FINDL!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       46 49 4E 44 
       4C 21 00    
041C8D C9          3315   	ret
041C8E             3316   
041C8E             3317   FPP:
041C8E CD 02 1A 04 3318   	call printInline
041C92 65 78 65 63 3319   	asciz "exec.asm called FPP!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       46 50 50 21 
       00          
041CA7 C9          3320   	ret
041CA8             3321   
041CA8             3322   GCOL:
041CA8 CD 02 1A 04 3323   	call printInline
041CAC 65 78 65 63 3324   	asciz "exec.asm called GCOL!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       47 43 4F 4C 
       21 00       
041CC2 C9          3325   	ret
041CC3             3326   
041CC3             3327   GETDEF:
041CC3 CD 02 1A 04 3328   	call printInline
041CC7 65 78 65 63 3329   	asciz "exec.asm called GETDEF!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       47 45 54 44 
       45 46 21 00 
041CDF C9          3330   	ret
041CE0             3331   
041CE0             3332   GETVAR:
041CE0 CD 02 1A 04 3333   	call printInline
041CE4 65 78 65 63 3334   	asciz "exec.asm called GETVAR!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       47 45 54 56 
       41 52 21 00 
041CFC C9          3335   	ret
041CFD             3336   
041CFD             3337   HEXSTR:
041CFD CD 02 1A 04 3338   	call printInline
041D01 65 78 65 63 3339   	asciz "exec.asm called HEXSTR!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       48 45 58 53 
       54 52 21 00 
041D19 C9          3340   	ret
041D1A             3341   
041D1A             3342   ITEMI:
041D1A CD 02 1A 04 3343   	call printInline
041D1E 65 78 65 63 3344   	asciz "exec.asm called ITEMI!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       49 54 45 4D 
       49 21 00    
041D35 C9          3345   	ret
041D36             3346   
041D36             3347   LIST_:
041D36 CD 02 1A 04 3348   	call printInline
041D3A 65 78 65 63 3349   	asciz "exec.asm called LIST_!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4C 49 53 54 
       5F 21 00    
041D51 C9          3350   	ret
041D52             3351   
041D52             3352   LOAD:
041D52 CD 02 1A 04 3353   	call printInline
041D56 65 78 65 63 3354   	asciz "exec.asm called LOAD!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4C 4F 41 44 
       21 00       
041D6C C9          3355   	ret
041D6D             3356   
041D6D             3357   LOAD0:
041D6D CD 02 1A 04 3358   	call printInline
041D71 65 78 65 63 3359   	asciz "exec.asm called LOAD0!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4C 4F 41 44 
       30 21 00    
041D88 C9          3360   	ret
041D89             3361   
041D89             3362   LOAD4:
041D89 CD 02 1A 04 3363   	call printInline
041D8D 65 78 65 63 3364   	asciz "exec.asm called LOAD4!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4C 4F 41 44 
       34 21 00    
041DA4 C9          3365   	ret
041DA5             3366   
041DA5             3367   LOADN:
041DA5 CD 02 1A 04 3368   	call printInline
041DA9 65 78 65 63 3369   	asciz "exec.asm called LOADN!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4C 4F 41 44 
       4E 21 00    
041DC0 C9          3370   	ret
041DC1             3371   
041DC1             3372   LOADS:
041DC1 CD 02 1A 04 3373   	call printInline
041DC5 65 78 65 63 3374   	asciz "exec.asm called LOADS!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4C 4F 41 44 
       53 21 00    
041DDC C9          3375   	ret
041DDD             3376   
041DDD             3377   MODE:
041DDD CD 02 1A 04 3378   	call printInline
041DE1 65 78 65 63 3379   	asciz "exec.asm called MODE!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4D 4F 44 45 
       21 00       
041DF7 C9          3380   	ret
041DF8             3381   
041DF8             3382   MOVE:
041DF8 CD 02 1A 04 3383   	call printInline
041DFC 65 78 65 63 3384   	asciz "exec.asm called MOVE!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4D 4F 56 45 
       21 00       
041E12 C9          3385   	ret
041E13             3386   
041E13             3387   NEW:
041E13 CD 02 1A 04 3388   	call printInline
041E17 65 78 65 63 3389   	asciz "exec.asm called NEW!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4E 45 57 21 
       00          
041E2C C9          3390   	ret
041E2D             3391   
041E2D             3392   NXT:
041E2D CD 02 1A 04 3393   	call printInline
041E31 65 78 65 63 3394   	asciz "exec.asm called NXT!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4E 58 54 21 
       00          
041E46 C9          3395   	ret
041E47             3396   
041E47             3397   OLD:
041E47 CD 02 1A 04 3398   	call printInline
041E4B 65 78 65 63 3399   	asciz "exec.asm called OLD!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 4C 44 21 
       00          
041E60 C9          3400   	ret
041E61             3401   
041E61             3402   OSBGET:
041E61 CD 02 1A 04 3403   	call printInline
041E65 65 78 65 63 3404   	asciz "exec.asm called OSBGET!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 53 42 47 
       45 54 21 00 
041E7D C9          3405   	ret
041E7E             3406   
041E7E             3407   OSBPUT:
041E7E CD 02 1A 04 3408   	call printInline
041E82 65 78 65 63 3409   	asciz "exec.asm called OSBPUT!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 53 42 50 
       55 54 21 00 
041E9A C9          3410   	ret
041E9B             3411   
041E9B             3412   OSCALL:
041E9B CD 02 1A 04 3413   	call printInline
041E9F 65 78 65 63 3414   	asciz "exec.asm called OSCALL!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 53 43 41 
       4C 4C 21 00 
041EB7 C9          3415   	ret
041EB8             3416   
041EB8             3417   OSCLI:
041EB8 CD 02 1A 04 3418   	call printInline
041EBC 65 78 65 63 3419   	asciz "exec.asm called OSCLI!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 53 43 4C 
       49 21 00    
041ED3 C9          3420   	ret
041ED4             3421   
041ED4             3422   OSLINE:
041ED4 CD 02 1A 04 3423   	call printInline
041ED8 65 78 65 63 3424   	asciz "exec.asm called OSLINE!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 53 4C 49 
       4E 45 21 00 
041EF0 C9          3425   	ret
041EF1             3426   
041EF1             3427   OSSHUT:
041EF1 CD 02 1A 04 3428   	call printInline
041EF5 65 78 65 63 3429   	asciz "exec.asm called OSSHUT!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 53 53 48 
       55 54 21 00 
041F0D C9          3430   	ret
041F0E             3431   
041F0E             3432   OSWRCH:
041F0E CD 02 1A 04 3433   	call printInline
041F12 65 78 65 63 3434   	asciz "exec.asm called OSWRCH!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 53 57 52 
       43 48 21 00 
041F2A C9          3435   	ret
041F2B             3436   
041F2B             3437   OUTCHR:
041F2B CD 02 1A 04 3438   	call printInline
041F2F 65 78 65 63 3439   	asciz "exec.asm called OUTCHR!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 55 54 43 
       48 52 21 00 
041F47 C9          3440   	ret
041F48             3441   
041F48             3442   OUT_:
041F48 CD 02 1A 04 3443   	call printInline
041F4C 65 78 65 63 3444   	asciz "exec.asm called OUT_!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       4F 55 54 5F 
       21 00       
041F62 C9          3445   	ret
041F63             3446   
041F63             3447   PBCDL:
041F63 CD 02 1A 04 3448   	call printInline
041F67 65 78 65 63 3449   	asciz "exec.asm called PBCDL!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       50 42 43 44 
       4C 21 00    
041F7E C9          3450   	ret
041F7F             3451   
041F7F             3452   PLOT:
041F7F CD 02 1A 04 3453   	call printInline
041F83 65 78 65 63 3454   	asciz "exec.asm called PLOT!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       50 4C 4F 54 
       21 00       
041F99 C9          3455   	ret
041F9A             3456   
041F9A             3457   POPS:
041F9A CD 02 1A 04 3458   	call printInline
041F9E 65 78 65 63 3459   	asciz "exec.asm called POPS!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       50 4F 50 53 
       21 00       
041FB4 C9          3460   	ret
041FB5             3461   
041FB5             3462   PUSHS:
041FB5 CD 02 1A 04 3463   	call printInline
041FB9 65 78 65 63 3464   	asciz "exec.asm called PUSHS!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       50 55 53 48 
       53 21 00    
041FD0 C9          3465   	ret
041FD1             3466   
041FD1             3467   PUTCSR:
041FD1 CD 02 1A 04 3468   	call printInline
041FD5 65 78 65 63 3469   	asciz "exec.asm called PUTCSR!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       50 55 54 43 
       53 52 21 00 
041FED C9          3470   	ret
041FEE             3471   
041FEE             3472   PUTIME:
041FEE CD 02 1A 04 3473   	call printInline
041FF2 65 78 65 63 3474   	asciz "exec.asm called PUTIME!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       50 55 54 49 
       4D 45 21 00 
04200A C9          3475   	ret
04200B             3476   
04200B             3477   PUTIMS:
04200B CD 02 1A 04 3478   	call printInline
04200F 65 78 65 63 3479   	asciz "exec.asm called PUTIMS!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       50 55 54 49 
       4D 53 21 00 
042027 C9          3480   	ret
042028             3481   
042028             3482   PUTPTR:
042028 CD 02 1A 04 3483   	call printInline
04202C 65 78 65 63 3484   	asciz "exec.asm called PUTPTR!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       50 55 54 50 
       54 52 21 00 
042044 C9          3485   	ret
042045             3486   
042045             3487   PUTVAR:
042045 CD 02 1A 04 3488   	call printInline
042049 65 78 65 63 3489   	asciz "exec.asm called PUTVAR!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       50 55 54 56 
       41 52 21 00 
042061 C9          3490   	ret
042062             3491   
042062             3492   RENUM:
042062 CD 02 1A 04 3493   	call printInline
042066 65 78 65 63 3494   	asciz "exec.asm called RENUM!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       52 45 4E 55 
       4D 21 00    
04207D C9          3495   	ret
04207E             3496   
04207E             3497   REPORT:
04207E CD 02 1A 04 3498   	call printInline
042082 65 78 65 63 3499   	asciz "exec.asm called REPORT!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       52 45 50 4F 
       52 54 21 00 
04209A C9          3500   	ret
04209B             3501   
04209B             3502   SAVE:
04209B CD 02 1A 04 3503   	call printInline
04209F 65 78 65 63 3504   	asciz "exec.asm called SAVE!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       53 41 56 45 
       21 00       
0420B5 C9          3505   	ret
0420B6             3506   
0420B6             3507   SAYLN:
0420B6 CD 02 1A 04 3508   	call printInline
0420BA 65 78 65 63 3509   	asciz "exec.asm called SAYLN!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       53 41 59 4C 
       4E 21 00    
0420D1 C9          3510   	ret
0420D2             3511   
0420D2             3512   SETLIN:
0420D2 CD 02 1A 04 3513   	call printInline
0420D6 65 78 65 63 3514   	asciz "exec.asm called SETLIN!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       53 45 54 4C 
       49 4E 21 00 
0420EE C9          3515   	ret
0420EF             3516   
0420EF             3517   SFIX:
0420EF CD 02 1A 04 3518   	call printInline
0420F3 65 78 65 63 3519   	asciz "exec.asm called SFIX!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       53 46 49 58 
       21 00       
042109 C9          3520   	ret
04210A             3521   
04210A             3522   SOUND:
04210A CD 02 1A 04 3523   	call printInline
04210E 65 78 65 63 3524   	asciz "exec.asm called SOUND!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       53 4F 55 4E 
       44 21 00    
042125 C9          3525   	ret
042126             3526   
042126             3527   STR:
042126 CD 02 1A 04 3528   	call printInline
04212A 65 78 65 63 3529   	asciz "exec.asm called STR!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       53 54 52 21 
       00          
04213F C9          3530   	ret
042140             3531   
042140             3532   SWAP:
042140 CD 02 1A 04 3533   	call printInline
042144 65 78 65 63 3534   	asciz "exec.asm called SWAP!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       53 57 41 50 
       21 00       
04215A C9          3535   	ret
04215B             3536   
04215B             3537   TELL:
04215B CD 02 1A 04 3538   	call printInline
04215F 65 78 65 63 3539   	asciz "exec.asm called TELL!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       54 45 4C 4C 
       21 00       
042175 C9          3540   	ret
042176             3541   
042176             3542   TEST:
042176 CD 02 1A 04 3543   	call printInline
04217A 65 78 65 63 3544   	asciz "exec.asm called TEST!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       54 45 53 54 
       21 00       
042190 C9          3545   	ret
042191             3546   
042191             3547   TRAP:
042191 CD 02 1A 04 3548   	call printInline
042195 65 78 65 63 3549   	asciz "exec.asm called TRAP!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       54 52 41 50 
       21 00       
0421AB C9          3550   	ret
0421AC             3551   
0421AC             3552   VAL0:
0421AC CD 02 1A 04 3553   	call printInline
0421B0 65 78 65 63 3554   	asciz "exec.asm called VAL0!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       56 41 4C 30 
       21 00       
0421C6 C9          3555   	ret
0421C7             3556   
0421C7             3557   WARM:
0421C7 CD 02 1A 04 3558   	call printInline
0421CB 65 78 65 63 3559   	asciz "exec.asm called WARM!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       57 41 52 4D 
       21 00       
0421E1 C9          3560   	ret
0421E2             3561   
0421E2             3562   ZERO:
0421E2 CD 02 1A 04 3563   	call printInline
0421E6 65 78 65 63 3564   	asciz "exec.asm called ZERO!"
       2E 61 73 6D 
       20 63 61 6C 
       6C 65 64 20 
       5A 45 52 4F 
       21 00       
0421FC C9          3565   	ret
