PC     Output      Line
040000             0001        .assume adl=1
040000             0002        .org 0x040000
040000             0003    
040000 C3 45 00 04 0004        jp start
040004             0005    
040004 FF FF FF FF 0006        .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0007        .db "MOS"
040043 00          0008        .db 00h
040044 01          0009        .db 01h
040045             0010    
040045             0011    start:
040045 F5          0012        push af
040046 C5          0013        push bc
040047 D5          0014        push de
040048 DD E5       0015        push ix
04004A FD E5       0016        push iy
04004C             0017    
04004C             0018        ; jp temp
04004C CD 3D 10 04 0019        call init
040050 CD 6F 10 04 0020        call main
040054             0021    
040054             0022    exit:
040054 FD E1       0023        pop iy
040056 DD E1       0024        pop ix
040058 D1          0025        pop de
040059 C1          0026        pop bc
04005A F1          0027        pop af
04005B 21 00 00 00 0028        ld hl,0
04005F             0029    
04005F C9          0030        ret
040060             0031    
040060             0032        include "mos_api.inc"
040060             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*   ;
040060             0003*   ; Title:	AGON MOS - API for user projects
040060             0004*   ; Author:	Dean Belfield
040060             0005*   ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0006*   ;			Added MOS error codes for return in HL
040060             0007*   ; Created:	03/08/2022
040060             0008*   ; Last Updated:	10/08/2023
040060             0009*   ;
040060             0010*   ; Modinfo:
040060             0011*   ; 05/08/2022:	Added mos_feof
040060             0012*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0013*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0014*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0015*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0016*   ; 13/10/2022:	Added mos_oscli
040060             0017*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0018*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0019*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0020*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0021*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0022*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0023*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0024*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0025*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0026*   ; 19/05/2023:	Added sysvar_scrMode
040060             0027*   ; 05/06/2023:	Added sysvar_rtcEnable
040060             0028*   ; 03/08/2023:	Added mos_setkbvector
040060             0029*   ; 10/08/2023:	Added mos_getkbmap
040060             0030*   
040060             0031*   ; VDP control (VDU 23, 0, n)
040060             0032*   ;
040060             0033*   vdp_gp:				EQU 80h
040060             0034*   vdp_keycode:		EQU 81h
040060             0035*   vdp_cursor:			EQU	82h
040060             0036*   vdp_scrchar:		EQU	83h
040060             0037*   vdp_scrpixel:		EQU	84h
040060             0038*   vdp_audio:			EQU	85h
040060             0039*   vdp_mode:			EQU	86h
040060             0040*   vdp_rtc:			EQU	87h
040060             0041*   vdp_keystate:		EQU	88h
040060             0042*   vdp_logicalcoords:	EQU	C0h
040060             0043*   vdp_terminalmode:	EQU	FFh
040060             0044*   
040060             0045*   ;
040060             0046*   ; Macro for calling the API
040060             0047*   ; Parameters:
040060             0048*   ; - function: One of the function numbers listed below
040060             0049*   ;
040060             0050*   	MACRO	MOSCALL	function
040060             0051*   			LD	A, function
040060             0052*   			RST.LIL	08h
040060             0053*   	ENDMACRO
040060             0054*   
040060             0055*   ; MOS high level functions
040060             0056*   ;
040060             0057*   ; Get keycode
040060             0058*   ; Returns:
040060             0059*   ;  A: ASCII code of key pressed, or 0 if no key pressed
040060             0060*   mos_getkey:			EQU	00h
040060             0061*   
040060             0062*   ; Load an area of memory from a file.
040060             0063*   ; HLU: Address of filename (zero terminated)
040060             0064*   ; DEU: Address at which to load
040060             0065*   ; BCU: Maximum allowed size (bytes)
040060             0066*   ; Returns:
040060             0067*   ; - A: File error, or 0 if OK
040060             0068*   ; - F: Carry reset indicates no room for file.
040060             0069*   mos_load:			EQU	01h
040060             0070*   
040060             0071*   ; Save a file to the SD card from RAM
040060             0072*   ; HLU: Address of filename (zero terminated)
040060             0073*   ; DEU: Address to save from
040060             0074*   ; BCU: Number of bytes to save
040060             0075*   ; Returns:
040060             0076*   ; - A: File error, or 0 if OK
040060             0077*   ; - F: Carry reset indicates no room for file
040060             0078*   mos_save:			EQU	02h
040060             0079*   
040060             0080*   ; Change directory
040060             0081*   ; HLU: Address of path (zero terminated)
040060             0082*   ; Returns:
040060             0083*   ; - A: File error, or 0 if OK
040060             0084*   mos_cd:				EQU	03h
040060             0085*   
040060             0086*   ; Directory listing
040060             0087*   ; HLU: Address of path (zero terminated)
040060             0088*   ; Returns:
040060             0089*   ; - A: File error, or 0 if OK
040060             0090*   mos_dir:			EQU	04h
040060             0091*   
040060             0092*   ; Delete a file from the SD card
040060             0093*   ; HLU: Address of filename (zero terminated)
040060             0094*   ; Returns:
040060             0095*   ; - A: File error, or 0 if OK
040060             0096*   mos_del:			EQU	05h
040060             0097*   
040060             0098*   ; Rename a file on the SD card
040060             0099*   ; HLU: Address of filename1 (zero terminated)
040060             0100*   ; DEU: Address of filename2 (zero terminated)
040060             0101*   ; Returns:
040060             0102*   ; - A: File error, or 0 if OK
040060             0103*   mos_ren:			EQU	06h
040060             0104*   
040060             0105*   ; Make a folder on the SD card
040060             0106*   ; HLU: Address of filename (zero terminated)
040060             0107*   ; Returns:
040060             0108*   ; - A: File error, or 0 if OK
040060             0109*   mos_mkdir:			EQU	07h
040060             0110*   
040060             0111*   ; Get a pointer to a system variable
040060             0112*   ; Returns:
040060             0113*   ; IXU: Pointer to system variables (see mos_api.asm for more details)
040060             0114*   mos_sysvars:		EQU	08h
040060             0115*   
040060             0116*   ; Invoke the line editor
040060             0117*   ; HLU: Address of the buffer
040060             0118*   ; BCU: Buffer length
040060             0119*   ;   E: 0 to not clear buffer, 1 to clear
040060             0120*   ; Returns:
040060             0121*   ;   A: Key that was used to exit the input loop (CR=13, ESC=27)
040060             0122*   mos_editline:		EQU	09h
040060             0123*   
040060             0124*   ; Open a file
040060             0125*   ; HLU: Filename
040060             0126*   ;   C: Mode
040060             0127*   ; Returns:
040060             0128*   ;   A: Filehandle, or 0 if couldn't open
040060             0129*   mos_fopen:			EQU	0Ah
040060             0130*   
040060             0131*   ; Close a file
040060             0132*   ;   C: Filehandle
040060             0133*   ; Returns
040060             0134*   ;   A: Number of files still open
040060             0135*   mos_fclose:			EQU	0Bh
040060             0136*   
040060             0137*   ; Get a character from a file
040060             0138*   ;   C: Filehandle
040060             0139*   ; Returns:
040060             0140*   ;   A: Character read
040060             0141*   ;   F: C set if last character in file, otherwise NC
040060             0142*   mos_fgetc:			EQU	0Ch
040060             0143*   
040060             0144*   ; Write a character to a file
040060             0145*   ;   C: Filehandle
040060             0146*   ;   B: Character to write
040060             0147*   mos_fputc:			EQU	0Dh
040060             0148*   
040060             0149*   ; Check whether we're at the end of the file
040060             0150*   ;   C: Filehandle
040060             0151*   ; Returns:
040060             0152*   ;   A: 1 if at end of file, otherwise 0
040060             0153*   mos_feof:			EQU	0Eh
040060             0154*   
040060             0155*   ; Copy an error message
040060             0156*   ;   E: The error code
040060             0157*   ; HLU: Address of buffer to copy message into
040060             0158*   ; BCU: Size of buffer
040060             0159*   mos_getError:		EQU	0Fh
040060             0160*   
040060             0161*   ; Execute a MOS command
040060             0162*   ; HLU: Pointer the the MOS command string
040060             0163*   ; DEU: Pointer to additional command structure
040060             0164*   ; BCU: Number of additional commands
040060             0165*   ; Returns:
040060             0166*   ;   A: MOS error code
040060             0167*   mos_oscli:			EQU	10h
040060             0168*   
040060             0169*   ; Copy a file on the SD card
040060             0170*   ; HLU: Address of filename1 (zero terminated)
040060             0171*   ; DEU: Address of filename2 (zero terminated)
040060             0172*   ; Returns:
040060             0173*   ; - A: File error, or 0 if OK
040060             0174*   mos_copy:			EQU	11h
040060             0175*   
040060             0176*   ; Fetch a RTC string
040060             0177*   ; HLU: Pointer to a buffer to copy the string to
040060             0178*   ; Returns:
040060             0179*   ;   A: Length of time
040060             0180*   mos_getrtc:			EQU	12h
040060             0181*   
040060             0182*   ; Set the RTC
040060             0183*   ; HLU: Pointer to a buffer with the time data in
040060             0184*   mos_setrtc:			EQU	13h
040060             0185*   
040060             0186*   ; Set an interrupt vector
040060             0187*   ; HLU: Pointer to the interrupt vector (24-bit pointer)
040060             0188*   ;   E: Vector # to set
040060             0189*   ; Returns:
040060             0190*   ; HLU: Pointer to the previous vector
040060             0191*   mos_setintvector:	EQU	14h
040060             0192*   
040060             0193*   ; Open UART1
040060             0194*   ; IXU: Pointer to UART struct
040060             0195*   ;	+0: Baud rate (24-bit, little endian)
040060             0196*   ;	+3: Data bits
040060             0197*   ;	+4: Stop bits
040060             0198*   ;	+5: Parity bits
040060             0199*   ;	+6: Flow control (0: None, 1: Hardware)
040060             0200*   ;	+7: Enabled interrupts
040060             0201*   ; Returns:
040060             0202*   ;   A: Error code (0 = no error)
040060             0203*   mos_uopen:			EQU	15h
040060             0204*   
040060             0205*   ; Close UART1
040060             0206*   mos_uclose:			EQU	16h
040060             0207*   
040060             0208*   ; Get a character from UART1
040060             0209*   ; Returns:
040060             0210*   ;   A: Character read
040060             0211*   ;   F: C if successful
040060             0212*   ;   F: NC if the UART is not open
040060             0213*   mos_ugetc:			EQU	17h
040060             0214*   
040060             0215*   ; Write a character to UART1
040060             0216*   ;   C: Character to write
040060             0217*   ; Returns:
040060             0218*   ;   F: C if successful
040060             0219*   ;   F: NC if the UART is not open
040060             0220*   mos_uputc:			EQU	18h
040060             0221*   
040060             0222*   ; Convert a file handle to a FIL structure pointer
040060             0223*   ;   C: Filehandle
040060             0224*   ; Returns:
040060             0225*   ; HLU: Pointer to a FIL struct
040060             0226*   mos_getfil:			EQU	19h
040060             0227*   
040060             0228*   ; Read a block of data from a file
040060             0229*   ;   C: Filehandle
040060             0230*   ; HLU: Pointer to where to write the data to
040060             0231*   ; DEU: Number of bytes to read
040060             0232*   ; Returns:
040060             0233*   ; DEU: Number of bytes read
040060             0234*   mos_fread:			EQU	1Ah
040060             0235*   
040060             0236*   ; Write a block of data to a file
040060             0237*   ;  C: Filehandle
040060             0238*   ; HLU: Pointer to where the data is
040060             0239*   ; DEU: Number of bytes to write
040060             0240*   ; Returns:
040060             0241*   ; DEU: Number of bytes read
040060             0242*   mos_fwrite:			EQU	1Bh
040060             0243*   
040060             0244*   ; Move the read/write pointer in a file
040060             0245*   ;   C: Filehandle
040060             0246*   ; HLU: Least significant 3 bytes of the offset from the start of the file (DWORD)
040060             0247*   ;   E: Most significant byte of the offset
040060             0248*   ; Returns:
040060             0249*   ;   A: FRESULT
040060             0250*   mos_flseek:			EQU	1Ch
040060             0251*   
040060             0252*   ; Move the read/write pointer in a file relative to the current position
040060             0253*   ;   C: Filehandle
040060             0254*   ; DEU: Signed 24-bit offset
040060             0255*   ; Returns:
040060             0256*   ;   A: FRESULT
040060             0257*   mos_api_flseek_rel:
040060 C5          0258*   	push bc ; back up file handle in c
040061 D5          0259*   	push de ; save offset
040062             0260*   	MOSCALL mos_getfil
040062 3E 19       0001*M1 			LD	A, function
040064 5B CF       0002*M1 			RST.LIL	08h
040066 E5          0261*   	push hl
040067 FD E1       0262*   	pop iy ; iy points to FIL struct
040069 FD 27 11    0263*   	ld hl,(iy+fil_fptr) ; get lowest 3 bytes of current position
04006C AF          0264*   	xor a ; clear carry
04006D D1          0265*   	pop de ; restore offset
04006E ED 5A       0266*   	adc hl,de ; adc the offset because we need sign flag
040070 F2 78 00 04 0267*   	jp p,@not_neg
040074 21 00 00 00 0268*   	ld hl,0 ; seek to beginning of file
040078             0269*   @not_neg:
040078 C1          0270*   	pop bc ; restore file handle to c
040079 1E 00       0271*   	ld e,0 ; highest byte of offset
04007B             0272*   	MOSCALL mos_flseek
04007B 3E 1C       0001*M1 			LD	A, function
04007D 5B CF       0002*M1 			RST.LIL	08h
04007F C9          0273*   	ret
040080             0274*   
040080             0275*   ; Set a VDP keyboard packet receiver callback
040080             0276*   ;   C: If non-zero then set the top byte of HLU(callback address)  to MB (for ADL=0 callers)
040080             0277*   ; HLU: Pointer to callback
040080             0278*   mos_setkbvector:	EQU	1Dh
040080             0279*   
040080             0280*   ; Get the address of the keyboard map
040080             0281*   ; Returns:
040080             0282*   ; IXU: Base address of the keymap
040080             0283*   mos_getkbmap:		EQU	1Eh
040080             0284*   
040080             0285*   ; MOS program exit codes
040080             0286*   ;
040080             0287*   EXIT_OK:				EQU  0;	"OK",
040080             0288*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040080             0289*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040080             0290*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040080             0291*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040080             0292*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040080             0293*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040080             0294*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040080             0295*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040080             0296*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040080             0297*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040080             0298*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040080             0299*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040080             0300*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040080             0301*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040080             0302*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040080             0303*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040080             0304*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040080             0305*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040080             0306*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040080             0307*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040080             0308*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040080             0309*   
040080             0310*   ; FatFS file access functions
040080             0311*   ;
040080             0312*   ; Open a file
040080             0313*   ; HLU: Pointer to a blank FIL struct
040080             0314*   ; DEU: Pointer to the filename (0 terminated)
040080             0315*   ;   C: File mode
040080             0316*   ; Returns:
040080             0317*   ;   A: FRESULT
040080             0318*   ffs_fopen:			EQU	80h
040080             0319*   
040080             0320*   ; Close a file
040080             0321*   ; HLU: Pointer to a blank FIL struct
040080             0322*   ; Returns:
040080             0323*   ;   A: FRESULT
040080             0324*   ffs_fclose:			EQU	81h
040080             0325*   
040080             0326*   ; Read data from a file
040080             0327*   ; HLU: Pointer to a FIL struct
040080             0328*   ; DEU: Pointer to where to write the file out
040080             0329*   ; BCU: Number of bytes to read
040080             0330*   ; Returns:
040080             0331*   ;   A: FRESULT
040080             0332*   ; BCU: Number of bytes read
040080             0333*   ffs_fread:			EQU	82h
040080             0334*   
040080             0335*   ; Write data to a file
040080             0336*   ; HLU: Pointer to a FIL struct
040080             0337*   ; DEU: Pointer to the data to write out
040080             0338*   ; BCU: Number of bytes to write
040080             0339*   ; Returns:
040080             0340*   ;   A: FRESULT
040080             0341*   ; BCU: Number of bytes written
040080             0342*   ffs_fwrite:			EQU	83h
040080             0343*   
040080             0344*   ; Move the read/write pointer in a file
040080             0345*   ; HLU: Pointer to a FIL struct
040080             0346*   ; DEU: Least significant 3 bytes of the offset from the start of the file (DWORD)
040080             0347*   ;   C: Most significant byte of the offset
040080             0348*   ; Returns:
040080             0349*   ;   A: FRESULT
040080             0350*   ffs_flseek:			EQU	84h
040080             0351*   
040080             0352*   ; not implemented
040080             0353*   ffs_ftruncate:		EQU	85h
040080             0354*   
040080             0355*   ; not implemented
040080             0356*   ffs_fsync:			EQU	86h
040080             0357*   
040080             0358*   ; not implemented
040080             0359*   ffs_fforward:		EQU	87h
040080             0360*   
040080             0361*   ; not implemented
040080             0362*   ffs_fexpand:		EQU	88h
040080             0363*   
040080             0364*   ; not implemented
040080             0365*   ffs_fgets:			EQU	89h
040080             0366*   
040080             0367*   ; not implemented
040080             0368*   ffs_fputc:			EQU	8Ah
040080             0369*   
040080             0370*   ; not implemented
040080             0371*   ffs_fputs:			EQU	8Bh
040080             0372*   
040080             0373*   ; not implemented
040080             0374*   ffs_fprintf:		EQU	8Ch
040080             0375*   
040080             0376*   ; not implemented
040080             0377*   ffs_ftell:			EQU	8Dh
040080             0378*   
040080             0379*   ; Check for EOF
040080             0380*   ; HLU: Pointer to a FILINFO struct
040080             0381*   ; Returns:
040080             0382*   ;   A: 1 if end of file, otherwise 0
040080             0383*   ffs_feof:			EQU	8Eh
040080             0384*   
040080             0385*   ; not implemented
040080             0386*   ffs_fsize:			EQU	8Fh
040080             0387*   
040080             0388*   ; not implemented
040080             0389*   ffs_ferror:			EQU	90h
040080             0390*   
040080             0391*   ; FatFS directory access functions
040080             0392*   ;
040080             0393*   ; Open a directory
040080             0394*   ; HLU: Pointer to a blank DIR struct
040080             0395*   ; DEU: Pointer to the directory path
040080             0396*   ; Returns:
040080             0397*   ; A: FRESULT
040080             0398*   ffs_dopen:			EQU	91h
040080             0399*   
040080             0400*   ; Close a directory
040080             0401*   ; HLU: Pointer to an open DIR struct
040080             0402*   ; Returns:
040080             0403*   ; A: FRESULT
040080             0404*   ffs_dclose:			EQU	92h
040080             0405*   
040080             0406*   ; Read the next FILINFO from an open DIR
040080             0407*   ; HLU: Pointer to an open DIR struct
040080             0408*   ; DEU: Pointer to an empty FILINFO struct
040080             0409*   ; Returns:
040080             0410*   ; A: FRESULT
040080             0411*   ffs_dread:			EQU	93h
040080             0412*   
040080             0413*   ; not implemented
040080             0414*   ffs_dfindfirst:		EQU	94h
040080             0415*   
040080             0416*   ; not implemented
040080             0417*   ffs_dfindnext:		EQU	95h
040080             0418*   
040080             0419*   ; FatFS file and directory management functions
040080             0420*   ;
040080             0421*   ; Check file exists
040080             0422*   ; HLU: Pointer to a FILINFO struct
040080             0423*   ; DEU: Pointer to the filename (0 terminated)
040080             0424*   ; Returns:
040080             0425*   ;   A: FRESULT
040080             0426*   ffs_stat:			EQU	96h
040080             0427*   
040080             0428*   ; not implemented
040080             0429*   ffs_unlink:			EQU	97h
040080             0430*   
040080             0431*   ; not implemented
040080             0432*   ffs_rename:			EQU	98h
040080             0433*   
040080             0434*   ; not implemented
040080             0435*   ffs_chmod:			EQU	99h
040080             0436*   
040080             0437*   ; not implemented
040080             0438*   ffs_utime:			EQU	9Ah
040080             0439*   
040080             0440*   ; not implemented
040080             0441*   ffs_mkdir:			EQU	9Bh
040080             0442*   
040080             0443*   ; not implemented
040080             0444*   ffs_chdir:			EQU	9Ch
040080             0445*   
040080             0446*   ; not implemented
040080             0447*   ffs_chdrive:		EQU	9Dh
040080             0448*   
040080             0449*   ; Copy the current directory (string) into buffer (hl)
040080             0450*   ; HLU: Pointer to a buffer
040080             0451*   ; BCU: Maximum length of buffer
040080             0452*   ; Returns:
040080             0453*   ; A: FRESULT
040080             0454*   ffs_getcwd:			EQU	9Eh
040080             0455*   
040080             0456*   ; FatFS volume management and system configuration functions
040080             0457*   ;
040080             0458*   ; not implemented
040080             0459*   ffs_mount:			EQU	9Fh
040080             0460*   
040080             0461*   ; not implemented
040080             0462*   ffs_mkfs:			EQU	A0h
040080             0463*   
040080             0464*   ; not implemented
040080             0465*   ffs_fdisk:			EQU	A1h
040080             0466*   
040080             0467*   ; not implemented
040080             0468*   ffs_getfree:		EQU	A2h
040080             0469*   
040080             0470*   ; not implemented
040080             0471*   ffs_getlabel:		EQU	A3h
040080             0472*   
040080             0473*   ; not implemented
040080             0474*   ffs_setlabel:		EQU	A4h
040080             0475*   
040080             0476*   ; not implemented
040080             0477*   ffs_setcp:			EQU	A5h
040080             0478*   
040080             0479*   ; File access modes
040080             0480*   ;
040080             0481*   fa_read:			EQU	01h
040080             0482*   fa_write:			EQU	02h
040080             0483*   fa_open_existing:	EQU	00h
040080             0484*   fa_create_new:		EQU	04h
040080             0485*   fa_create_always:	EQU	08h
040080             0486*   fa_open_always:		EQU	10h
040080             0487*   fa_open_append:		EQU	30h
040080             0488*   
040080             0489*   ; System variable indexes for api_sysvars
040080             0490*   ; Index into _sysvars in globals.asm
040080             0491*   ;
040080             0492*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040080             0493*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040080             0494*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040080             0495*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040080             0496*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040080             0497*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040080             0498*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040080             0499*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040080             0500*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040080             0501*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040080             0502*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040080             0503*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040080             0504*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040080             0505*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040080             0506*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040080             0507*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040080             0508*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040080             0509*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040080             0510*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040080             0511*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040080             0512*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040080             0513*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040080             0514*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040080             0515*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040080             0516*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
040080             0517*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040080             0518*   
040080             0519*   ; Flags for the VPD protocol
040080             0520*   ;
040080             0521*   vdp_pflag_cursor:		EQU	00000001b
040080             0522*   vdp_pflag_scrchar:		EQU	00000010b
040080             0523*   vdp_pflag_point:		EQU	00000100b
040080             0524*   vdp_pflag_audio:		EQU	00001000b
040080             0525*   vdp_pflag_mode:			EQU	00010000b
040080             0526*   vdp_pflag_rtc:			EQU	00100000b
040080             0527*   
040080             0528*   ;
040080             0529*   ; FatFS structures
040080             0530*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040080             0531*   ;
040080             0532*   ; Object ID and allocation information (FFOBJID)
040080             0533*   ;
040080             0534*   ; Indexes into FFOBJID structure
040080             0535*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040080             0536*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040080             0537*   ffobjid_attr:		EQU	5	; 1: Object attribute
040080             0538*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040080             0539*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040080             0540*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040080             0541*   ;
040080             0542*   ; File object structure (FIL)
040080             0543*   ;
040080             0544*   ; Indexes into FIL structure
040080             0545*   fil_obj:		EQU 0	; 15: Object identifier
040080             0546*   fil_flag:		EQU	15 	;  1: File status flags
040080             0547*   fil_err:		EQU	16	;  1: Abort flag (error code)
040080             0548*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040080             0549*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040080             0550*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040080             0551*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040080             0552*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040080             0553*   ;
040080             0554*   ; Directory object structure (DIR)
040080             0555*   ; Indexes into DIR structure
040080             0556*   dir_obj:		EQU  0	; 15: Object identifier
040080             0557*   dir_dptr:		EQU	15	;  4: Current read/write offset
040080             0558*   dir_clust:		EQU	19	;  4: Current cluster
040080             0559*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040080             0560*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040080             0561*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040080             0562*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040080             0563*   ;
040080             0564*   ; File information structure (FILINFO)
040080             0565*   ;
040080             0566*   ; Indexes into FILINFO structure
040080             0567*   filinfo_fsize:		EQU 0	;   4: File size
040080             0568*   filinfo_fdate:		EQU	4	;   2: Modified date
040080             0569*   filinfo_ftime:		EQU	6	;   2: Modified time
040080             0570*   filinfo_fattrib:	EQU	8	;   1: File attribute
040080             0571*   filinfo_altname:	EQU	9	;  13: Alternative file name
040080             0572*   filinfo_fname:		EQU	22	; 256: Primary file name
040080             0033        include "maths.inc"
040080             0001*   ; test the sign of HL
040080             0002*   ; inputs: HL obviously
040080             0003*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040080             0004*   ; destroys: flags
040080             0005*       MACRO sign_hlu
040080             0006*       add hl,de
040080             0007*       or a ; clear flags
040080             0008*       sbc hl,de
040080             0009*       ENDMACRO
040080             0010*   
040080             0011*   
040080             0012*   ;------------------------------------------------------------------------
040080             0013*   ; Scratch area for calculations
040080             0014*   ;------------------------------------------------------------------------
040080 00 00 00    0015*   scratch1:	dw24	0	;bit manipulation buffer 1
040083 00 00 00    0016*   scratch2:	dw24	0	;bit manipulation buffer 2
040086             0017*   
040086             0018*   ; absolute value of hlu
040086             0019*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040086             0020*   ;         s1,z0,pv0,n1,c0 if hlu was negative
040086             0021*   ;         s0,z1,pv0,n1,c0 if hlu was zero
040086             0022*   ;         s0,z0,pv0,n1,c0 if hlu was positive
040086             0023*   ; destroys: a
040086             0024*   hlu_abs:
040086 19          0025*       add hl,de
040087 B7          0026*       or a
040088 ED 52       0027*       sbc hl,de
04008A FA 8F 00 04 0028*       jp m,@is_neg
04008E C9          0029*       ret         ; hlu is positive or zero so we're done
04008F             0030*   @is_neg:
04008F F5          0031*       push af     ; otherwise, save current flags for return
040090 CD 96 00 04 0032*       call neg_hlu ; negate hlu
040094 F1          0033*       pop af      ; get back flags
040095 C9          0034*       ret
040096             0035*   
040096             0036*   ; flip the sign of hlu
040096             0037*   ; inputs: hlu
040096             0038*   ; returns: 0-hlu, flags set appropriately for the result:
040096             0039*   ;         s1,z0,pv0,n1,c1 if result is negative
040096             0040*   ;         s0,z1,pv0,n1,c0 if result is zero
040096             0041*   ;         s0,z0,pv0,n1,c1 if result is positive
040096             0042*   ; destroys a
040096             0043*   neg_hlu:
040096 D5          0044*       push de     ; save de
040097 EB          0045*       ex de,hl    ; put hl into de
040098 21 00 00 00 0046*       ld hl,0     ; clear hl
04009C AF          0047*       xor a       ; clear carry
04009D ED 52       0048*       sbc hl,de   ; 0-hlu = -hlu
04009F D1          0049*       pop de      ; get de back
0400A0 C9          0050*       ret         ; easy peasy
0400A1             0051*   
0400A1             0052*   ;------------------------------------------------------------------------
0400A1             0053*   ; divide hlu by 2, inspired by above
0400A1             0054*   ;------------------------------------------------------------------------
0400A1             0055*   hlu_div2:
0400A1 22 80 00 04 0056*   	ld		(scratch1),hl
0400A5 21 82 00 04 0057*   	ld		hl,scratch1+2
0400A9 CB 1E       0058*   	rr		(hl)
0400AB 2B          0059*   	dec		hl
0400AC CB 1E       0060*   	rr		(hl)
0400AE 2B          0061*   	dec		hl
0400AF CB 1E       0062*   	rr		(hl)
0400B1 23          0063*   	inc		hl
0400B2 23          0064*   	inc		hl
0400B3 2A 80 00 04 0065*       ld hl,(scratch1)
0400B7 C9          0066*       ret
0400B8             0067*   
0400B8             0068*   ; this is my little hack to divide by 16
0400B8             0069*   hlu_div16:
0400B8 AF          0070*       xor a
0400B9 29          0071*       add hl,hl
0400BA 17          0072*       rla
0400BB 29          0073*       add hl,hl
0400BC 17          0074*       rla
0400BD 29          0075*       add hl,hl
0400BE 17          0076*       rla
0400BF 29          0077*       add hl,hl
0400C0 17          0078*       rla
0400C1 22 CE 00 04 0079*       ld (@scratch),hl
0400C5 32 D1 00 04 0080*       ld (@scratch+3),a
0400C9 2A CF 00 04 0081*       ld hl,(@scratch+1)
0400CD C9          0082*       ret
0400CE             0083*   @scratch: ds 4
0400D2             0084*   
0400D2             0085*   ; hlu signed division by 256
0400D2             0086*   ; returns: hlu / 256
0400D2             0087*   ; destroys: af
0400D2             0088*   hlu_sdiv256:
       FF FF FF FF 
0400D2 AF          0089*       xor a ; assume hl is positive
0400D3 22 E9 00 04 0090*       ld (@buffer),hl
0400D7             0091*       sign_hlu
0400D7 19          0001*M1     add hl,de
0400D8 B7          0002*M1     or a ; clear flags
0400D9 ED 52       0003*M1     sbc hl,de
0400DB F2 E0 00 04 0092*       jp p,@hl_pos
0400DF 3D          0093*       dec a
0400E0             0094*   @hl_pos:
0400E0 32 EC 00 04 0095*       ld (@buffer+3),a
0400E4 2A EA 00 04 0096*       ld hl,(@buffer+1)
0400E8 C9          0097*       ret
0400E9             0098*   @buffer: ds 4
0400ED             0099*   
0400ED             0100*   ; hlu 1 byte right shift, unsigned
0400ED             0101*   ; returns: hlu / 256, fractional portion in a
0400ED             0102*   ; destroys: af
0400ED             0103*   hlu_udiv256:
       FF FF FF FF 
0400ED AF          0104*   	xor a
0400EE 32 FF 00 04 0105*   	ld (@buffer+3),a
0400F2 7D          0106*   	ld a,l ; save the fractional portion
0400F3 22 FC 00 04 0107*   	ld (@buffer),hl
0400F7 2A FD 00 04 0108*   	ld hl,(@buffer+1)
0400FB C9          0109*   	ret
0400FC             0110*   @buffer: ds 4
040100             0111*   
040100             0112*       MACRO hlu_mul256
040100             0113*           add hl,hl ; * 2
040100             0114*           add hl,hl ; * 4
040100             0115*           add hl,hl ; * 8
040100             0116*           add hl,hl ; * 16
040100             0117*           add hl,hl ; * 32
040100             0118*           add hl,hl ; * 64
040100             0119*           add hl,hl ; * 128
040100             0120*           add hl,hl ; * 256
040100             0121*       ENDMACRO
040100             0122*   
       FF FF FF FF 
040100 00 00 00 00 0123*   add_bcd_arg1: db #00,#00,#00,#00
040104 00 00 00 00 0124*   add_bcd_arg2: db #00,#00,#00,#00
040108             0125*   
040108             0126*   ; set bcd values in a scratch memory address from registers bcde
040108             0127*   ; input: hl; scratch address,bcde; 8-place bcd number
040108             0128*   ; destroys ; hl
040108             0129*   set_bcd:
040108 73          0130*       ld (hl),e
040109 23          0131*       inc hl
04010A 72          0132*       ld (hl),d
04010B 23          0133*       inc hl
04010C 71          0134*       ld (hl),c
04010D 23          0135*       inc hl
04010E 70          0136*       ld (hl),b
04010F C9          0137*       ret
040110             0138*   
040110             0139*   ; load bcd values from a scratch memory address to bcde
040110             0140*   ; input: hl; scratch address
040110             0141*   ; output: bcde; 8-place bcd number
040110             0142*   ; destroys: hl
040110             0143*   get_bcd:
040110 5E          0144*       ld e,(hl)
040111 23          0145*       inc hl
040112 56          0146*       ld d,(hl)
040113 23          0147*       inc hl
040114 4E          0148*       ld c,(hl)
040115 23          0149*       inc hl
040116 46          0150*       ld b,(hl)
040117 C9          0151*       ret
040118             0152*   
040118             0153*   ; BCD addition
040118             0154*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040118             0155*   ;       a is the number of bytes holding each number (number of places/2)
040118             0156*   ; outputs: (hl) + (de) --> (hl)
040118             0157*   ; destroys: a,b,de,hl
040118             0158*   add_bcd:
040118 47          0159*       ld b,a ; loop counter
040119 AF          0160*       xor a ; reset a, clear carry flag
04011A             0161*   adcec:
04011A 1A          0162*       ld a,(de) ; addend to acc
04011B 8E          0163*       adc a,(hl) ; add (hl) to acc
04011C 27          0164*       daa ; adjust result to bcd
04011D 77          0165*       ld (hl),a ; store result
04011E 23          0166*       inc hl ; advance memory pointers
04011F 13          0167*       inc de
040120 10 F8       0168*       djnz adcec ; loop until b == 0
040122 C9          0169*       ret
040123             0170*   
040123             0171*   ; BCD subtraction
040123             0172*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040123             0173*   ;       a is the number of bytes holding each number (number of places/2)
040123             0174*   ; outputs: (hl) - (de) --> (hl)
040123             0175*   ; destroys: a,b,de,hl
040123             0176*   sub_bcd:
040123 47          0177*       ld b,a ; loop counter
040124 AF          0178*       xor a ; reset a,clear carry flag
040125             0179*   subdec:
040125 1A          0180*       ld a,(de) ; subtrahend to acc
040126 9E          0181*       sbc a,(hl) ; subtract (hl) from acc
040127 27          0182*       daa ; adjust result to bcd
040128 77          0183*       ld (hl),a ; store result
040129 23          0184*       inc hl ; advance memory pointers
04012A 13          0185*       inc de
04012B 10 F8       0186*       djnz subdec ; loop until b == 0
04012D C9          0187*       ret
04012E             0188*   
04012E             0189*   ; http://www.z80.info/pseudo-random.txt
04012E             0190*   rand_8:
04012E C5          0191*       push bc
04012F 3A 42 01 04 0192*       ld a,(r_seed)
040133 4F          0193*       ld c,a
040134             0194*   
040134 0F          0195*       rrca ; multiply by 32
040135 0F          0196*       rrca
040136 0F          0197*       rrca
040137 EE 1F       0198*       xor 0x1f
040139             0199*   
040139 81          0200*       add a,c
04013A DE FF       0201*       sbc a,255 ; carry
04013C             0202*   
04013C 32 42 01 04 0203*       ld (r_seed),a
040140 C1          0204*       pop bc
040141 C9          0205*       ret
040142 50          0206*   r_seed: defb $50
040143             0034        include "functions.inc"
040143             0001*   
040143             0002*       MACRO printChar char
040143             0003*       LD A, char
040143             0004*       RST.LIL 10h
040143             0005*       ENDMACRO
040143             0006*   
040143             0007*   ; Simulated call to subroutine at HL
040143             0008*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040143             0009*   ; outputs: whatever the subroutine does, including HL and BC
040143             0010*   ; destroys: only what the subroutine does, but always BC
040143             0011*       MACRO callHL
040143             0012*       ld bc,@F ; Address of first instruction after the jump
040143             0013*       push bc ; which constitutes the return address
040143             0014*       jp (hl) ; Jump to the address in HL
040143             0015*   @@:
040143             0016*       ENDMACRO
040143             0017*   
040143             0018*   ; Simulated call to subroutine at IX
040143             0019*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040143             0020*   ; outputs: whatever the subroutine does, including IX and BC
040143             0021*   ; destroys: only what the subroutine does, but always BC
040143             0022*       MACRO callIX
040143             0023*       ld bc,@F ; Address of first instruction after the jump
040143             0024*       push bc ; which constitutes the return address
040143             0025*       jp (ix) ; Jump to the address in IX
040143             0026*   @@:
040143             0027*       ENDMACRO
040143             0028*   
040143             0029*   ; Simulated call to soubroutinte at IY
040143             0030*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040143             0031*   ; outputs: whatever the subroutine does, including IY and BC
040143             0032*   ; destroys: only what the subroutine does, but always BC
040143             0033*       MACRO callIY
040143             0034*       ld bc,@F ; Address of first instruction after the jump
040143             0035*       push bc ; which constitutes the return address
040143             0036*       jp (iy) ; Jump to the address in IY
040143             0037*   @@:
040143             0038*       ENDMACRO
040143             0039*   
040143             0040*   ; put the value in HLU into the accumulator
040143             0041*   ; destroys: af
040143             0042*       MACRO HLU_TO_A
040143             0043*       push hl ; 4 cycles
040143             0044*       inc sp ; 1 cycle
040143             0045*       pop af ; 4 cycles
040143             0046*       dec sp ; 1 cycle
040143             0047*       ; 10 cycles total
040143             0048*       ENDMACRO
040143             0049*   
040143             0050*   A_TO_HLU:
040143             0051*       ; call is 7 cycles
040143 22 50 01 04 0052*       ld (@scratch),hl ; 7 cycles
040147 32 52 01 04 0053*       ld (@scratch+2),a ; 5 cycles
04014B 2A 50 01 04 0054*       ld hl,(@scratch) ; 7 cycles
04014F C9          0055*       ret ; 6 cycles
040150             0056*       ; 25 cycles total
040150 00 00 00    0057*   @scratch: dl 0
040153             0058*   
040153             0059*       ; TODO: implement this
040153             0060*       ; MACRO A_TO_HLU
040153             0061*       ;     push.s af
040153             0062*       ;     inc sp
040153             0063*       ;     push.s hl
040153             0064*       ;     pop hl
040153             0065*       ;     inc sp
040153             0066*       ;     inc sp
040153             0067*       ; ENDMACRO
040153             0068*   
040153             0069*       MACRO PUSH_ALL
040153             0070*       ex af,af'
040153             0071*       exx
040153             0072*       push af
040153             0073*       push hl
040153             0074*       push bc
040153             0075*       push de
040153             0076*   
040153             0077*       ex af,af'
040153             0078*       exx
040153             0079*       push af
040153             0080*       push hl
040153             0081*       push bc
040153             0082*       push de
040153             0083*       push ix
040153             0084*       push iy
040153             0085*       ENDMACRO
040153             0086*   
040153             0087*       MACRO POP_ALL
040153             0088*       pop iy
040153             0089*       pop ix
040153             0090*       pop de
040153             0091*       pop bc
040153             0092*       pop hl
040153             0093*       pop af
040153             0094*       ex af,af'
040153             0095*       exx
040153             0096*   
040153             0097*       pop de
040153             0098*       pop bc
040153             0099*       pop hl
040153             0100*       pop af
040153             0101*       ex af,af'
040153             0102*       exx
040153             0103*       ENDMACRO
040153             0104*   
040153             0105*   ; Print a zero-terminated string inline with code, e.g.:
040153             0106*   ;
040153             0107*   ;    call printInline
040153             0108*   ;    ASCIZ "Hello, world!\r\n"
040153             0109*   ;
040153             0110*   ; Destroys: HL,AF
040153             0111*   printInline:
040153 E1          0112*       pop hl ; get the return address = pointer to start of string
040154 CD 5A 01 04 0113*       call printString ; HL advances to end of string
040158 E5          0114*       push hl ; restore the return address = pointer to end of string
040159 C9          0115*       ret
04015A             0116*   
04015A             0117*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
04015A             0118*   ; Print a zero-terminated string
04015A             0119*   ; HL: Pointer to string
04015A             0120*   printString:
04015A C5          0121*       PUSH BC
04015B 01 00 00 00 0122*       LD BC,0
04015F 3E 00       0123*       LD A,0
040161 5B DF       0124*       RST.LIL 18h
040163 C1          0125*       POP BC
040164 C9          0126*       RET
040165             0127*   ; print a VDU sequence
040165             0128*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
040165             0129*   sendVDUsequence:
040165 C5          0130*       PUSH BC
040166 01 00 00 00 0131*       LD BC, 0
04016A 4E          0132*       LD C, (HL)
04016B 5B DF       0133*       RST.LIL 18h
04016D C1          0134*       POP BC
04016E C9          0135*       RET
04016F             0136*   ; Print Newline sequence to VDP
04016F             0137*   printNewLine:
04016F F5          0138*       push af ; for some reason rst.lil 10h sets carry flag
040170 3E 0D       0139*       LD A, '\r'
040172 5B D7       0140*       RST.LIL 10h
040174 3E 0A       0141*       LD A, '\n'
040176 5B D7       0142*       RST.LIL 10h
040178 F1          0143*       pop af
040179 C9          0144*       RET
04017A             0145*   
04017A             0146*   ; Print a 24-bit HEX number
04017A             0147*   ; HLU: Number to print
04017A             0148*   printHex24:
04017A             0149*       HLU_TO_A
04017A E5          0001*M1     push hl ; 4 cycles
04017B 33          0002*M1     inc sp ; 1 cycle
04017C F1          0003*M1     pop af ; 4 cycles
04017D 3B          0004*M1     dec sp ; 1 cycle
04017E             0005*M1     ; 10 cycles total
04017E CD 88 01 04 0150*       CALL printHex8
040182             0151*   ; Print a 16-bit HEX number
040182             0152*   ; HL: Number to print
040182             0153*   printHex16:
040182 7C          0154*       LD A,H
040183 CD 88 01 04 0155*       CALL printHex8
040187 7D          0156*       LD A,L
040188             0157*   ; Print an 8-bit HEX number
040188             0158*   ; A: Number to print
040188             0159*   printHex8:
040188 4F          0160*       LD C,A
040189 1F          0161*       RRA
04018A 1F          0162*       RRA
04018B 1F          0163*       RRA
04018C 1F          0164*       RRA
04018D CD 92 01 04 0165*       CALL @F
040191 79          0166*       LD A,C
040192             0167*   @@:
040192 E6 0F       0168*       AND 0Fh
040194 C6 90       0169*       ADD A,90h
040196 27          0170*       DAA
040197 CE 40       0171*       ADC A,40h
040199 27          0172*       DAA
04019A 5B D7       0173*       RST.LIL 10h
04019C C9          0174*       RET
04019D             0175*   
04019D             0176*   printHexA:
04019D F5          0177*       push af
04019E C5          0178*       push bc
04019F CD 88 01 04 0179*       call printHex8
0401A3 3E 20       0180*       ld a,' '
0401A5 5B D7       0181*       rst.lil 10h
0401A7 C1          0182*       pop bc
0401A8 F1          0183*       pop af
0401A9 C9          0184*       ret
0401AA             0185*   
0401AA             0186*   printHexHL:
0401AA F5          0187*       push af
0401AB C5          0188*       push bc
0401AC CD 82 01 04 0189*       call printHex16
0401B0 3E 20       0190*       ld a,' '
0401B2 5B D7       0191*       rst.lil 10h
0401B4 C1          0192*       pop bc
0401B5 F1          0193*       pop af
0401B6 C9          0194*       ret
0401B7             0195*   
0401B7             0196*   printHexUHL:
0401B7 F5          0197*       push af
0401B8 C5          0198*       push bc
0401B9 CD 7A 01 04 0199*       call printHex24
0401BD 3E 20       0200*       ld a,' '
0401BF 5B D7       0201*       rst.lil 10h
0401C1 C1          0202*       pop bc
0401C2 F1          0203*       pop af
0401C3 C9          0204*       ret
0401C4             0205*   
0401C4             0206*   printHexAUHL:
0401C4 F5          0207*       push af
0401C5 C5          0208*       push bc
0401C6 CD 88 01 04 0209*       call printHex8
0401CA 3E 2E       0210*       ld a,'.'
0401CC 5B D7       0211*       rst.lil 10h
0401CE CD 7A 01 04 0212*       call printHex24
0401D2 3E 20       0213*       ld a,' '
0401D4 5B D7       0214*       rst.lil 10h
0401D6 C1          0215*       pop bc
0401D7 F1          0216*       pop af
0401D8 C9          0217*       ret
0401D9             0218*   
0401D9             0219*   printHexABHL:
0401D9             0220*   ; preserve registers
0401D9 C5          0221*       push bc ; b will be ok c will not
0401DA F5          0222*       push af ; will get totally destroyed
0401DB             0223*   ; print a
0401DB CD 88 01 04 0224*       call printHex8
0401DF             0225*   ; print b
0401DF 78          0226*       ld a,b
0401E0 CD 88 01 04 0227*       call printHex8
0401E4             0228*   ; print hl
0401E4 CD 82 01 04 0229*       call printHex16
0401E8             0230*   ; restore registers
0401E8 F1          0231*       pop af
0401E9 C1          0232*       pop bc
0401EA C9          0233*       ret
0401EB             0234*   
0401EB             0235*   printHexBHL:
0401EB             0236*   ; preserve registers
0401EB C5          0237*       push bc ; b will be ok c will not
0401EC F5          0238*       push af ; will get totally destroyed
0401ED             0239*   ; print b
0401ED 78          0240*       ld a,b
0401EE CD 88 01 04 0241*       call printHex8
0401F2             0242*   ; print hl
0401F2 CD 82 01 04 0243*       call printHex16
0401F6             0244*   ; restore registers
0401F6 F1          0245*       pop af
0401F7 C1          0246*       pop bc
0401F8 C9          0247*       ret
0401F9             0248*   
0401F9             0249*   printHexCDE:
0401F9             0250*   ; preserve registers
0401F9 C5          0251*       push bc ; b will be ok c will not
0401FA F5          0252*       push af ; will get totally destroyed
0401FB             0253*   ; print c
0401FB 79          0254*       ld a,c
0401FC CD 88 01 04 0255*       call printHex8
040200             0256*   ; print de
040200 EB          0257*       ex de,hl
040201 CD 82 01 04 0258*       call printHex16
040205 EB          0259*       ex de,hl
040206             0260*   ; restore registers
040206 F1          0261*       pop af
040207 C1          0262*       pop bc
040208 C9          0263*       ret
040209             0264*   
040209             0265*   printHexUIX:
040209             0266*   ; store everything in scratch
040209 22 82 06 04 0267*       ld (uhl),hl
04020D ED 43 85 06 0268*       ld (ubc),bc
       04          
040212 ED 53 88 06 0269*       ld (ude),de
       04          
040217 DD 22 8B 06 0270*       ld (uix),ix
       04          
04021C FD 22 8E 06 0271*       ld (uiy),iy
       04          
040221 F5          0272*       push af ; fml
040222             0273*   
040222 21 19 06 04 0274*       ld hl,str_ixu
040226 CD 5A 01 04 0275*       call printString
04022A 2A 8B 06 04 0276*       ld hl,(uix)
04022E CD 7A 01 04 0277*       call printHex24
040232 CD 6F 01 04 0278*       call printNewLine
040236             0279*   
040236             0280*   ; restore everything
040236 2A 82 06 04 0281*       ld hl, (uhl)
04023A ED 4B 85 06 0282*       ld bc, (ubc)
       04          
04023F ED 5B 88 06 0283*       ld de, (ude)
       04          
040244 DD 2A 8B 06 0284*       ld ix, (uix)
       04          
040249 FD 2A 8E 06 0285*       ld iy, (uiy)
       04          
04024E F1          0286*       pop af
04024F             0287*   ; all done
04024F C9          0288*       ret
040250             0289*   
040250             0290*   ; Print a 0x HEX prefix
040250             0291*   DisplayHexPrefix:
040250 3E 30       0292*       LD A, '0'
040252 5B D7       0293*       RST.LIL 10h
040254 3E 78       0294*       LD A, 'x'
040256 5B D7       0295*       RST.LIL 10h
040258 C9          0296*       RET
040259             0297*   
040259             0298*       MACRO printDecBC
040259             0299*       push hl
040259             0300*       push bc
040259             0301*       pop hl
040259             0302*       call printDec
040259             0303*       pop hl
040259             0304*       ENDMACRO
040259             0305*   
040259             0306*       MACRO printDecDE
040259             0307*       push hl
040259             0308*       push de
040259             0309*       pop hl
040259             0310*       call printDec
040259             0311*       pop hl
040259             0312*       ENDMACRO
040259             0313*   
040259             0314*       MACRO printDecHL
040259             0315*       call printDec
040259             0316*       ENDMACRO
040259             0317*   
040259             0318*       MACRO printDecIX
040259             0319*       push hl
040259             0320*       push ix
040259             0321*       pop hl
040259             0322*       call printDec
040259             0323*       pop hl
040259             0324*       ENDMACRO
040259             0325*   
040259             0326*       MACRO printDecIY
040259             0327*       push hl
040259             0328*       push iy
040259             0329*       pop hl
040259             0330*       call printDec
040259             0331*       pop hl
040259             0332*       ENDMACRO
040259             0333*   
040259             0334*   
040259             0335*   ; Prints the right justified decimal value in HL without leading zeroes
040259             0336*   ; HL : Value to print
040259             0337*   ; preserves all registers and flags
040259             0338*   printDec:
040259             0339*   ; BEGIN MY CODE
040259             0340*   ; back up all the things
040259 F5          0341*       push af
04025A C5          0342*       push bc
04025B D5          0343*       push de
04025C E5          0344*       push hl
04025D             0345*   ; END MY CODE
04025D 11 85 02 04 0346*       LD DE, _printDecBuffer
040261 CD 95 02 04 0347*       CALL u24_to_ascii
040265             0348*   ; BEGIN MY CODE
040265             0349*   ; replace leading zeroes with spaces
040265 21 85 02 04 0350*       LD HL, _printDecBuffer
040269 06 07       0351*       ld B, 7 ; if HL was 0, we want to keep the final zero
04026B             0352*   @loop:
04026B 7E          0353*       LD A, (HL)
04026C FE 30       0354*       CP '0'
04026E C2 78 02 04 0355*       JP NZ, @done
040272 3E 20       0356*       LD A, ' '
040274 77          0357*       LD (HL), A
040275 23          0358*       INC HL
040276             0359*       ; CALL vdu_cursor_forward
040276 10 F3       0360*       DJNZ @loop
040278             0361*   @done:
040278             0362*   ; END MY CODE
040278 21 85 02 04 0363*       LD HL, _printDecBuffer
04027C CD 5A 01 04 0364*       CALL printString
040280             0365*   ; BEGIN MY CODE
040280             0366*   ; restore all the things
040280 E1          0367*       pop hl
040281 D1          0368*       pop de
040282 C1          0369*       pop bc
040283 F1          0370*       pop af
040284             0371*   ; END MY CODE
040284 C9          0372*       RET
040285 00 00 00 00 0373*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040295             0374*   
040295             0375*   ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
040295             0376*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040295             0377*   ; so it will allways be 8 characters length
040295             0378*   ; HL : Value to convert to string
040295             0379*   ; DE : pointer to buffer, at least 8 byte + 0
040295             0380*   u24_to_ascii:
040295 01 80 69 67 0381*       LD BC,-10000000
040299 CD CC 02 04 0382*       CALL @one_digit
04029D 01 C0 BD F0 0383*       LD BC,-1000000
0402A1 CD CC 02 04 0384*       CALL @one_digit
0402A5 01 60 79 FE 0385*       LD BC,-100000
0402A9 CD CC 02 04 0386*       CALL @one_digit
0402AD 01 F0 D8 FF 0387*       LD BC,-10000
0402B1 CD CC 02 04 0388*       CALL @one_digit
0402B5 01 18 FC FF 0389*       LD BC,-1000
0402B9 CD CC 02 04 0390*       CALL @one_digit
0402BD 01 9C FF FF 0391*       LD BC,-100
0402C1 CD CC 02 04 0392*       CALL @one_digit
0402C5 0E F6       0393*       LD C,-10
0402C7 CD CC 02 04 0394*       CALL @one_digit
0402CB 48          0395*       LD C,B
0402CC             0396*   @one_digit:
0402CC 3E 2F       0397*       LD A,'0'-1
0402CE             0398*   @divide_me:
0402CE 3C          0399*       INC A
0402CF 09          0400*       ADD HL,BC
0402D0 38 FC       0401*       JR C,@divide_me
0402D2 ED 42       0402*       SBC HL,BC
0402D4 12          0403*       LD (DE),A
0402D5 13          0404*       INC DE
0402D6 C9          0405*       RET
0402D7             0406*   
0402D7             0407*   print_u24:
0402D7 D5          0408*       push de
0402D8 E5          0409*       push hl
0402D9 11 85 02 04 0410*       ld de,_printDecBuffer
0402DD CD 95 02 04 0411*       call u24_to_ascii
0402E1 21 85 02 04 0412*       ld hl,_printDecBuffer
0402E5 CD 5A 01 04 0413*       call printString
0402E9 3E 20       0414*       ld a,' '
0402EB 5B D7       0415*       rst.lil 10h
0402ED E1          0416*       pop hl
0402EE D1          0417*       pop de
0402EF C9          0418*       ret
0402F0             0419*   
0402F0             0420*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0402F0             0421*   ; HL : Value to convert to string (integer part in H, fractional part in L)
0402F0             0422*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0402F0             0423*   u168_to_ascii:
0402F0             0424*   ; add a leading space to make room for sign flag if needed
0402F0 3E 20       0425*       ld a,' '
0402F2 12          0426*       ld (de),a
0402F3 13          0427*       inc de
0402F4             0428*   ; Convert integer part
0402F4 E5          0429*       push hl ; Save HL (well need the fractional part later)
0402F5 CD ED 00 04 0430*       call hlu_udiv256 ; Shift to get integer portion in HL
0402F9 01 F0 D8 FF 0431*       ld bc, -10000
0402FD CD 20 03 04 0432*       call @one_int
040301 01 18 FC FF 0433*       ld bc, -1000
040305 CD 20 03 04 0434*       call @one_int
040309 01 9C FF FF 0435*       ld bc, -100
04030D CD 20 03 04 0436*       call @one_int
040311 0E F6       0437*       ld c, -10
040313 CD 20 03 04 0438*       call @one_int
040317 48          0439*       ld c, b
040318 CD 20 03 04 0440*       call @one_int
04031C C3 2B 03 04 0441*       jp @frac ; Jump to fractional part conversion
040320             0442*   @one_int:
040320 3E 2F       0443*       ld a, '0' - 1 ; Start ASCII character at '0'
040322             0444*   @divide_me:
040322 3C          0445*       inc a
040323 09          0446*       add hl, bc ; Accumulate until overflow
040324 38 FC       0447*       jr c, @divide_me
040326 ED 42       0448*       sbc hl, bc ; Remove excess after overflow
040328 12          0449*       ld (de), a ; Store ASCII digit
040329 13          0450*       inc de
04032A C9          0451*       ret
04032B             0452*   ; Convert fractional part
04032B             0453*   @frac:
04032B 3E 2E       0454*       ld a, '.' ; Decimal point
04032D 12          0455*       ld (de), a
04032E 13          0456*       inc de
04032F E1          0457*       pop hl ; Restore HL with original fraction
040330 06 03       0458*       ld b, 3 ; Loop counter for 3 fractional digits
040332             0459*   @frac_loop:
040332 26 0A       0460*       ld h, 10 ; Load multiplier for fractional part
040334 ED 6C       0461*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
040336 3E 30       0462*       ld a, '0'
040338 84          0463*       add a, h ; Convert integer part to ASCII
040339 12          0464*       ld (de), a
04033A 13          0465*       inc de
04033B 10 F5       0466*       djnz @frac_loop ; Repeat for each fractional digit
04033D             0467*   ; Add null terminator
04033D AF          0468*       xor a ; Null terminator
04033E 12          0469*       ld (de), a
04033F C9          0470*       ret
040340             0471*   
040340             0472*   print_u168:
040340 D5          0473*       push de
040341 E5          0474*       push hl
040342 11 85 02 04 0475*       ld de,_printDecBuffer
040346 CD F0 02 04 0476*       call u168_to_ascii
04034A 21 85 02 04 0477*       ld hl,_printDecBuffer
04034E CD 5A 01 04 0478*       call printString
040352 E1          0479*       pop hl
040353 D1          0480*       pop de
040354 C9          0481*       ret
040355             0482*   
040355             0483*   ; signed version of u168_to_ascii
040355             0484*   s168_to_ascii:
040355 D5          0485*       push de ; save starting address of buffer
040356 CD 86 00 04 0486*       call hlu_abs
04035A F5          0487*       push af ; save sign flag
04035B CD F0 02 04 0488*       call u168_to_ascii
04035F F1          0489*       pop af ; restore sign flag
040360 D1          0490*       pop de ; restore starting address of buffer
040361 F0          0491*       ret p ; hlu was positive so nothing to do
040362 3E 2D       0492*       ld a,'-'
040364 12          0493*       ld (de),a
040365 C9          0494*       ret
040366             0495*   
040366             0496*   print_s168:
040366 D5          0497*       push de
040367 E5          0498*       push hl
040368 11 85 02 04 0499*       ld de,_printDecBuffer
04036C CD 55 03 04 0500*       call s168_to_ascii
040370 21 85 02 04 0501*       ld hl,_printDecBuffer
040374 CD 5A 01 04 0502*       call printString
040378 E1          0503*       pop hl
040379 D1          0504*       pop de
04037A C9          0505*       ret
04037B             0506*   
04037B             0507*   print_s168_hl:
04037B F5          0508*       push af
04037C E5          0509*       push hl
04037D CD 66 03 04 0510*       call print_s168
040381 3E 20       0511*       ld a,' '
040383 5B D7       0512*       rst.lil 10h
040385 E1          0513*       pop hl
040386 F1          0514*       pop af
040387 C9          0515*       ret
040388             0516*   
040388             0517*   print_s168_bc:
040388 F5          0518*       push af
040389 C5          0519*       push bc
04038A E5          0520*       push hl
04038B C5          0521*       push bc
04038C E1          0522*       pop hl
04038D CD 66 03 04 0523*       call print_s168
040391 3E 20       0524*       ld a,' '
040393 5B D7       0525*       rst.lil 10h
040395 E1          0526*       pop hl
040396 C1          0527*       pop bc
040397 F1          0528*       pop af
040398 C9          0529*       ret
040399             0530*   
040399             0531*   print_s168_de:
040399 F5          0532*       push af
04039A D5          0533*       push de
04039B E5          0534*       push hl
04039C EB          0535*       ex de,hl
04039D CD 66 03 04 0536*       call print_s168
0403A1 3E 20       0537*       ld a,' '
0403A3 5B D7       0538*       rst.lil 10h
0403A5 E1          0539*       pop hl
0403A6 D1          0540*       pop de
0403A7 F1          0541*       pop af
0403A8 C9          0542*       ret
0403A9             0543*   
0403A9             0544*   print_s168_hl_bc_de:
0403A9 F5          0545*       push af
0403AA C5          0546*       push bc
0403AB D5          0547*       push de
0403AC E5          0548*       push hl
0403AD CD 66 03 04 0549*       call print_s168
0403B1 3E 20       0550*       ld a,' '
0403B3 5B D7       0551*       rst.lil 10h
0403B5 C5          0552*       push bc
0403B6 E1          0553*       pop hl
0403B7 CD 66 03 04 0554*       call print_s168
0403BB 3E 20       0555*       ld a,' '
0403BD 5B D7       0556*       rst.lil 10h
0403BF EB          0557*       ex de,hl
0403C0 CD 66 03 04 0558*       call print_s168
0403C4 3E 20       0559*       ld a,' '
0403C6 5B D7       0560*       rst.lil 10h
0403C8 E1          0561*       pop hl
0403C9 D1          0562*       pop de
0403CA C1          0563*       pop bc
0403CB F1          0564*       pop af
0403CC C9          0565*       ret
0403CD             0566*   
0403CD             0567*   print_s168_bc_de:
0403CD F5          0568*       push af
0403CE C5          0569*       push bc
0403CF D5          0570*       push de
0403D0 C5          0571*       push bc
0403D1 E1          0572*       pop hl
0403D2 CD 66 03 04 0573*       call print_s168
0403D6 3E 20       0574*       ld a,' '
0403D8 5B D7       0575*       rst.lil 10h
0403DA EB          0576*       ex de,hl
0403DB CD 66 03 04 0577*       call print_s168
0403DF 3E 20       0578*       ld a,' '
0403E1 5B D7       0579*       rst.lil 10h
0403E3 E1          0580*       pop hl
0403E4 D1          0581*       pop de
0403E5 C1          0582*       pop bc
0403E6 F1          0583*       pop af
0403E7 C9          0584*       ret
0403E8             0585*   
0403E8             0586*   print_s168_a:
0403E8 F5          0587*       push af
0403E9 C5          0588*       push bc
0403EA E5          0589*       push hl
0403EB 21 00 00 00 0590*       ld hl,0
0403EF 6F          0591*       ld l,a
0403F0 CD 7B 03 04 0592*       call print_s168_hl
0403F4 E1          0593*       pop hl
0403F5 C1          0594*       pop bc
0403F6 F1          0595*       pop af
0403F7 C9          0596*       ret
0403F8             0597*   
0403F8             0598*   ; #### new functions added by Brandon R. Gates ####
0403F8             0599*   
0403F8             0600*   ; print the binary representation of the 8-bit value in a
0403F8             0601*   ; destroys a, hl, bc
0403F8             0602*   printBin8:
0403F8 06 08       0603*       ld b,8 ; loop counter for 8 bits
0403FA 21 15 04 04 0604*       ld hl,@cmd ; set hl to the low byte of the output string
0403FE             0605*       ; (which will be the high bit of the value in a)
0403FE             0606*   @loop:
0403FE 07          0607*       rlca ; put the next highest bit into carry
0403FF 38 04       0608*       jr c,@one
040401 36 30       0609*       ld (hl),'0'
040403 18 02       0610*       jr @next_bit
040405             0611*   @one:
040405 36 31       0612*       ld (hl),'1'
040407             0613*   @next_bit:
040407 23          0614*       inc hl
040408 10 F4       0615*       djnz @loop
04040A             0616*   ; print it
04040A 21 15 04 04 0617*       ld hl,@cmd
04040E 01 08 00 00 0618*       ld bc,@end-@cmd
040412 5B DF       0619*       rst.lil $18
040414 C9          0620*       ret
040415             0621*   @cmd: ds 8 ; eight bytes for eight bits
04041D             0622*   @end:
04041D             0623*   
04041D             0624*   ; print the binary representation of the 8-bit value in a
04041D             0625*   ; in reverse order (lsb first)
04041D             0626*   ; destroys a, hl, bc
04041D             0627*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
04041D 06 08       0628*       ld b,8 ; loop counter for 8 bits
04041F 21 3A 04 04 0629*       ld hl,@cmd ; set hl to the low byte of the output string
040423             0630*       ; (which will be the high bit of the value in a)
040423             0631*   @loop:
040423 0F          0632*       rrca ; put the next lowest bit into carry
040424 38 04       0633*       jr c,@one
040426 36 30       0634*       ld (hl),'0'
040428 18 02       0635*       jr @next_bit
04042A             0636*   @one:
04042A 36 31       0637*       ld (hl),'1'
04042C             0638*   @next_bit:
04042C 23          0639*       inc hl
04042D 10 F4       0640*       djnz @loop
04042F             0641*   ; print it
04042F 21 3A 04 04 0642*       ld hl,@cmd
040433 01 08 00 00 0643*       ld bc,@end-@cmd
040437 5B DF       0644*       rst.lil $18
040439 C9          0645*       ret
04043A             0646*   @cmd: ds 8 ; eight bytes for eight bits
040442             0647*   @end:
040442             0648*   
040442             0649*   ; print registers to screen in hexidecimal format
040442             0650*   ; inputs: none
040442             0651*   ; outputs: values of every register printed to screen
040442             0652*   ;    values of each register in global scratch memory
040442             0653*   ; destroys: nothing
040442             0654*   stepRegistersHex:
040442             0655*   ; store everything in scratch
       FF FF FF FF 
       FF FF FF FF 
040442 22 82 06 04 0656*       ld (uhl),hl
040446 ED 43 85 06 0657*       ld (ubc),bc
       04          
04044B ED 53 88 06 0658*       ld (ude),de
       04          
040450 DD 22 8B 06 0659*       ld (uix),ix
       04          
040455 FD 22 8E 06 0660*       ld (uiy),iy
       04          
04045A F5          0661*       push af ; fml
04045B E1          0662*       pop hl ; thanks, zilog
04045C 22 7F 06 04 0663*       ld (uaf),hl
040460 F5          0664*       push af ; dammit
040461             0665*   
040461             0666*   ; home the cursor
040461             0667*       ; call vdu_home_cursor
040461             0668*   
040461             0669*   ; print each register
040461 21 05 06 04 0670*       ld hl,str_afu
040465 CD 5A 01 04 0671*       call printString
040469 2A 7F 06 04 0672*       ld hl,(uaf)
04046D CD 7A 01 04 0673*       call printHex24
040471 CD 6F 01 04 0674*       call printNewLine
040475             0675*   
040475 21 0A 06 04 0676*       ld hl,str_hlu
040479 CD 5A 01 04 0677*       call printString
04047D 2A 82 06 04 0678*       ld hl,(uhl)
040481 CD 7A 01 04 0679*       call printHex24
040485 CD 6F 01 04 0680*       call printNewLine
040489             0681*   
040489 21 0F 06 04 0682*       ld hl,str_bcu
04048D CD 5A 01 04 0683*       call printString
040491 2A 85 06 04 0684*       ld hl,(ubc)
040495 CD 7A 01 04 0685*       call printHex24
040499 CD 6F 01 04 0686*       call printNewLine
04049D             0687*   
04049D 21 14 06 04 0688*       ld hl,str_deu
0404A1 CD 5A 01 04 0689*       call printString
0404A5 2A 88 06 04 0690*       ld hl,(ude)
0404A9 CD 7A 01 04 0691*       call printHex24
0404AD CD 6F 01 04 0692*       call printNewLine
0404B1             0693*   
0404B1 21 19 06 04 0694*       ld hl,str_ixu
0404B5 CD 5A 01 04 0695*       call printString
0404B9 2A 8B 06 04 0696*       ld hl,(uix)
0404BD CD 7A 01 04 0697*       call printHex24
0404C1 CD 6F 01 04 0698*       call printNewLine
0404C5             0699*   
0404C5 21 1E 06 04 0700*       ld hl,str_iyu
0404C9 CD 5A 01 04 0701*       call printString
0404CD 2A 8E 06 04 0702*       ld hl,(uiy)
0404D1 CD 7A 01 04 0703*       call printHex24
0404D5 CD 6F 01 04 0704*       call printNewLine
0404D9             0705*   
0404D9             0706*       ; call vsync
0404D9             0707*   
0404D9 CD 6F 01 04 0708*       call printNewLine
0404DD             0709*   
0404DD             0710*   ; check for right shift key and quit if pressed
0404DD             0711*       MOSCALL mos_getkbmap
0404DD 3E 1E       0001*M1 			LD	A, function
0404DF 5B CF       0002*M1 			RST.LIL	08h
0404E1             0712*   @stayhere:
0404E1             0713*   ; 7 RightShift
0404E1 DD CB 00 76 0714*       bit 6,(ix+0)
0404E5 20 02       0715*       jr nz,@RightShift
0404E7 18 F8       0716*       jr @stayhere
0404E9             0717*   @RightShift:
0404E9 DD CB 0E 86 0718*       res 0,(ix+14) ; debounce the key (hopefully)
0404ED 3E 80       0719*       ld a,%10000000
0404EF             0720*       ; call multiPurposeDelay
0404EF             0721*   
0404EF             0722*   ; restore everything
0404EF 2A 82 06 04 0723*       ld hl, (uhl)
0404F3 ED 4B 85 06 0724*       ld bc, (ubc)
       04          
0404F8 ED 5B 88 06 0725*       ld de, (ude)
       04          
0404FD DD 2A 8B 06 0726*       ld ix, (uix)
       04          
040502 FD 2A 8E 06 0727*       ld iy, (uiy)
       04          
040507 F1          0728*       pop af
040508             0729*   ; all done
040508 C9          0730*       ret
040509             0731*   
040509             0732*   ; print registers to screen in hexidecimal format
040509             0733*   ; inputs: none
040509             0734*   ; outputs: values of every register printed to screen
040509             0735*   ;    values of each register in global scratch memory
040509             0736*   ; destroys: nothing
040509             0737*   dumpRegistersHex:
040509             0738*   ; store everything in scratch
040509 22 82 06 04 0739*       ld (uhl),hl
04050D ED 43 85 06 0740*       ld (ubc),bc
       04          
040512 ED 53 88 06 0741*       ld (ude),de
       04          
040517 DD 22 8B 06 0742*       ld (uix),ix
       04          
04051C FD 22 8E 06 0743*       ld (uiy),iy
       04          
040521 F5          0744*       push af ; fml
040522 E1          0745*       pop hl ; thanks, zilog
040523 22 7F 06 04 0746*       ld (uaf),hl
040527 F5          0747*       push af ; dammit
040528             0748*   
040528             0749*   ; home the cursor
040528             0750*       ; call vdu_home_cursor
040528             0751*       ; call printNewLine
040528             0752*   
040528             0753*   ; print each register
040528 21 05 06 04 0754*       ld hl,str_afu
04052C CD 5A 01 04 0755*       call printString
040530 2A 7F 06 04 0756*       ld hl,(uaf)
040534 CD 7A 01 04 0757*       call printHex24
040538             0758*       ; call printNewLine
040538             0759*   
040538 21 0A 06 04 0760*       ld hl,str_hlu
04053C CD 5A 01 04 0761*       call printString
040540 2A 82 06 04 0762*       ld hl,(uhl)
040544 CD 7A 01 04 0763*       call printHex24
040548             0764*       ; call printNewLine
040548             0765*   
040548 21 0F 06 04 0766*       ld hl,str_bcu
04054C CD 5A 01 04 0767*       call printString
040550 2A 85 06 04 0768*       ld hl,(ubc)
040554 CD 7A 01 04 0769*       call printHex24
040558             0770*       ; call printNewLine
040558             0771*   
040558 21 14 06 04 0772*       ld hl,str_deu
04055C CD 5A 01 04 0773*       call printString
040560 2A 88 06 04 0774*       ld hl,(ude)
040564 CD 7A 01 04 0775*       call printHex24
040568             0776*       ; call printNewLine
040568             0777*   
040568 21 19 06 04 0778*       ld hl,str_ixu
04056C CD 5A 01 04 0779*       call printString
040570 2A 8B 06 04 0780*       ld hl,(uix)
040574 CD 7A 01 04 0781*       call printHex24
040578             0782*       ; call printNewLine
040578             0783*   
040578 21 1E 06 04 0784*       ld hl,str_iyu
04057C CD 5A 01 04 0785*       call printString
040580 2A 8E 06 04 0786*       ld hl,(uiy)
040584 CD 7A 01 04 0787*       call printHex24
040588             0788*       ; call printNewLine
040588             0789*   
040588             0790*       ; call vdu_vblank
040588             0791*   
040588 CD 6F 01 04 0792*       call printNewLine
04058C             0793*   ; restore everything
04058C 2A 82 06 04 0794*       ld hl, (uhl)
040590 ED 4B 85 06 0795*       ld bc, (ubc)
       04          
040595 ED 5B 88 06 0796*       ld de, (ude)
       04          
04059A DD 2A 8B 06 0797*       ld ix, (uix)
       04          
04059F FD 2A 8E 06 0798*       ld iy, (uiy)
       04          
0405A4 F1          0799*       pop af
0405A5             0800*   ; all done
0405A5 C9          0801*       ret
0405A6             0802*   
0405A6             0803*   dumpRegistersHexPrime:
0405A6 D9          0804*       exx
0405A7 08          0805*       ex af,af'
0405A8 CD 09 05 04 0806*       call dumpRegistersHex
0405AC 08          0807*       ex af,af'
0405AD D9          0808*       exx
0405AE C9          0809*       ret
0405AF             0810*   
0405AF             0811*   ; additionally dump prime registers
0405AF             0812*   ; inputs: none
0405AF             0813*   ; outputs: values of every register printed to screen
0405AF             0814*   ; destroys: nothing
0405AF             0815*   dumpRegistersHexAll:
0405AF CD 09 05 04 0816*       call dumpRegistersHex
0405B3 08          0817*       ex af,af'
0405B4 D9          0818*       exx
0405B5 CD 09 05 04 0819*       call dumpRegistersHex
0405B9 08          0820*       ex af,af'
0405BA D9          0821*       exx
0405BB C9          0822*       ret
0405BC             0823*   
0405BC             0824*   ; print hlu to screen in hexidecimal format
0405BC             0825*   ; inputs: none
0405BC             0826*   ; destroys: nothing
0405BC             0827*   print_hex_hl:
0405BC F5          0828*       push af
0405BD E5          0829*       push hl
0405BE 21 0A 06 04 0830*       ld hl,str_hlu
0405C2 CD 5A 01 04 0831*       call printString
0405C6 E1          0832*       pop hl
0405C7 E5          0833*       push hl
0405C8 CD 7A 01 04 0834*       call printHex24
0405CC 3E 20       0835*       ld a,' '
0405CE 5B D7       0836*       rst.lil 10h
0405D0 E1          0837*       pop hl
0405D1 F1          0838*       pop af
0405D2 C9          0839*       ret
0405D3             0840*   
0405D3             0841*   ; print bcu to screen in hexidecimal format
0405D3             0842*   ; inputs: none
0405D3             0843*   ; destroys: nothing
0405D3             0844*   print_hex_bc:
0405D3 F5          0845*       push af
0405D4 E5          0846*       push hl
0405D5 C5          0847*       push bc
0405D6 21 0F 06 04 0848*       ld hl,str_bcu
0405DA CD 5A 01 04 0849*       call printString
0405DE E1          0850*       pop hl
0405DF E5          0851*       push hl
0405E0 CD 7A 01 04 0852*       call printHex24
0405E4 3E 20       0853*       ld a,' '
0405E6 5B D7       0854*       rst.lil 10h
0405E8 C1          0855*       pop bc
0405E9 E1          0856*       pop hl
0405EA F1          0857*       pop af
0405EB C9          0858*       ret
0405EC             0859*   
0405EC             0860*   ; print deu to screen in hexidecimal format
0405EC             0861*   ; inputs: none
0405EC             0862*   ; destroys: nothing
0405EC             0863*   print_hex_de:
0405EC F5          0864*       push af
0405ED E5          0865*       push hl
0405EE D5          0866*       push de
0405EF 21 14 06 04 0867*       ld hl,str_deu
0405F3 CD 5A 01 04 0868*       call printString
0405F7 E1          0869*       pop hl
0405F8 E5          0870*       push hl
0405F9 CD 7A 01 04 0871*       call printHex24
0405FD 3E 20       0872*       ld a,' '
0405FF 5B D7       0873*       rst.lil 10h
040601 D1          0874*       pop de
040602 E1          0875*       pop hl
040603 F1          0876*       pop af
040604 C9          0877*       ret
040605             0878*   
040605 20 61 66 3D 0879*   str_afu: db " af=",0
       00          
04060A 20 68 6C 3D 0880*   str_hlu: db " hl=",0
       00          
04060F 20 62 63 3D 0881*   str_bcu: db " bc=",0
       00          
040614 20 64 65 3D 0882*   str_deu: db " de=",0
       00          
040619 20 69 78 3D 0883*   str_ixu: db " ix=",0
       00          
04061E 20 69 79 3D 0884*   str_iyu: db " iy=",0
       00          
040623             0885*   
040623             0886*   ; print udeuhl to screen in hexidecimal format
040623             0887*   ; inputs: none
040623             0888*   ; outputs: concatenated hexidecimal udeuhl
040623             0889*   ; destroys: nothing
040623             0890*   dumpUDEUHLHex:
040623             0891*   ; store everything in scratch
040623 22 82 06 04 0892*       ld (uhl),hl
040627 ED 43 85 06 0893*       ld (ubc),bc
       04          
04062C ED 53 88 06 0894*       ld (ude),de
       04          
040631 DD 22 8B 06 0895*       ld (uix),ix
       04          
040636 FD 22 8E 06 0896*       ld (uiy),iy
       04          
04063B F5          0897*       push af
04063C             0898*   
04063C             0899*   ; print each register
04063C             0900*   
04063C 21 76 06 04 0901*       ld hl,str_udeuhl
040640 CD 5A 01 04 0902*       call printString
040644 2A 88 06 04 0903*       ld hl,(ude)
040648 CD 7A 01 04 0904*       call printHex24
04064C 3E 2E       0905*       ld a,'.' ; print a dot to separate the values
04064E 5B D7       0906*       rst.lil 10h
040650 2A 82 06 04 0907*       ld hl,(uhl)
040654 CD 7A 01 04 0908*       call printHex24
040658 CD 6F 01 04 0909*       call printNewLine
04065C             0910*   
04065C             0911*   ; restore everything
04065C 2A 82 06 04 0912*       ld hl, (uhl)
040660 ED 4B 85 06 0913*       ld bc, (ubc)
       04          
040665 ED 5B 88 06 0914*       ld de, (ude)
       04          
04066A DD 2A 8B 06 0915*       ld ix, (uix)
       04          
04066F FD 2A 8E 06 0916*       ld iy, (uiy)
       04          
040674 F1          0917*       pop af
040675             0918*   ; all done
040675 C9          0919*       ret
040676             0920*   
040676 75 64 65 2E 0921*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04067F             0922*   
04067F             0923*   ; global scratch memory for registers
04067F 00 00 00    0924*   uaf: dl 0
040682 00 00 00    0925*   uhl: dl 0
040685 00 00 00    0926*   ubc: dl 0
040688 00 00 00    0927*   ude: dl 0
04068B 00 00 00    0928*   uix: dl 0
04068E 00 00 00    0929*   uiy: dl 0
040691 00 00 00    0930*   usp: dl 0
040694 00 00 00    0931*   upc: dl 0
040697             0932*   
040697             0933*   ; inputs: whatever is in the flags register
040697             0934*   ; outputs: binary representation of flags
040697             0935*   ;          with a header so we know which is what
040697             0936*   ; destroys: nothing
040697             0937*   ; preserves: everything
040697             0938*   dumpFlags:
040697             0939*   ; first we curse zilog for not giving direct access to flags
040697 F5          0940*       push af ; this is so we can send it back unharmed
040698 F5          0941*       push af ; this is so we can pop it to hl
040699             0942*   ; store everything in scratch
040699 22 82 06 04 0943*       ld (uhl),hl
04069D ED 43 85 06 0944*       ld (ubc),bc
       04          
0406A2 ED 53 88 06 0945*       ld (ude),de
       04          
0406A7 DD 22 8B 06 0946*       ld (uix),ix
       04          
0406AC FD 22 8E 06 0947*       ld (uiy),iy
       04          
0406B1             0948*   ; next we print the header
0406B1 21 DD 06 04 0949*       ld hl,@header
0406B5 CD 5A 01 04 0950*       call printString
0406B9 E1          0951*       pop hl ; flags are now in l
0406BA 7D          0952*       ld a,l ; flags are now in a
0406BB CD F8 03 04 0953*       call printBin8
0406BF CD 6F 01 04 0954*       call printNewLine
0406C3             0955*   ; restore everything
0406C3 2A 82 06 04 0956*       ld hl, (uhl)
0406C7 ED 4B 85 06 0957*       ld bc, (ubc)
       04          
0406CC ED 5B 88 06 0958*       ld de, (ude)
       04          
0406D1 DD 2A 8B 06 0959*       ld ix, (uix)
       04          
0406D6 FD 2A 8E 06 0960*       ld iy, (uiy)
       04          
0406DB F1          0961*       pop af ; send her home the way she came
0406DC C9          0962*       ret
0406DD             0963*   ; Bit 7 (S): Sign flag
0406DD             0964*   ; Bit 6 (Z): Zero flag
0406DD             0965*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0406DD             0966*   ; Bit 4 (H): Half Carry flag
0406DD             0967*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0406DD             0968*   ; Bit 2 (PV): Parity/Overflow flag
0406DD             0969*   ; Bit 1 (N): Subtract flag
0406DD             0970*   ; Bit 0 (C): Carry flag
0406DD 53 5A 78 48 0971*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0406E8             0972*   
0406E8             0973*   ; set all the bits in the flag register
0406E8             0974*   ; more of an academic exercise than anything useful
0406E8             0975*   ; inputs; none
0406E8             0976*   ; outputs; a=0,f=255
0406E8             0977*   ; destroys: flags, hl
0406E8             0978*   ; preserves: a, because why not
0406E8             0979*   setAllFlags:
0406E8 21 FF 00 00 0980*       ld hl,255
0406EC 67          0981*       ld h,a ; four cycles to preserve a is cheap
0406ED E5          0982*       push hl
0406EE F1          0983*       pop af
0406EF C9          0984*       ret
0406F0             0985*   
0406F0             0986*   ; reset all the bits in the flag register
0406F0             0987*   ; unlike its inverse counterpart, this may actually be useful
0406F0             0988*   ; inputs; none
0406F0             0989*   ; outputs; a=0,f=0
0406F0             0990*   ; destroys: flags, hl
0406F0             0991*   ; preserves: a, because why not
0406F0             0992*   resetAllFlags:
0406F0 21 00 00 00 0993*       ld hl,0
0406F4 67          0994*       ld h,a ; four cycles to preserve a is cheap
0406F5 E5          0995*       push hl
0406F6 F1          0996*       pop af
0406F7 C9          0997*       ret
0406F8             0998*   
0406F8             0999*   ; wait until user presses a key
0406F8             1000*   ; inputs: none
0406F8             1001*   ; outputs: ascii code of key pressed in a
0406F8             1002*   ; destroys: af,ix
0406F8             1003*   waitKeypress:
0406F8             1004*       MOSCALL mos_getkey
0406F8 3E 00       0001*M1 			LD	A, function
0406FA 5B CF       0002*M1 			RST.LIL	08h
0406FC C9          1005*       ret
0406FD             1006*   
0406FD             1007*   ; print bytes from an address to the screen in hexidecimal format
0406FD             1008*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0406FD             1009*   ; outputs: values of each byte printed to screen separated by spaces
0406FD             1010*   ; destroys: nothing
0406FD             1011*   dumpMemoryHex:
0406FD             1012*   ; save registers to the stack
0406FD C5          1013*       push bc
0406FE E5          1014*       push hl
0406FF F5          1015*       push af
040700             1016*   
040700             1017*   ; print the address and separator
040700 CD 7A 01 04 1018*       call printHex24
040704 3E 3A       1019*       ld a,':'
040706 5B D7       1020*       rst.lil 10h
040708 3E 20       1021*       ld a,' '
04070A 5B D7       1022*       rst.lil 10h
04070C             1023*   
04070C             1024*   ; set b to be our loop counter
04070C F1          1025*       pop af
04070D 47          1026*       ld b,a
04070E E1          1027*       pop hl
04070F E5          1028*       push hl
040710 F5          1029*       push af
040711             1030*   @loop:
040711             1031*   ; print the byte
040711 7E          1032*       ld a,(hl)
040712 CD 88 01 04 1033*       call printHex8
040716             1034*   ; print a space
040716 3E 20       1035*       ld a,' '
040718 5B D7       1036*       rst.lil 10h
04071A 23          1037*       inc hl
04071B 10 F4       1038*       djnz @loop
04071D CD 6F 01 04 1039*       call printNewLine
040721             1040*   
040721             1041*   ; restore everything
040721 F1          1042*       pop af
040722 E1          1043*       pop hl
040723 C1          1044*       pop bc
040724             1045*   
040724             1046*   ; all done
040724 C9          1047*       ret
040725             1048*   
040725             1049*   
040725             1050*   ; print bytes from an address to the screen in binary format
040725             1051*   ; inputs: hl = address of first byte to print, a = number of bytes to print
040725             1052*   ; outputs: values of each byte printed to screen separated by spaces
040725             1053*   ; destroys: nothing
040725             1054*   dumpMemoryBin:
040725             1055*   ; save all registers to the stack
040725 F5          1056*       push af
040726 C5          1057*       push bc
040727 D5          1058*       push de
040728 E5          1059*       push hl
040729 DD E5       1060*       push ix
04072B FD E5       1061*       push iy
04072D             1062*   
04072D             1063*   ; set b to be our loop counter
04072D 47          1064*       ld b,a
04072E             1065*   @loop:
04072E             1066*   ; print the byte
04072E 7E          1067*       ld a,(hl)
04072F E5          1068*       push hl
040730 C5          1069*       push bc
040731 CD F8 03 04 1070*       call printBin8
040735 C1          1071*       pop bc
040736             1072*   ; print a space
040736 3E 20       1073*       ld a,' '
040738 5B D7       1074*       rst.lil 10h
04073A E1          1075*       pop hl
04073B 23          1076*       inc hl
04073C 10 F0       1077*       djnz @loop
04073E CD 6F 01 04 1078*       call printNewLine
040742             1079*   
040742             1080*   ; restore everything
040742 FD E1       1081*       pop iy
040744 DD E1       1082*       pop ix
040746 E1          1083*       pop hl
040747 D1          1084*       pop de
040748 C1          1085*       pop bc
040749 F1          1086*       pop af
04074A             1087*   ; all done
04074A C9          1088*       ret
04074B             1089*   
04074B             1090*   ; print bytes from an address to the screen in binary format
04074B             1091*   ; with the bits of each byte in reverse order (lsb first)
04074B             1092*   ; inputs: hl = address of first byte to print, a = number of bytes to print
04074B             1093*   ; outputs: values of each byte printed to screen separated by spaces
04074B             1094*   ; destroys: nothing
04074B             1095*   dumpMemoryBinRev:
04074B             1096*   ; save all registers to the stack
04074B F5          1097*       push af
04074C C5          1098*       push bc
04074D D5          1099*       push de
04074E E5          1100*       push hl
04074F DD E5       1101*       push ix
040751 FD E5       1102*       push iy
040753             1103*   
040753             1104*   ; set b to be our loop counter
040753 47          1105*       ld b,a
040754             1106*   @loop:
040754             1107*   ; print the byte
040754 7E          1108*       ld a,(hl)
040755 E5          1109*       push hl
040756 C5          1110*       push bc
040757 CD 1D 04 04 1111*       call printBin8Rev
04075B C1          1112*       pop bc
04075C             1113*   ; print a space
04075C 3E 20       1114*       ld a,' '
04075E 5B D7       1115*       rst.lil 10h
040760 E1          1116*       pop hl
040761 23          1117*       inc hl
040762 10 F0       1118*       djnz @loop
040764 CD 6F 01 04 1119*       call printNewLine
040768             1120*   
040768             1121*   ; restore everything
040768 FD E1       1122*       pop iy
04076A DD E1       1123*       pop ix
04076C E1          1124*       pop hl
04076D D1          1125*       pop de
04076E C1          1126*       pop bc
04076F F1          1127*       pop af
040770             1128*   ; all done
040770 C9          1129*       ret
040771             0035        include "input.inc"
040771 00          0001*   dithering_type: db 0x00 ; 0=none, 1=bayer ordered matrix, 2=floyd-steinberg
040772 00 01 00    0002*   current_image_id: dl 256 ; buffer_id of the current image
040775 00 00 00    0003*   current_image_index: dl 0 ; index of the current image
040778             0004*   
040778             0005*   keyboard_masks: ds 16 ; 16 bytes for the keyboard masks
040788             0006*   
040788             0007*   ; check system virtual keyboard map for keys down and or them with local keyboard masks
040788             0008*   ; inputs: none
040788             0009*   ; outputs: none
040788             0010*   ; clobbers: a, b, ix, iy
040788             0011*   set_keys:
040788             0012*       MOSCALL mos_getkbmap ; ix points to the virtual keyboard map
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040788 3E 1E       0001*M1 			LD	A, function
04078A 5B CF       0002*M1 			RST.LIL	08h
04078C FD 21 78 07 0013*       ld iy,keyboard_masks
       04          
040791 06 10       0014*       ld b,16 ; loop counter
040793             0015*   @loop:
040793 DD 7E 00    0016*       ld a,(ix)
040796 FD B6 00    0017*       or (iy)
040799 FD 77 00    0018*       ld (iy),a
04079C DD 23       0019*       inc ix
04079E FD 23       0020*       inc iy
0407A0 10 F1       0021*       djnz @loop
0407A2 C9          0022*       ret
0407A3             0023*   
0407A3             0024*   ; reset the local keyboard masks to zero
0407A3             0025*   ; inputs: none
0407A3             0026*   ; outputs: none
0407A3             0027*   ; clobbers: a, b, iy
0407A3             0028*   reset_keys:
0407A3 FD 21 78 07 0029*       ld iy,keyboard_masks
       04          
0407A8 AF          0030*       xor a
0407A9 06 10       0031*       ld b,16 ; loop counter
0407AB             0032*   @loop:
0407AB FD 77 00    0033*       ld (iy),a
0407AE FD 23       0034*       inc iy
0407B0 10 F9       0035*       djnz @loop
0407B2 C9          0036*       ret
0407B3             0037*   
0407B3             0038*   ; ============ KEYBOARD INPUT ============
0407B3             0039*   do_input:
0407B3             0040*   ; get user keyboard input
0407B3 DD 21 78 07 0041*       ld ix,keyboard_masks
       04          
0407B8 3E FF       0042*       ld a,-1 ; anything non-zero to indicates no key pressed
0407BA             0043*   
0407BA             0044*   ; ------ QUIT ------
0407BA             0045*   ; 113 Escape
0407BA DD CB 0E 46 0046*       bit 0,(ix+14)
0407BE C2 FB 10 04 0047*   	jp nz,main_end
0407C2             0048*   
0407C2             0049*   ; ------ RENDERING OPTIONS ------
0407C2             0050*   ; ; 99 Space cycle through dithering types
0407C2             0051*   ;     bit 2,(ix+12)
0407C2             0052*   ;     call nz,cycle_dithering
0407C2             0053*   ;     xor a
0407C2             0054*   
0407C2             0055*   ; 26 Left
0407C2 DD CB 03 4E 0056*       bit 1,(ix+3)
0407C6 CA D6 07 04 0057*       jp z,@Left
0407CA ED 5B 75 07 0058*       ld de,(current_image_index)
       04          
0407CF 1B          0059*       dec de
0407D0 ED 53 75 07 0060*       ld (current_image_index),de
       04          
0407D5 AF          0061*       xor a
0407D6             0062*   @Left:
0407D6             0063*   
0407D6             0064*   ; 122 Right
0407D6 DD CB 0F 4E 0065*       bit 1,(ix+15)
0407DA CA EA 07 04 0066*       jp z,@Right
0407DE ED 5B 75 07 0067*       ld de,(current_image_index)
       04          
0407E3 13          0068*       inc de
0407E4 ED 53 75 07 0069*       ld (current_image_index),de
       04          
0407E9 AF          0070*       xor a
0407EA             0071*   @Right:
0407EA             0072*   ; check keypress flag and branch accordingly
0407EA A7          0073*       and a
0407EB CA 8F 10 04 0074*       jp z,rendbmp
0407EF             0075*   
0407EF             0076*   ; check slideshow timer and branch accordingly
0407EF CD 2B 08 04 0077*       call tmr_slideshow_get
0407F3 F2 EF 10 04 0078*       jp p,no_move
0407F7 CD 13 08 04 0079*       call tmr_slideshow_set
0407FB ED 5B 75 07 0080*       ld de,(current_image_index)
       04          
040800 13          0081*       inc de
040801 ED 53 75 07 0082*       ld (current_image_index),de
       04          
040806 C3 8F 10 04 0083*       jp rendbmp
04080A             0084*   
04080A             0085*   ; slideshow timer routines
04080A             0086*   tmr_slideshow: ds 6 ; buffer to hold slideshow timer
       FF FF FF FF 
       FF FF 
040810 B0 04 00    0087*   tmr_slideshow_reset: dl 10*120
040813             0088*   
040813             0089*   ; set a countdown timer for the slideshow using the timestamp timer
040813             0090*   ; returns: hl = current time
040813             0091*   ; destroys: af,hl,de,ix,iy
040813             0092*   tmr_slideshow_set:
040813 FD 21 0A 08 0093*       ld iy,tmr_slideshow
       04          
040818 2A 10 08 04 0094*       ld hl,(tmr_slideshow_reset)
04081C FD 2F 03    0095*       ld (iy+3),hl ; set time remaining
04081F CD 2C 09 04 0096*       call timestamp_tick
040823 2A 23 09 04 0097*       ld hl,(timestamp_now)   ; get current timestamp
040827 FD 2F 00    0098*       ld (iy+0),hl ; set start time
04082A C9          0099*       ret
04082B             0100*   
04082B             0101*   ; gets time remaining on the slideshow countdown timer following the global timestamp
04082B             0102*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04082B             0103*   ;          sign flags: pos = time not expired,zero or neg = time expired
04082B             0104*   ; destroys: af,hl,de,ix,iy
04082B             0105*   tmr_slideshow_get:
04082B CD 2C 09 04 0106*       call timestamp_tick
04082F FD 21 0A 08 0107*       ld iy,tmr_slideshow
       04          
040834 CD 54 09 04 0108*       call timestamp_tmr_get
040838 C9          0109*       ret
040839             0036        include "timer.inc"
040839             0001*   ; Table 32. Timer Control Registers
040839             0002*   ; this constant is the base address of the timer control registers
040839             0003*   ; each timer takes three bytes:
040839             0004*   ;   0: control register
040839             0005*   ;   1: low byte of timer reset value
040839             0006*   ;   2: high byte of timer reset value
040839             0007*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
040839             0008*   ; which correctly force the high and upper bytes of the address bus to zero
040839             0009*   TMR_CTL:     equ 80h
040839             0010*   
040839             0011*   ; Timer Control Register Bit Definitions
040839             0012*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
040839             0013*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
040839             0014*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
040839             0015*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
040839             0016*                               ; the TMRx_CTL register is read.
040839             0017*   
040839             0018*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
040839             0019*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
040839             0020*   
040839             0021*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
040839             0022*                               ;  0,and counting stops when the end-of-count value is reached.
040839             0023*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
040839             0024*                               ; written to the counter when the end-of-count value is reached.
040839             0025*   
040839             0026*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
040839             0027*   CLK_DIV_256:  equ %00001100 ;
040839             0028*   CLK_DIV_64:   equ %00001000 ;
040839             0029*   CLK_DIV_16:   equ %00000100 ;
040839             0030*   CLK_DIV_4:    equ %00000000 ;
040839             0031*   
040839             0032*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
040839             0033*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
040839             0034*                               ; When a 1 is written to this bit,the values in the reload registers
040839             0035*                               ;  are loaded into the downcounter when the timer restarts. The
040839             0036*                               ; programmer must ensure that this bit is set to 1 each time
040839             0037*                               ; SINGLE-PASS mode is used.
040839             0038*   
040839             0039*   ; disable/enable the programmable reload timer
040839             0040*   PRT_EN_0:     equ %00000000 ;
040839             0041*   PRT_EN_1:     equ %00000001 ;
040839             0042*   
040839             0043*   ; Table 37. Timer Input Source Select Register
040839             0044*   ; Each of the 4 timers are allocated two bits of the 8-bit register
040839             0045*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
040839             0046*   ;   00: System clock / CLK_DIV
040839             0047*   ;   01: RTC / CLK_DIV
040839             0048*   ;   NOTE: these are the values given in the manual,but it may be a typo
040839             0049*   ;   10: GPIO port B pin 1.
040839             0050*   ;   11: GPIO port B pin 1.
040839             0051*   TMR_ISS:   equ 92h ; register address
040839             0052*   
040839             0053*   ; Table 51. Real-Time Clock Control Register
040839             0054*   RTC_CTRL: equ EDh ; register address
040839             0055*   
040839             0056*   ; alarm interrupt disable/enable
040839             0057*   RTC_ALARM_0:    equ %00000000
040839             0058*   RTC_ALARM_1:    equ %10000000
040839             0059*   
040839             0060*   ; interrupt on alarm disable/enable
040839             0061*   RTC_INT_ENT_0:  equ %00000000
040839             0062*   RTC_INT_ENT_1:  equ %01000000
040839             0063*   
040839             0064*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
040839             0065*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
040839             0066*   
040839             0067*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
040839             0068*                                   ; On-chip 32768 Hz oscillator is enabled.
040839             0069*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
040839             0070*                                   ; On-chip 32768 Hz oscillator is disabled.
040839             0071*   
040839             0072*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
040839             0073*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
040839             0074*   
040839             0075*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
040839             0076*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
040839             0077*   
040839             0078*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
040839             0079*                                   ; RTC counter is enabled.
040839             0080*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
040839             0081*                                   ; RTC counter is disabled.
040839             0082*   
040839             0083*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
040839             0084*   
040839             0085*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
040839             0086*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
040839 00 00 00    0087*   prt_reload: dl 0x000000
04083C             0088*   
04083C             0089*   ; ; returns: a = 0 if running on hardware,1 if running on emulator
04083C             0090*   ; ;          de = number PRT interrupts during test interval
04083C             0091*   ; prt_calibrate:
04083C             0092*   ;     call vdu_vblank
04083C             0093*   ; ; set a MOS timer
04083C             0094*   ;     ld hl,120*1 ; 1 second
04083C             0095*   ;     ld iy,tmr_test
04083C             0096*   ;     call tmr_set
04083C             0097*   ; ; set a PRT timer
04083C             0098*   ;     ; ld hl,prt_reload_hardware
04083C             0099*   ;     ; ld hl,prt_reload_emulator
04083C             0100*   ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
04083C             0101*   ;     ld (prt_reload),hl
04083C             0102*   ;     call prt_set
04083C             0103*   ; @loop:
04083C             0104*   ; ; check time remaining on MOS timer
04083C             0105*   ;     call tmr_get
04083C             0106*   ;     jp z,@done ; time expired,so quit
04083C             0107*   ;     jp m,@done ; time past expiration (negative),so quit
04083C             0108*   ;     jr @loop
04083C             0109*   ; @done:
04083C             0110*   ;     ld de,(prt_irq_counter)
04083C             0111*   ;     ld bc,prt_reload_hardware ; default value for running on hardware
04083C             0112*   ;     ld (prt_reload),bc
04083C             0113*   ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
04083C             0114*   ;     xor a ; clear carry,zero is default value for running on hardware
04083C             0115*   ;     ld (is_emulator),a
04083C             0116*   ;     sbc hl,de
04083C             0117*   ;     ld hl,on_hardware ; default message for running on hardware
04083C             0118*   ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
04083C             0119*   ;     ret m ; negative result means we're on hardware
04083C             0120*   ;     inc a ; we're on emulator
04083C             0121*   ;     ld (is_emulator),a
04083C             0122*   ;     ld bc,prt_reload_emulator
04083C             0123*   ;     ld (prt_reload),bc
04083C             0124*   ;     ld hl,on_emulator
04083C             0125*   ;     ret
04083C             0126*   
04083C             0127*   ; calibrating_timer: defb "Calibrating timer\r\n",0
04083C             0128*   
04083C             0129*   ; set PRT timer
04083C             0130*   prt_set:
04083C 21 00 00 00 0131*       ld hl,0
040840 22 8A 08 04 0132*       ld (prt_irq_counter),hl
040844 2A 39 08 04 0133*       ld hl,(prt_reload)
040848 ED 29 84    0134*       out0 ($84),l
04084B ED 21 85    0135*   	out0 ($85),h
04084E             0136*   ; disable timer
04084E 3E 06       0137*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
040850 ED 39 83    0138*   	out0 ($83),a
040853             0139*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
040853 3E 57       0140*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
040855 ED 39 83    0141*   	out0 ($83),a
040858 C9          0142*       ret
040859             0143*   
040859             0144*   ; ===============================================
040859             0145*   ; PRT Timer Interrupt Handling
040859             0146*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
040859             0147*   ; -----------------------------------------------
040859             0148*   prt_irq_init:
040859             0149*       ; set up interrupt vector table 2
040859 21 00 00 00 0150*   	ld hl,0
04085D 3A 0C 01 00 0151*   	ld a,($10c)
040861 6F          0152*   	ld l,a
040862 3A 0D 01 00 0153*   	ld a,($10d)
040866 67          0154*   	ld h,a
040867             0155*   
040867             0156*   	; skip over CALL ($c3)
040867 23          0157*   	inc hl
040868             0158*   	; load address of jump into vector table 2 (in ram)
040868 ED 27       0159*   	ld hl,(hl)
04086A             0160*   
04086A             0161*   	; write CALL prt_irq_handler to vector table 2
04086A 3E C3       0162*   	ld a,$c3
04086C 77          0163*   	ld (hl),a
04086D 23          0164*   	inc hl
04086E 11 75 08 04 0165*   	ld de,prt_irq_handler
040872 ED 1F       0166*   	ld (hl),de
040874             0167*   
040874 C9          0168*       ret
040875             0169*   
040875             0170*   prt_irq_handler:
040875 F3          0171*   	di
040876 F5          0172*   	push af
040877 E5          0173*       push hl
040878 ED 38 83    0174*   	in0 a,($83)
04087B 2A 8A 08 04 0175*   	ld hl,(prt_irq_counter)
04087F 23          0176*   	inc hl
040880 22 8A 08 04 0177*   	ld (prt_irq_counter),hl
040884 E1          0178*       pop hl
040885 F1          0179*   	pop af
040886 FB          0180*   	ei
040887 5B ED 4D    0181*   	reti.l
04088A             0182*   
04088A             0183*   prt_irq_counter:
04088A 00 00 00    0184*   	.dl 0
04088D             0185*   prt_irq_counter_saved:
04088D 00 00 00    0186*       .dl 0
040890             0187*   
040890             0188*   prt_loop_reset:
040890 E5          0189*       push hl
040891 21 00 00 00 0190*   	ld hl,0
040895 22 8A 08 04 0191*   	ld (prt_irq_counter),hl
040899 22 FB 08 04 0192*       ld (prt_loop_counter),hl
04089D 22 FE 08 04 0193*       ld (prt_loops),hl
0408A1 CD 3C 08 04 0194*       call prt_set
0408A5 E1          0195*       pop hl
0408A6 C9          0196*       ret
0408A7             0197*   
0408A7             0198*   prt_loop_start:
0408A7 E5          0199*       push hl
0408A8 21 00 00 00 0200*   	ld hl,0
0408AC 22 8A 08 04 0201*   	ld (prt_irq_counter),hl
0408B0 E1          0202*       pop hl
0408B1 C9          0203*       ret
0408B2             0204*   
0408B2             0205*   prt_loop_stop:
0408B2 E5          0206*       push hl
0408B3 D5          0207*       push de
0408B4 2A 8A 08 04 0208*       ld hl,(prt_irq_counter)
0408B8 ED 5B FB 08 0209*       ld de,(prt_loop_counter)
       04          
0408BD 19          0210*       add hl,de
0408BE 22 FB 08 04 0211*       ld (prt_loop_counter),hl
0408C2 21 00 00 00 0212*       ld hl,0
0408C6 22 8A 08 04 0213*       ld (prt_irq_counter),hl
0408CA 2A FE 08 04 0214*       ld hl,(prt_loops)
0408CE 23          0215*       inc hl
0408CF 22 FE 08 04 0216*       ld (prt_loops),hl
0408D3 D1          0217*       pop de
0408D4 E1          0218*       pop hl
0408D5 C9          0219*       ret
0408D6             0220*   
0408D6             0221*   ; inputs: bc = y,x text coordinates to print
0408D6             0222*   prt_loop_print:
0408D6 F5          0223*       push af
0408D7 E5          0224*       push hl
0408D8 C5          0225*       push bc
0408D9 D5          0226*       push de
0408DA DD E5       0227*       push ix
0408DC FD E5       0228*       push iy
0408DE CD F3 09 04 0229*       call vdu_move_cursor
0408E2             0230*   
0408E2 2A FB 08 04 0231*       ld hl,(prt_loop_counter)
0408E6 CD 59 02 04 0232*       call printDec
0408EA             0233*   
0408EA 2A FE 08 04 0234*       ld hl,(prt_loops)
0408EE CD 59 02 04 0235*       call printDec
0408F2             0236*   
0408F2 FD E1       0237*       pop iy
0408F4 DD E1       0238*       pop ix
0408F6 D1          0239*       pop de
0408F7 C1          0240*       pop bc
0408F8 E1          0241*       pop hl
0408F9 F1          0242*       pop af
0408FA C9          0243*       ret
0408FB             0244*   
0408FB             0245*   prt_loop_counter:
0408FB 00 00 00    0246*       .dl 0
0408FE             0247*   prt_loops:
0408FE 00 00 00    0248*       .dl 0
040901             0249*   
040901             0250*   ; ===============================================
040901             0251*   ; Timer functions
040901             0252*   ; -----------------------------------------------
040901             0253*   ; set a countdown timer
040901             0254*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
040901             0255*   ; returns: hl = current time
040901             0256*   tmr_set:
040901 FD 2F 03    0257*       ld (iy+3),hl            ; set time remaining
040904             0258*       MOSCALL mos_sysvars     ; ix points to syvars table
040904 3E 08       0001*M1 			LD	A, function
040906 5B CF       0002*M1 			RST.LIL	08h
040908 DD 27 00    0259*       ld hl,(ix+sysvar_time)  ; get current time
04090B FD 2F 00    0260*       ld (iy+0),hl            ; set start time
04090E C9          0261*       ret
04090F             0262*   
04090F             0263*   ; gets time remaining on a countdown timer
04090F             0264*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04090F             0265*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04090F             0266*   ;          sign flags: pos = time not expired,zero or neg = time expired
04090F             0267*   tmr_get:
04090F             0268*       MOSCALL mos_sysvars     ; ix points to syvars table
04090F 3E 08       0001*M1 			LD	A, function
040911 5B CF       0002*M1 			RST.LIL	08h
040913 DD 17 00    0269*       ld de,(ix+sysvar_time)  ; get current time
040916 FD 27 00    0270*       ld hl,(iy+0)            ; get start time
040919 AF          0271*       xor a                   ; clear carry
04091A ED 52       0272*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04091C FD 17 03    0273*       ld de,(iy+3)            ; get timer set value
04091F AF          0274*       xor a                   ; clear carry
040920 ED 5A       0275*       adc hl,de               ; hl = time remaining
040922             0276*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
040922 C9          0277*       ret
040923             0278*   
040923 00 00 00    0279*   timestamp_now: dl 0
040926 00 00 00    0280*   timestamp_old: dl 0
040929 00 00 00    0281*   timestamp_chg: dl 0
04092C             0282*   
04092C             0283*   ; update the global timestamp from the system clock
04092C             0284*   ; inputs: none
04092C             0285*   ; returns: hl = time elapsed in 1/120ths of a second
04092C             0286*   ;          de = current time
04092C             0287*   ;          ix = pointer to syvars table
04092C             0288*   ; destroys: af,hl,de,ix
04092C             0289*   timestamp_tick:
04092C ED 5B 23 09 0290*       ld de,(timestamp_now)   ; get previous time
       04          
040931 ED 53 26 09 0291*       ld (timestamp_old),de   ; save previous time
       04          
040936             0292*       MOSCALL mos_sysvars     ; ix points to syvars table
040936 3E 08       0001*M1 			LD	A, function
040938 5B CF       0002*M1 			RST.LIL	08h
04093A DD 27 00    0293*       ld hl,(ix+sysvar_time)  ; get current time
04093D 22 23 09 04 0294*       ld (timestamp_now),hl   ; save current time
040941 AF          0295*       xor a                   ; clear carry
040942 ED 52       0296*       sbc hl,de               ; hl = time elapsed
040944 22 29 09 04 0297*       ld (timestamp_chg),hl   ; save elapsed time
040948 C9          0298*       ret
040949             0299*   
040949             0300*   ; set a countdown timer
040949             0301*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
040949             0302*   ; requires: timestamp_tick to be called at least once before this function
040949             0303*   ; returns: hl = current time
040949             0304*   ; destroys: hl
040949             0305*   timestamp_tmr_set:
040949 FD 2F 03    0306*       ld (iy+3),hl            ; set time remaining
04094C 2A 23 09 04 0307*       ld hl,(timestamp_now)   ; get current timestamp
040950 FD 2F 00    0308*       ld (iy+0),hl            ; set start time
040953 C9          0309*       ret
040954             0310*   
040954             0311*   ; gets time remaining on a countdown timer following the global timestamp
040954             0312*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
040954             0313*   ; requires: timestamp_tick to be called at least once before this function
040954             0314*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
040954             0315*   ;          sign flags: pos = time not expired,zero or neg = time expired
040954             0316*   ; destroys: af,hl,de
040954             0317*   timestamp_tmr_get:
040954 ED 5B 23 09 0318*       ld de,(timestamp_now)   ; get current timestamp
       04          
040959 FD 27 00    0319*       ld hl,(iy+0)            ; get start time
04095C AF          0320*       xor a                   ; clear carry
04095D ED 52       0321*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04095F FD 17 03    0322*       ld de,(iy+3)            ; get timer set value
040962 AF          0323*       xor a                   ; clear carry
040963 ED 5A       0324*       adc hl,de               ; hl = time remaining
040965             0325*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
040965 C9          0326*       ret
040966             0327*   
040966             0328*   ; main loop timer functions
040966             0329*   tmr_main_loop: ds 6 ; buffer to hold main loop timer
04096C             0330*   
04096C             0331*   ; set a countdown timer for the main loop using the timestamp timer
04096C             0332*   ; inputs: hl = time to set in 1/120ths of a second
04096C             0333*   ; returns: hl = current time
04096C             0334*   ; destroys: af,hl,de,ix,iy
04096C             0335*   tmr_main_loop_set:
       FF FF FF FF 
       FF FF 
04096C FD 21 66 09 0336*       ld iy,tmr_main_loop
       04          
040971 FD 2F 03    0337*       ld (iy+3),hl ; set time remaining
040974 CD 2C 09 04 0338*       call timestamp_tick
040978 2A 23 09 04 0339*       ld hl,(timestamp_now)   ; get current timestamp
04097C FD 2F 00    0340*       ld (iy+0),hl ; set start time
04097F C9          0341*       ret
040980             0342*   
040980             0343*   ; gets time remaining on the main loop countdown timer following the global timestamp
040980             0344*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
040980             0345*   ;          sign flags: pos = time not expired,zero or neg = time expired
040980             0346*   ; destroys: af,hl,de,ix,iy
040980             0347*   tmr_main_loop_get:
040980 CD 2C 09 04 0348*       call timestamp_tick
040984 FD 21 66 09 0349*       ld iy,tmr_main_loop
       04          
040989 CD 54 09 04 0350*       call timestamp_tmr_get
04098D C9          0351*       ret
04098E             0352*   
04098E             0353*   ; set a stopwatch
04098E             0354*   ; returns: hl = start time
04098E             0355*   ; destroys: hl,ix
04098E             0356*   stopwatch_set:
04098E             0357*       MOSCALL mos_sysvars     ; ix points to syvars table
04098E 3E 08       0001*M1 			LD	A, function
040990 5B CF       0002*M1 			RST.LIL	08h
040992 DD 27 00    0358*       ld hl,(ix+sysvar_time)  ; get current time
040995 22 AA 09 04 0359*       ld (stopwatch_started),hl            ; set start time
040999 C9          0360*       ret
04099A             0361*   
04099A             0362*   ; gets time elapsed on a stopwatch
04099A             0363*   ; returns: hl = time elapsed in 1/120ths of a second
04099A             0364*   ; destroys: af,hl,de,ix
04099A             0365*   stopwatch_get:
04099A             0366*       MOSCALL mos_sysvars     ; ix points to syvars table
04099A 3E 08       0001*M1 			LD	A, function
04099C 5B CF       0002*M1 			RST.LIL	08h
04099E DD 27 00    0367*       ld hl,(ix+sysvar_time)  ; get current time
0409A1 ED 5B AA 09 0368*       ld de,(stopwatch_started)            ; get start time
       04          
0409A6 AF          0369*       xor a                   ; clear carry
0409A7 ED 52       0370*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0409A9 C9          0371*       ret
0409AA             0372*   
0409AA             0373*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0409AD             0374*   
0409AD             0375*   ; ------------------
0409AD             0376*   ; delay routine
0409AD             0377*   ; Author: Richard Turrnidge
0409AD             0378*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0409AD             0379*   ; routine waits a fixed time,then returns
0409AD             0380*   ; arrive with A =  the delay byte. One bit to be set only.
0409AD             0381*   ; eg. ld A,00000100b
0409AD             0382*   
0409AD             0383*   multiPurposeDelay:
       FF FF FF 
0409AD F5          0384*       push af
0409AE C5          0385*       push bc
0409AF DD E5       0386*       push ix
0409B1 47          0387*       ld b,a
0409B2 3E 08       0388*       ld a,$08
0409B4 5B CF       0389*       RST.LIL	08h                 ; get IX pointer to sysvars
0409B6             0390*   
0409B6             0391*   waitLoop:
0409B6             0392*   
0409B6 DD 7E 00    0393*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0409B9             0394*   
0409B9             0395*                                   ;   we check if bit set is same as last time we checked.
0409B9             0396*                                   ;   bit 0 - don't use
0409B9             0397*                                   ;   bit 1 - changes 64 times per second
0409B9             0398*                                   ;   bit 2 - changes 32 times per second
0409B9             0399*                                   ;   bit 3 - changes 16 times per second
0409B9             0400*   
0409B9             0401*                                   ;   bit 4 - changes 8 times per second
0409B9             0402*                                   ;   bit 5 - changes 4 times per second
0409B9             0403*                                   ;   bit 6 - changes 2 times per second
0409B9             0404*                                   ;   bit 7 - changes 1 times per second
0409B9 A0          0405*       and b
0409BA 4F          0406*       ld c,a
0409BB 3A CC 09 04 0407*       ld a,(oldTimeStamp)
0409BF B9          0408*       cp c                        ; is A same as last value?
0409C0 28 F4       0409*       jr z,waitLoop              ; loop here if it is
0409C2 79          0410*       ld a,c
0409C3 32 CC 09 04 0411*       ld (oldTimeStamp),a        ; set new value
0409C7             0412*   
0409C7 DD E1       0413*       pop ix
0409C9 C1          0414*       pop bc
0409CA F1          0415*       pop af
0409CB C9          0416*       ret
0409CC             0417*   
0409CC 00          0418*   oldTimeStamp:   .db 00h
0409CD             0037        include "vdu.inc"
0409CD             0001*   ; &E8-&EF 	232-239 	Bitmap plot 
0409CD             0002*   plot_bmp: equ 0xE8
0409CD             0003*   ; 5 	Plot absolute in current foreground colour
0409CD             0004*   dr_abs_fg: equ 5
0409CD             0005*   
0409CD             0006*   ; VDU 30: Home cursor
0409CD             0007*   vdu_home_cursor:
0409CD 3E 1E       0008*       ld a,30
0409CF 5B D7       0009*   	rst.lil $10
0409D1 C9          0010*   	ret
0409D2             0011*   
0409D2             0012*   cursor_on:
0409D2 21 DD 09 04 0013*   	ld hl,@cmd
0409D6 01 03 00 00 0014*   	ld bc,@end-@cmd
0409DA 5B DF       0015*   	rst.lil $18
0409DC C9          0016*   	ret
0409DD             0017*   @cmd:
0409DD 17 01 01    0018*   	db 23,1,1
0409E0             0019*   @end:
0409E0             0020*   
0409E0             0021*   cursor_off:
0409E0 21 EB 09 04 0022*   	ld hl,@cmd
0409E4 01 03 00 00 0023*   	ld bc,@end-@cmd
0409E8 5B DF       0024*   	rst.lil $18
0409EA C9          0025*   	ret
0409EB             0026*   @cmd:
0409EB 17 01 00    0027*   	db 23,1,0
0409EE             0028*   @end:
0409EE             0029*   
0409EE             0030*   ; VDU 9: Move cursor forward one character
0409EE             0031*   vdu_cursor_forward:
0409EE 3E 09       0032*       ld a,9
0409F0 5B D7       0033*   	rst.lil $10
0409F2 C9          0034*   	ret
0409F3             0035*   
0409F3             0036*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0409F3             0037*   ; inputs: c=x, b=y 8-bit unsigned integers
0409F3             0038*   vdu_move_cursor:
0409F3 ED 43 04 0A 0039*       ld (@x0),bc
       04          
0409F8 21 03 0A 04 0040*   	ld hl,@cmd
0409FC 01 03 00 00 0041*   	ld bc,@end-@cmd
040A00 5B DF       0042*   	rst.lil $18
040A02 C9          0043*   	ret
040A03 1F          0044*   @cmd: 	db 31
040A04 00          0045*   @x0:	db 0
040A05 00          0046*   @y0: 	db 0
040A06 00          0047*   @end: 	db 0 ; padding
040A07             0048*   
040A07             0049*   ; VDU 12: Clear text area (CLS)
040A07             0050*   vdu_cls:
040A07 3E 0C       0051*       ld a,12
040A09 5B D7       0052*   	rst.lil $10
040A0B C9          0053*   	ret
040A0C             0054*   
040A0C             0055*   vdu_flip:
040A0C 21 17 0A 04 0056*   	ld hl,@cmd
040A10 01 03 00 00 0057*   	ld bc,@end-@cmd
040A14 5B DF       0058*   	rst.lil $18
040A16 C9          0059*   	ret
040A17 17 00 C3    0060*   @cmd: db 23,0,0xC3
040A1A             0061*   @end:
040A1A             0062*   
040A1A             0063*   ; VDU 16: Clear graphics area (CLG)
040A1A             0064*   vdu_clg:
040A1A 3E 10       0065*       ld a,16
040A1C 5B D7       0066*   	rst.lil $10
040A1E C9          0067*   	ret
040A1F             0068*   
040A1F             0069*   ; Wait for VBLANK interrupt
040A1F             0070*   vdu_vblank:
040A1F DD E5       0071*       PUSH 	IX
040A21             0072*   	MOSCALL	mos_sysvars
040A21 3E 08       0001*M1 			LD	A, function
040A23 5B CF       0002*M1 			RST.LIL	08h
040A25 DD 7E 00    0073*   	LD	A, (IX + sysvar_time + 0)
040A28             0074*   @wait:
040A28 DD BE 00    0075*       CP 	A, (IX + sysvar_time + 0)
040A2B 28 FB       0076*       JR	Z, @wait
040A2D DD E1       0077*       POP	IX
040A2F C9          0078*       RET
040A30             0079*   
040A30             0080*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
040A30             0081*   ; NOTE: the order of the y-coordinate parameters are inverted
040A30             0082*   ; 	because we have turned off logical screen scaling
040A30             0083*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
040A30             0084*   ; outputs; nothing
040A30             0085*   ; destroys: a might make it out alive
040A30             0086*   vdu_set_gfx_viewport:
040A30 ED 43 50 0A 0087*       ld (@x0),bc
       04          
040A35 FD 22 52 0A 0088*       ld (@y1),iy
       04          
040A3A DD 22 54 0A 0089*   	ld (@x1),ix
       04          
040A3F ED 53 56 0A 0090*   	ld (@y0),de
       04          
040A44 21 4F 0A 04 0091*   	ld hl,@cmd
040A48 01 09 00 00 0092*   	ld bc,@end-@cmd
040A4C 5B DF       0093*   	rst.lil $18
040A4E C9          0094*   	ret
040A4F 18          0095*   @cmd:   db 24 ; set graphics viewport command
040A50 00 00       0096*   @x0: 	dw 0x0000 ; set by bc
040A52 00 00       0097*   @y1: 	dw 0x0000 ; set by iy
040A54 00 00       0098*   @x1: 	dw 0x0000 ; set by ix
040A56 00 00       0099*   @y0: 	dw 0x0000 ; set by de
040A58 00          0100*   @end:   db 0x00	  ; padding
040A59             0101*   
040A59             0102*   ; SCREEN MODES
040A59             0103*   ; ===============================
040A59             0104*   ; Mode  Horz  Vert  Cols  Refresh
040A59             0105*   ; ---   ----  ----  ----  -------
040A59             0106*   ; 11    320   240   2     60hz
040A59             0107*   ; 139   320   240   2     60hz
040A59             0108*   ; 23    512   384   2     60hz
040A59             0109*   ; 151   512   384   2     60hz
040A59             0110*   ; 6     640   240   2     60hz
040A59             0111*   ; 134   640   240   2     60hz
040A59             0112*   ; 2     640   480   2     60hz
040A59             0113*   ; 130   640   480   2     60hz
040A59             0114*   ; 17    800   600   2     60hz
040A59             0115*   ; 145   800   600   2     60hz
040A59             0116*   ; 18    1024  768   2     60hz
040A59             0117*   ; 146   1024  768   2     60hz
040A59             0118*   ; ---   ----  ----  ----  -------
040A59             0119*   ; 10    320   240   4     60hz
040A59             0120*   ; 138   320   240   4     60hz
040A59             0121*   ; 22    512   384   4     60hz
040A59             0122*   ; 150   512   384   4     60hz
040A59             0123*   ; 5     640   240   4     60hz
040A59             0124*   ; 133   640   240   4     60hz
040A59             0125*   ; 1     640   480   4     60hz
040A59             0126*   ; 129   640   480   4     60hz
040A59             0127*   ; 16    800   600   4     60hz
040A59             0128*   ; 19    1024  768   4     60hz
040A59             0129*   ; ---   ----  ----  ----  -------
040A59             0130*   ; 9     320   240   16    60hz
040A59             0131*   ; 137   320   240   16    60hz
040A59             0132*   ; 21    512   384   16    60hz
040A59             0133*   ; 149   512   384   16    60hz
040A59             0134*   ; 4     640   240   16    60hz
040A59             0135*   ; 132   640   240   16    60hz
040A59             0136*   ; 0     640   480   16    60hz
040A59             0137*   ; 7     n/a   n/a   16    60hz
040A59             0138*   ; ---   ----  ----  ----  -------
040A59             0139*   ; 8     320   240   64    60hz
040A59             0140*   ; 136   320   240   64    60hz
040A59             0141*   ; 20    512   384   64    60hz
040A59             0142*   ; 3     640   240   64    60hz
040A59             0143*   ; ---   ----  ----  ----  -------
040A59             0144*   vdu_set_screen_mode:
040A59 32 69 0A 04 0145*   	ld (@arg),a
040A5D 21 68 0A 04 0146*   	ld hl,@cmd
040A61 01 02 00 00 0147*   	ld bc,@end-@cmd
040A65 5B DF       0148*   	rst.lil $18
040A67 C9          0149*   	ret
040A68 16          0150*   @cmd: db 22 ; set screen mode
040A69 00          0151*   @arg: db 0  ; screen mode parameter
040A6A             0152*   @end:
040A6A             0153*   
040A6A             0154*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
040A6A             0155*   ; inputs: a is scaling mode, 1=on, 0=off
040A6A             0156*   ; note: default setting on boot is scaling ON
040A6A             0157*   vdu_set_scaling:
040A6A 32 7C 0A 04 0158*   	ld (@arg),a
040A6E 21 79 0A 04 0159*   	ld hl,@cmd
040A72 01 04 00 00 0160*   	ld bc,@end-@cmd
040A76 5B DF       0161*   	rst.lil $18
040A78 C9          0162*   	ret
040A79 17 00 C0    0163*   @cmd: db 23,0,0xC0
040A7C 00          0164*   @arg: db 0  ; scaling on/off
040A7D             0165*   @end:
040A7D             0166*   
040A7D             0167*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
040A7D             0168*   ; inputs: hl=bufferId
040A7D             0169*   vdu_buff_select:
040A7D 22 8F 0A 04 0170*   	ld (@bufferId),hl
040A81 21 8C 0A 04 0171*   	ld hl,@cmd
040A85 01 05 00 00 0172*   	ld bc,@end-@cmd
040A89 5B DF       0173*   	rst.lil $18
040A8B C9          0174*   	ret
040A8C 17 1B 20    0175*   @cmd: db 23,27,0x20
040A8F 00 00       0176*   @bufferId: dw 0x0000
040A91 00          0177*   @end: db 0x00 ; padding
040A92             0178*   
040A92             0179*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
040A92             0180*   ; inputs: a=format; bc=width; de=height
040A92             0181*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
040A92             0182*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040A92             0183*   ; 0 	RGBA8888 (4-bytes per pixel)
040A92             0184*   ; 1 	RGBA2222 (1-bytes per pixel)
040A92             0185*   ; 2 	Mono/Mask (1-bit per pixel)
040A92             0186*   ; 3 	Reserved for internal use by VDP (native format)
040A92             0187*   vdu_bmp_create:
040A92 ED 43 AE 0A 0188*       ld (@width),bc
       04          
040A97 ED 53 B0 0A 0189*       ld (@height),de
       04          
040A9C 32 B2 0A 04 0190*       ld (@fmt),a
040AA0 21 AB 0A 04 0191*   	ld hl,@cmd
040AA4 01 08 00 00 0192*   	ld bc,@end-@cmd
040AA8 5B DF       0193*   	rst.lil $18
040AAA C9          0194*   	ret
040AAB 17 1B 21    0195*   @cmd:       db 23,27,0x21
040AAE 00 00       0196*   @width:     dw 0x0000
040AB0 00 00       0197*   @height:    dw 0x0000
040AB2 00          0198*   @fmt:       db 0x00
040AB3             0199*   @end:
040AB3             0200*   
040AB3             0201*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040AB3             0202*   ; &E8-&EF 	232-239 	Bitmap plot 
040AB3             0203*   ; VDU 25, mode, x; y;: PLOT command
040AB3             0204*   ; inputs: bc=x0, de=y0
040AB3             0205*   ; prerequisites: vdu_buff_select
040AB3             0206*   vdu_plot_bmp:
040AB3 ED 43 CA 0A 0207*       ld (@x0),bc
       04          
040AB8 ED 53 CC 0A 0208*       ld (@y0),de
       04          
040ABD 21 C8 0A 04 0209*   	ld hl,@cmd
040AC1 01 06 00 00 0210*   	ld bc,@end-@cmd
040AC5 5B DF       0211*   	rst.lil $18
040AC7 C9          0212*   	ret
040AC8 19          0213*   @cmd:   db 25
040AC9 ED          0214*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
040ACA 00 00       0215*   @x0: 	dw 0x0000
040ACC 00 00       0216*   @y0: 	dw 0x0000
040ACE 00          0217*   @end:   db 0x00 ; padding
040ACF             0218*   
040ACF             0219*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
040ACF             0220*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
040ACF             0221*   vdu_load_img_rgba2_to_8:
040ACF             0222*   ; backup the target buffer id and image dimensions
040ACF E5          0223*       push hl
040AD0 D5          0224*       push de
040AD1 C5          0225*       push bc
040AD2             0226*   ; load the rgba2 image to working buffer 65534
040AD2 21 FE FF 00 0227*       ld hl,65534 ; temporary working buffer id
040AD6 CD C8 0B 04 0228*   	call vdu_load_buffer_from_file
040ADA             0229*   ; restore the image dimensions and target buffer id
040ADA C1          0230*       pop bc
040ADB D1          0231*       pop de
040ADC E1          0232*       pop hl
040ADD             0233*   ; fall through to vdu_rgba2_to_8
040ADD             0234*   
040ADD             0235*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
040ADD             0236*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
040ADD             0237*   ; the "expand bitmap" command is:
040ADD             0238*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
040ADD             0239*   ; and then to reverse the byte order to fix endian-ness:
040ADD             0240*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
040ADD             0241*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
040ADD             0242*   ; VDU 23,27,&20,targetBufferID%;
040ADD             0243*   ; VDU 23,27,&21,width%;height%;0
040ADD             0244*   ; -------------------------------------------------------------------
040ADD             0245*   ; inputs: bc,de image width,height ; hl = targetBufferId
040ADD             0246*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
040ADD             0247*   vdu_rgba2_to_8:
040ADD             0248*   ; load the image dimensions and buffer id parameters
040ADD ED 43 39 0B 0249*       ld (@width),bc
       04          
040AE2 ED 53 3B 0B 0250*       ld (@height),de
       04          
040AE7 22 1E 0B 04 0251*       ld (@bufferId0),hl
040AEB 22 2B 0B 04 0252*       ld (@bufferId2),hl
040AEF 22 34 0B 04 0253*       ld (@bufferId1),hl
040AF3             0254*   ; clean up bytes that got stomped on by the ID loads
040AF3 3E 48       0255*       ld a,0x48
040AF5 32 20 0B 04 0256*       ld (@bufferId0+2),a
040AF9 3E 17       0257*       ld a,23
040AFB 32 36 0B 04 0258*       ld (@bufferId1+2),a
040AFF 3E 18       0259*       ld a,24
040B01 32 2D 0B 04 0260*       ld (@bufferId2+2),a
040B05 AF          0261*       xor a
040B06 32 3D 0B 04 0262*       ld (@height+2),a
040B0A             0263*   ; send the vdu command strings
040B0A 21 15 0B 04 0264*       ld hl,@beg
040B0E 01 29 00 00 0265*       ld bc,@end-@beg
040B12 5B DF       0266*       rst.lil $18
040B14 C9          0267*       ret
040B15             0268*   @beg:
040B15             0269*   ; Command 14: Consolidate blocks in a buffer
040B15             0270*   ; VDU 23, 0, &A0, bufferId; 14
040B15 17 00 A0    0271*       db 23,0,0xA0
040B18 FE FF       0272*       dw 65534 ; workingBufferId
040B1A 0E          0273*       db 14 ; consolidate blocks
040B1B             0274*   ; the "expand bitmap" command is:
040B1B             0275*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
040B1B 17 00 A0    0276*       db 23,0,0xA0
040B1E 00 00       0277*   @bufferId0: dw 0x0000 ; targetBufferId
040B20 48          0278*       db 0x48 ; given as decimal command 72 in the docs
040B21 02          0279*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
040B22 FE FF       0280*       dw 65534 ; sourceBufferId
040B24 00 7F BF FF 0281*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
040B28             0282*   ; reverse the byte order to fix endian-ness:
040B28             0283*   ; Command 24: Reverse the order of data of blocks within a buffer
040B28             0284*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
040B28             0285*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
040B28 17 00 A0    0286*       db 23,0,0xA0
040B2B 00 00       0287*   @bufferId2:    dw 0x0000 ; targetBufferId
040B2D 18          0288*       db 24 ; reverse byte order
040B2E 04          0289*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
040B2F 04 00       0290*       dw 4 ; size (4 bytes)
040B31             0291*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
040B31             0292*   ; VDU 23,27,&20,targetBufferID%;
040B31 17 1B 20    0293*       db 23,27,0x20 ; select bitmap
040B34 00 00       0294*   @bufferId1: dw 0x0000 ; targetBufferId
040B36             0295*   ; VDU 23,27,&21,width%;height%;0
040B36 17 1B 21    0296*       db 23,27,0x21 ; create bitmap from buffer
040B39 00 00       0297*   @width: dw 0x0000
040B3B 00 00       0298*   @height: dw 0x0000
040B3D 00          0299*       db 0x00 ; rgba8888 format
040B3E             0300*   @end:
040B3E             0301*   
040B3E             0302*   ; scratch variables
040B3E 00 00 00    0303*   bufferId0: dl 0x000000
040B41 00 00 00    0304*   bufferId1: dl 0x000000
040B44             0305*   
040B44             0306*   ; load a vdu buffer from local memory
040B44             0307*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
040B44             0308*   vdu_load_buffer:
040B44 ED 43 6D 0B 0309*       ld (@length),bc
       04          
040B49 D5          0310*       push de ; save data pointer
040B4A             0311*   ; send the vdu command string
040B4A 7D          0312*       ld a,l
040B4B 32 6A 0B 04 0313*       ld (@bufferId),a
040B4F 7C          0314*       ld a,h
040B50 32 6B 0B 04 0315*       ld (@bufferId+1),a
040B54 21 67 0B 04 0316*       ld hl,@cmd
040B58 01 08 00 00 0317*       ld bc,@end-@cmd
040B5C 5B DF       0318*       rst.lil $18
040B5E             0319*   ; send the buffer data
040B5E E1          0320*       pop hl ; pointer to data
040B5F ED 4B 6D 0B 0321*       ld bc,(@length)
       04          
040B64 5B DF       0322*       rst.lil $18 ; send it
040B66 C9          0323*       ret
040B67             0324*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040B67 17 00 A0    0325*   @cmd:       db 23,0,0xA0
040B6A 00 00       0326*   @bufferId:	dw 0x0000
040B6C 00          0327*   		    db 0 ; load buffer
040B6D 00 00       0328*   @length:	dw 0x0000
040B6F 00          0329*   @end: db 0 ; padding
040B70             0330*   
040B70             0331*   ; clear a buffer
040B70             0332*   ; inputs: hl = bufferId
040B70             0333*   vdu_clear_buffer:
040B70 7D          0334*       ld a,l
040B71 32 88 0B 04 0335*       ld (@bufferId),a
040B75 7C          0336*       ld a,h
040B76 32 89 0B 04 0337*       ld (@bufferId+1),a
040B7A 21 85 0B 04 0338*       ld hl,@cmd
040B7E 01 06 00 00 0339*       ld bc,@end-@cmd
040B82 5B DF       0340*       rst.lil $18
040B84 C9          0341*       ret
040B85 17 00 A0    0342*   @cmd:       db 23,0,0xA0
040B88 00 00       0343*   @bufferId:	dw 0x0000
040B8A 02          0344*   		    db 2 ; clear buffer
040B8B             0345*   @end:
040B8B             0346*   
040B8B             0347*   ; Command 14: Consolidate blocks in a buffer
040B8B             0348*   vdu_consolidate_buffer:
040B8B             0349*   ; set parameters for vdu call
040B8B 7D          0350*       ld a,l
040B8C 32 A3 0B 04 0351*       ld (@bufferId),a
040B90 7C          0352*       ld a,h
040B91 32 A4 0B 04 0353*       ld (@bufferId+1),a
040B95 21 A0 0B 04 0354*       ld hl,@beg
040B99 01 06 00 00 0355*       ld bc,@end-@beg
040B9D 5B DF       0356*       rst.lil $18
040B9F C9          0357*       ret
040BA0             0358*   ; VDU 23, 0, &A0, bufferId; 14
040BA0 17 00 A0    0359*   @beg: db 23,0,0xA0
040BA3 00 00       0360*   @bufferId: dw 0x0000
040BA5 0E          0361*              db 14
040BA6             0362*   @end:
040BA6             0363*   
040BA6             0364*   ; load an image file to a buffer and make it a bitmap
040BA6             0365*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
040BA6             0366*   vdu_load_img:
040BA6             0367*   ; back up image type and dimension parameters
040BA6 22 3E 0B 04 0368*       ld (bufferId0),hl
040BAA F5          0369*       push af
040BAB C5          0370*   	push bc
040BAC D5          0371*   	push de
040BAD             0372*   ; load the image
040BAD CD C8 0B 04 0373*   	call vdu_load_buffer_from_file
040BB1             0374*   ; now make it a bitmap
040BB1 2A 3E 0B 04 0375*       ld hl,(bufferId0)
040BB5 CD 8B 0B 04 0376*       call vdu_consolidate_buffer
040BB9 2A 3E 0B 04 0377*       ld hl,(bufferId0)
040BBD CD 7D 0A 04 0378*       call vdu_buff_select
040BC1 D1          0379*   	pop de ; image height
040BC2 C1          0380*   	pop bc ; image width
040BC3 F1          0381*   	pop af ; image type
040BC4 C3 92 0A 04 0382*   	jp vdu_bmp_create ; will return to caller from there
040BC8             0383*   
040BC8             0384*   ; inputs: hl = bufferId; iy = pointer to filename
040BC8             0385*   vdu_load_buffer_from_file:
040BC8 22 3E 0B 04 0386*       ld (bufferId0),hl
040BCC             0387*   
040BCC             0388*   ; clear target buffer
040BCC CD 70 0B 04 0389*       call vdu_clear_buffer
040BD0             0390*   
040BD0             0391*   ; open the file in read mode
040BD0             0392*   ; Open a file
040BD0             0393*   ; HLU: Filename
040BD0             0394*   ;   C: Mode
040BD0             0395*   ; Returns:
040BD0             0396*   ;   A: Filehandle, or 0 if couldn't open
040BD0 FD E5       0397*   	push iy ; pointer to filename
040BD2 E1          0398*   	pop hl
040BD3 0E 01       0399*   	ld c,fa_read
040BD5             0400*       MOSCALL mos_fopen
040BD5 3E 0A       0001*M1 			LD	A, function
040BD7 5B CF       0002*M1 			RST.LIL	08h
040BD9 32 14 0C 04 0401*       ld (@filehandle),a
040BDD             0402*   
040BDD             0403*   @read_file:
040BDD             0404*   ; Read a block of data from a file
040BDD             0405*   ;   C: Filehandle
040BDD             0406*   ; HLU: Pointer to where to write the data to
040BDD             0407*   ; DEU: Number of bytes to read
040BDD             0408*   ; Returns:
040BDD             0409*   ; DEU: Number of bytes read
040BDD 3A 14 0C 04 0410*       ld a,(@filehandle)
040BE1 4F          0411*       ld c,a
040BE2 21 00 E0 B7 0412*       ld hl,filedata
040BE6 11 00 20 00 0413*       ld de,8192 ; max we can read into onboard sram at one time
040BEA             0414*       MOSCALL mos_fread
040BEA 3E 1A       0001*M1 			LD	A, function
040BEC 5B CF       0002*M1 			RST.LIL	08h
040BEE             0415*   
040BEE             0416*   ; test de for zero bytes read
040BEE 21 00 00 00 0417*       ld hl,0
040BF2 AF          0418*       xor a ; clear carry
040BF3 ED 52       0419*       sbc hl,de
040BF5 CA 0B 0C 04 0420*       jp z,@close_file
040BF9             0421*   
040BF9             0422*   ; load a vdu buffer from local memory
040BF9             0423*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
040BF9 2A 3E 0B 04 0424*       ld hl,(bufferId0)
040BFD D5          0425*       push de ; chunksize
040BFE C1          0426*       pop bc
040BFF 11 00 E0 B7 0427*       ld de,filedata
040C03 CD 44 0B 04 0428*       call vdu_load_buffer
040C07             0429*   
040C07             0430*   ; ; print progress breadcrumbs
040C07             0431*   ;     ld a,'.'
040C07             0432*   ;     rst.lil 10h
040C07             0433*   
040C07             0434*   ; read the next block
040C07 C3 DD 0B 04 0435*       jp @read_file
040C0B             0436*   
040C0B             0437*   ; close the file
040C0B             0438*   @close_file:
040C0B 3A 14 0C 04 0439*       ld a,(@filehandle)
040C0F             0440*       MOSCALL mos_fclose
040C0F 3E 0B       0001*M1 			LD	A, function
040C11 5B CF       0002*M1 			RST.LIL	08h
040C13 C9          0441*       ret ; vdu_load_buffer_from_file
040C14             0442*   
040C14 00          0443*   @filehandle: db 0 ; file handle
040C15 00 00 00    0444*   @fil: dl 0 ; pointer to FIL struct
040C18             0445*   
040C18 00 00 00    0446*   @chunkpointer: dl 0 ; pointer to current chunk
040C1B             0447*   
040C1B             0448*   ; File information structure (FILINFO)
040C1B             0449*   @filinfo:
040C1B 00 00 00 00 0450*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
040C1F 00 00       0451*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
040C21 00 00       0452*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
040C23 00          0453*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
040C24 00 00 00 00 0454*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
040C31 00 00 00 00 0455*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D31             0038        include "images.inc"
040D31             0001*   ; Generated by make_images.py
040D31             0002*   
040D31             0003*   image_type: equ 0
040D31             0004*   image_width: equ image_type+3
040D31             0005*   image_height: equ image_width+3
040D31             0006*   image_filesize: equ image_height+3
040D31             0007*   image_filename: equ image_filesize+3
040D31             0008*   image_record_size: equ image_filename+3
040D31             0009*   
040D31             0010*   num_images: equ 20
040D31             0011*   
040D31             0012*   ; buffer_ids:
040D31             0013*   buf_Zhan44: equ 256
040D31             0014*   buf_aurora: equ 257
040D31             0015*   buf_balloon: equ 258
040D31             0016*   buf_berkeley1: equ 259
040D31             0017*   buf_berkeley2: equ 260
040D31             0018*   buf_berkeley3: equ 261
040D31             0019*   buf_bridge: equ 262
040D31             0020*   buf_canyon: equ 263
040D31             0021*   buf_cliff: equ 264
040D31             0022*   buf_clouds: equ 265
040D31             0023*   buf_fisherman: equ 266
040D31             0024*   buf_fjord: equ 267
040D31             0025*   buf_islands: equ 268
040D31             0026*   buf_lasers: equ 269
040D31             0027*   buf_mountain: equ 270
040D31             0028*   buf_road: equ 271
040D31             0029*   buf_sand: equ 272
040D31             0030*   buf_temple: equ 273
040D31             0031*   buf_trees: equ 274
040D31             0032*   buf_waterfall: equ 275
040D31             0033*   
040D31             0034*   image_list: ; type; width; height; filename:
040D31 01 00 00 00 0035*   	dl 1, 512, 384, 196608, fn_Zhan44
       02 00 80 01 
       00 00 00 03 
       5D 0E 04    
040D40 01 00 00 00 0036*   	dl 1, 512, 384, 196608, fn_aurora
       02 00 80 01 
       00 00 00 03 
       71 0E 04    
040D4F 01 00 00 00 0037*   	dl 1, 512, 384, 196608, fn_balloon
       02 00 80 01 
       00 00 00 03 
       85 0E 04    
040D5E 01 00 00 00 0038*   	dl 1, 512, 384, 196608, fn_berkeley1
       02 00 80 01 
       00 00 00 03 
       9A 0E 04    
040D6D 01 00 00 00 0039*   	dl 1, 512, 384, 196608, fn_berkeley2
       02 00 80 01 
       00 00 00 03 
       B1 0E 04    
040D7C 01 00 00 00 0040*   	dl 1, 512, 384, 196608, fn_berkeley3
       02 00 80 01 
       00 00 00 03 
       C8 0E 04    
040D8B 01 00 00 00 0041*   	dl 1, 512, 384, 196608, fn_bridge
       02 00 80 01 
       00 00 00 03 
       DF 0E 04    
040D9A 01 00 00 00 0042*   	dl 1, 512, 384, 196608, fn_canyon
       02 00 80 01 
       00 00 00 03 
       F3 0E 04    
040DA9 01 00 00 00 0043*   	dl 1, 512, 384, 196608, fn_cliff
       02 00 80 01 
       00 00 00 03 
       07 0F 04    
040DB8 01 00 00 00 0044*   	dl 1, 512, 384, 196608, fn_clouds
       02 00 80 01 
       00 00 00 03 
       1A 0F 04    
040DC7 01 00 00 00 0045*   	dl 1, 512, 384, 196608, fn_fisherman
       02 00 80 01 
       00 00 00 03 
       2E 0F 04    
040DD6 01 00 00 00 0046*   	dl 1, 512, 384, 196608, fn_fjord
       02 00 80 01 
       00 00 00 03 
       45 0F 04    
040DE5 01 00 00 00 0047*   	dl 1, 512, 384, 196608, fn_islands
       02 00 80 01 
       00 00 00 03 
       58 0F 04    
040DF4 01 00 00 00 0048*   	dl 1, 512, 384, 196608, fn_lasers
       02 00 80 01 
       00 00 00 03 
       6D 0F 04    
040E03 01 00 00 00 0049*   	dl 1, 512, 384, 196608, fn_mountain
       02 00 80 01 
       00 00 00 03 
       81 0F 04    
040E12 01 00 00 00 0050*   	dl 1, 512, 384, 196608, fn_road
       02 00 80 01 
       00 00 00 03 
       97 0F 04    
040E21 01 00 00 00 0051*   	dl 1, 512, 384, 196608, fn_sand
       02 00 80 01 
       00 00 00 03 
       A9 0F 04    
040E30 01 00 00 00 0052*   	dl 1, 512, 384, 196608, fn_temple
       02 00 80 01 
       00 00 00 03 
       BB 0F 04    
040E3F 01 00 00 00 0053*   	dl 1, 512, 384, 196608, fn_trees
       02 00 80 01 
       00 00 00 03 
       CF 0F 04    
040E4E 01 00 00 00 0054*   	dl 1, 512, 384, 196608, fn_waterfall
       02 00 80 01 
       00 00 00 03 
       E2 0F 04    
040E5D             0055*   
040E5D             0056*   ; files_list: ; filename:
040E5D 69 6D 61 67 0057*   fn_Zhan44: db "images/Zhan44.rgba2",0
       65 73 2F 5A 
       68 61 6E 34 
       34 2E 72 67 
       62 61 32 00 
040E71 69 6D 61 67 0058*   fn_aurora: db "images/aurora.rgba2",0
       65 73 2F 61 
       75 72 6F 72 
       61 2E 72 67 
       62 61 32 00 
040E85 69 6D 61 67 0059*   fn_balloon: db "images/balloon.rgba2",0
       65 73 2F 62 
       61 6C 6C 6F 
       6F 6E 2E 72 
       67 62 61 32 
       00          
040E9A 69 6D 61 67 0060*   fn_berkeley1: db "images/berkeley1.rgba2",0
       65 73 2F 62 
       65 72 6B 65 
       6C 65 79 31 
       2E 72 67 62 
       61 32 00    
040EB1 69 6D 61 67 0061*   fn_berkeley2: db "images/berkeley2.rgba2",0
       65 73 2F 62 
       65 72 6B 65 
       6C 65 79 32 
       2E 72 67 62 
       61 32 00    
040EC8 69 6D 61 67 0062*   fn_berkeley3: db "images/berkeley3.rgba2",0
       65 73 2F 62 
       65 72 6B 65 
       6C 65 79 33 
       2E 72 67 62 
       61 32 00    
040EDF 69 6D 61 67 0063*   fn_bridge: db "images/bridge.rgba2",0
       65 73 2F 62 
       72 69 64 67 
       65 2E 72 67 
       62 61 32 00 
040EF3 69 6D 61 67 0064*   fn_canyon: db "images/canyon.rgba2",0
       65 73 2F 63 
       61 6E 79 6F 
       6E 2E 72 67 
       62 61 32 00 
040F07 69 6D 61 67 0065*   fn_cliff: db "images/cliff.rgba2",0
       65 73 2F 63 
       6C 69 66 66 
       2E 72 67 62 
       61 32 00    
040F1A 69 6D 61 67 0066*   fn_clouds: db "images/clouds.rgba2",0
       65 73 2F 63 
       6C 6F 75 64 
       73 2E 72 67 
       62 61 32 00 
040F2E 69 6D 61 67 0067*   fn_fisherman: db "images/fisherman.rgba2",0
       65 73 2F 66 
       69 73 68 65 
       72 6D 61 6E 
       2E 72 67 62 
       61 32 00    
040F45 69 6D 61 67 0068*   fn_fjord: db "images/fjord.rgba2",0
       65 73 2F 66 
       6A 6F 72 64 
       2E 72 67 62 
       61 32 00    
040F58 69 6D 61 67 0069*   fn_islands: db "images/islands.rgba2",0
       65 73 2F 69 
       73 6C 61 6E 
       64 73 2E 72 
       67 62 61 32 
       00          
040F6D 69 6D 61 67 0070*   fn_lasers: db "images/lasers.rgba2",0
       65 73 2F 6C 
       61 73 65 72 
       73 2E 72 67 
       62 61 32 00 
040F81 69 6D 61 67 0071*   fn_mountain: db "images/mountain.rgba2",0
       65 73 2F 6D 
       6F 75 6E 74 
       61 69 6E 2E 
       72 67 62 61 
       32 00       
040F97 69 6D 61 67 0072*   fn_road: db "images/road.rgba2",0
       65 73 2F 72 
       6F 61 64 2E 
       72 67 62 61 
       32 00       
040FA9 69 6D 61 67 0073*   fn_sand: db "images/sand.rgba2",0
       65 73 2F 73 
       61 6E 64 2E 
       72 67 62 61 
       32 00       
040FBB 69 6D 61 67 0074*   fn_temple: db "images/temple.rgba2",0
       65 73 2F 74 
       65 6D 70 6C 
       65 2E 72 67 
       62 61 32 00 
040FCF 69 6D 61 67 0075*   fn_trees: db "images/trees.rgba2",0
       65 73 2F 74 
       72 65 65 73 
       2E 72 67 62 
       61 32 00    
040FE2 69 6D 61 67 0076*   fn_waterfall: db "images/waterfall.rgba2",0
       65 73 2F 77 
       61 74 65 72 
       66 61 6C 6C 
       2E 72 67 62 
       61 32 00    
040FF9             0039        include "temp.inc"
040FF9             0001*   temp:
040FF9 21 80 00 00 0002*       ld hl,128 ; random bufferId
040FFD 01 28 00 00 0003*       ld bc,@temp_string_end-@temp_string
041001 11 15 10 04 0004*       ld de,@temp_string
041005 CD 44 0B 04 0005*       call vdu_load_buffer
041009             0006*   
041009 21 15 10 04 0007*       ld hl,@temp_string
04100D CD 5A 01 04 0008*       call printString
041011 C3 54 00 04 0009*       jp exit
041015 0D 0A 54 65 0010*   @temp_string: db "\r\nTemporary routine ran successfully!\r\n",0
       6D 70 6F 72 
       61 72 79 20 
       72 6F 75 74 
       69 6E 65 20 
       72 61 6E 20 
       73 75 63 63 
       65 73 73 66 
       75 6C 6C 79 
       21 0D 0A 00 
04103D             0011*   @temp_string_end:
04103D             0040    
04103D             0041    init:
04103D             0042    ; set screen mode
04103D             0043        ; ld a,0 ; 640x480x16 single-buffered
04103D             0044        ; ld a,19 ; 1024x768x4 single-buffered
04103D             0045        ; ld a,8 ; 320x240x64 single-buffered
04103D 3E 14       0046        ld a,20 ; 512x384x64 single-buffered
04103F             0047        ; ld a,23 ; 512x384x2 single-buffered
04103F CD 59 0A 04 0048        call vdu_set_screen_mode
041043             0049    
041043             0050    ; set screen scaling and background colors
041043 21 51 10 04 0051        ld hl,@beg
041047 01 09 00 00 0052        ld bc,@end-@beg
04104B 5B DF       0053        rst.lil $18
04104D C3 5A 10 04 0054        jp @end
041051             0055    @beg:
041051             0056    ;   VDU 23, 0, &C0, 0: Normal coordinates
041051 17 00 C0 00 0057        db 23,0,$C0,0
041055             0058    ;   VDU 17, color : set text background color
041055 11 8C       0059        db 17,12+128 ; blue
041057             0060    ;   VDU 18, color : set gfx background color
041057 12 00 8C    0061        db 18,0,12+128 ; blue
04105A             0062    @end:
04105A CD E0 09 04 0063        call cursor_off
04105E CD 07 0A 04 0064        call vdu_cls
041062             0065    
041062             0066    ; initialize main loop timer
041062             0067    main_loop_timer_reset: equ 60 ; 120ths of a second
041062 21 3C 00 00 0068        ld hl,main_loop_timer_reset
041066 CD 6C 09 04 0069        call tmr_main_loop_set
04106A             0070    
04106A CD 13 08 04 0071        call tmr_slideshow_set
04106E             0072    
04106E C9          0073        ret ; init
04106F             0074    
04106F             0075    main:
04106F 11 00 00 00 0076        ld de, 0
041073 C3 8F 10 04 0077        jp rendbmp
041077             0078    
041077             0079    mainloop:
041077 CD A3 07 04 0080        call reset_keys
04107B             0081    
04107B             0082    waitloop:
04107B CD 88 07 04 0083        call set_keys
04107F CD 80 09 04 0084        call tmr_main_loop_get
041083 CA B3 07 04 0085        jp z, do_input
041087 FA B3 07 04 0086        jp m, do_input
04108B C3 7B 10 04 0087        jp waitloop
04108F             0088    
04108F             0089    rendbmp:
04108F             0090    ; test de for wraparound
04108F 21 00 00 00 0091        ld hl,0
041093 AF          0092        xor a ; clear carry
041094 ED 52       0093        sbc hl,de
041096 CA A6 10 04 0094        jp z,@not_neg
04109A FA A6 10 04 0095        jp m,@not_neg
04109E 11 13 00 00 0096        ld de,num_images-1
0410A2 C3 B5 10 04 0097        jp @load_image
0410A6             0098    @not_neg:
0410A6 21 13 00 00 0099        ld hl,num_images-1
0410AA AF          0100        xor a ; clear carry
0410AB ED 52       0101        sbc hl,de
0410AD F2 B5 10 04 0102        jp p,@load_image
0410B1 11 00 00 00 0103        ld de,0
0410B5             0104    @load_image:
0410B5 ED 53 75 07 0105        ld (current_image_index),de
       04          
0410BA 16 0F       0106        ld d,image_record_size
0410BC ED 5C       0107        mlt de
0410BE FD 21 31 0D 0108        ld iy,image_list
       04          
0410C3 FD 19       0109        add iy,de
0410C5 FD 7E 00    0110        ld a,(iy+image_type) ; get image type
0410C8 FD 07 03    0111        ld bc,(iy+image_width) ; get image width
0410CB FD 17 06    0112        ld de,(iy+image_height) ; get image height
0410CE FD 31 09    0113        ld ix,(iy+image_filesize) ; get image file size
0410D1 FD 27 0C    0114        ld hl,(iy+image_filename) ; get image filename
0410D4 E5          0115        push hl
0410D5 FD E1       0116        pop iy
0410D7 21 00 01 00 0117        ld hl,256 ; set image bufferId
0410DB CD A6 0B 04 0118        call vdu_load_img
0410DF             0119    ; plot image
0410DF CD 07 0A 04 0120        call vdu_cls
0410E3 01 00 00 00 0121        ld bc,0 ; x
0410E7 11 00 00 00 0122        ld de,0 ; y
0410EB CD B3 0A 04 0123        call vdu_plot_bmp
0410EF             0124    
0410EF             0125    no_move:
0410EF 21 3C 00 00 0126        ld hl,main_loop_timer_reset
0410F3 CD 6C 09 04 0127        call tmr_main_loop_set
0410F7 C3 77 10 04 0128        jp mainloop
0410FB             0129    
0410FB             0130    main_end:
0410FB             0131    ; exit program gracefully
0410FB AF          0132        xor a ; 640x480x16 single-buffered
0410FC CD 59 0A 04 0133        call vdu_set_screen_mode
041100 3E 01       0134        ld a,1 ; scaling on
041102 CD 6A 0A 04 0135        call vdu_set_scaling
041106 CD D2 09 04 0136        call cursor_on
04110A C9          0137        ret
04110B             0138    
04110B             0139    ; load to onboard 8k sram
04110B             0140    filedata: equ 0xB7E000
