PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004 FF FF FF FF 0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C             0015    
04004C CD 04 1F 04 0016        call init
040050 CD B0 1F 04 0017        call main
040054             0018    
040054             0019    exit:
040054 FD E1       0020        pop iy
040056 DD E1       0021        pop ix
040058 D1          0022        pop de
040059 C1          0023        pop bc
04005A F1          0024        pop af
04005B 21 00 00 00 0025        ld hl,0
04005F             0026    
04005F C9          0027        ret
040060             0028    
040060             0029    ; API INCLUDES
040060             0030        include "mos_api.inc"
040060             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*   ; Title:	AGON MOS - API for user projects
040060             0003*   ; Author:	Dean Belfield
040060             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*   ;			Added MOS error codes for return in HL
040060             0006*   ; Created:	03/08/2022
040060             0007*   ; Last Updated:	10/08/2023
040060             0008*   ;
040060             0009*   ; Modinfo:
040060             0010*   ; 05/08/2022:	Added mos_feof
040060             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*   ; 13/10/2022:	Added mos_oscli
040060             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*   ; 19/05/2023:	Added sysvar_scrMode
040060             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*   ; 03/08/2023:	Added mos_setkbvector
040060             0028*   ; 10/08/2023:	Added mos_getkbmap
040060             0029*   
040060             0030*   ; VDP control (VDU 23, 0, n)
040060             0031*   ;
040060             0032*   vdp_gp:				EQU 80h
040060             0033*   vdp_keycode:		EQU 81h
040060             0034*   vdp_cursor:			EQU	82h
040060             0035*   vdp_scrchar:		EQU	83h
040060             0036*   vdp_scrpixel:		EQU	84h
040060             0037*   vdp_audio:			EQU	85h
040060             0038*   vdp_mode:			EQU	86h
040060             0039*   vdp_rtc:			EQU	87h
040060             0040*   vdp_keystate:		EQU	88h
040060             0041*   vdp_logicalcoords:	EQU	C0h
040060             0042*   vdp_terminalmode:	EQU	FFh
040060             0043*   
040060             0044*   ; MOS high level functions
040060             0045*   ;
040060             0046*   mos_getkey:			EQU	00h
040060             0047*   mos_load:			EQU	01h
040060             0048*   mos_save:			EQU	02h
040060             0049*   mos_cd:				EQU	03h
040060             0050*   mos_dir:			EQU	04h
040060             0051*   mos_del:			EQU	05h
040060             0052*   mos_ren:			EQU	06h
040060             0053*   mos_mkdir:			EQU	07h
040060             0054*   mos_sysvars:		EQU	08h
040060             0055*   mos_editline:		EQU	09h
040060             0056*   mos_fopen:			EQU	0Ah
040060             0057*   mos_fclose:			EQU	0Bh
040060             0058*   mos_fgetc:			EQU	0Ch
040060             0059*   mos_fputc:			EQU	0Dh
040060             0060*   mos_feof:			EQU	0Eh
040060             0061*   mos_getError:		EQU	0Fh
040060             0062*   mos_oscli:			EQU	10h
040060             0063*   mos_copy:			EQU	11h
040060             0064*   mos_getrtc:			EQU	12h
040060             0065*   mos_setrtc:			EQU	13h
040060             0066*   mos_setintvector:	EQU	14h
040060             0067*   mos_uopen:			EQU	15h
040060             0068*   mos_uclose:			EQU	16h
040060             0069*   mos_ugetc:			EQU	17h
040060             0070*   mos_uputc:			EQU	18h
040060             0071*   mos_getfil:			EQU	19h
040060             0072*   mos_fread:			EQU	1Ah
040060             0073*   mos_fwrite:			EQU	1Bh
040060             0074*   mos_flseek:			EQU	1Ch
040060             0075*   mos_setkbvector:	EQU	1Dh
040060             0076*   mos_getkbmap:		EQU	1Eh
040060             0077*   
040060             0078*   ; MOS program exit codes
040060             0079*   ;
040060             0080*   EXIT_OK:				EQU  0;	"OK",
040060             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*   ; FatFS file access functions
040060             0103*   ;
040060             0104*   ffs_fopen:			EQU	80h
040060             0105*   ffs_fclose:			EQU	81h
040060             0106*   ffs_fread:			EQU	82h
040060             0107*   ffs_fwrite:			EQU	83h
040060             0108*   ffs_flseek:			EQU	84h
040060             0109*   ffs_ftruncate:		EQU	85h
040060             0110*   ffs_fsync:			EQU	86h
040060             0111*   ffs_fforward:		EQU	87h
040060             0112*   ffs_fexpand:		EQU	88h
040060             0113*   ffs_fgets:			EQU	89h
040060             0114*   ffs_fputc:			EQU	8Ah
040060             0115*   ffs_fputs:			EQU	8Bh
040060             0116*   ffs_fprintf:		EQU	8Ch
040060             0117*   ffs_ftell:			EQU	8Dh
040060             0118*   ffs_feof:			EQU	8Eh
040060             0119*   ffs_fsize:			EQU	8Fh
040060             0120*   ffs_ferror:			EQU	90h
040060             0121*   
040060             0122*   ; FatFS directory access functions
040060             0123*   ;
040060             0124*   ffs_dopen:			EQU	91h
040060             0125*   ffs_dclose:			EQU	92h
040060             0126*   ffs_dread:			EQU	93h
040060             0127*   ffs_dfindfirst:		EQU	94h
040060             0128*   ffs_dfindnext:		EQU	95h
040060             0129*   
040060             0130*   ; FatFS file and directory management functions
040060             0131*   ;
040060             0132*   ffs_stat:			EQU	96h
040060             0133*   ffs_unlink:			EQU	97h
040060             0134*   ffs_rename:			EQU	98h
040060             0135*   ffs_chmod:			EQU	99h
040060             0136*   ffs_utime:			EQU	9Ah
040060             0137*   ffs_mkdir:			EQU	9Bh
040060             0138*   ffs_chdir:			EQU	9Ch
040060             0139*   ffs_chdrive:		EQU	9Dh
040060             0140*   ffs_getcwd:			EQU	9Eh
040060             0141*   
040060             0142*   ; FatFS volume management and system configuration functions
040060             0143*   ;
040060             0144*   ffs_mount:			EQU	9Fh
040060             0145*   ffs_mkfs:			EQU	A0h
040060             0146*   ffs_fdisk:			EQU	A1h
040060             0147*   ffs_getfree:		EQU	A2h
040060             0148*   ffs_getlabel:		EQU	A3h
040060             0149*   ffs_setlabel:		EQU	A4h
040060             0150*   ffs_setcp:			EQU	A5h
040060             0151*   
040060             0152*   ; File access modes
040060             0153*   ;
040060             0154*   fa_read:			EQU	01h
040060             0155*   fa_write:			EQU	02h
040060             0156*   fa_open_existing:	EQU	00h
040060             0157*   fa_create_new:		EQU	04h
040060             0158*   fa_create_always:	EQU	08h
040060             0159*   fa_open_always:		EQU	10h
040060             0160*   fa_open_append:		EQU	30h
040060             0161*   
040060             0162*   ; System variable indexes for api_sysvars
040060             0163*   ; Index into _sysvars in globals.inc
040060             0164*   ;
040060             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*   
040060             0192*   ; Flags for the VPD protocol
040060             0193*   ;
040060             0194*   vdp_pflag_cursor:		EQU	00000001b
040060             0195*   vdp_pflag_scrchar:		EQU	00000010b
040060             0196*   vdp_pflag_point:		EQU	00000100b
040060             0197*   vdp_pflag_audio:		EQU	00001000b
040060             0198*   vdp_pflag_mode:			EQU	00010000b
040060             0199*   vdp_pflag_rtc:			EQU	00100000b
040060             0200*   
040060             0201*   ;
040060             0202*   ; FatFS structures
040060             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*   ;
040060             0205*   ; Object ID and allocation information (FFOBJID)
040060             0206*   ;
040060             0207*   ; Indexes into FFOBJID structure
040060             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*   ;
040060             0215*   ; File object structure (FIL)
040060             0216*   ;
040060             0217*   ; Indexes into FIL structure
040060             0218*   fil_obj:		EQU 0	; 15: Object identifier
040060             0219*   fil_flag:		EQU	15 	;  1: File status flags
040060             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*   ;
040060             0227*   ; Directory object structure (DIR)
040060             0228*   ; Indexes into DIR structure
040060             0229*   dir_obj:		EQU  0	; 15: Object identifier
040060             0230*   dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*   dir_clust:		EQU	19	;  4: Current cluster
040060             0232*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*   ;
040060             0237*   ; File information structure (FILINFO)
040060             0238*   ;
040060             0239*   ; Indexes into FILINFO structure
040060             0240*   filinfo_fsize:		EQU 0	;   4: File size
040060             0241*   filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*   filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*   filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*   filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*   filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*   ;
040060             0247*   ; Macro for calling the API
040060             0248*   ; Parameters:
040060             0249*   ; - function: One of the function numbers listed above
040060             0250*   ;
040060             0251*   	MACRO	MOSCALL	function
040060             0252*   			LD	A, function
040060             0253*   			RST.LIL	08h
040060             0254*   	ENDMACRO
040060             0031        include "macros.inc"
040060             0001*   
040060             0002*   ; test the sign of HL
040060             0003*   ; inputs: HL obviously
040060             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0005*   ; destroys: flags
040060             0006*       MACRO SIGN_HLU
040060             0007*       add hl,de ; 1 cycle
040060             0008*       or a ; clear flags ; 1 cycle
040060             0009*       sbc hl,de ; 2 cycles
040060             0010*       ; 4 cycles total
040060             0011*       ENDMACRO
040060             0012*   
040060             0013*   ; put the value in A into HLU
040060             0014*   ; affects: HLU
040060             0015*   ; destroys: nothing
040060             0016*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
040060             0017*       MACRO A_TO_HLU
040060             0018*       xor a ; 1 cycle
040060             0019*       ld ($+8+1),hl ; 7 cycles
040060             0020*       ld ($+4+3),a ; 5 cycles
040060             0021*       ld hl,0x000000 ; 4 cycles
040060             0022*       ; 17 cycles total
040060             0023*       ENDMACRO
040060             0024*   
040060             0025*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
040060             0026*   ; one cycle less but burns flags
040060             0027*       MACRO A_TO_HLU_ALT
040060             0028*       push hl ; 4 cycles
040060             0029*       ld hl,2 ; 4 cycles
040060             0030*       add hl,sp ; 1 cycle
040060             0031*       ld (hl),a ; 2 cycles
040060             0032*       pop hl ; 4 cycles
040060             0033*       ; 15 cycles total
040060             0034*       ENDMACRO
040060             0035*   
040060             0036*       MACRO hlu_mul256
040060             0037*       add hl,hl ; * 2
040060             0038*       add hl,hl ; * 4
040060             0039*       add hl,hl ; * 8
040060             0040*       add hl,hl ; * 16
040060             0041*       add hl,hl ; * 32
040060             0042*       add hl,hl ; * 64
040060             0043*       add hl,hl ; * 128
040060             0044*       add hl,hl ; * 256
040060             0045*       ENDMACRO
040060             0046*   
040060             0047*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
040060             0048*       MACRO SRL_UHL
040060             0049*       dec sp ; 1 cycle
040060             0050*       push hl ; 4 cycles
040060             0051*       inc sp ; 1 cycle
040060             0052*       pop hl ; 4 cycles
040060             0053*       inc hl ; 1 cycle
040060             0054*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040060             0055*       ; 13 cycles total
040060             0056*       ENDMACRO
040060             0057*   
040060             0058*       MACRO printChar char
040060             0059*       LD A, char
040060             0060*       RST.LIL 10h
040060             0061*       ENDMACRO
040060             0062*   
040060             0063*   ; Simulated call to subroutine at HL
040060             0064*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0065*   ; outputs: whatever the subroutine does, including HL and BC
040060             0066*   ; destroys: only what the subroutine does, but always BC
040060             0067*       MACRO CALL_HL
040060             0068*       ld bc,$+6 ; Address of first instruction after the jump
040060             0069*       push bc ; which constitutes the return address
040060             0070*       jp (hl) ; Jump to the address in HL
040060             0071*       ENDMACRO
040060             0072*   
040060             0073*   ; Simulated call to subroutine at IX
040060             0074*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0075*   ; outputs: whatever the subroutine does, including IX and BC
040060             0076*   ; destroys: only what the subroutine does, but always BC
040060             0077*       MACRO CALL_IX
040060             0078*       ld bc,$+6 ; Address of first instruction after the jump
040060             0079*       push bc ; which constitutes the return address
040060             0080*       jp (ix) ; Jump to the address in IX
040060             0081*       ENDMACRO
040060             0082*   
040060             0083*   ; Simulated call to soubroutinte at IY
040060             0084*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0085*   ; outputs: whatever the subroutine does, including IY and BC
040060             0086*   ; destroys: only what the subroutine does, but always BC
040060             0087*       MACRO CALL_IY
040060             0088*       ld bc,$+6 ; Address of first instruction after the jump
040060             0089*       push bc ; which constitutes the return address
040060             0090*       jp (iy) ; Jump to the address in IY
040060             0091*       ENDMACRO
040060             0092*   
040060             0093*   ; put the value in HLU into A
040060             0094*   ; destroys: af
040060             0095*       MACRO HLU_TO_A
040060             0096*       dec sp ; 1 cycle
040060             0097*       push hl ; 4 cycles
040060             0098*       inc sp ; 1 cycle
040060             0099*       pop af ; 4 cycles
040060             0100*       ; 10 cycles total
040060             0101*       ENDMACRO
040060             0102*   
040060             0103*       MACRO PUSH_ALL
040060             0104*       ex af,af'
040060             0105*       exx
040060             0106*       push af
040060             0107*       push hl
040060             0108*       push bc
040060             0109*       push de
040060             0110*   
040060             0111*       ex af,af'
040060             0112*       exx
040060             0113*       push af
040060             0114*       push hl
040060             0115*       push bc
040060             0116*       push de
040060             0117*       push ix
040060             0118*       push iy
040060             0119*       ENDMACRO
040060             0120*   
040060             0121*       MACRO POP_ALL
040060             0122*       pop iy
040060             0123*       pop ix
040060             0124*       pop de
040060             0125*       pop bc
040060             0126*       pop hl
040060             0127*       pop af
040060             0128*       ex af,af'
040060             0129*       exx
040060             0130*   
040060             0131*       pop de
040060             0132*       pop bc
040060             0133*       pop hl
040060             0134*       pop af
040060             0135*       ex af,af'
040060             0136*       exx
040060             0137*       ENDMACRO
040060             0032        include "functions.inc"
040060             0001*   ; Print a zero-terminated string inline with code, e.g.:
040060             0002*   ;
040060             0003*   ;    call printInline
040060             0004*   ;    ASCIZ "Hello, world!\r\n"
040060             0005*   ;
040060             0006*   ; Destroys: HL,AF
040060             0007*   printInline:
040060 E1          0008*       pop hl ; get the return address = pointer to start of string
040061 CD 67 00 04 0009*       call printString ; HL advances to end of string
040065 E5          0010*       push hl ; restore the return address = pointer to end of string
040066 C9          0011*       ret
040067             0012*   
040067             0013*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040067             0014*   ; Print a zero-terminated string
040067             0015*   ; HL: Pointer to string
040067             0016*   printString:
040067 C5          0017*       PUSH BC
040068 01 00 00 00 0018*       LD BC,0
04006C 3E 00       0019*       LD A,0
04006E 5B DF       0020*       RST.LIL 18h
040070 C1          0021*       POP BC
040071 C9          0022*       RET
040072             0023*   ; print a VDU sequence
040072             0024*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
040072             0025*   sendVDUsequence:
040072 C5          0026*       PUSH BC
040073 01 00 00 00 0027*       LD BC, 0
040077 4E          0028*       LD C, (HL)
040078 5B DF       0029*       RST.LIL 18h
04007A C1          0030*       POP BC
04007B C9          0031*       RET
04007C             0032*   ; Print Newline sequence to VDP
04007C             0033*   ; destroys bc
04007C             0034*   printNewLine:
04007C F5          0035*       push af ; for some reason rst.lil 10h sets carry flag
04007D 3E 0D       0036*       LD A, '\r'
04007F 5B D7       0037*       RST.LIL 10h
040081 3E 0A       0038*       LD A, '\n'
040083 5B D7       0039*       RST.LIL 10h
040085 F1          0040*       pop af
040086 C9          0041*       RET
040087             0042*   
040087             0043*   ; print a zero-terminated string at a graphics coordinate
040087             0044*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
040087             0045*   printStringGfx:
040087 E5          0046*       push hl ; preserve string pointer
040088             0047*   ; move graphics cursor to x,y location
040088 3E 44       0048*       ld a,plot_pt+mv_abs
04008A CD 37 16 04 0049*       call vdu_plot
04008E             0050*   ; print string
04008E E1          0051*       pop hl ; restore string pointer
04008F             0052*   @print_loop:
04008F 7E          0053*       ld a,(hl)
040090 B7          0054*       or a ; check for end of string
040091 C8          0055*       ret z ; if zero, we're done
040092 08          0056*       ex af,af' ; preserve character
040093 3E 05       0057*       ld a,5 ; VDU 5 char to gfx cursor
040095 5B D7       0058*       rst.lil 10h ; send it
040097 08          0059*       ex af,af' ; restore character
040098 5B D7       0060*       rst.lil 10h ; print character
04009A 23          0061*       inc hl
04009B C3 8F 00 04 0062*       jp @print_loop
04009F C9          0063*       ret
0400A0             0064*   ; end printStringGfx
0400A0             0065*   
0400A0             0066*   ; Print a 24-bit HEX number
0400A0             0067*   ; HLU: Number to print
0400A0             0068*   printHex24:
0400A0             0069*       HLU_TO_A
0400A0 3B          0001*M1     dec sp ; 1 cycle
0400A1 E5          0002*M1     push hl ; 4 cycles
0400A2 33          0003*M1     inc sp ; 1 cycle
0400A3 F1          0004*M1     pop af ; 4 cycles
0400A4             0005*M1     ; 10 cycles total
0400A4 CD AE 00 04 0070*       CALL printHex8
0400A8             0071*   ; Print a 16-bit HEX number
0400A8             0072*   ; HL: Number to print
0400A8             0073*   printHex16:
0400A8 7C          0074*       LD A,H
0400A9 CD AE 00 04 0075*       CALL printHex8
0400AD 7D          0076*       LD A,L
0400AE             0077*   ; Print an 8-bit HEX number
0400AE             0078*   ; A: Number to print
0400AE             0079*   printHex8:
0400AE 4F          0080*       LD C,A
0400AF 1F          0081*       RRA
0400B0 1F          0082*       RRA
0400B1 1F          0083*       RRA
0400B2 1F          0084*       RRA
0400B3 CD B8 00 04 0085*       CALL @F
0400B7 79          0086*       LD A,C
0400B8             0087*   @@:
0400B8 E6 0F       0088*       AND 0Fh
0400BA C6 90       0089*       ADD A,90h
0400BC 27          0090*       DAA
0400BD CE 40       0091*       ADC A,40h
0400BF 27          0092*       DAA
0400C0 5B D7       0093*       RST.LIL 10h
0400C2 C9          0094*       RET
0400C3             0095*   
0400C3             0096*   ; Print a 0x HEX prefix
0400C3             0097*   DisplayHexPrefix:
0400C3 3E 30       0098*       LD A, '0'
0400C5 5B D7       0099*       RST.LIL 10h
0400C7 3E 78       0100*       LD A, 'x'
0400C9 5B D7       0101*       RST.LIL 10h
0400CB C9          0102*       RET
0400CC             0103*   
0400CC             0104*       MACRO printDecBC
0400CC             0105*       push hl
0400CC             0106*       push bc
0400CC             0107*       pop hl
0400CC             0108*       call printDec
0400CC             0109*       pop hl
0400CC             0110*       ENDMACRO
0400CC             0111*   
0400CC             0112*       MACRO printDecDE
0400CC             0113*       push hl
0400CC             0114*       push de
0400CC             0115*       pop hl
0400CC             0116*       call printDec
0400CC             0117*       pop hl
0400CC             0118*       ENDMACRO
0400CC             0119*   
0400CC             0120*       MACRO printDecHL
0400CC             0121*       call printDec
0400CC             0122*       ENDMACRO
0400CC             0123*   
0400CC             0124*       MACRO printDecIX
0400CC             0125*       push hl
0400CC             0126*       push ix
0400CC             0127*       pop hl
0400CC             0128*       call printDec
0400CC             0129*       pop hl
0400CC             0130*       ENDMACRO
0400CC             0131*   
0400CC             0132*       MACRO printDecIY
0400CC             0133*       push hl
0400CC             0134*       push iy
0400CC             0135*       pop hl
0400CC             0136*       call printDec
0400CC             0137*       pop hl
0400CC             0138*       ENDMACRO
0400CC             0139*   
0400CC             0140*   
0400CC             0141*   ; Prints the right justified decimal value in HL without leading zeroes
0400CC             0142*   ; HL : Value to print
0400CC             0143*   ; preserves all registers and flags
0400CC             0144*   printDec:
0400CC             0145*   ; BEGIN MY CODE
0400CC             0146*   ; back up all the things
0400CC F5          0147*       push af
0400CD C5          0148*       push bc
0400CE D5          0149*       push de
0400CF E5          0150*       push hl
0400D0             0151*   ; END MY CODE
0400D0 11 F8 00 04 0152*       LD DE, _printDecBuffer
0400D4 CD 08 01 04 0153*       CALL u24_to_ascii
0400D8             0154*   ; BEGIN MY CODE
0400D8             0155*   ; replace leading zeroes with spaces
0400D8 21 F8 00 04 0156*       LD HL, _printDecBuffer
0400DC 06 07       0157*       ld B, 7 ; if HL was 0, we want to keep the final zero
0400DE             0158*   @loop:
0400DE 7E          0159*       LD A, (HL)
0400DF FE 30       0160*       CP '0'
0400E1 C2 EB 00 04 0161*       JP NZ, @done
0400E5 3E 20       0162*       LD A, ' '
0400E7 77          0163*       LD (HL), A
0400E8 23          0164*       INC HL
0400E9             0165*       ; CALL vdu_cursor_forward
0400E9 10 F3       0166*       DJNZ @loop
0400EB             0167*   @done:
0400EB             0168*   ; END MY CODE
0400EB 21 F8 00 04 0169*       LD HL, _printDecBuffer
0400EF CD 67 00 04 0170*       CALL printString
0400F3             0171*   ; BEGIN MY CODE
0400F3             0172*   ; restore all the things
0400F3 E1          0173*       pop hl
0400F4 D1          0174*       pop de
0400F5 C1          0175*       pop bc
0400F6 F1          0176*       pop af
0400F7             0177*   ; END MY CODE
0400F7 C9          0178*       RET
0400F8 00 00 00 00 0179*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040108             0180*   
040108             0181*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
040108             0182*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040108             0183*   ; so it will allways be 8 characters length
040108             0184*   ; HL : Value to convert to string
040108             0185*   ; DE : pointer to buffer, at least 8 byte + 0
040108             0186*   u24_to_ascii:
040108 01 80 69 67 0187*       LD BC,-10000000
04010C CD 3F 01 04 0188*       CALL @one_digit
040110 01 C0 BD F0 0189*       LD BC,-1000000
040114 CD 3F 01 04 0190*       CALL @one_digit
040118 01 60 79 FE 0191*       LD BC,-100000
04011C CD 3F 01 04 0192*       CALL @one_digit
040120 01 F0 D8 FF 0193*       LD BC,-10000
040124 CD 3F 01 04 0194*       CALL @one_digit
040128 01 18 FC FF 0195*       LD BC,-1000
04012C CD 3F 01 04 0196*       CALL @one_digit
040130 01 9C FF FF 0197*       LD BC,-100
040134 CD 3F 01 04 0198*       CALL @one_digit
040138 0E F6       0199*       LD C,-10
04013A CD 3F 01 04 0200*       CALL @one_digit
04013E 48          0201*       LD C,B
04013F             0202*   @one_digit:
04013F 3E 2F       0203*       LD A,'0'-1
040141             0204*   @divide_me:
040141 3C          0205*       INC A
040142 09          0206*       ADD HL,BC
040143 38 FC       0207*       JR C,@divide_me
040145 ED 42       0208*       SBC HL,BC
040147 12          0209*       LD (DE),A
040148 13          0210*       INC DE
040149 C9          0211*       RET
04014A             0212*   
04014A             0213*   print_u24:
04014A D5          0214*       push de
04014B E5          0215*       push hl
04014C 11 F8 00 04 0216*       ld de,_printDecBuffer
040150 CD 08 01 04 0217*       call u24_to_ascii
040154 21 F8 00 04 0218*       ld hl,_printDecBuffer
040158 CD 67 00 04 0219*       call printString
04015C 3E 20       0220*       ld a,' '
04015E 5B D7       0221*       rst.lil 10h
040160 E1          0222*       pop hl
040161 D1          0223*       pop de
040162 C9          0224*       ret
040163             0225*   
040163             0226*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040163             0227*   ; HL : Value to convert to string (integer part in H, fractional part in L)
040163             0228*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040163             0229*   u168_to_ascii:
040163             0230*   ; add a leading space to make room for sign flag if needed
040163 3E 20       0231*       ld a,' '
040165 12          0232*       ld (de),a
040166 13          0233*       inc de
040167             0234*   ; Convert integer part
040167 E5          0235*       push hl ; Save HL (we’ll need the fractional part later)
040168             0236*       ; call hlu_udiv256 ; Shift to get integer portion in HL
040168             0237*       SRL_UHL ; Shift to get integer portion in HL
040168 3B          0001*M1     dec sp ; 1 cycle
040169 E5          0002*M1     push hl ; 4 cycles
04016A 33          0003*M1     inc sp ; 1 cycle
04016B E1          0004*M1     pop hl ; 4 cycles
04016C 23          0005*M1     inc hl ; 1 cycle
04016D 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04016F             0007*M1     ; 13 cycles total
04016F 01 F0 D8 FF 0238*       ld bc, -10000
040173 CD 96 01 04 0239*       call @one_int
040177 01 18 FC FF 0240*       ld bc, -1000
04017B CD 96 01 04 0241*       call @one_int
04017F 01 9C FF FF 0242*       ld bc, -100
040183 CD 96 01 04 0243*       call @one_int
040187 0E F6       0244*       ld c, -10
040189 CD 96 01 04 0245*       call @one_int
04018D 48          0246*       ld c, b
04018E CD 96 01 04 0247*       call @one_int
040192 C3 A1 01 04 0248*       jp @frac ; Jump to fractional part conversion
040196             0249*   @one_int:
040196 3E 2F       0250*       ld a, '0' - 1 ; Start ASCII character at '0'
040198             0251*   @divide_me:
040198 3C          0252*       inc a
040199 09          0253*       add hl, bc ; Accumulate until overflow
04019A 38 FC       0254*       jr c, @divide_me
04019C ED 42       0255*       sbc hl, bc ; Remove excess after overflow
04019E 12          0256*       ld (de), a ; Store ASCII digit
04019F 13          0257*       inc de
0401A0 C9          0258*       ret
0401A1             0259*   ; Convert fractional part
0401A1             0260*   @frac:
0401A1 3E 2E       0261*       ld a, '.' ; Decimal point
0401A3 12          0262*       ld (de), a
0401A4 13          0263*       inc de
0401A5 E1          0264*       pop hl ; Restore HL with original fraction
0401A6 06 03       0265*       ld b, 3 ; Loop counter for 3 fractional digits
0401A8             0266*   @frac_loop:
0401A8 26 0A       0267*       ld h, 10 ; Load multiplier for fractional part
0401AA ED 6C       0268*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0401AC 3E 30       0269*       ld a, '0'
0401AE 84          0270*       add a, h ; Convert integer part to ASCII
0401AF 12          0271*       ld (de), a
0401B0 13          0272*       inc de
0401B1 10 F5       0273*       djnz @frac_loop ; Repeat for each fractional digit
0401B3             0274*   ; Add null terminator
0401B3 AF          0275*       xor a ; Null terminator
0401B4 12          0276*       ld (de), a
0401B5 C9          0277*       ret
0401B6             0278*   
0401B6             0279*   print_u168:
0401B6 D5          0280*       push de
0401B7 E5          0281*       push hl
0401B8 11 F8 00 04 0282*       ld de,_printDecBuffer
0401BC CD 63 01 04 0283*       call u168_to_ascii
0401C0 21 F8 00 04 0284*       ld hl,_printDecBuffer
0401C4 CD 67 00 04 0285*       call printString
0401C8 E1          0286*       pop hl
0401C9 D1          0287*       pop de
0401CA C9          0288*       ret
0401CB             0289*   
0401CB             0290*   ; signed version of u168_to_ascii
0401CB             0291*   s168_to_ascii:
0401CB D5          0292*       push de ; save starting address of buffer
0401CC CD 70 04 04 0293*       call hlu_abs
0401D0 F5          0294*       push af ; save sign flag
0401D1 CD 63 01 04 0295*       call u168_to_ascii
0401D5 F1          0296*       pop af ; restore sign flag
0401D6 D1          0297*       pop de ; restore starting address of buffer
0401D7 F0          0298*       ret p ; hlu was positive so nothing to do
0401D8 3E 2D       0299*       ld a,'-'
0401DA 12          0300*       ld (de),a
0401DB C9          0301*       ret
0401DC             0302*   
0401DC             0303*   print_s168:
0401DC D5          0304*       push de
0401DD E5          0305*       push hl
0401DE 11 F8 00 04 0306*       ld de,_printDecBuffer
0401E2 CD CB 01 04 0307*       call s168_to_ascii
0401E6 21 F8 00 04 0308*       ld hl,_printDecBuffer
0401EA CD 67 00 04 0309*       call printString
0401EE E1          0310*       pop hl
0401EF D1          0311*       pop de
0401F0 C9          0312*       ret
0401F1             0313*   
0401F1             0314*   print_s168_hl:
0401F1 F5          0315*       push af
0401F2 E5          0316*       push hl
0401F3 CD DC 01 04 0317*       call print_s168
0401F7 3E 20       0318*       ld a,' '
0401F9 5B D7       0319*       rst.lil 10h
0401FB E1          0320*       pop hl
0401FC F1          0321*       pop af
0401FD C9          0322*       ret
0401FE             0323*   
0401FE             0324*   print_s168_bc:
0401FE F5          0325*       push af
0401FF C5          0326*       push bc
040200 E5          0327*       push hl
040201 C5          0328*       push bc
040202 E1          0329*       pop hl
040203 CD DC 01 04 0330*       call print_s168
040207 3E 20       0331*       ld a,' '
040209 5B D7       0332*       rst.lil 10h
04020B E1          0333*       pop hl
04020C C1          0334*       pop bc
04020D F1          0335*       pop af
04020E C9          0336*       ret
04020F             0337*   
04020F             0338*   print_s168_de:
04020F F5          0339*       push af
040210 D5          0340*       push de
040211 E5          0341*       push hl
040212 EB          0342*       ex de,hl
040213 CD DC 01 04 0343*       call print_s168
040217 3E 20       0344*       ld a,' '
040219 5B D7       0345*       rst.lil 10h
04021B E1          0346*       pop hl
04021C D1          0347*       pop de
04021D F1          0348*       pop af
04021E C9          0349*       ret
04021F             0350*   
04021F             0351*   print_s168_hl_bc_de:
04021F F5          0352*       push af
040220 C5          0353*       push bc
040221 D5          0354*       push de
040222 E5          0355*       push hl
040223 CD DC 01 04 0356*       call print_s168
040227 3E 20       0357*       ld a,' '
040229 5B D7       0358*       rst.lil 10h
04022B C5          0359*       push bc
04022C E1          0360*       pop hl
04022D CD DC 01 04 0361*       call print_s168
040231 3E 20       0362*       ld a,' '
040233 5B D7       0363*       rst.lil 10h
040235 EB          0364*       ex de,hl
040236 CD DC 01 04 0365*       call print_s168
04023A 3E 20       0366*       ld a,' '
04023C 5B D7       0367*       rst.lil 10h
04023E E1          0368*       pop hl
04023F D1          0369*       pop de
040240 C1          0370*       pop bc
040241 F1          0371*       pop af
040242 C9          0372*       ret
040243             0373*   
040243             0374*   print_s168_bc_de:
040243 F5          0375*       push af
040244 C5          0376*       push bc
040245 D5          0377*       push de
040246 C5          0378*       push bc
040247 E1          0379*       pop hl
040248 CD DC 01 04 0380*       call print_s168
04024C 3E 20       0381*       ld a,' '
04024E 5B D7       0382*       rst.lil 10h
040250 EB          0383*       ex de,hl
040251 CD DC 01 04 0384*       call print_s168
040255 3E 20       0385*       ld a,' '
040257 5B D7       0386*       rst.lil 10h
040259 E1          0387*       pop hl
04025A D1          0388*       pop de
04025B C1          0389*       pop bc
04025C F1          0390*       pop af
04025D C9          0391*       ret
04025E             0392*   
04025E             0393*   print_s168_a:
04025E F5          0394*       push af
04025F C5          0395*       push bc
040260 E5          0396*       push hl
040261 21 00 00 00 0397*       ld hl,0
040265 6F          0398*       ld l,a
040266 CD F1 01 04 0399*       call print_s168_hl
04026A E1          0400*       pop hl
04026B C1          0401*       pop bc
04026C F1          0402*       pop af
04026D C9          0403*       ret
04026E             0404*   
04026E             0405*   ; #### new functions added by Brandon R. Gates ####
04026E             0406*   
04026E             0407*   ; print the binary representation of the 8-bit value in a
04026E             0408*   ; destroys a, hl, bc
04026E             0409*   printBin8:
04026E 06 08       0410*       ld b,8 ; loop counter for 8 bits
040270 21 8B 02 04 0411*       ld hl,@cmd ; set hl to the low byte of the output string
040274             0412*       ; (which will be the high bit of the value in a)
040274             0413*   @loop:
040274 07          0414*       rlca ; put the next highest bit into carry
040275 38 04       0415*       jr c,@one
040277 36 30       0416*       ld (hl),'0'
040279 18 02       0417*       jr @next_bit
04027B             0418*   @one:
04027B 36 31       0419*       ld (hl),'1'
04027D             0420*   @next_bit:
04027D 23          0421*       inc hl
04027E 10 F4       0422*       djnz @loop
040280             0423*   ; print it
040280 21 8B 02 04 0424*       ld hl,@cmd
040284 01 08 00 00 0425*       ld bc,@end-@cmd
040288 5B DF       0426*       rst.lil $18
04028A C9          0427*       ret
04028B             0428*   @cmd: ds 8 ; eight bytes for eight bits
040293             0429*   @end:
040293             0430*   
040293             0431*   ; print the binary representation of the 8-bit value in a
040293             0432*   ; in reverse order (lsb first)
040293             0433*   ; destroys a, hl, bc
040293             0434*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
040293 06 08       0435*       ld b,8 ; loop counter for 8 bits
040295 21 B0 02 04 0436*       ld hl,@cmd ; set hl to the low byte of the output string
040299             0437*       ; (which will be the high bit of the value in a)
040299             0438*   @loop:
040299 0F          0439*       rrca ; put the next lowest bit into carry
04029A 38 04       0440*       jr c,@one
04029C 36 30       0441*       ld (hl),'0'
04029E 18 02       0442*       jr @next_bit
0402A0             0443*   @one:
0402A0 36 31       0444*       ld (hl),'1'
0402A2             0445*   @next_bit:
0402A2 23          0446*       inc hl
0402A3 10 F4       0447*       djnz @loop
0402A5             0448*   ; print it
0402A5 21 B0 02 04 0449*       ld hl,@cmd
0402A9 01 08 00 00 0450*       ld bc,@end-@cmd
0402AD 5B DF       0451*       rst.lil $18
0402AF C9          0452*       ret
0402B0             0453*   @cmd: ds 8 ; eight bytes for eight bits
0402B8             0454*   @end:
0402B8             0455*   
       FF FF FF FF 
       FF FF FF FF 
0402B8 20 61 66 3D 0456*   str_afu: db " af=",0
       00          
0402BD 20 68 6C 3D 0457*   str_hlu: db " hl=",0
       00          
0402C2 20 62 63 3D 0458*   str_bcu: db " bc=",0
       00          
0402C7 20 64 65 3D 0459*   str_deu: db " de=",0
       00          
0402CC 20 69 78 3D 0460*   str_ixu: db " ix=",0
       00          
0402D1 20 69 79 3D 0461*   str_iyu: db " iy=",0
       00          
0402D6             0462*   
0402D6             0463*   ; print udeuhl to screen in hexidecimal format
0402D6             0464*   ; inputs: none
0402D6             0465*   ; outputs: concatenated hexidecimal udeuhl
0402D6             0466*   ; destroys: nothing
0402D6             0467*   dumpUDEUHLHex:
0402D6             0468*   ; store everything in scratch
0402D6 22 35 03 04 0469*       ld (uhl),hl
0402DA ED 43 38 03 0470*       ld (ubc),bc
       04          
0402DF ED 53 3B 03 0471*       ld (ude),de
       04          
0402E4 DD 22 3E 03 0472*       ld (uix),ix
       04          
0402E9 FD 22 41 03 0473*       ld (uiy),iy
       04          
0402EE F5          0474*       push af
0402EF             0475*   
0402EF             0476*   ; print each register
0402EF             0477*   
0402EF 21 29 03 04 0478*       ld hl,str_udeuhl
0402F3 CD 67 00 04 0479*       call printString
0402F7 2A 3B 03 04 0480*       ld hl,(ude)
0402FB CD A0 00 04 0481*       call printHex24
0402FF 3E 2E       0482*       ld a,'.' ; print a dot to separate the values
040301 5B D7       0483*       rst.lil 10h
040303 2A 35 03 04 0484*       ld hl,(uhl)
040307 CD A0 00 04 0485*       call printHex24
04030B CD 7C 00 04 0486*       call printNewLine
04030F             0487*   
04030F             0488*   ; restore everything
04030F 2A 35 03 04 0489*       ld hl, (uhl)
040313 ED 4B 38 03 0490*       ld bc, (ubc)
       04          
040318 ED 5B 3B 03 0491*       ld de, (ude)
       04          
04031D DD 2A 3E 03 0492*       ld ix, (uix)
       04          
040322 FD 2A 41 03 0493*       ld iy, (uiy)
       04          
040327 F1          0494*       pop af
040328             0495*   ; all done
040328 C9          0496*       ret
040329             0497*   
040329 75 64 65 2E 0498*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
040332             0499*   
040332             0500*   ; global scratch memory for registers
040332 00 00 00    0501*   uaf: dl 0
040335 00 00 00    0502*   uhl: dl 0
040338 00 00 00    0503*   ubc: dl 0
04033B 00 00 00    0504*   ude: dl 0
04033E 00 00 00    0505*   uix: dl 0
040341 00 00 00    0506*   uiy: dl 0
040344 00 00 00    0507*   usp: dl 0
040347 00 00 00    0508*   upc: dl 0
04034A             0509*   
04034A             0510*   
04034A             0511*   ; set all the bits in the flag register
04034A             0512*   ; more of an academic exercise than anything useful
04034A             0513*   ; inputs; none
04034A             0514*   ; outputs; a=0,f=255
04034A             0515*   ; destroys: flags, hl
04034A             0516*   ; preserves: a, because why not
04034A             0517*   setAllFlags:
04034A 21 FF 00 00 0518*       ld hl,255
04034E 67          0519*       ld h,a ; four cycles to preserve a is cheap
04034F E5          0520*       push hl
040350 F1          0521*       pop af
040351 C9          0522*       ret
040352             0523*   
040352             0524*   ; reset all the bits in the flag register
040352             0525*   ; unlike its inverse counterpart, this may actually be useful
040352             0526*   ; inputs; none
040352             0527*   ; outputs; a=0,f=0
040352             0528*   ; destroys: flags, hl
040352             0529*   ; preserves: a, because why not
040352             0530*   resetAllFlags:
040352 21 00 00 00 0531*       ld hl,0
040356 67          0532*       ld h,a ; four cycles to preserve a is cheap
040357 E5          0533*       push hl
040358 F1          0534*       pop af
040359 C9          0535*       ret
04035A             0536*   
04035A             0537*   ; wait until user presses a key
04035A             0538*   ; inputs: none
04035A             0539*   ; outputs: ascii code of key pressed in a
04035A             0540*   ; destroys: af,ix
04035A             0541*   waitKeypress:
04035A             0542*       MOSCALL mos_getkey
04035A 3E 00       0001*M1 			LD	A, function
04035C 5B CF       0002*M1 			RST.LIL	08h
04035E C9          0543*       ret
04035F             0544*   
04035F             0545*   ; clear a block of memory by writing a prescribed value to each byte in the range
04035F             0546*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
04035F             0547*   ; outputs: memory block is cleared
04035F             0548*   ; destroys: hl, de
04035F             0549*   clear_mem:
04035F 0B          0550*       dec bc ; we do this because we will increment de before writing the first byte
040360 77          0551*       ld (hl),a
040361 E5          0552*       push hl
040362 D1          0553*       pop de
040363 13          0554*       inc de ; target address
040364 ED B0       0555*       ldir
040366 C9          0556*       ret
040367             0033        include "arith24.inc"
040367             0001*   ;------------------------------------------------------------------------
040367             0002*   ;  arith24.asm
040367             0003*   ;  24-bit ez80 arithmetic routines
040367             0004*   ;  Copyright (c) Shawn Sijnstra 2024
040367             0005*   ;  MIT license
040367             0006*   ;
040367             0007*   ;  This library was created as a tool to help make ez80
040367             0008*   ;  24-bit native assembly routines for simple mathematical problems
040367             0009*   ;  more widely available.
040367             0010*   ;
040367             0011*   ;------------------------------------------------------------------------
040367             0012*   
040367             0013*   ;------------------------------------------------------------------------
040367             0014*   ; umul24:	HL = HL*DE (unsigned)
040367             0015*   ; Preserves AF, BC, DE
040367             0016*   ; Uses a fast multiply routine.
040367             0017*   ;------------------------------------------------------------------------
040367             0018*   umul24:
040367 D5          0019*   	push	DE
040368 C5          0020*   	push	BC
040369 F5          0021*   	push	AF
04036A E5          0022*   	push	HL
04036B C1          0023*   	pop		BC
04036C 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
04036E 21 00 00 00 0025*       ld	 	hl, 0 ; Result
040372             0026*   umul24_lp:
040372 29          0027*   	add	hl,hl
040373 EB          0028*   	ex	de,hl
040374 29          0029*   	add	hl,hl
040375 EB          0030*   	ex	de,hl
040376 30 01       0031*   	jr	nc,umul24_nc
040378 09          0032*   	add	hl,bc
040379             0033*   umul24_nc:
040379 3D          0034*   	dec	a
04037A 20 F6       0035*   	jr	nz,umul24_lp
04037C F1          0036*   	pop	af
04037D C1          0037*   	pop	bc
04037E D1          0038*   	pop	de
04037F C9          0039*   	ret
040380             0040*   
040380             0041*   
040380             0042*   ;------------------------------------------------------------------------
040380             0043*   ; udiv24
040380             0044*   ; Unsigned 24-bit division
040380             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040380             0046*   ;
040380             0047*   ; Uses AF BC DE HL
040380             0048*   ; Uses Restoring Division algorithm
040380             0049*   ;------------------------------------------------------------------------
040380             0050*   
040380             0051*   udiv24:
040380 E5          0052*   	push	hl
040381 C1          0053*   	pop		bc	;move dividend to BCU
040382 21 00 00 00 0054*   	ld		hl,0	;result
040386 A7          0055*   	and		a
040387 ED 52       0056*   	sbc		hl,de	;test for div by 0
040389 C8          0057*   	ret		z		;it's zero, carry flag is clear
04038A 19          0058*   	add		hl,de	;HL is 0 again
04038B 3E 18       0059*   	ld		a,24	;number of loops through.
04038D             0060*   udiv1:
04038D C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
04038E E3          0062*   	ex		(sp),hl
04038F 37          0063*   	scf
040390 ED 6A       0064*   	adc	hl,hl
040392 E3          0065*   	ex	(sp),hl
040393 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
040394             0067*   
040394 ED 6A       0068*   	adc	hl,hl
040396 A7          0069*   	and	a		;is this the bug
040397 ED 52       0070*   	sbc	hl,de
040399 30 02       0071*   	jr	nc,udiv2
04039B 19          0072*   	add	hl,de
04039C             0073*   ;	dec	c
04039C 0B          0074*   	dec	bc
04039D             0075*   udiv2:
04039D 3D          0076*   	dec	a
04039E 20 ED       0077*   	jr	nz,udiv1
0403A0 37          0078*   	scf		;flag used for div0 error
0403A1 C5          0079*   	push	bc
0403A2 D1          0080*   	pop		de	;remainder
0403A3 C9          0081*   	ret
0403A4             0082*   
0403A4             0083*   
0403A4             0084*   
0403A4             0085*   ;------------------------------------------------------------------------
0403A4             0086*   ; neg24
0403A4             0087*   ; Returns: HLU = 0-HLU
0403A4             0088*   ; preserves all other registers
0403A4             0089*   ;------------------------------------------------------------------------
0403A4             0090*   neg24:
0403A4 D5          0091*   	push	de
0403A5 EB          0092*   	ex		de,hl
0403A6 21 00 00 00 0093*   	ld		hl,0
0403AA B7          0094*   	or		a
0403AB ED 52       0095*   	sbc		hl,de
0403AD D1          0096*   	pop		de
0403AE C9          0097*   	ret
0403AF             0098*   
0403AF             0099*   ;------------------------------------------------------------------------
0403AF             0100*   ; or_hlu_deu: 24 bit bitwise OR
0403AF             0101*   ; Returns: hlu = hlu OR deu
0403AF             0102*   ; preserves all other registers
0403AF             0103*   ;------------------------------------------------------------------------
0403AF             0104*   or_hlu_deu:
0403AF 22 38 04 04 0105*   	ld	(bitbuf1),hl
0403B3 ED 53 3B 04 0106*   	ld	(bitbuf2),de
       04          
0403B8 D5          0107*   	push	de	;preserve DEU
0403B9 C5          0108*   	push	bc	;preserve BCU
0403BA 06 03       0109*   	ld		b,3
0403BC 21 38 04 04 0110*   	ld	hl,bitbuf1
0403C0 11 38 04 04 0111*   	ld	de,bitbuf1
0403C4             0112*   orloop_24:
0403C4 1A          0113*   	ld	a,(de)
0403C5 B6          0114*   	or	(hl)
0403C6 12          0115*   	ld	(de),a
0403C7 13          0116*   	inc	de
0403C8 23          0117*   	inc	hl
0403C9 10 F9       0118*   	djnz	orloop_24
0403CB 2A 3B 04 04 0119*   	ld	hl,(bitbuf2)
0403CF C1          0120*   	pop		bc	;restore BC
0403D0 D1          0121*   	pop		de	;restore DE
0403D1             0122*   
0403D1             0123*   ;------------------------------------------------------------------------
0403D1             0124*   ; and_hlu_deu: 24 bit bitwise AND
0403D1             0125*   ; Returns: hlu = hlu AND deu
0403D1             0126*   ; preserves all other registers
0403D1             0127*   ;------------------------------------------------------------------------
0403D1             0128*   and_hlu_deu:
0403D1 22 38 04 04 0129*   	ld	(bitbuf1),hl
0403D5 ED 53 3B 04 0130*   	ld	(bitbuf2),de
       04          
0403DA D5          0131*   	push	de	;preserve DEU
0403DB C5          0132*   	push	bc	;preserve BCU
0403DC 06 03       0133*   	ld		b,3
0403DE 21 38 04 04 0134*   	ld	hl,bitbuf1
0403E2 11 38 04 04 0135*   	ld	de,bitbuf1
0403E6             0136*   andloop_24:
0403E6 1A          0137*   	ld	a,(de)
0403E7 A6          0138*   	and	(hl)
0403E8 12          0139*   	ld	(de),a
0403E9 13          0140*   	inc	de
0403EA 23          0141*   	inc	hl
0403EB 10 F9       0142*   	djnz	andloop_24
0403ED 2A 3B 04 04 0143*   	ld	hl,(bitbuf2)
0403F1 C1          0144*   	pop		bc	;restore BC
0403F2 D1          0145*   	pop		de	;restore DE
0403F3             0146*   
0403F3             0147*   ;------------------------------------------------------------------------
0403F3             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0403F3             0149*   ; Returns: hlu = hlu XOR deu
0403F3             0150*   ; preserves all other registers
0403F3             0151*   ;------------------------------------------------------------------------
0403F3             0152*   xor_hlu_deu:
0403F3 22 38 04 04 0153*   	ld	(bitbuf1),hl
0403F7 ED 53 3B 04 0154*   	ld	(bitbuf2),de
       04          
0403FC D5          0155*   	push	de	;preserve DEU
0403FD C5          0156*   	push	bc	;preserve BCU
0403FE 06 03       0157*   	ld		b,3
040400 21 38 04 04 0158*   	ld	hl,bitbuf1
040404 11 38 04 04 0159*   	ld	de,bitbuf1
040408             0160*   xorloop_24:
040408 1A          0161*   	ld	a,(de)
040409 AE          0162*   	xor	(hl)
04040A 12          0163*   	ld	(de),a
04040B 13          0164*   	inc	de
04040C 23          0165*   	inc	hl
04040D 10 F9       0166*   	djnz	xorloop_24
04040F 2A 3B 04 04 0167*   	ld	hl,(bitbuf2)
040413 C1          0168*   	pop		bc	;restore BC
040414 D1          0169*   	pop		de	;restore DE
040415             0170*   
040415             0171*   ;------------------------------------------------------------------------
040415             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
040415             0173*   ; Returns: hlu = hlu << a
040415             0174*   ;		   a = 0
040415             0175*   ; NOTE: only considers a up to 16 bits.
040415             0176*   ; preserves all other registers
040415             0177*   ; modified by Brandon R. Gates to use a instead of de
040415             0178*   ;------------------------------------------------------------------------
040415             0179*   shl_hlu:
040415 B7          0180*   	or a
040416 C8          0181*   	ret		z		;we're done
040417 29          0182*   	add		hl,hl	;shift HLU left
040418 3D          0183*   	dec a
040419 18 FA       0184*   	jr		shl_hlu
04041B             0185*   
04041B             0186*   ;------------------------------------------------------------------------
04041B             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
04041B             0188*   ; Returns: hlu = hlu >> a
04041B             0189*   ;		   a = 0
04041B             0190*   ; NOTE: only considers a up to 16 bits.
04041B             0191*   ; preserves all other registers
04041B             0192*   ; modified by Brandon R. Gates to use a instead of de
04041B             0193*   ;------------------------------------------------------------------------
04041B             0194*   shr_hlu:
04041B 22 38 04 04 0195*   	ld		(bitbuf1),hl
04041F 21 3A 04 04 0196*   	ld		hl,bitbuf1+2
040423             0197*   @shr_loop:
040423 B7          0198*   	or a
040424 28 0D       0199*   	jr		z,@shr_done		;we're done
040426             0200*   ;carry is clear from or instruction
040426 CB 1E       0201*   	rr		(hl)
040428 2B          0202*   	dec		hl
040429 CB 1E       0203*   	rr		(hl)
04042B 2B          0204*   	dec		hl
04042C CB 1E       0205*   	rr		(hl)
04042E 23          0206*   	inc		hl
04042F 23          0207*   	inc		hl
040430 3D          0208*   	dec a
040431 18 F0       0209*   	jr		@shr_loop
040433             0210*   @shr_done:
040433 2A 38 04 04 0211*   	ld		hl,(bitbuf1)	;collect result
040437 C9          0212*   	ret
040438             0213*   
040438             0214*   ;------------------------------------------------------------------------
040438             0215*   ; Scratch area for calculations
040438             0216*   ;------------------------------------------------------------------------
040438 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
04043B 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
04043E             0219*   
04043E             0220*   ; -----------------------------------------------------------------------
04043E             0221*   ; Functions added by Brandon R. Gates
04043E             0222*   ; -----------------------------------------------------------------------
04043E             0223*   
04043E             0224*   ;------------------------------------------------------------------------
04043E             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
04043E             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
04043E             0227*   ;              HLU = HLU >> LSB(A)
04043E             0228*   ; Returns: HLU = HLU >> LSB(A)
04043E             0229*   ; Destroys: af
04043E             0230*   ;------------------------------------------------------------------------
04043E             0231*   shr_hlu_log2a:
04043E B7          0232*   	or a    ; check for zero
04043F C8          0233*   	ret z   ; nothing to shift so we're done
040440 C5          0234*   	push 	bc ; preserve
040441 06 00       0235*   	ld		b,0 ; clear b
040443             0236*   @find_bit:
040443 0F          0237*   	rrca ; bit 0 to carry
040444 DA 4D 04 04 0238*   	jp c,@found_bit
040448 04          0239*   	inc b ; next bit
040449 C3 43 04 04 0240*   	jp @find_bit
04044D             0241*   @found_bit:
04044D 78          0242*   	ld a,b
04044E CD 1B 04 04 0243*   	call shr_hlu
040452 C1          0244*   	pop 	bc ; restore
040453 C9          0245*   	ret
040454             0246*   ; end shr_hlu_log2a
040454             0247*   
040454             0248*   ;------------------------------------------------------------------------
040454             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040454             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
040454             0251*   ;                HLU = HLU << LSB(A)
040454             0252*   ; Returns: HLU = HLU << LSB(A)
040454             0253*   ; Destroys: af
040454             0254*   ;------------------------------------------------------------------------
040454             0255*   shl_hlu_log2a:
040454 B7          0256*   	or a    ; check for zero
040455 C8          0257*   	ret z   ; nothing to shift so we're done
040456 C5          0258*   	push 	bc ; preserve
040457 06 00       0259*   	ld		b,0 ; clear b
040459             0260*   @find_bit:
040459 0F          0261*   	rrca ; bit 0 to carry
04045A DA 63 04 04 0262*   	jp c,@found_bit
04045E 04          0263*   	inc b ; next bit
04045F C3 59 04 04 0264*   	jp @find_bit
040463             0265*   @found_bit:
040463 78          0266*   	ld a,b
040464 CD 15 04 04 0267*   	call shl_hlu
040468 C1          0268*   	pop 	bc ; restore
040469 C9          0269*   	ret
04046A             0270*   ; end shl_hlu_log2a
04046A             0034        include "maths.inc"
04046A             0001*   ;------------------------------------------------------------------------
04046A             0002*   ; Scratch area for calculations
04046A             0003*   ;------------------------------------------------------------------------
04046A 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
04046D 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
040470             0006*   
040470             0007*   ; absolute value of hlu
040470             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040470             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
040470             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
040470             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
040470             0012*   ; destroys: a
040470             0013*   hlu_abs:
040470 19          0014*       add hl,de
040471 B7          0015*       or a
040472 ED 52       0016*       sbc hl,de
040474 FA 79 04 04 0017*       jp m,@is_neg
040478 C9          0018*       ret ; hlu is positive or zero so we're done
040479             0019*   @is_neg:
040479 F5          0020*       push af ; otherwise, save current flags for return
04047A CD 80 04 04 0021*       call neg_hlu ; negate hlu
04047E F1          0022*       pop af ; get back flags
04047F C9          0023*       ret
040480             0024*   
040480             0025*   ; flip the sign of hlu
040480             0026*   ; inputs: hlu
040480             0027*   ; returns: 0-hlu, flags set appropriately for the result:
040480             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
040480             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
040480             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
040480             0031*   ; destroys a
040480             0032*   neg_hlu:
040480 D5          0033*       push de ; save de
040481 EB          0034*       ex de,hl ; put hl into de
040482 21 00 00 00 0035*       ld hl,0 ; clear hl
040486 AF          0036*       xor a ; clear carry
040487 ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
040489 D1          0038*       pop de ; get de back
04048A C9          0039*       ret ; easy peasy
04048B             0040*   
04048B             0041*   ;------------------------------------------------------------------------
04048B             0042*   ; divide hlu by 2, inspired by above
04048B             0043*   ;------------------------------------------------------------------------
04048B             0044*   hlu_div2:
04048B 22 6A 04 04 0045*       ld (scratch1),hl
04048F 21 6C 04 04 0046*       ld hl,scratch1+2
040493 CB 1E       0047*       rr (hl)
040495 2B          0048*       dec hl
040496 CB 1E       0049*       rr (hl)
040498 2B          0050*       dec hl
040499 CB 1E       0051*       rr (hl)
04049B 23          0052*       inc hl
04049C 23          0053*       inc hl
04049D 2A 6A 04 04 0054*       ld hl,(scratch1)
0404A1 C9          0055*       ret
0404A2             0056*   
0404A2             0057*   ; this is my little hack to divide by 16
0404A2             0058*   hlu_div16:
0404A2 AF          0059*       xor a
0404A3 29          0060*       add hl,hl
0404A4 17          0061*       rla
0404A5 29          0062*       add hl,hl
0404A6 17          0063*       rla
0404A7 29          0064*       add hl,hl
0404A8 17          0065*       rla
0404A9 29          0066*       add hl,hl
0404AA 17          0067*       rla
0404AB 22 B8 04 04 0068*       ld (@scratch),hl
0404AF 32 BB 04 04 0069*       ld (@scratch+3),a
0404B3 2A B9 04 04 0070*       ld hl,(@scratch+1)
0404B7 C9          0071*       ret
0404B8             0072*   @scratch: ds 4
0404BC             0073*   
0404BC             0074*   ; hlu signed division by 256
0404BC             0075*   ; returns: hlu / 256
0404BC             0076*   ; destroys: af
0404BC             0077*   hlu_sdiv256:
       FF FF FF FF 
0404BC AF          0078*       xor a ; assume hl is positive
0404BD 22 D3 04 04 0079*       ld (@buffer),hl
0404C1             0080*       SIGN_HLU
0404C1 19          0001*M1     add hl,de ; 1 cycle
0404C2 B7          0002*M1     or a ; clear flags ; 1 cycle
0404C3 ED 52       0003*M1     sbc hl,de ; 2 cycles
0404C5             0004*M1     ; 4 cycles total
0404C5 F2 CA 04 04 0081*       jp p,@hl_pos
0404C9 3D          0082*       dec a
0404CA             0083*   @hl_pos:
0404CA 32 D6 04 04 0084*       ld (@buffer+3),a
0404CE 2A D4 04 04 0085*       ld hl,(@buffer+1)
0404D2 C9          0086*       ret
0404D3             0087*   @buffer: ds 4
0404D7             0088*   
0404D7             0089*   ; hlu 1 byte right shift, unsigned
0404D7             0090*   ; returns: hlu / 256, fractional portion in a
0404D7             0091*   ; destroys: af
0404D7             0092*   hlu_udiv256:
       FF FF FF FF 
0404D7 AF          0093*       xor a
0404D8 32 E9 04 04 0094*       ld (@buffer+3),a
0404DC 7D          0095*       ld a,l ; save the fractional portion
0404DD 22 E6 04 04 0096*       ld (@buffer),hl
0404E1 2A E7 04 04 0097*       ld hl,(@buffer+1)
0404E5 C9          0098*       ret
0404E6             0099*   @buffer: ds 4
0404EA             0100*   
       FF FF FF FF 
0404EA 00 00 00 00 0101*   add_bcd_arg1: db #00,#00,#00,#00
0404EE 00 00 00 00 0102*   add_bcd_arg2: db #00,#00,#00,#00
0404F2             0103*   
0404F2             0104*   ; set bcd values in a scratch memory address from registers bcde
0404F2             0105*   ; input: hl; scratch address,bcde; 8-place bcd number
0404F2             0106*   ; destroys ; hl
0404F2             0107*   set_bcd:
0404F2 73          0108*       ld (hl),e
0404F3 23          0109*       inc hl
0404F4 72          0110*       ld (hl),d
0404F5 23          0111*       inc hl
0404F6 71          0112*       ld (hl),c
0404F7 23          0113*       inc hl
0404F8 70          0114*       ld (hl),b
0404F9 C9          0115*       ret
0404FA             0116*   
0404FA             0117*   ; load bcd values from a scratch memory address to bcde
0404FA             0118*   ; input: hl; scratch address
0404FA             0119*   ; output: bcde; 8-place bcd number
0404FA             0120*   ; destroys: hl
0404FA             0121*   get_bcd:
0404FA 5E          0122*       ld e,(hl)
0404FB 23          0123*       inc hl
0404FC 56          0124*       ld d,(hl)
0404FD 23          0125*       inc hl
0404FE 4E          0126*       ld c,(hl)
0404FF 23          0127*       inc hl
040500 46          0128*       ld b,(hl)
040501 C9          0129*       ret
040502             0130*   
040502             0131*   ; BCD addition
040502             0132*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040502             0133*   ;       a is the number of bytes holding each number (number of places/2)
040502             0134*   ; outputs: (hl) + (de) --> (hl)
040502             0135*   ; destroys: a,b,de,hl
040502             0136*   add_bcd:
040502 47          0137*       ld b,a ; loop counter
040503 AF          0138*       xor a ; reset a, clear carry flag
040504             0139*   adcec:
040504 1A          0140*       ld a,(de) ; addend to acc
040505 8E          0141*       adc a,(hl) ; add (hl) to acc
040506 27          0142*       daa ; adjust result to bcd
040507 77          0143*       ld (hl),a ; store result
040508 23          0144*       inc hl ; advance memory pointers
040509 13          0145*       inc de
04050A 10 F8       0146*       djnz adcec ; loop until b == 0
04050C C9          0147*       ret
04050D             0148*   
04050D             0149*   ; BCD subtraction
04050D             0150*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04050D             0151*   ;       a is the number of bytes holding each number (number of places/2)
04050D             0152*   ; outputs: (hl) - (de) --> (hl)
04050D             0153*   ; destroys: a,b,de,hl
04050D             0154*   sub_bcd:
04050D 47          0155*       ld b,a ; loop counter
04050E AF          0156*       xor a ; reset a,clear carry flag
04050F             0157*   subdec:
04050F 1A          0158*       ld a,(de) ; subtrahend to acc
040510 9E          0159*       sbc a,(hl) ; subtract (hl) from acc
040511 27          0160*       daa ; adjust result to bcd
040512 77          0161*       ld (hl),a ; store result
040513 23          0162*       inc hl ; advance memory pointers
040514 13          0163*       inc de
040515 10 F8       0164*       djnz subdec ; loop until b == 0
040517 C9          0165*       ret
040518             0166*   
040518             0167*   ; http://www.z80.info/pseudo-random.txt
040518             0168*   rand_8:
040518 C5          0169*       push bc
040519 3A 2C 05 04 0170*       ld a,(r_seed)
04051D 4F          0171*       ld c,a
04051E             0172*   
04051E 0F          0173*       rrca ; multiply by 32
04051F 0F          0174*       rrca
040520 0F          0175*       rrca
040521 EE 1F       0176*       xor 0x1f
040523             0177*   
040523 81          0178*       add a,c
040524 DE FF       0179*       sbc a,255 ; carry
040526             0180*   
040526 32 2C 05 04 0181*       ld (r_seed),a
04052A C1          0182*       pop bc
04052B C9          0183*       ret
04052C 50          0184*   r_seed: defb $50
04052D             0185*   
04052D             0186*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04052D             0187*   prng24:
04052D             0188*   ;;Expects ADL mode.
04052D             0189*   ;;Output: HL
04052D             0190*   ;;50cc
04052D             0191*   ;;33 bytes
04052D             0192*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04052D ED 5B 4E 05 0193*       ld de,(seed1)
       04          
040532 B7          0194*       or a
040533 ED 62       0195*       sbc hl,hl
040535 19          0196*       add hl,de
040536 29          0197*       add hl,hl
040537 29          0198*       add hl,hl
040538 2C          0199*       inc l
040539 19          0200*       add hl,de
04053A 22 4E 05 04 0201*       ld (seed1),hl
04053E 2A 51 05 04 0202*       ld hl,(seed2)
040542 29          0203*       add hl,hl
040543 9F          0204*       sbc a,a
040544 E6 1B       0205*       and %00011011
040546 AD          0206*       xor l
040547 6F          0207*       ld l,a
040548 22 51 05 04 0208*       ld (seed2),hl
04054C 19          0209*       add hl,de
04054D C9          0210*       ret
04054E 00 00 00    0211*   seed1: dl 0
040551 00 00 00    0212*   seed2: dl 0
040554             0035        include "files.inc"
040554             0001*   ; load to onboard 8k sram
040554             0002*   filedata: equ 0xB7E000; Directory object structure (DIR)
040554             0036        include "fixed168.inc"
040554             0001*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040554             0002*   ; uses EZ80 MLT instruction for speed
040554             0003*   ; operation: UHL * A --> UHL
040554             0004*   ; destroys: AF, HL
040554             0005*   smul24x8:
040554             0006*   ; make hl positive and store sign flag
040554 CD 70 04 04 0007*       call hlu_abs
040558 F5          0008*       push af
040559             0009*   ; do the division
040559 CD 64 05 04 0010*       call mul24x8 ; hl = product
04055D             0011*   ; adjust sign of result
04055D F1          0012*       pop af ; sign de
04055E F0          0013*       ret p ; hl was positive, nothing to do
04055F CD 80 04 04 0014*       call neg_hlu ; result is negative
040563 C9          0015*       ret
040564             0016*   
040564             0017*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040564             0018*   ; uses EZ80 MLT instruction for speed
040564             0019*   ; operation: UHL * A --> AUHL
040564             0020*   ; destroys: AF, HL
040564             0021*   mul24x8:
040564 D5          0022*       push de ; preserve de
040565             0023*   ; low byte
040565 5D          0024*       ld e,l
040566 57          0025*       ld d,a
040567 ED 5C       0026*       mlt de
040569 6B          0027*       ld l,e ; product low byte
04056A 08          0028*       ex af,af' ; save multiplier
04056B 7A          0029*       ld a,d ; carry
04056C 08          0030*       ex af,af' ; save carry, restore multiplier
04056D             0031*   ; high byte
04056D 5C          0032*       ld e,h
04056E 57          0033*       ld d,a
04056F ED 5C       0034*       mlt de
040571 08          0035*       ex af,af' ; save multiplier, restore carry
040572 83          0036*       add a,e ; add carry
040573 67          0037*       ld h,a ; product middle byte
040574 7A          0038*       ld a,d ; carry
040575 08          0039*       ex af,af' ; save carry, restore multiplier
040576             0040*   ; upper byte
040576 22 91 05 04 0041*       ld (@scratch),hl ; 7 cycles
04057A 5F          0042*       ld e,a
04057B 3A 93 05 04 0043*       ld a,(@scratch+2)
04057F 57          0044*       ld d,a
040580 ED 5C       0045*       mlt de
040582 08          0046*       ex af,af' ; restore carry
040583 8B          0047*       adc a,e ; add carry
040584 32 93 05 04 0048*       ld (@scratch+2),a ; 5 cycles
040588 2A 91 05 04 0049*       ld hl,(@scratch) ; 7 cycles
04058C             0050*   ; highest byte
04058C 3E 00       0051*       ld a,0 ; preserve carry flag
04058E 8A          0052*       adc a,d ; product highest byte
04058F D1          0053*       pop de ; restore de
040590 C9          0054*       ret
040591             0055*   @scratch: ds 3
040594             0056*   
       FF FF FF 
040594 00 00 00 00 0057*   mul24out: blkb 6,0
       00 00       
04059A             0058*   
04059A             0059*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
04059A             0060*   ; operation: UHL * UDE --> mul24out
04059A             0061*   mul24:
04059A DD E5       0062*       push ix ; preserve
04059C             0063*   ; point to output buffer and clear it
04059C DD 21 94 05 0064*       ld ix,mul24out
       04          
0405A1 C5          0065*       push bc
0405A2 01 00 00 00 0066*       ld bc,0
0405A6 DD 0F 00    0067*       ld (ix),bc
0405A9 DD 0F 03    0068*       ld (ix+3),bc
0405AC C1          0069*       pop bc
0405AD             0070*   ; STEP 1: UHL * E
0405AD 7B          0071*       ld a,e
0405AE E5          0072*       push hl
0405AF CD 64 05 04 0073*       call mul24x8
0405B3 DD 2F 00    0074*       ld (ix+0),hl
0405B6 DD 77 03    0075*       ld (ix+3),a
0405B9             0076*   ; STEP 2: UHL * D
0405B9 E1          0077*       pop hl
0405BA E5          0078*       push hl
0405BB 7A          0079*       ld a,d
0405BC CD 64 05 04 0080*       call mul24x8
0405C0 CD D9 05 04 0081*       call @accumulate
0405C4             0082*   ; STEP 3: UHL * DEU
0405C4 E1          0083*       pop hl
0405C5 ED 53 09 06 0084*       ld (@de),de
       04          
0405CA 3A 0B 06 04 0085*       ld a,(@de+2)
0405CE CD 64 05 04 0086*       call mul24x8
0405D2 CD D9 05 04 0087*       call @accumulate
0405D6             0088*   ; all done
0405D6 DD E1       0089*       pop ix ; restore
0405D8 C9          0090*       ret
0405D9             0091*   @accumulate:
0405D9 DD 23       0092*       inc ix
0405DB             0093*   ; highest byte of product to carry
0405DB DD 77 03    0094*       ld (ix+3),a
0405DE             0095*   ; low byte of product
0405DE 7D          0096*       ld a,l
0405DF DD 86 00    0097*       add a,(ix+0)
0405E2 DD 77 00    0098*       ld (ix+0),a
0405E5             0099*   ; high byte of product
0405E5 7C          0100*       ld a,h
0405E6 DD 8E 01    0101*       adc a,(ix+1)
0405E9 DD 77 01    0102*       ld (ix+1),a
0405EC             0103*   ; uppper byte of product
0405EC 22 06 06 04 0104*       ld (@hl),hl
0405F0 3A 08 06 04 0105*       ld a,(@hl+2)
0405F4 DD 8E 02    0106*       adc a,(ix+2)
0405F7 DD 77 02    0107*       ld (ix+2),a
0405FA             0108*   ; carry
0405FA 3E 00       0109*       ld a,0 ; preserve flags
0405FC DD 8E 03    0110*       adc a,(ix+3)
0405FF DD 77 03    0111*       ld (ix+3),a
040602 C9          0112*       ret
040603             0113*   
040603 00 00 00    0114*   @ix: dl 0
040606 00 00 00    0115*   @hl: dl 0
040609 00 00 00    0116*   @de: dl 0
04060C             0117*   
04060C             0118*   ; ; UHL * UDE --> UHL (unsigned)
04060C             0119*   ; umul24:
04060C             0120*   ;     call mul24
04060C             0121*   ;     ld hl,(mul24out)
04060C             0122*   ;     ret
04060C             0123*   
04060C             0124*   ; UH.L = UH.L*UD.E (unsigned)
04060C             0125*   umul168:
04060C CD 9A 05 04 0126*       call mul24
040610 2A 95 05 04 0127*       ld hl,(mul24out+1)
040614 C9          0128*       ret
040615             0129*   
040615             0130*   ; UH.L * UD.E --> UH.L (signed)
040615             0131*   smul168:
040615             0132*   ; make everything positive and store sign flags
040615 CD 70 04 04 0133*       call hlu_abs
040619 F5          0134*       push af
04061A EB          0135*       ex de,hl
04061B CD 70 04 04 0136*       call hlu_abs
04061F EB          0137*       ex de,hl
040620 F5          0138*       push af
040621             0139*   ; do the division
040621 CD 0C 06 04 0140*       call umul168 ; hl = product
040625             0141*   ; adjust sign of result
040625 F1          0142*       pop af ; sign de
040626 FA 31 06 04 0143*       jp m,@de_neg
04062A F1          0144*       pop af ; sign hl
04062B F0          0145*       ret p ; both positive, nothing to do
04062C             0146*   @hl_neg:
04062C CD 80 04 04 0147*       call neg_hlu ; de pos, hl neg, result is negative
040630 C9          0148*       ret
040631             0149*   @de_neg:
040631 F1          0150*       pop af
040632 F8          0151*       ret m ; both negative, nothing to do
040633 CD 80 04 04 0152*       call neg_hlu ; result is negative
040637 C9          0153*       ret
040638             0154*   
040638             0155*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040638             0156*   ; perform unsigned division of 16.8 fixed place values
040638             0157*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
040638             0158*   udiv168:
040638             0159*   ; back up divisor
040638 ED 53 6F 06 0160*       ld (@ude),de
       04          
04063D             0161*   ; get the 16-bit integer part of the quotient
04063D CD 80 03 04 0162*       call udiv24 ; de = quotient, hl = remainder
040641             0163*   ; load quotient to upper three bytes of output
040641 ED 53 76 06 0164*       ld (div168_out+1),de
       04          
040646             0165*   @div256:
040646             0166*   ; multiply remainder by 256
040646             0167*       hlu_mul256
040646 29          0001*M1     add hl,hl ; * 2
040647 29          0002*M1     add hl,hl ; * 4
040648 29          0003*M1     add hl,hl ; * 8
040649 29          0004*M1     add hl,hl ; * 16
04064A 29          0005*M1     add hl,hl ; * 32
04064B 29          0006*M1     add hl,hl ; * 64
04064C 29          0007*M1     add hl,hl ; * 128
04064D 29          0008*M1     add hl,hl ; * 256
04064E             0168*   ; skip fractional computation if remainder is zero
04064E             0169*       SIGN_HLU
04064E 19          0001*M1     add hl,de ; 1 cycle
04064F B7          0002*M1     or a ; clear flags ; 1 cycle
040650 ED 52       0003*M1     sbc hl,de ; 2 cycles
040652             0004*M1     ; 4 cycles total
040652 20 03       0170*       jr nz,@div_frac
040654 AF          0171*       xor a
040655 18 0A       0172*       jr @write_frac
040657             0173*   ; now divide the shifted remainder by the divisor
040657             0174*   @div_frac:
040657 ED 5B 6F 06 0175*       ld de,(@ude) ; get back divisor
       04          
04065C CD 80 03 04 0176*       call udiv24 ; de = quotient, hl = remainder
040660             0177*   ; load low byte of quotient to low byte of output
040660 7B          0178*       ld a,e
040661             0179*   @write_frac:
040661 32 75 06 04 0180*       ld (div168_out),a
040665             0181*   ; load de with return value
040665 ED 5B 75 06 0182*       ld de,(div168_out)
       04          
04066A             0183*   ; load a with any overflow
04066A 3A 78 06 04 0184*       ld a,(div168_out+3)
04066E C9          0185*       ret ; ud.e is the 16.8 result
04066F             0186*   @ude: ds 6
040675             0187*   div168_out: ds 4 ; the extra byte is for overflow
040679             0188*   
040679             0189*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040679             0190*   ; perform signed division of 16.8 fixed place values
040679             0191*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040679             0192*   sdiv168:
040679             0193*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
040679 CD 70 04 04 0194*       call hlu_abs
04067D F5          0195*       push af
04067E EB          0196*       ex de,hl
04067F CD 70 04 04 0197*       call hlu_abs
040683 EB          0198*       ex de,hl
040684 F5          0199*       push af
040685             0200*   ; do the division
040685 CD 38 06 04 0201*       call udiv168 ; de = quotient, hl = remainder
040689             0202*   ; adjust sign of result
040689 F1          0203*       pop af ; sign de
04068A FA 97 06 04 0204*       jp m,@de_neg
04068E F1          0205*       pop af ; sign hl
04068F F0          0206*       ret p ; both positive, nothing to do
040690             0207*   @hl_neg:
040690 EB          0208*       ex de,hl ; hl = quotient, de = remainder
040691 CD 80 04 04 0209*       call neg_hlu ; de pos, hl neg, result is negative
040695 EB          0210*       ex de,hl ; de = negated quotient, hl = remainder
040696 C9          0211*       ret
040697             0212*   @de_neg:
040697 F1          0213*       pop af
040698 F8          0214*       ret m ; both negative, nothing to do
040699 EB          0215*       ex de,hl ; hl = quotient, de = remainder
04069A CD 80 04 04 0216*       call neg_hlu ; result is negative
04069E EB          0217*       ex de,hl ; de = negated quotient, hl = remainder
04069F C9          0218*       ret
0406A0             0219*   
0406A0             0220*   ; convert signed angles from a 360 to 256 degree circle
0406A0             0221*   ; inputs: uh.l is the angle360 in 16.8 fixed format
0406A0             0222*   ; outputs: uh.l is the angle256 in 16.8 fixed format
0406A0             0223*   ; destroys: TODO
0406A0             0224*   deg_360_to_256:
0406A0 D5          0225*       push de ; preserve de
0406A1             0226*   ; make angle positive and store sign flag
0406A1 CD 70 04 04 0227*       call hlu_abs
0406A5 F5          0228*       push af
0406A6             0229*   ; multiply by coversion factor of 256/360
0406A6 11 B6 00 00 0230*       ld de,0x0000B6 ; 0.711
0406AA CD 0C 06 04 0231*       call umul168 ; uh.l = uh.l * 0.711
0406AE             0232*   ; restore sign flag and adjust output accordingly
0406AE F1          0233*       pop af
0406AF F2 B7 06 04 0234*       jp p,@pos ; positive number
0406B3 CD 80 04 04 0235*       call neg_hlu
0406B7             0236*   @pos:
0406B7             0237*   ; restore de and return uh.l as the result
0406B7 D1          0238*       pop de
0406B8 C9          0239*       ret
0406B9             0240*   
0406B9             0241*   ; convert signed angles from a 256 to 360 degree circle
0406B9             0242*   ; inputs: uh.l is the angle256 in 16.8 fixed format
0406B9             0243*   ; outputs: uh.l is the angle360 in 16.8 fixed format
0406B9             0244*   ; destroys: TODO
0406B9             0245*   deg_256_to_360:
0406B9 D5          0246*       push de ; preserve de
0406BA             0247*   ; make angle positive and store sign flag
0406BA CD 70 04 04 0248*       call hlu_abs
0406BE F5          0249*       push af
0406BF             0250*   ; multiply by coversion factor of 360/256
0406BF 11 68 01 00 0251*       ld de,0x000168 ; 1.406
0406C3 CD 0C 06 04 0252*       call umul168 ; uh.l = uh.l * 1.406
0406C7             0253*   ; restore sign flag and adjust output accordingly
0406C7 F1          0254*       pop af
0406C8 F2 D0 06 04 0255*       jp p,@pos ; positive number
0406CC CD 80 04 04 0256*       call neg_hlu
0406D0             0257*   @pos:
0406D0             0258*   ; restore de and return uh.l as the result
0406D0 D1          0259*       pop de
0406D1 C9          0260*       ret
0406D2             0261*   
0406D2             0262*   ; fixed 16.8 routine
0406D2             0263*   ; cos(uh.l) --> uh.l
0406D2             0264*   ; destroys: f, hl
0406D2             0265*   cos168:
0406D2 D5          0266*       push de ; preserve de
0406D3             0267*   ; for cos we simply increment the angle by 90 degrees
0406D3             0268*   ; or 0x004000 in 16.8 degrees256
0406D3             0269*   ; which makes it a sin problem
0406D3 11 00 40 00 0270*       ld de,0x004000
0406D7 19          0271*       add hl,de ; modulo 256 happens below
0406D8 D1          0272*       pop de ; restore de
0406D9             0273*   ; fall through to sin168
0406D9             0274*   
0406D9             0275*   ; ---------------------
0406D9             0276*   ; fixed 16.8 routine
0406D9             0277*   ; sin(uh.l) --> uh.l
0406D9             0278*   ; destroys: f, hl
0406D9             0279*   sin168:
0406D9 D5          0280*       push de
0406DA             0281*   ; handle negative angles appropriately
0406DA CD 70 04 04 0282*       call hlu_abs
0406DE F2 E7 06 04 0283*       jp p,@F
0406E2 11 00 00 FF 0284*       ld de,-256*256
0406E6 19          0285*       add hl,de
0406E7             0286*   @@:
0406E7 2E 03       0287*       ld l,3 ; multiply by 3 to get our lookup index
0406E9 ED 6C       0288*       mlt hl
0406EB 11 9F 09 04 0289*       ld de,sin_lut_168 ; grab the lut address
0406EF 19          0290*       add hl,de ; bump hl by the index
0406F0 ED 27       0291*       ld hl,(hl) ; don't try this on a z80!
0406F2 D1          0292*       pop de
0406F3 C9          0293*       ret
0406F4             0294*   
0406F4             0295*   ; 16.8 fixed inputs / outputs
0406F4             0296*   ; takes: uh.l as angle in degrees 256
0406F4             0297*   ;        ud.e as radius
0406F4             0298*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
0406F4             0299*   ;        displacements from origin (0,0)
0406F4             0300*   ; destroys: everything except indexes
0406F4             0301*   polar_to_cartesian:
0406F4             0302*   ; back up input parameters
0406F4 22 23 07 04 0303*       ld (@angle), hl
0406F8 ED 53 26 07 0304*       ld (@radius), de
       04          
0406FD             0305*   ; compute dx = sin(uh.l) * ud.e
0406FD CD D9 06 04 0306*       call sin168 ; uh.l = sin(uh.l)
040701 ED 5B 26 07 0307*       ld de,(@radius)
       04          
040706 CD 15 06 04 0308*       call smul168 ; uh.l = dx
04070A E5          0309*       push hl
04070B             0310*   ; compute dy = -cos(uh.l) * ud.e
04070B 2A 23 07 04 0311*       ld hl,(@angle)
04070F CD D2 06 04 0312*       call cos168 ; uh.l = cos(uh.l)
040713 ED 5B 26 07 0313*       ld de,(@radius)
       04          
040718 CD 15 06 04 0314*       call smul168 ; uh.l = dy
04071C CD 80 04 04 0315*       call neg_hlu ; invert dy for screen coords convention
040720 EB          0316*       ex de,hl ; de = dy for output
040721 C1          0317*       pop bc ; bc = dx for output
040722             0318*   ; and out
040722 C9          0319*       ret
040723             0320*   @angle: ds 3
040726             0321*   @radius: ds 3
040729             0322*   
040729             0323*   ; 16.8 fixed inputs / outputs
040729             0324*   ; inputs: ub.c as dx, ud.e as dy
040729             0325*   ;        displacements from origin (0,0)
040729             0326*   ; returns: uh.l as angle in degrees 256
040729             0327*   ;        ud.e as radius
040729             0328*   ; destroys: everything except indexes
040729             0329*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
040729 ED 43 82 07 0330*       ld (dx168),bc ; dx argument for distance168
       04          
04072E ED 53 88 07 0331*       ld (dy168),de ; dy argument for distance168
       04          
040733             0332*   ; compute radius
040733 CD 8E 07 04 0333*       call distance168 ; uh.l = radius
040737 E5          0334*       push hl ; save radius
040738             0335*   ; compute angle
040738 ED 4B 82 07 0336*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
04073D ED 5B 88 07 0337*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040742 CD EE 07 04 0338*       call atan2_168fast ; uh.l = angle
040746             0339*   ; return result
040746 D1          0340*       pop de ; de = radius (was hl)
040747 C9          0341*       ret
040748             0342*   ; end cartesian_to_polar
040748             0343*   
040748             0344*   ; 16.8 fixed inputs / outputs
040748             0345*   ; inputs: ub.c as dx, ud.e as dy
040748             0346*   ;        displacements from origin (0,0)
040748             0347*   ; returns: uh.l as angle in degrees 256
040748             0348*   ;        ud.e as radius
040748             0349*   ; destroys: everything except indexes
040748             0350*   ; note: uses distance168sm which is more accurate for small deltas
040748             0351*   cartesian_to_polar_sm:
040748 ED 43 82 07 0352*       ld (dx168),bc ; dx argument for distance168
       04          
04074D ED 53 88 07 0353*       ld (dy168),de ; dy argument for distance168
       04          
040752             0354*   ; compute radius
040752 CD C9 07 04 0355*       call distance168sm ; uh.l = radius
040756 E5          0356*       push hl ; save radius
040757             0357*   ; compute angle
040757 ED 4B 82 07 0358*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
04075C ED 5B 88 07 0359*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040761 CD EE 07 04 0360*       call atan2_168fast ; uh.l = angle
040765             0361*   ; return result
040765 D1          0362*       pop de ; de = radius (was hl)
040766 C9          0363*       ret
040767             0364*   ; end cartesian_to_polar
040767             0365*   
040767             0366*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040767             0367*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040767             0368*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040767             0369*   ;         also populates scratch locations dx168 and dy168
040767             0370*   ; destroys: a,hl,bc,de
040767             0371*   dxy168:
040767             0372*   ; compute dx = x1-x0
040767 AF          0373*       xor a ; clear carry
040768 DD E5       0374*       push ix ; move ix to hl via the stack
04076A E1          0375*       pop hl ; hl = x1
04076B ED 42       0376*       sbc hl,bc ; hl = dx
04076D 22 82 07 04 0377*       ld (dx168),hl ; dx to scratch
040771             0378*   ; compute dy = y1-y0
040771 AF          0379*       xor a ; clear carry
040772 FD E5       0380*       push iy ; move iy to hl via the stack
040774 E1          0381*       pop hl ; hl = y1
040775 ED 52       0382*       sbc hl,de ; hl = dy
040777 22 88 07 04 0383*       ld (dy168),hl ; dy to scratch
04077B             0384*   ; populate output registers and return
04077B EB          0385*       ex de,hl ; ud.e = dy
04077C ED 4B 82 07 0386*       ld bc,(dx168) ; ub.c = dx
       04          
040781 C9          0387*       ret
040782 00 00 00 00 0388*   dx168: blkb 6,0
       00 00       
040788 00 00 00 00 0389*   dy168: blkb 6,0
       00 00       
04078E             0390*   
04078E             0391*   ; compute the euclidian distance between two cartesian coordinates
04078E             0392*   ; using the formula d = sqrt(dx^2+dy^2)
04078E             0393*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
04078E             0394*   ; output; uh.l is the 16.8 fixed format distance
04078E             0395*   ;         also populates scratch locations dx168 and dy168
04078E             0396*   ; destroys: a,hl,bc,de
04078E             0397*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
04078E             0398*   ;       thus the result will always be an integer, albeit in 16.8 format
04078E             0399*   distance168:
04078E             0400*   ; compute dy^2
04078E 2A 88 07 04 0401*       ld hl,(dy168)
040792 CD 70 04 04 0402*       call hlu_abs
040796             0403*       ; call hlu_udiv256 ; make integer to avoid overflow
040796             0404*       SRL_UHL ; make integer to avoid overflow
040796 3B          0001*M1     dec sp ; 1 cycle
040797 E5          0002*M1     push hl ; 4 cycles
040798 33          0003*M1     inc sp ; 1 cycle
040799 E1          0004*M1     pop hl ; 4 cycles
04079A 23          0005*M1     inc hl ; 1 cycle
04079B 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04079D             0007*M1     ; 13 cycles total
04079D E5          0405*       push hl
04079E D1          0406*       pop de
04079F CD 67 03 04 0407*       call umul24 ; hl = dy^2
0407A3 E5          0408*       push hl ; save dy^2
0407A4             0409*   ; compute dx^2
0407A4 2A 82 07 04 0410*       ld hl,(dx168)
0407A8 CD 70 04 04 0411*       call hlu_abs
0407AC             0412*       ; call hlu_udiv256 ; make integer to avoid overflow
0407AC             0413*       SRL_UHL ; make integer to avoid overflow
0407AC 3B          0001*M1     dec sp ; 1 cycle
0407AD E5          0002*M1     push hl ; 4 cycles
0407AE 33          0003*M1     inc sp ; 1 cycle
0407AF E1          0004*M1     pop hl ; 4 cycles
0407B0 23          0005*M1     inc hl ; 1 cycle
0407B1 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
0407B3             0007*M1     ; 13 cycles total
0407B3 E5          0414*       push hl
0407B4 D1          0415*       pop de
0407B5 CD 67 03 04 0416*       call umul24 ; hl = dx^2
0407B9             0417*   ; add dx^2 and dy^2
0407B9 D1          0418*       pop de ; de = dy^2 (was hl)
0407BA 19          0419*       add hl,de ; hl = dx^2 + dy^2
0407BB             0420*   ; compute the square root
0407BB CD B9 08 04 0421*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
0407BF EB          0422*       ex de,hl ; hl = distance
0407C0             0423*       hlu_mul256 ; convert back to 16.8 fixed
0407C0 29          0001*M1     add hl,hl ; * 2
0407C1 29          0002*M1     add hl,hl ; * 4
0407C2 29          0003*M1     add hl,hl ; * 8
0407C3 29          0004*M1     add hl,hl ; * 16
0407C4 29          0005*M1     add hl,hl ; * 32
0407C5 29          0006*M1     add hl,hl ; * 64
0407C6 29          0007*M1     add hl,hl ; * 128
0407C7 29          0008*M1     add hl,hl ; * 256
0407C8 C9          0424*       ret
0407C9             0425*   
0407C9             0426*   ; compute the euclidian distance between two cartesian coordinates
0407C9             0427*   ; using the formula d = sqrt(dx^2+dy^2)
0407C9             0428*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
0407C9             0429*   ; output; uh.l is the 16.8 fixed format distance
0407C9             0430*   ;         also populates scratch locations dx168 and dy168
0407C9             0431*   ; destroys: a,hl,bc,de
0407C9             0432*   ; NOTE: sm means 'small' because it doesn't round down the deltas
0407C9             0433*   ;       making it more accurate for small deltas,
0407C9             0434*   ;       but will overflow if used for screen-sized deltas
0407C9             0435*   distance168sm:
0407C9             0436*   ; compute dy^2
0407C9 2A 88 07 04 0437*       ld hl,(dy168)
0407CD CD 70 04 04 0438*       call hlu_abs
0407D1 E5          0439*       push hl
0407D2 D1          0440*       pop de
0407D3 CD 67 03 04 0441*       call umul24 ; hl = dy^2
0407D7 E5          0442*       push hl ; save dy^2
0407D8             0443*   ; compute dx^2
0407D8 2A 82 07 04 0444*       ld hl,(dx168)
0407DC CD 70 04 04 0445*       call hlu_abs
0407E0 E5          0446*       push hl
0407E1 D1          0447*       pop de
0407E2 CD 67 03 04 0448*       call umul24 ; hl = dx^2
0407E6             0449*   ; add dx^2 and dy^2
0407E6 D1          0450*       pop de ; de = dy^2 (was hl)
0407E7 19          0451*       add hl,de ; hl = dx^2 + dy^2
0407E8             0452*   ; compute the square root
0407E8 CD B9 08 04 0453*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
0407EC EB          0454*       ex de,hl ; hl = distance
0407ED C9          0455*       ret
0407EE             0456*   
0407EE             0457*   ; atan2_(ub.c,ud.e) --> uh.l
0407EE             0458*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0407EE             0459*   ;   whether inputs are integers or fractional doesn't matter
0407EE             0460*   ;   so long as the sign bit of the upper byte is correct
0407EE             0461*   ; output: uh.l is the 16.8 fixed angle in degrees 256
0407EE             0462*   ; angles are COMPASS HEADINGS based on
0407EE             0463*   ; screen coordinate conventions,where the y axis is flipped
0407EE             0464*   ; #E0 224      0       32 #20
0407EE             0465*   ;        -x,-y | +x,-y
0407EE             0466*   ; #C0 192------+------ 64 #40
0407EE             0467*   ;        -x,+y | +x,+y
0407EE             0468*   ; #A0 160   128 #80   96 #60
0407EE             0469*   atan2_168fast:
0407EE             0470*   ; get signs and make everything positive
0407EE             0471*   ; get abs(x) and store its original sign
0407EE C5          0472*       push bc
0407EF E1          0473*       pop hl
0407F0 CD 70 04 04 0474*       call hlu_abs ; if x was negative this also sets the sign flag
0407F4 E5          0475*       push hl ; store abs(x)
0407F5 C1          0476*       pop bc ; bc = abs(x)
0407F6 F5          0477*       push af ; store sign of x
0407F7             0478*   ; get abs(y) and store its original sign
0407F7 EB          0479*       ex de,hl ; hl = y
0407F8 CD 70 04 04 0480*       call hlu_abs ; if y was negative this also sets the sign flag
0407FC EB          0481*       ex de,hl ; de = abs(y)
0407FD F5          0482*       push af ; store sign of y
0407FE             0483*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0407FE             0484*   ; this ensures that our lookup value is between 0 and 1 inclusive
0407FE AF          0485*       xor a ; clear the carry flag
0407FF D5          0486*       push de
040800 E1          0487*       pop hl
040801 ED 42       0488*       sbc hl,bc
040803 F5          0489*       push af ; save sign of de - bc
040804 F2 0D 08 04 0490*       jp p,@1 ; bc <= de, so we skip ahead
040808             0491*   ; otherwise we swap bc and de
040808 C5          0492*       push bc
040809 E1          0493*       pop hl
04080A EB          0494*       ex de,hl
04080B E5          0495*       push hl
04080C C1          0496*       pop bc
04080D             0497*   @1:
04080D             0498*   ; now we're ready to snag our preliminary result
04080D C5          0499*       push bc
04080E E1          0500*       pop hl
04080F CD 7D 08 04 0501*       call atan_168fast ; uh.l comes back with prelim result
040813             0502*   ; now we adjust uh.l based on sign of de - bc
040813 F1          0503*       pop af
040814 F2 20 08 04 0504*       jp p,@2 ; bc <= de,so we skip ahead
040818 EB          0505*       ex de,hl
040819 21 00 40 00 0506*       ld hl,64*256 ; subtract from 64 (90) degrees
04081D AF          0507*       xor a ; clear the carry flag
04081E ED 52       0508*       sbc hl,de
040820             0509*   @2:
040820             0510*   ; adjust the result based on quadrant
040820             0511*   ; #E0 224      0       32 #20
040820             0512*   ;        -x,-y | +x,-y
040820             0513*   ; #C0 192------+------ 64 #40
040820             0514*   ;        -x,+y | +x,+y
040820             0515*   ; #A0 160   128 #80   96 #60
040820 F1          0516*       pop af ; sign of y
040821 CA 5E 08 04 0517*       jp z,@y_zero
040825 F2 3E 08 04 0518*       jp p,@y_pos
040829             0519*   ; y neg,check x
040829 F1          0520*       pop af ; sign of x
04082A CA 38 08 04 0521*       jp z,@y_neg_x_zero
04082E F2 3D 08 04 0522*       jp p,@y_neg_x_pos
040832             0523*   ; y neg,x neg
040832             0524*   ; angle is 128 to 256 (270 to 360)
040832             0525*   ; negating the intermediate does the trick
040832 CD 80 04 04 0526*       call neg_hlu
040836 18 31       0527*       jr @zero_hlu
040838             0528*   
040838             0529*   @y_neg_x_zero:
040838             0530*   ; y neg,x zero
040838             0531*   ; angle is 0
040838 21 00 00 00 0532*       ld hl,0
04083C C9          0533*       ret
04083D             0534*   @y_neg_x_pos:
04083D             0535*   ; y neg,x pos
04083D             0536*   ; angle is 0 to 64 (0 to 90)
04083D             0537*   ; so we're good
04083D C9          0538*       ret
04083E             0539*   
04083E             0540*   @y_pos:
04083E F1          0541*       pop af ; sign of x
04083F CA 4E 08 04 0542*       jp z,@y_pos_x_zero
040843 F2 53 08 04 0543*       jp p,@y_pos_x_pos
040847             0544*   ; y pos,x neg
040847             0545*   ; angle is 128 to 192 (180-270)
040847             0546*   ; so we add 128 to intermediate
040847 11 00 80 00 0547*       ld de,128*256
04084B 19          0548*       add hl,de
04084C 18 1B       0549*       jr @zero_hlu
04084E             0550*   @y_pos_x_zero:
04084E             0551*   ; y pos,x zero
04084E             0552*   ; angle is 128 (180)
04084E 21 00 80 00 0553*       ld hl,128*256
040852 C9          0554*       ret
040853             0555*   @y_pos_x_pos:
040853             0556*   ; y pos,x pos
040853             0557*   ; angle is 64 to 128 (90 to 180)
040853             0558*   ; neg the intermediate and add 180 degrees
040853 CD 80 04 04 0559*       call neg_hlu
040857 11 00 80 00 0560*       ld de,128*256
04085B 19          0561*       add hl,de
04085C 18 0B       0562*       jr @zero_hlu
04085E             0563*   
04085E             0564*   @y_zero:
04085E F1          0565*       pop af ; sign of x
04085F FA 64 08 04 0566*       jp m,@y_zero_x_neg
040863             0567*   ; y zero,x pos
040863             0568*   ; angle is 64 (90),nothing to do
040863 C9          0569*       ret
040864             0570*   @y_zero_x_neg:
040864             0571*   ; y zero ,x neg
040864             0572*   ; angle is 192 (270)
040864 21 00 C0 00 0573*       ld hl,192*256
040868 C9          0574*       ret
040869             0575*   @zero_hlu:
040869 AF          0576*       xor a
04086A 22 77 08 04 0577*       ld (@scratch),hl
04086E 32 79 08 04 0578*       ld (@scratch+2),a
040872 2A 77 08 04 0579*       ld hl,(@scratch)
040876 C9          0580*       ret
040877             0581*   @scratch: ds 6
04087D             0582*   
04087D             0583*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
04087D             0584*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
04087D             0585*   ; destroys: a,hl,bc,de
04087D             0586*   ; note: only works for angles from 0 to 32 (45) degrees
04087D             0587*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
04087D             0588*   atan_168fast:
04087D             0589*   ; because we use compass headings instead of geometric angles
04087D             0590*   ; we compute dx/dy which is 1/tan(theta) in the maths world
04087D             0591*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
04087D CD 38 06 04 0592*       call udiv168 ; ud.e = dx/dy
040881 EB          0593*       ex de,hl ; uh.l = dx/dy
040882             0594*   ; test uh.l for 0
040882 19          0595*       add hl,de
040883 B7          0596*       or a
040884 ED 52       0597*       sbc hl,de
040886 28 22       0598*       jr z,@is_zero
040888             0599*   ; test uh.l for 1
040888 AF          0600*       xor a ; clear carry
040889 EB          0601*       ex de,hl
04088A 21 00 01 00 0602*       ld hl,1*256 ; 1 in 16.8 fixed format
04088E ED 52       0603*       sbc hl,de
040890 28 13       0604*       jr z,@is_45
040892 EB          0605*       ex de,hl
040893             0606*   ; no special cases so we move on
040893             0607*   ; l contains the fractional portion of tan(uh.l)
040893             0608*   ; we multiply it by three to get our lookup table index
040893 26 03       0609*       ld h,3
040895 ED 6C       0610*       mlt hl ; index into lut
040897 11 00 00 00 0611*       ld de,0 ; clear deu
04089B 54          0612*       ld d,h ; copy hl to de
04089C 5D          0613*       ld e,l ; de contains our index
04089D 21 A2 0C 04 0614*       ld hl,atan_lut_168 ; grab the lut address
0408A1 19          0615*       add hl,de ; bump hl by the index
0408A2 ED 27       0616*       ld hl,(hl) ; don't try this on a z80!
0408A4 C9          0617*       ret ; and out
0408A5             0618*   @is_45:
0408A5 21 00 20 00 0619*       ld hl,32*256
0408A9 C9          0620*       ret
0408AA             0621*   ; for the case tan(0)
0408AA             0622*   @is_zero:
0408AA 21 00 00 00 0623*       ld hl,0*256
0408AE C9          0624*       ret
0408AF             0625*   
0408AF             0626*   ; Expects  ADL mode
0408AF             0627*   ; Inputs:  UH.L
0408AF             0628*   ; Outputs: UH.L is the 16.8 square root
0408AF             0629*   ;          UDE is the integer difference inputHL-DE^2
0408AF             0630*   sqrt168:
0408AF CD B9 08 04 0631*       call sqrt24
0408B3 EB          0632*       ex de,hl
0408B4 29          0633*       add hl,hl
0408B5 29          0634*       add hl,hl
0408B6 29          0635*       add hl,hl
0408B7 29          0636*       add hl,hl
0408B8 C9          0637*       ret
0408B9             0638*   
0408B9             0639*   ; credit: xeda112358
0408B9             0640*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
0408B9             0641*   sqrt24:
0408B9             0642*   ; Expects ADL mode
0408B9             0643*   ; Inputs: HL
0408B9             0644*   ; Outputs: DE is the integer square root
0408B9             0645*   ;  HL is the difference inputHL-DE^2
0408B9             0646*   ;  c flag reset
0408B9 01 00 00 00 0647*       ld bc,0 ; clear bcu
0408BD 11 00 00 00 0648*       ld de,0 ; clear deu
0408C1 AF          0649*       xor a
0408C2 45          0650*       ld b,l
0408C3 C5          0651*       push bc
0408C4 47          0652*       ld b,a
0408C5 6F          0653*       ld l,a
0408C6             0654*   ; Iteration 1
0408C6 29          0655*       add hl,hl
0408C7 CB 11       0656*       rl c
0408C9 29          0657*       add hl,hl
0408CA CB 11       0658*       rl c
0408CC 91          0659*       sub c
0408CD 30 04       0660*       jr nc,$+6
0408CF 1C          0661*       inc e
0408D0 1C          0662*       inc e
0408D1 2F          0663*       cpl
0408D2 4F          0664*       ld c,a
0408D3             0665*   ; Iteration 2
0408D3 29          0666*       add hl,hl
0408D4 CB 11       0667*       rl c
0408D6 29          0668*       add hl,hl
0408D7 CB 11       0669*       rl c
0408D9 CB 13       0670*       rl e
0408DB 7B          0671*       ld a,e
0408DC 91          0672*       sub c
0408DD 30 04       0673*       jr nc,$+6
0408DF 1C          0674*       inc e
0408E0 1C          0675*       inc e
0408E1 2F          0676*       cpl
0408E2 4F          0677*       ld c,a
0408E3             0678*   ; Iteration 3
0408E3 29          0679*       add hl,hl
0408E4 CB 11       0680*       rl c
0408E6 29          0681*       add hl,hl
0408E7 CB 11       0682*       rl c
0408E9 CB 13       0683*       rl e
0408EB 7B          0684*       ld a,e
0408EC 91          0685*       sub c
0408ED 30 04       0686*       jr nc,$+6
0408EF 1C          0687*       inc e
0408F0 1C          0688*       inc e
0408F1 2F          0689*       cpl
0408F2 4F          0690*       ld c,a
0408F3             0691*   ; Iteration 4
0408F3 29          0692*       add hl,hl
0408F4 CB 11       0693*       rl c
0408F6 29          0694*       add hl,hl
0408F7 CB 11       0695*       rl c
0408F9 CB 13       0696*       rl e
0408FB 7B          0697*       ld a,e
0408FC 91          0698*       sub c
0408FD 30 04       0699*       jr nc,$+6
0408FF 1C          0700*       inc e
040900 1C          0701*       inc e
040901 2F          0702*       cpl
040902 4F          0703*       ld c,a
040903             0704*   ; Iteration 5
040903 29          0705*       add hl,hl
040904 CB 11       0706*       rl c
040906 29          0707*       add hl,hl
040907 CB 11       0708*       rl c
040909 CB 13       0709*       rl e
04090B 7B          0710*       ld a,e
04090C 91          0711*       sub c
04090D 30 04       0712*       jr nc,$+6
04090F 1C          0713*       inc e
040910 1C          0714*       inc e
040911 2F          0715*       cpl
040912 4F          0716*       ld c,a
040913             0717*   ; Iteration 6
040913 29          0718*       add hl,hl
040914 CB 11       0719*       rl c
040916 29          0720*       add hl,hl
040917 CB 11       0721*       rl c
040919 CB 13       0722*       rl e
04091B 7B          0723*       ld a,e
04091C 91          0724*       sub c
04091D 30 04       0725*       jr nc,$+6
04091F 1C          0726*       inc e
040920 1C          0727*       inc e
040921 2F          0728*       cpl
040922 4F          0729*       ld c,a
040923             0730*   ; Iteration 7
040923 29          0731*       add hl,hl
040924 CB 11       0732*       rl c
040926 29          0733*       add hl,hl
040927 CB 11       0734*       rl c
040929 CB 10       0735*       rl b
04092B EB          0736*       ex de,hl
04092C 29          0737*       add hl,hl
04092D E5          0738*       push hl
04092E ED 42       0739*       sbc hl,bc
040930 30 06       0740*       jr nc,$+8
040932 7C          0741*       ld a,h
040933 2F          0742*       cpl
040934 47          0743*       ld b,a
040935 7D          0744*       ld a,l
040936 2F          0745*       cpl
040937 4F          0746*       ld c,a
040938 E1          0747*       pop hl
040939 30 02       0748*       jr nc,$+4
04093B 23          0749*       inc hl
04093C 23          0750*       inc hl
04093D EB          0751*       ex de,hl
04093E             0752*   ; Iteration 8
04093E 29          0753*       add hl,hl
04093F 69          0754*       ld l,c
040940 60          0755*       ld h,b
040941 ED 6A       0756*       adc hl,hl
040943 ED 6A       0757*       adc hl,hl
040945 EB          0758*       ex de,hl
040946 29          0759*       add hl,hl
040947 ED 52       0760*       sbc hl,de
040949 19          0761*       add hl,de
04094A EB          0762*       ex de,hl
04094B 30 04       0763*       jr nc,$+6
04094D ED 52       0764*       sbc hl,de
04094F 13          0765*       inc de
040950 13          0766*       inc de
040951             0767*   ; Iteration 9
040951 F1          0768*       pop af
040952 17          0769*       rla
040953 ED 6A       0770*       adc hl,hl
040955 17          0771*       rla
040956 ED 6A       0772*       adc hl,hl
040958 EB          0773*       ex de,hl
040959 29          0774*       add hl,hl
04095A ED 52       0775*       sbc hl,de
04095C 19          0776*       add hl,de
04095D EB          0777*       ex de,hl
04095E 30 04       0778*       jr nc,$+6
040960 ED 52       0779*       sbc hl,de
040962 13          0780*       inc de
040963 13          0781*       inc de
040964             0782*   ; Iteration 10
040964 17          0783*       rla
040965 ED 6A       0784*       adc hl,hl
040967 17          0785*       rla
040968 ED 6A       0786*       adc hl,hl
04096A EB          0787*       ex de,hl
04096B 29          0788*       add hl,hl
04096C ED 52       0789*       sbc hl,de
04096E 19          0790*       add hl,de
04096F EB          0791*       ex de,hl
040970 30 04       0792*       jr nc,$+6
040972 ED 52       0793*       sbc hl,de
040974 13          0794*       inc de
040975 13          0795*       inc de
040976             0796*   ; Iteration 11
040976 17          0797*       rla
040977 ED 6A       0798*       adc hl,hl
040979 17          0799*       rla
04097A ED 6A       0800*       adc hl,hl
04097C EB          0801*       ex de,hl
04097D 29          0802*       add hl,hl
04097E ED 52       0803*       sbc hl,de
040980 19          0804*       add hl,de
040981 EB          0805*       ex de,hl
040982 30 04       0806*       jr nc,$+6
040984 ED 52       0807*       sbc hl,de
040986 13          0808*       inc de
040987 13          0809*       inc de
040988             0810*   ; Iteration 12
040988 17          0811*       rla
040989 ED 6A       0812*       adc hl,hl
04098B 17          0813*       rla
04098C ED 6A       0814*       adc hl,hl
04098E EB          0815*       ex de,hl
04098F 29          0816*       add hl,hl
040990 ED 52       0817*       sbc hl,de
040992 19          0818*       add hl,de
040993 EB          0819*       ex de,hl
040994 30 04       0820*       jr nc,$+6
040996 ED 52       0821*       sbc hl,de
040998 13          0822*       inc de
040999 13          0823*       inc de
04099A CB 1A       0824*       rr d
04099C CB 1B       0825*       rr e
04099E C9          0826*       ret
04099F             0827*   
04099F             0828*   sin_lut_168:
04099F 00 00 00    0829*       dl 0x000000 ; 0.000 00, 0.000
0409A2 06 00 00    0830*       dl 0x000006 ; 1.406 01, 0.025
0409A5 0C 00 00    0831*       dl 0x00000C ; 2.813 02, 0.049
0409A8 12 00 00    0832*       dl 0x000012 ; 4.219 03, 0.074
0409AB 19 00 00    0833*       dl 0x000019 ; 5.625 04, 0.098
0409AE 1F 00 00    0834*       dl 0x00001F ; 7.031 05, 0.122
0409B1 25 00 00    0835*       dl 0x000025 ; 8.438 06, 0.147
0409B4 2B 00 00    0836*       dl 0x00002B ; 9.844 07, 0.171
0409B7 31 00 00    0837*       dl 0x000031 ; 11.250 08, 0.195
0409BA 38 00 00    0838*       dl 0x000038 ; 12.656 09, 0.219
0409BD 3E 00 00    0839*       dl 0x00003E ; 14.063 0A, 0.243
0409C0 44 00 00    0840*       dl 0x000044 ; 15.469 0B, 0.267
0409C3 4A 00 00    0841*       dl 0x00004A ; 16.875 0C, 0.290
0409C6 50 00 00    0842*       dl 0x000050 ; 18.281 0D, 0.314
0409C9 56 00 00    0843*       dl 0x000056 ; 19.688 0E, 0.337
0409CC 5C 00 00    0844*       dl 0x00005C ; 21.094 0F, 0.360
0409CF 61 00 00    0845*       dl 0x000061 ; 22.500 10, 0.383
0409D2 67 00 00    0846*       dl 0x000067 ; 23.906 11, 0.405
0409D5 6D 00 00    0847*       dl 0x00006D ; 25.313 12, 0.428
0409D8 73 00 00    0848*       dl 0x000073 ; 26.719 13, 0.450
0409DB 78 00 00    0849*       dl 0x000078 ; 28.125 14, 0.471
0409DE 7E 00 00    0850*       dl 0x00007E ; 29.531 15, 0.493
0409E1 83 00 00    0851*       dl 0x000083 ; 30.938 16, 0.514
0409E4 88 00 00    0852*       dl 0x000088 ; 32.344 17, 0.535
0409E7 8E 00 00    0853*       dl 0x00008E ; 33.750 18, 0.556
0409EA 93 00 00    0854*       dl 0x000093 ; 35.156 19, 0.576
0409ED 98 00 00    0855*       dl 0x000098 ; 36.563 1A, 0.596
0409F0 9D 00 00    0856*       dl 0x00009D ; 37.969 1B, 0.615
0409F3 A2 00 00    0857*       dl 0x0000A2 ; 39.375 1C, 0.634
0409F6 A7 00 00    0858*       dl 0x0000A7 ; 40.781 1D, 0.653
0409F9 AB 00 00    0859*       dl 0x0000AB ; 42.188 1E, 0.672
0409FC B0 00 00    0860*       dl 0x0000B0 ; 43.594 1F, 0.690
0409FF B5 00 00    0861*       dl 0x0000B5 ; 45.000 20, 0.707
040A02 B9 00 00    0862*       dl 0x0000B9 ; 46.406 21, 0.724
040A05 BD 00 00    0863*       dl 0x0000BD ; 47.813 22, 0.741
040A08 C1 00 00    0864*       dl 0x0000C1 ; 49.219 23, 0.757
040A0B C5 00 00    0865*       dl 0x0000C5 ; 50.625 24, 0.773
040A0E C9 00 00    0866*       dl 0x0000C9 ; 52.031 25, 0.788
040A11 CD 00 00    0867*       dl 0x0000CD ; 53.438 26, 0.803
040A14 D1 00 00    0868*       dl 0x0000D1 ; 54.844 27, 0.818
040A17 D4 00 00    0869*       dl 0x0000D4 ; 56.250 28, 0.831
040A1A D8 00 00    0870*       dl 0x0000D8 ; 57.656 29, 0.845
040A1D DB 00 00    0871*       dl 0x0000DB ; 59.063 2A, 0.858
040A20 DE 00 00    0872*       dl 0x0000DE ; 60.469 2B, 0.870
040A23 E1 00 00    0873*       dl 0x0000E1 ; 61.875 2C, 0.882
040A26 E4 00 00    0874*       dl 0x0000E4 ; 63.281 2D, 0.893
040A29 E7 00 00    0875*       dl 0x0000E7 ; 64.688 2E, 0.904
040A2C EA 00 00    0876*       dl 0x0000EA ; 66.094 2F, 0.914
040A2F EC 00 00    0877*       dl 0x0000EC ; 67.500 30, 0.924
040A32 EE 00 00    0878*       dl 0x0000EE ; 68.906 31, 0.933
040A35 F1 00 00    0879*       dl 0x0000F1 ; 70.313 32, 0.942
040A38 F3 00 00    0880*       dl 0x0000F3 ; 71.719 33, 0.950
040A3B F4 00 00    0881*       dl 0x0000F4 ; 73.125 34, 0.957
040A3E F6 00 00    0882*       dl 0x0000F6 ; 74.531 35, 0.964
040A41 F8 00 00    0883*       dl 0x0000F8 ; 75.938 36, 0.970
040A44 F9 00 00    0884*       dl 0x0000F9 ; 77.344 37, 0.976
040A47 FB 00 00    0885*       dl 0x0000FB ; 78.750 38, 0.981
040A4A FC 00 00    0886*       dl 0x0000FC ; 80.156 39, 0.985
040A4D FD 00 00    0887*       dl 0x0000FD ; 81.563 3A, 0.989
040A50 FE 00 00    0888*       dl 0x0000FE ; 82.969 3B, 0.992
040A53 FE 00 00    0889*       dl 0x0000FE ; 84.375 3C, 0.995
040A56 FF 00 00    0890*       dl 0x0000FF ; 85.781 3D, 0.997
040A59 FF 00 00    0891*       dl 0x0000FF ; 87.188 3E, 0.999
040A5C FF 00 00    0892*       dl 0x0000FF ; 88.594 3F, 1.000
040A5F 00 01 00    0893*       dl 0x000100 ; 90.000 40, 1.000
040A62 FF 00 00    0894*       dl 0x0000FF ; 91.406 41, 1.000
040A65 FF 00 00    0895*       dl 0x0000FF ; 92.813 42, 0.999
040A68 FF 00 00    0896*       dl 0x0000FF ; 94.219 43, 0.997
040A6B FE 00 00    0897*       dl 0x0000FE ; 95.625 44, 0.995
040A6E FE 00 00    0898*       dl 0x0000FE ; 97.031 45, 0.992
040A71 FD 00 00    0899*       dl 0x0000FD ; 98.438 46, 0.989
040A74 FC 00 00    0900*       dl 0x0000FC ; 99.844 47, 0.985
040A77 FB 00 00    0901*       dl 0x0000FB ; 101.250 48, 0.981
040A7A F9 00 00    0902*       dl 0x0000F9 ; 102.656 49, 0.976
040A7D F8 00 00    0903*       dl 0x0000F8 ; 104.063 4A, 0.970
040A80 F6 00 00    0904*       dl 0x0000F6 ; 105.469 4B, 0.964
040A83 F4 00 00    0905*       dl 0x0000F4 ; 106.875 4C, 0.957
040A86 F3 00 00    0906*       dl 0x0000F3 ; 108.281 4D, 0.950
040A89 F1 00 00    0907*       dl 0x0000F1 ; 109.688 4E, 0.942
040A8C EE 00 00    0908*       dl 0x0000EE ; 111.094 4F, 0.933
040A8F EC 00 00    0909*       dl 0x0000EC ; 112.500 50, 0.924
040A92 EA 00 00    0910*       dl 0x0000EA ; 113.906 51, 0.914
040A95 E7 00 00    0911*       dl 0x0000E7 ; 115.313 52, 0.904
040A98 E4 00 00    0912*       dl 0x0000E4 ; 116.719 53, 0.893
040A9B E1 00 00    0913*       dl 0x0000E1 ; 118.125 54, 0.882
040A9E DE 00 00    0914*       dl 0x0000DE ; 119.531 55, 0.870
040AA1 DB 00 00    0915*       dl 0x0000DB ; 120.938 56, 0.858
040AA4 D8 00 00    0916*       dl 0x0000D8 ; 122.344 57, 0.845
040AA7 D4 00 00    0917*       dl 0x0000D4 ; 123.750 58, 0.831
040AAA D1 00 00    0918*       dl 0x0000D1 ; 125.156 59, 0.818
040AAD CD 00 00    0919*       dl 0x0000CD ; 126.563 5A, 0.803
040AB0 C9 00 00    0920*       dl 0x0000C9 ; 127.969 5B, 0.788
040AB3 C5 00 00    0921*       dl 0x0000C5 ; 129.375 5C, 0.773
040AB6 C1 00 00    0922*       dl 0x0000C1 ; 130.781 5D, 0.757
040AB9 BD 00 00    0923*       dl 0x0000BD ; 132.188 5E, 0.741
040ABC B9 00 00    0924*       dl 0x0000B9 ; 133.594 5F, 0.724
040ABF B5 00 00    0925*       dl 0x0000B5 ; 135.000 60, 0.707
040AC2 B0 00 00    0926*       dl 0x0000B0 ; 136.406 61, 0.690
040AC5 AB 00 00    0927*       dl 0x0000AB ; 137.813 62, 0.672
040AC8 A7 00 00    0928*       dl 0x0000A7 ; 139.219 63, 0.653
040ACB A2 00 00    0929*       dl 0x0000A2 ; 140.625 64, 0.634
040ACE 9D 00 00    0930*       dl 0x00009D ; 142.031 65, 0.615
040AD1 98 00 00    0931*       dl 0x000098 ; 143.438 66, 0.596
040AD4 93 00 00    0932*       dl 0x000093 ; 144.844 67, 0.576
040AD7 8E 00 00    0933*       dl 0x00008E ; 146.250 68, 0.556
040ADA 88 00 00    0934*       dl 0x000088 ; 147.656 69, 0.535
040ADD 83 00 00    0935*       dl 0x000083 ; 149.063 6A, 0.514
040AE0 7E 00 00    0936*       dl 0x00007E ; 150.469 6B, 0.493
040AE3 78 00 00    0937*       dl 0x000078 ; 151.875 6C, 0.471
040AE6 73 00 00    0938*       dl 0x000073 ; 153.281 6D, 0.450
040AE9 6D 00 00    0939*       dl 0x00006D ; 154.688 6E, 0.428
040AEC 67 00 00    0940*       dl 0x000067 ; 156.094 6F, 0.405
040AEF 61 00 00    0941*       dl 0x000061 ; 157.500 70, 0.383
040AF2 5C 00 00    0942*       dl 0x00005C ; 158.906 71, 0.360
040AF5 56 00 00    0943*       dl 0x000056 ; 160.313 72, 0.337
040AF8 50 00 00    0944*       dl 0x000050 ; 161.719 73, 0.314
040AFB 4A 00 00    0945*       dl 0x00004A ; 163.125 74, 0.290
040AFE 44 00 00    0946*       dl 0x000044 ; 164.531 75, 0.267
040B01 3E 00 00    0947*       dl 0x00003E ; 165.938 76, 0.243
040B04 38 00 00    0948*       dl 0x000038 ; 167.344 77, 0.219
040B07 31 00 00    0949*       dl 0x000031 ; 168.750 78, 0.195
040B0A 2B 00 00    0950*       dl 0x00002B ; 170.156 79, 0.171
040B0D 25 00 00    0951*       dl 0x000025 ; 171.563 7A, 0.147
040B10 1F 00 00    0952*       dl 0x00001F ; 172.969 7B, 0.122
040B13 19 00 00    0953*       dl 0x000019 ; 174.375 7C, 0.098
040B16 12 00 00    0954*       dl 0x000012 ; 175.781 7D, 0.074
040B19 0C 00 00    0955*       dl 0x00000C ; 177.188 7E, 0.049
040B1C 06 00 00    0956*       dl 0x000006 ; 178.594 7F, 0.025
040B1F 00 00 00    0957*       dl 0x000000 ; 180.000 80, 0.000
040B22 FA FF FF    0958*       dl 0xFFFFFA ; 181.406 81, -0.025
040B25 F4 FF FF    0959*       dl 0xFFFFF4 ; 182.813 82, -0.049
040B28 EE FF FF    0960*       dl 0xFFFFEE ; 184.219 83, -0.074
040B2B E7 FF FF    0961*       dl 0xFFFFE7 ; 185.625 84, -0.098
040B2E E1 FF FF    0962*       dl 0xFFFFE1 ; 187.031 85, -0.122
040B31 DB FF FF    0963*       dl 0xFFFFDB ; 188.438 86, -0.147
040B34 D5 FF FF    0964*       dl 0xFFFFD5 ; 189.844 87, -0.171
040B37 CF FF FF    0965*       dl 0xFFFFCF ; 191.250 88, -0.195
040B3A C8 FF FF    0966*       dl 0xFFFFC8 ; 192.656 89, -0.219
040B3D C2 FF FF    0967*       dl 0xFFFFC2 ; 194.063 8A, -0.243
040B40 BC FF FF    0968*       dl 0xFFFFBC ; 195.469 8B, -0.267
040B43 B6 FF FF    0969*       dl 0xFFFFB6 ; 196.875 8C, -0.290
040B46 B0 FF FF    0970*       dl 0xFFFFB0 ; 198.281 8D, -0.314
040B49 AA FF FF    0971*       dl 0xFFFFAA ; 199.688 8E, -0.337
040B4C A4 FF FF    0972*       dl 0xFFFFA4 ; 201.094 8F, -0.360
040B4F 9F FF FF    0973*       dl 0xFFFF9F ; 202.500 90, -0.383
040B52 99 FF FF    0974*       dl 0xFFFF99 ; 203.906 91, -0.405
040B55 93 FF FF    0975*       dl 0xFFFF93 ; 205.313 92, -0.428
040B58 8D FF FF    0976*       dl 0xFFFF8D ; 206.719 93, -0.450
040B5B 88 FF FF    0977*       dl 0xFFFF88 ; 208.125 94, -0.471
040B5E 82 FF FF    0978*       dl 0xFFFF82 ; 209.531 95, -0.493
040B61 7D FF FF    0979*       dl 0xFFFF7D ; 210.938 96, -0.514
040B64 78 FF FF    0980*       dl 0xFFFF78 ; 212.344 97, -0.535
040B67 72 FF FF    0981*       dl 0xFFFF72 ; 213.750 98, -0.556
040B6A 6D FF FF    0982*       dl 0xFFFF6D ; 215.156 99, -0.576
040B6D 68 FF FF    0983*       dl 0xFFFF68 ; 216.563 9A, -0.596
040B70 63 FF FF    0984*       dl 0xFFFF63 ; 217.969 9B, -0.615
040B73 5E FF FF    0985*       dl 0xFFFF5E ; 219.375 9C, -0.634
040B76 59 FF FF    0986*       dl 0xFFFF59 ; 220.781 9D, -0.653
040B79 55 FF FF    0987*       dl 0xFFFF55 ; 222.188 9E, -0.672
040B7C 50 FF FF    0988*       dl 0xFFFF50 ; 223.594 9F, -0.690
040B7F 4B FF FF    0989*       dl 0xFFFF4B ; 225.000 A0, -0.707
040B82 47 FF FF    0990*       dl 0xFFFF47 ; 226.406 A1, -0.724
040B85 43 FF FF    0991*       dl 0xFFFF43 ; 227.813 A2, -0.741
040B88 3F FF FF    0992*       dl 0xFFFF3F ; 229.219 A3, -0.757
040B8B 3B FF FF    0993*       dl 0xFFFF3B ; 230.625 A4, -0.773
040B8E 37 FF FF    0994*       dl 0xFFFF37 ; 232.031 A5, -0.788
040B91 33 FF FF    0995*       dl 0xFFFF33 ; 233.438 A6, -0.803
040B94 2F FF FF    0996*       dl 0xFFFF2F ; 234.844 A7, -0.818
040B97 2C FF FF    0997*       dl 0xFFFF2C ; 236.250 A8, -0.831
040B9A 28 FF FF    0998*       dl 0xFFFF28 ; 237.656 A9, -0.845
040B9D 25 FF FF    0999*       dl 0xFFFF25 ; 239.063 AA, -0.858
040BA0 22 FF FF    1000*       dl 0xFFFF22 ; 240.469 AB, -0.870
040BA3 1F FF FF    1001*       dl 0xFFFF1F ; 241.875 AC, -0.882
040BA6 1C FF FF    1002*       dl 0xFFFF1C ; 243.281 AD, -0.893
040BA9 19 FF FF    1003*       dl 0xFFFF19 ; 244.688 AE, -0.904
040BAC 16 FF FF    1004*       dl 0xFFFF16 ; 246.094 AF, -0.914
040BAF 14 FF FF    1005*       dl 0xFFFF14 ; 247.500 B0, -0.924
040BB2 12 FF FF    1006*       dl 0xFFFF12 ; 248.906 B1, -0.933
040BB5 0F FF FF    1007*       dl 0xFFFF0F ; 250.313 B2, -0.942
040BB8 0D FF FF    1008*       dl 0xFFFF0D ; 251.719 B3, -0.950
040BBB 0C FF FF    1009*       dl 0xFFFF0C ; 253.125 B4, -0.957
040BBE 0A FF FF    1010*       dl 0xFFFF0A ; 254.531 B5, -0.964
040BC1 08 FF FF    1011*       dl 0xFFFF08 ; 255.938 B6, -0.970
040BC4 07 FF FF    1012*       dl 0xFFFF07 ; 257.344 B7, -0.976
040BC7 05 FF FF    1013*       dl 0xFFFF05 ; 258.750 B8, -0.981
040BCA 04 FF FF    1014*       dl 0xFFFF04 ; 260.156 B9, -0.985
040BCD 03 FF FF    1015*       dl 0xFFFF03 ; 261.563 BA, -0.989
040BD0 02 FF FF    1016*       dl 0xFFFF02 ; 262.969 BB, -0.992
040BD3 02 FF FF    1017*       dl 0xFFFF02 ; 264.375 BC, -0.995
040BD6 01 FF FF    1018*       dl 0xFFFF01 ; 265.781 BD, -0.997
040BD9 01 FF FF    1019*       dl 0xFFFF01 ; 267.188 BE, -0.999
040BDC 01 FF FF    1020*       dl 0xFFFF01 ; 268.594 BF, -1.000
040BDF 00 FF FF    1021*       dl 0xFFFF00 ; 270.000 C0, -1.000
040BE2 01 FF FF    1022*       dl 0xFFFF01 ; 271.406 C1, -1.000
040BE5 01 FF FF    1023*       dl 0xFFFF01 ; 272.813 C2, -0.999
040BE8 01 FF FF    1024*       dl 0xFFFF01 ; 274.219 C3, -0.997
040BEB 02 FF FF    1025*       dl 0xFFFF02 ; 275.625 C4, -0.995
040BEE 02 FF FF    1026*       dl 0xFFFF02 ; 277.031 C5, -0.992
040BF1 03 FF FF    1027*       dl 0xFFFF03 ; 278.438 C6, -0.989
040BF4 04 FF FF    1028*       dl 0xFFFF04 ; 279.844 C7, -0.985
040BF7 05 FF FF    1029*       dl 0xFFFF05 ; 281.250 C8, -0.981
040BFA 07 FF FF    1030*       dl 0xFFFF07 ; 282.656 C9, -0.976
040BFD 08 FF FF    1031*       dl 0xFFFF08 ; 284.063 CA, -0.970
040C00 0A FF FF    1032*       dl 0xFFFF0A ; 285.469 CB, -0.964
040C03 0C FF FF    1033*       dl 0xFFFF0C ; 286.875 CC, -0.957
040C06 0D FF FF    1034*       dl 0xFFFF0D ; 288.281 CD, -0.950
040C09 0F FF FF    1035*       dl 0xFFFF0F ; 289.688 CE, -0.942
040C0C 12 FF FF    1036*       dl 0xFFFF12 ; 291.094 CF, -0.933
040C0F 14 FF FF    1037*       dl 0xFFFF14 ; 292.500 D0, -0.924
040C12 16 FF FF    1038*       dl 0xFFFF16 ; 293.906 D1, -0.914
040C15 19 FF FF    1039*       dl 0xFFFF19 ; 295.313 D2, -0.904
040C18 1C FF FF    1040*       dl 0xFFFF1C ; 296.719 D3, -0.893
040C1B 1F FF FF    1041*       dl 0xFFFF1F ; 298.125 D4, -0.882
040C1E 22 FF FF    1042*       dl 0xFFFF22 ; 299.531 D5, -0.870
040C21 25 FF FF    1043*       dl 0xFFFF25 ; 300.938 D6, -0.858
040C24 28 FF FF    1044*       dl 0xFFFF28 ; 302.344 D7, -0.845
040C27 2C FF FF    1045*       dl 0xFFFF2C ; 303.750 D8, -0.831
040C2A 2F FF FF    1046*       dl 0xFFFF2F ; 305.156 D9, -0.818
040C2D 33 FF FF    1047*       dl 0xFFFF33 ; 306.563 DA, -0.803
040C30 37 FF FF    1048*       dl 0xFFFF37 ; 307.969 DB, -0.788
040C33 3B FF FF    1049*       dl 0xFFFF3B ; 309.375 DC, -0.773
040C36 3F FF FF    1050*       dl 0xFFFF3F ; 310.781 DD, -0.757
040C39 43 FF FF    1051*       dl 0xFFFF43 ; 312.188 DE, -0.741
040C3C 47 FF FF    1052*       dl 0xFFFF47 ; 313.594 DF, -0.724
040C3F 4B FF FF    1053*       dl 0xFFFF4B ; 315.000 E0, -0.707
040C42 50 FF FF    1054*       dl 0xFFFF50 ; 316.406 E1, -0.690
040C45 55 FF FF    1055*       dl 0xFFFF55 ; 317.813 E2, -0.672
040C48 59 FF FF    1056*       dl 0xFFFF59 ; 319.219 E3, -0.653
040C4B 5E FF FF    1057*       dl 0xFFFF5E ; 320.625 E4, -0.634
040C4E 63 FF FF    1058*       dl 0xFFFF63 ; 322.031 E5, -0.615
040C51 68 FF FF    1059*       dl 0xFFFF68 ; 323.438 E6, -0.596
040C54 6D FF FF    1060*       dl 0xFFFF6D ; 324.844 E7, -0.576
040C57 72 FF FF    1061*       dl 0xFFFF72 ; 326.250 E8, -0.556
040C5A 78 FF FF    1062*       dl 0xFFFF78 ; 327.656 E9, -0.535
040C5D 7D FF FF    1063*       dl 0xFFFF7D ; 329.063 EA, -0.514
040C60 82 FF FF    1064*       dl 0xFFFF82 ; 330.469 EB, -0.493
040C63 88 FF FF    1065*       dl 0xFFFF88 ; 331.875 EC, -0.471
040C66 8D FF FF    1066*       dl 0xFFFF8D ; 333.281 ED, -0.450
040C69 93 FF FF    1067*       dl 0xFFFF93 ; 334.688 EE, -0.428
040C6C 99 FF FF    1068*       dl 0xFFFF99 ; 336.094 EF, -0.405
040C6F 9F FF FF    1069*       dl 0xFFFF9F ; 337.500 F0, -0.383
040C72 A4 FF FF    1070*       dl 0xFFFFA4 ; 338.906 F1, -0.360
040C75 AA FF FF    1071*       dl 0xFFFFAA ; 340.313 F2, -0.337
040C78 B0 FF FF    1072*       dl 0xFFFFB0 ; 341.719 F3, -0.314
040C7B B6 FF FF    1073*       dl 0xFFFFB6 ; 343.125 F4, -0.290
040C7E BC FF FF    1074*       dl 0xFFFFBC ; 344.531 F5, -0.267
040C81 C2 FF FF    1075*       dl 0xFFFFC2 ; 345.938 F6, -0.243
040C84 C8 FF FF    1076*       dl 0xFFFFC8 ; 347.344 F7, -0.219
040C87 CF FF FF    1077*       dl 0xFFFFCF ; 348.750 F8, -0.195
040C8A D5 FF FF    1078*       dl 0xFFFFD5 ; 350.156 F9, -0.171
040C8D DB FF FF    1079*       dl 0xFFFFDB ; 351.563 FA, -0.147
040C90 E1 FF FF    1080*       dl 0xFFFFE1 ; 352.969 FB, -0.122
040C93 E7 FF FF    1081*       dl 0xFFFFE7 ; 354.375 FC, -0.098
040C96 EE FF FF    1082*       dl 0xFFFFEE ; 355.781 FD, -0.074
040C99 F4 FF FF    1083*       dl 0xFFFFF4 ; 357.188 FE, -0.049
040C9C FA FF FF    1084*       dl 0xFFFFFA ; 358.594 FF, -0.025
040C9F 00 00 00    1085*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
040CA2             1086*   
040CA2             1087*   atan_lut_168:
040CA2 00 00 00    1088*       dl 0x000000 ; 000000, 0.000
040CA5 28 00 00    1089*       dl 0x000028 ; 000001, 0.224
040CA8 51 00 00    1090*       dl 0x000051 ; 000002, 0.448
040CAB 7A 00 00    1091*       dl 0x00007A ; 000003, 0.671
040CAE A2 00 00    1092*       dl 0x0000A2 ; 000004, 0.895
040CB1 CB 00 00    1093*       dl 0x0000CB ; 000005, 1.119
040CB4 F4 00 00    1094*       dl 0x0000F4 ; 000006, 1.343
040CB7 1D 01 00    1095*       dl 0x00011D ; 000007, 1.566
040CBA 45 01 00    1096*       dl 0x000145 ; 000008, 1.790
040CBD 6E 01 00    1097*       dl 0x00016E ; 000009, 2.013
040CC0 97 01 00    1098*       dl 0x000197 ; 00000A, 2.237
040CC3 BF 01 00    1099*       dl 0x0001BF ; 00000B, 2.460
040CC6 E8 01 00    1100*       dl 0x0001E8 ; 00000C, 2.684
040CC9 11 02 00    1101*       dl 0x000211 ; 00000D, 2.907
040CCC 39 02 00    1102*       dl 0x000239 ; 00000E, 3.130
040CCF 62 02 00    1103*       dl 0x000262 ; 00000F, 3.353
040CD2 8B 02 00    1104*       dl 0x00028B ; 000010, 3.576
040CD5 B3 02 00    1105*       dl 0x0002B3 ; 000011, 3.799
040CD8 DC 02 00    1106*       dl 0x0002DC ; 000012, 4.022
040CDB 04 03 00    1107*       dl 0x000304 ; 000013, 4.245
040CDE 2D 03 00    1108*       dl 0x00032D ; 000014, 4.467
040CE1 55 03 00    1109*       dl 0x000355 ; 000015, 4.690
040CE4 7E 03 00    1110*       dl 0x00037E ; 000016, 4.912
040CE7 A6 03 00    1111*       dl 0x0003A6 ; 000017, 5.134
040CEA CE 03 00    1112*       dl 0x0003CE ; 000018, 5.356
040CED F7 03 00    1113*       dl 0x0003F7 ; 000019, 5.578
040CF0 1F 04 00    1114*       dl 0x00041F ; 00001A, 5.799
040CF3 48 04 00    1115*       dl 0x000448 ; 00001B, 6.021
040CF6 70 04 00    1116*       dl 0x000470 ; 00001C, 6.242
040CF9 98 04 00    1117*       dl 0x000498 ; 00001D, 6.463
040CFC C0 04 00    1118*       dl 0x0004C0 ; 00001E, 6.684
040CFF E8 04 00    1119*       dl 0x0004E8 ; 00001F, 6.905
040D02 11 05 00    1120*       dl 0x000511 ; 000020, 7.125
040D05 39 05 00    1121*       dl 0x000539 ; 000021, 7.345
040D08 61 05 00    1122*       dl 0x000561 ; 000022, 7.565
040D0B 89 05 00    1123*       dl 0x000589 ; 000023, 7.785
040D0E B1 05 00    1124*       dl 0x0005B1 ; 000024, 8.005
040D11 D9 05 00    1125*       dl 0x0005D9 ; 000025, 8.224
040D14 01 06 00    1126*       dl 0x000601 ; 000026, 8.443
040D17 28 06 00    1127*       dl 0x000628 ; 000027, 8.662
040D1A 50 06 00    1128*       dl 0x000650 ; 000028, 8.881
040D1D 78 06 00    1129*       dl 0x000678 ; 000029, 9.099
040D20 A0 06 00    1130*       dl 0x0006A0 ; 00002A, 9.317
040D23 C7 06 00    1131*       dl 0x0006C7 ; 00002B, 9.535
040D26 EF 06 00    1132*       dl 0x0006EF ; 00002C, 9.752
040D29 16 07 00    1133*       dl 0x000716 ; 00002D, 9.970
040D2C 3E 07 00    1134*       dl 0x00073E ; 00002E, 10.187
040D2F 65 07 00    1135*       dl 0x000765 ; 00002F, 10.403
040D32 8D 07 00    1136*       dl 0x00078D ; 000030, 10.620
040D35 B4 07 00    1137*       dl 0x0007B4 ; 000031, 10.836
040D38 DB 07 00    1138*       dl 0x0007DB ; 000032, 11.051
040D3B 03 08 00    1139*       dl 0x000803 ; 000033, 11.267
040D3E 2A 08 00    1140*       dl 0x00082A ; 000034, 11.482
040D41 51 08 00    1141*       dl 0x000851 ; 000035, 11.697
040D44 78 08 00    1142*       dl 0x000878 ; 000036, 11.911
040D47 9F 08 00    1143*       dl 0x00089F ; 000037, 12.125
040D4A C6 08 00    1144*       dl 0x0008C6 ; 000038, 12.339
040D4D ED 08 00    1145*       dl 0x0008ED ; 000039, 12.553
040D50 13 09 00    1146*       dl 0x000913 ; 00003A, 12.766
040D53 3A 09 00    1147*       dl 0x00093A ; 00003B, 12.978
040D56 61 09 00    1148*       dl 0x000961 ; 00003C, 13.191
040D59 87 09 00    1149*       dl 0x000987 ; 00003D, 13.403
040D5C AE 09 00    1150*       dl 0x0009AE ; 00003E, 13.614
040D5F D4 09 00    1151*       dl 0x0009D4 ; 00003F, 13.825
040D62 FB 09 00    1152*       dl 0x0009FB ; 000040, 14.036
040D65 21 0A 00    1153*       dl 0x000A21 ; 000041, 14.247
040D68 47 0A 00    1154*       dl 0x000A47 ; 000042, 14.457
040D6B 6D 0A 00    1155*       dl 0x000A6D ; 000043, 14.666
040D6E 94 0A 00    1156*       dl 0x000A94 ; 000044, 14.876
040D71 BA 0A 00    1157*       dl 0x000ABA ; 000045, 15.085
040D74 E0 0A 00    1158*       dl 0x000AE0 ; 000046, 15.293
040D77 05 0B 00    1159*       dl 0x000B05 ; 000047, 15.501
040D7A 2B 0B 00    1160*       dl 0x000B2B ; 000048, 15.709
040D7D 51 0B 00    1161*       dl 0x000B51 ; 000049, 15.916
040D80 77 0B 00    1162*       dl 0x000B77 ; 00004A, 16.123
040D83 9C 0B 00    1163*       dl 0x000B9C ; 00004B, 16.329
040D86 C2 0B 00    1164*       dl 0x000BC2 ; 00004C, 16.535
040D89 E7 0B 00    1165*       dl 0x000BE7 ; 00004D, 16.740
040D8C 0C 0C 00    1166*       dl 0x000C0C ; 00004E, 16.945
040D8F 32 0C 00    1167*       dl 0x000C32 ; 00004F, 17.150
040D92 57 0C 00    1168*       dl 0x000C57 ; 000050, 17.354
040D95 7C 0C 00    1169*       dl 0x000C7C ; 000051, 17.558
040D98 A1 0C 00    1170*       dl 0x000CA1 ; 000052, 17.761
040D9B C6 0C 00    1171*       dl 0x000CC6 ; 000053, 17.964
040D9E EB 0C 00    1172*       dl 0x000CEB ; 000054, 18.166
040DA1 0F 0D 00    1173*       dl 0x000D0F ; 000055, 18.368
040DA4 34 0D 00    1174*       dl 0x000D34 ; 000056, 18.569
040DA7 58 0D 00    1175*       dl 0x000D58 ; 000057, 18.770
040DAA 7D 0D 00    1176*       dl 0x000D7D ; 000058, 18.970
040DAD A1 0D 00    1177*       dl 0x000DA1 ; 000059, 19.170
040DB0 C6 0D 00    1178*       dl 0x000DC6 ; 00005A, 19.370
040DB3 EA 0D 00    1179*       dl 0x000DEA ; 00005B, 19.569
040DB6 0E 0E 00    1180*       dl 0x000E0E ; 00005C, 19.767
040DB9 32 0E 00    1181*       dl 0x000E32 ; 00005D, 19.965
040DBC 56 0E 00    1182*       dl 0x000E56 ; 00005E, 20.163
040DBF 7A 0E 00    1183*       dl 0x000E7A ; 00005F, 20.360
040DC2 9E 0E 00    1184*       dl 0x000E9E ; 000060, 20.556
040DC5 C1 0E 00    1185*       dl 0x000EC1 ; 000061, 20.752
040DC8 E5 0E 00    1186*       dl 0x000EE5 ; 000062, 20.947
040DCB 08 0F 00    1187*       dl 0x000F08 ; 000063, 21.142
040DCE 2C 0F 00    1188*       dl 0x000F2C ; 000064, 21.337
040DD1 4F 0F 00    1189*       dl 0x000F4F ; 000065, 21.531
040DD4 72 0F 00    1190*       dl 0x000F72 ; 000066, 21.724
040DD7 95 0F 00    1191*       dl 0x000F95 ; 000067, 21.917
040DDA B8 0F 00    1192*       dl 0x000FB8 ; 000068, 22.109
040DDD DB 0F 00    1193*       dl 0x000FDB ; 000069, 22.301
040DE0 FE 0F 00    1194*       dl 0x000FFE ; 00006A, 22.493
040DE3 21 10 00    1195*       dl 0x001021 ; 00006B, 22.683
040DE6 44 10 00    1196*       dl 0x001044 ; 00006C, 22.874
040DE9 66 10 00    1197*       dl 0x001066 ; 00006D, 23.063
040DEC 89 10 00    1198*       dl 0x001089 ; 00006E, 23.253
040DEF AB 10 00    1199*       dl 0x0010AB ; 00006F, 23.441
040DF2 CD 10 00    1200*       dl 0x0010CD ; 000070, 23.629
040DF5 EF 10 00    1201*       dl 0x0010EF ; 000071, 23.817
040DF8 11 11 00    1202*       dl 0x001111 ; 000072, 24.004
040DFB 33 11 00    1203*       dl 0x001133 ; 000073, 24.191
040DFE 55 11 00    1204*       dl 0x001155 ; 000074, 24.376
040E01 77 11 00    1205*       dl 0x001177 ; 000075, 24.562
040E04 99 11 00    1206*       dl 0x001199 ; 000076, 24.747
040E07 BA 11 00    1207*       dl 0x0011BA ; 000077, 24.931
040E0A DC 11 00    1208*       dl 0x0011DC ; 000078, 25.115
040E0D FD 11 00    1209*       dl 0x0011FD ; 000079, 25.298
040E10 1E 12 00    1210*       dl 0x00121E ; 00007A, 25.481
040E13 3F 12 00    1211*       dl 0x00123F ; 00007B, 25.663
040E16 60 12 00    1212*       dl 0x001260 ; 00007C, 25.844
040E19 81 12 00    1213*       dl 0x001281 ; 00007D, 26.025
040E1C A2 12 00    1214*       dl 0x0012A2 ; 00007E, 26.206
040E1F C3 12 00    1215*       dl 0x0012C3 ; 00007F, 26.386
040E22 E4 12 00    1216*       dl 0x0012E4 ; 000080, 26.565
040E25 04 13 00    1217*       dl 0x001304 ; 000081, 26.744
040E28 25 13 00    1218*       dl 0x001325 ; 000082, 26.922
040E2B 45 13 00    1219*       dl 0x001345 ; 000083, 27.100
040E2E 65 13 00    1220*       dl 0x001365 ; 000084, 27.277
040E31 85 13 00    1221*       dl 0x001385 ; 000085, 27.453
040E34 A5 13 00    1222*       dl 0x0013A5 ; 000086, 27.629
040E37 C5 13 00    1223*       dl 0x0013C5 ; 000087, 27.805
040E3A E5 13 00    1224*       dl 0x0013E5 ; 000088, 27.979
040E3D 05 14 00    1225*       dl 0x001405 ; 000089, 28.154
040E40 24 14 00    1226*       dl 0x001424 ; 00008A, 28.327
040E43 44 14 00    1227*       dl 0x001444 ; 00008B, 28.501
040E46 63 14 00    1228*       dl 0x001463 ; 00008C, 28.673
040E49 83 14 00    1229*       dl 0x001483 ; 00008D, 28.845
040E4C A2 14 00    1230*       dl 0x0014A2 ; 00008E, 29.017
040E4F C1 14 00    1231*       dl 0x0014C1 ; 00008F, 29.187
040E52 E0 14 00    1232*       dl 0x0014E0 ; 000090, 29.358
040E55 FF 14 00    1233*       dl 0x0014FF ; 000091, 29.527
040E58 1E 15 00    1234*       dl 0x00151E ; 000092, 29.697
040E5B 3C 15 00    1235*       dl 0x00153C ; 000093, 29.865
040E5E 5B 15 00    1236*       dl 0x00155B ; 000094, 30.033
040E61 79 15 00    1237*       dl 0x001579 ; 000095, 30.201
040E64 98 15 00    1238*       dl 0x001598 ; 000096, 30.368
040E67 B6 15 00    1239*       dl 0x0015B6 ; 000097, 30.534
040E6A D4 15 00    1240*       dl 0x0015D4 ; 000098, 30.700
040E6D F2 15 00    1241*       dl 0x0015F2 ; 000099, 30.865
040E70 10 16 00    1242*       dl 0x001610 ; 00009A, 31.030
040E73 2E 16 00    1243*       dl 0x00162E ; 00009B, 31.194
040E76 4C 16 00    1244*       dl 0x00164C ; 00009C, 31.357
040E79 6A 16 00    1245*       dl 0x00166A ; 00009D, 31.520
040E7C 87 16 00    1246*       dl 0x001687 ; 00009E, 31.682
040E7F A5 16 00    1247*       dl 0x0016A5 ; 00009F, 31.844
040E82 C2 16 00    1248*       dl 0x0016C2 ; 0000A0, 32.005
040E85 DF 16 00    1249*       dl 0x0016DF ; 0000A1, 32.166
040E88 FC 16 00    1250*       dl 0x0016FC ; 0000A2, 32.326
040E8B 19 17 00    1251*       dl 0x001719 ; 0000A3, 32.486
040E8E 36 17 00    1252*       dl 0x001736 ; 0000A4, 32.645
040E91 53 17 00    1253*       dl 0x001753 ; 0000A5, 32.803
040E94 70 17 00    1254*       dl 0x001770 ; 0000A6, 32.961
040E97 8C 17 00    1255*       dl 0x00178C ; 0000A7, 33.118
040E9A A9 17 00    1256*       dl 0x0017A9 ; 0000A8, 33.275
040E9D C5 17 00    1257*       dl 0x0017C5 ; 0000A9, 33.431
040EA0 E2 17 00    1258*       dl 0x0017E2 ; 0000AA, 33.587
040EA3 FE 17 00    1259*       dl 0x0017FE ; 0000AB, 33.742
040EA6 1A 18 00    1260*       dl 0x00181A ; 0000AC, 33.896
040EA9 36 18 00    1261*       dl 0x001836 ; 0000AD, 34.050
040EAC 52 18 00    1262*       dl 0x001852 ; 0000AE, 34.203
040EAF 6E 18 00    1263*       dl 0x00186E ; 0000AF, 34.356
040EB2 8A 18 00    1264*       dl 0x00188A ; 0000B0, 34.509
040EB5 A5 18 00    1265*       dl 0x0018A5 ; 0000B1, 34.660
040EB8 C1 18 00    1266*       dl 0x0018C1 ; 0000B2, 34.811
040EBB DC 18 00    1267*       dl 0x0018DC ; 0000B3, 34.962
040EBE F7 18 00    1268*       dl 0x0018F7 ; 0000B4, 35.112
040EC1 13 19 00    1269*       dl 0x001913 ; 0000B5, 35.262
040EC4 2E 19 00    1270*       dl 0x00192E ; 0000B6, 35.410
040EC7 49 19 00    1271*       dl 0x001949 ; 0000B7, 35.559
040ECA 64 19 00    1272*       dl 0x001964 ; 0000B8, 35.707
040ECD 7F 19 00    1273*       dl 0x00197F ; 0000B9, 35.854
040ED0 99 19 00    1274*       dl 0x001999 ; 0000BA, 36.001
040ED3 B4 19 00    1275*       dl 0x0019B4 ; 0000BB, 36.147
040ED6 CE 19 00    1276*       dl 0x0019CE ; 0000BC, 36.293
040ED9 E9 19 00    1277*       dl 0x0019E9 ; 0000BD, 36.438
040EDC 03 1A 00    1278*       dl 0x001A03 ; 0000BE, 36.582
040EDF 1D 1A 00    1279*       dl 0x001A1D ; 0000BF, 36.726
040EE2 37 1A 00    1280*       dl 0x001A37 ; 0000C0, 36.870
040EE5 51 1A 00    1281*       dl 0x001A51 ; 0000C1, 37.013
040EE8 6B 1A 00    1282*       dl 0x001A6B ; 0000C2, 37.155
040EEB 85 1A 00    1283*       dl 0x001A85 ; 0000C3, 37.297
040EEE 9F 1A 00    1284*       dl 0x001A9F ; 0000C4, 37.439
040EF1 B9 1A 00    1285*       dl 0x001AB9 ; 0000C5, 37.579
040EF4 D2 1A 00    1286*       dl 0x001AD2 ; 0000C6, 37.720
040EF7 EC 1A 00    1287*       dl 0x001AEC ; 0000C7, 37.859
040EFA 05 1B 00    1288*       dl 0x001B05 ; 0000C8, 37.999
040EFD 1E 1B 00    1289*       dl 0x001B1E ; 0000C9, 38.137
040F00 37 1B 00    1290*       dl 0x001B37 ; 0000CA, 38.276
040F03 50 1B 00    1291*       dl 0x001B50 ; 0000CB, 38.413
040F06 69 1B 00    1292*       dl 0x001B69 ; 0000CC, 38.550
040F09 82 1B 00    1293*       dl 0x001B82 ; 0000CD, 38.687
040F0C 9B 1B 00    1294*       dl 0x001B9B ; 0000CE, 38.823
040F0F B4 1B 00    1295*       dl 0x001BB4 ; 0000CF, 38.959
040F12 CC 1B 00    1296*       dl 0x001BCC ; 0000D0, 39.094
040F15 E5 1B 00    1297*       dl 0x001BE5 ; 0000D1, 39.228
040F18 FD 1B 00    1298*       dl 0x001BFD ; 0000D2, 39.362
040F1B 16 1C 00    1299*       dl 0x001C16 ; 0000D3, 39.496
040F1E 2E 1C 00    1300*       dl 0x001C2E ; 0000D4, 39.629
040F21 46 1C 00    1301*       dl 0x001C46 ; 0000D5, 39.762
040F24 5E 1C 00    1302*       dl 0x001C5E ; 0000D6, 39.894
040F27 76 1C 00    1303*       dl 0x001C76 ; 0000D7, 40.025
040F2A 8E 1C 00    1304*       dl 0x001C8E ; 0000D8, 40.156
040F2D A5 1C 00    1305*       dl 0x001CA5 ; 0000D9, 40.286
040F30 BD 1C 00    1306*       dl 0x001CBD ; 0000DA, 40.416
040F33 D5 1C 00    1307*       dl 0x001CD5 ; 0000DB, 40.546
040F36 EC 1C 00    1308*       dl 0x001CEC ; 0000DC, 40.675
040F39 04 1D 00    1309*       dl 0x001D04 ; 0000DD, 40.803
040F3C 1B 1D 00    1310*       dl 0x001D1B ; 0000DE, 40.931
040F3F 32 1D 00    1311*       dl 0x001D32 ; 0000DF, 41.059
040F42 49 1D 00    1312*       dl 0x001D49 ; 0000E0, 41.186
040F45 60 1D 00    1313*       dl 0x001D60 ; 0000E1, 41.312
040F48 77 1D 00    1314*       dl 0x001D77 ; 0000E2, 41.438
040F4B 8E 1D 00    1315*       dl 0x001D8E ; 0000E3, 41.564
040F4E A5 1D 00    1316*       dl 0x001DA5 ; 0000E4, 41.689
040F51 BB 1D 00    1317*       dl 0x001DBB ; 0000E5, 41.814
040F54 D2 1D 00    1318*       dl 0x001DD2 ; 0000E6, 41.938
040F57 E9 1D 00    1319*       dl 0x001DE9 ; 0000E7, 42.061
040F5A FF 1D 00    1320*       dl 0x001DFF ; 0000E8, 42.184
040F5D 15 1E 00    1321*       dl 0x001E15 ; 0000E9, 42.307
040F60 2C 1E 00    1322*       dl 0x001E2C ; 0000EA, 42.429
040F63 42 1E 00    1323*       dl 0x001E42 ; 0000EB, 42.551
040F66 58 1E 00    1324*       dl 0x001E58 ; 0000EC, 42.672
040F69 6E 1E 00    1325*       dl 0x001E6E ; 0000ED, 42.793
040F6C 84 1E 00    1326*       dl 0x001E84 ; 0000EE, 42.913
040F6F 99 1E 00    1327*       dl 0x001E99 ; 0000EF, 43.033
040F72 AF 1E 00    1328*       dl 0x001EAF ; 0000F0, 43.152
040F75 C5 1E 00    1329*       dl 0x001EC5 ; 0000F1, 43.271
040F78 DA 1E 00    1330*       dl 0x001EDA ; 0000F2, 43.390
040F7B F0 1E 00    1331*       dl 0x001EF0 ; 0000F3, 43.508
040F7E 05 1F 00    1332*       dl 0x001F05 ; 0000F4, 43.625
040F81 1B 1F 00    1333*       dl 0x001F1B ; 0000F5, 43.742
040F84 30 1F 00    1334*       dl 0x001F30 ; 0000F6, 43.859
040F87 45 1F 00    1335*       dl 0x001F45 ; 0000F7, 43.975
040F8A 5A 1F 00    1336*       dl 0x001F5A ; 0000F8, 44.091
040F8D 6F 1F 00    1337*       dl 0x001F6F ; 0000F9, 44.206
040F90 84 1F 00    1338*       dl 0x001F84 ; 0000FA, 44.321
040F93 99 1F 00    1339*       dl 0x001F99 ; 0000FB, 44.435
040F96 AD 1F 00    1340*       dl 0x001FAD ; 0000FC, 44.549
040F99 C2 1F 00    1341*       dl 0x001FC2 ; 0000FD, 44.662
040F9C D7 1F 00    1342*       dl 0x001FD7 ; 0000FE, 44.775
040F9F EB 1F 00    1343*       dl 0x001FEB ; 0000FF, 44.888
040FA2 00 20 00    1344*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
040FA5             0037        include "timer.inc"
040FA5             0001*   ; Table 32. Timer Control Registers
040FA5             0002*   ; this constant is the base address of the timer control registers
040FA5             0003*   ; each timer takes three bytes:
040FA5             0004*   ;   0: control register
040FA5             0005*   ;   1: low byte of timer reset value
040FA5             0006*   ;   2: high byte of timer reset value
040FA5             0007*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
040FA5             0008*   ; which correctly force the high and upper bytes of the address bus to zero
040FA5             0009*   TMR_CTL:     equ 80h
040FA5             0010*   
040FA5             0011*   ; Timer Control Register Bit Definitions
040FA5             0012*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
040FA5             0013*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
040FA5             0014*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
040FA5             0015*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
040FA5             0016*                               ; the TMRx_CTL register is read.
040FA5             0017*   
040FA5             0018*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
040FA5             0019*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
040FA5             0020*   
040FA5             0021*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
040FA5             0022*                               ;  0,and counting stops when the end-of-count value is reached.
040FA5             0023*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
040FA5             0024*                               ; written to the counter when the end-of-count value is reached.
040FA5             0025*   
040FA5             0026*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
040FA5             0027*   CLK_DIV_256:  equ %00001100 ;
040FA5             0028*   CLK_DIV_64:   equ %00001000 ;
040FA5             0029*   CLK_DIV_16:   equ %00000100 ;
040FA5             0030*   CLK_DIV_4:    equ %00000000 ;
040FA5             0031*   
040FA5             0032*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
040FA5             0033*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
040FA5             0034*                               ; When a 1 is written to this bit,the values in the reload registers
040FA5             0035*                               ;  are loaded into the downcounter when the timer restarts. The
040FA5             0036*                               ; programmer must ensure that this bit is set to 1 each time
040FA5             0037*                               ; SINGLE-PASS mode is used.
040FA5             0038*   
040FA5             0039*   ; disable/enable the programmable reload timer
040FA5             0040*   PRT_EN_0:     equ %00000000 ;
040FA5             0041*   PRT_EN_1:     equ %00000001 ;
040FA5             0042*   
040FA5             0043*   ; Table 37. Timer Input Source Select Register
040FA5             0044*   ; Each of the 4 timers are allocated two bits of the 8-bit register
040FA5             0045*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
040FA5             0046*   ;   00: System clock / CLK_DIV
040FA5             0047*   ;   01: RTC / CLK_DIV
040FA5             0048*   ;   NOTE: these are the values given in the manual,but it may be a typo
040FA5             0049*   ;   10: GPIO port B pin 1.
040FA5             0050*   ;   11: GPIO port B pin 1.
040FA5             0051*   TMR_ISS:   equ 92h ; register address
040FA5             0052*   
040FA5             0053*   ; Table 51. Real-Time Clock Control Register
040FA5             0054*   RTC_CTRL: equ EDh ; register address
040FA5             0055*   
040FA5             0056*   ; alarm interrupt disable/enable
040FA5             0057*   RTC_ALARM_0:    equ %00000000
040FA5             0058*   RTC_ALARM_1:    equ %10000000
040FA5             0059*   
040FA5             0060*   ; interrupt on alarm disable/enable
040FA5             0061*   RTC_INT_ENT_0:  equ %00000000
040FA5             0062*   RTC_INT_ENT_1:  equ %01000000
040FA5             0063*   
040FA5             0064*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
040FA5             0065*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
040FA5             0066*   
040FA5             0067*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
040FA5             0068*                                   ; On-chip 32768 Hz oscillator is enabled.
040FA5             0069*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
040FA5             0070*                                   ; On-chip 32768 Hz oscillator is disabled.
040FA5             0071*   
040FA5             0072*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
040FA5             0073*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
040FA5             0074*   
040FA5             0075*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
040FA5             0076*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
040FA5             0077*   
040FA5             0078*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
040FA5             0079*                                   ; RTC counter is enabled.
040FA5             0080*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
040FA5             0081*                                   ; RTC counter is disabled.
040FA5             0082*   
040FA5             0083*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
040FA5             0084*   
040FA5             0085*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
040FA5             0086*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
040FA5 00 00 00    0087*   prt_reload: dl 0x000000
040FA8             0088*   
040FA8             0089*   ; set PRT timer
040FA8             0090*   prt_set:
040FA8 21 00 00 00 0091*       ld hl,0
040FAC 22 F6 0F 04 0092*       ld (prt_irq_counter),hl
040FB0 2A A5 0F 04 0093*       ld hl,(prt_reload)
040FB4 ED 29 84    0094*       out0 ($84),l
040FB7 ED 21 85    0095*   	out0 ($85),h
040FBA             0096*   ; disable timer
040FBA 3E 06       0097*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
040FBC ED 39 83    0098*   	out0 ($83),a
040FBF             0099*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
040FBF 3E 57       0100*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
040FC1 ED 39 83    0101*   	out0 ($83),a
040FC4 C9          0102*       ret
040FC5             0103*   
040FC5             0104*   ; ===============================================
040FC5             0105*   ; PRT Timer Interrupt Handling
040FC5             0106*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
040FC5             0107*   ; -----------------------------------------------
040FC5             0108*   prt_irq_init:
040FC5             0109*       ; set up interrupt vector table 2
040FC5 21 00 00 00 0110*   	ld hl,0
040FC9 3A 0C 01 00 0111*   	ld a,($10c)
040FCD 6F          0112*   	ld l,a
040FCE 3A 0D 01 00 0113*   	ld a,($10d)
040FD2 67          0114*   	ld h,a
040FD3             0115*   
040FD3             0116*   	; skip over CALL ($c3)
040FD3 23          0117*   	inc hl
040FD4             0118*   	; load address of jump into vector table 2 (in ram)
040FD4 ED 27       0119*   	ld hl,(hl)
040FD6             0120*   
040FD6             0121*   	; write CALL prt_irq_handler to vector table 2
040FD6 3E C3       0122*   	ld a,$c3
040FD8 77          0123*   	ld (hl),a
040FD9 23          0124*   	inc hl
040FDA 11 E1 0F 04 0125*   	ld de,prt_irq_handler
040FDE ED 1F       0126*   	ld (hl),de
040FE0             0127*   
040FE0 C9          0128*       ret
040FE1             0129*   
040FE1             0130*   prt_irq_handler:
040FE1 F3          0131*   	di
040FE2 F5          0132*   	push af
040FE3 E5          0133*       push hl
040FE4 ED 38 83    0134*   	in0 a,($83)
040FE7 2A F6 0F 04 0135*   	ld hl,(prt_irq_counter)
040FEB 23          0136*   	inc hl
040FEC 22 F6 0F 04 0137*   	ld (prt_irq_counter),hl
040FF0 E1          0138*       pop hl
040FF1 F1          0139*   	pop af
040FF2 FB          0140*   	ei
040FF3 5B ED 4D    0141*   	reti.l
040FF6             0142*   
040FF6             0143*   prt_irq_counter:
040FF6 00 00 00    0144*   	.dl 0
040FF9             0145*   prt_irq_counter_saved:
040FF9 00 00 00    0146*       .dl 0
040FFC             0147*   
040FFC             0148*   prt_loop_reset:
040FFC E5          0149*       push hl
040FFD 21 00 00 00 0150*   	ld hl,0
041001 22 F6 0F 04 0151*   	ld (prt_irq_counter),hl
041005 22 67 10 04 0152*       ld (prt_loop_counter),hl
041009 22 6A 10 04 0153*       ld (prt_loops),hl
04100D CD A8 0F 04 0154*       call prt_set
041011 E1          0155*       pop hl
041012 C9          0156*       ret
041013             0157*   
041013             0158*   prt_loop_start:
041013 E5          0159*       push hl
041014 21 00 00 00 0160*   	ld hl,0
041018 22 F6 0F 04 0161*   	ld (prt_irq_counter),hl
04101C E1          0162*       pop hl
04101D C9          0163*       ret
04101E             0164*   
04101E             0165*   prt_loop_stop:
04101E E5          0166*       push hl
04101F D5          0167*       push de
041020 2A F6 0F 04 0168*       ld hl,(prt_irq_counter)
041024 ED 5B 67 10 0169*       ld de,(prt_loop_counter)
       04          
041029 19          0170*       add hl,de
04102A 22 67 10 04 0171*       ld (prt_loop_counter),hl
04102E 21 00 00 00 0172*       ld hl,0
041032 22 F6 0F 04 0173*       ld (prt_irq_counter),hl
041036 2A 6A 10 04 0174*       ld hl,(prt_loops)
04103A 23          0175*       inc hl
04103B 22 6A 10 04 0176*       ld (prt_loops),hl
04103F D1          0177*       pop de
041040 E1          0178*       pop hl
041041 C9          0179*       ret
041042             0180*   
041042             0181*   ; inputs: bc = y,x text coordinates to print
041042             0182*   prt_loop_print:
041042 F5          0183*       push af
041043 E5          0184*       push hl
041044 C5          0185*       push bc
041045 D5          0186*       push de
041046 DD E5       0187*       push ix
041048 FD E5       0188*       push iy
04104A CD 4E 11 04 0189*       call vdu_move_cursor
04104E             0190*   
04104E 2A 67 10 04 0191*       ld hl,(prt_loop_counter)
041052 CD CC 00 04 0192*       call printDec
041056             0193*   
041056 2A 6A 10 04 0194*       ld hl,(prt_loops)
04105A CD CC 00 04 0195*       call printDec
04105E             0196*   
04105E FD E1       0197*       pop iy
041060 DD E1       0198*       pop ix
041062 D1          0199*       pop de
041063 C1          0200*       pop bc
041064 E1          0201*       pop hl
041065 F1          0202*       pop af
041066 C9          0203*       ret
041067             0204*   
041067             0205*   prt_loop_counter:
041067 00 00 00    0206*       .dl 0
04106A             0207*   prt_loops:
04106A 00 00 00    0208*       .dl 0
04106D             0209*   
04106D             0210*   ; ===============================================
04106D             0211*   ; Timer functions
04106D             0212*   ; -----------------------------------------------
04106D             0213*   ; set a countdown timer
04106D             0214*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04106D             0215*   ; returns: hl = current time
04106D             0216*   tmr_set:
04106D FD 2F 03    0217*       ld (iy+3),hl            ; set time remaining
041070             0218*       MOSCALL mos_sysvars     ; ix points to syvars table
041070 3E 08       0001*M1 			LD	A, function
041072 5B CF       0002*M1 			RST.LIL	08h
041074 DD 27 00    0219*       ld hl,(ix+sysvar_time)  ; get current time
041077 FD 2F 00    0220*       ld (iy+0),hl            ; set start time
04107A C9          0221*       ret
04107B             0222*   
04107B             0223*   ; gets time remaining on a countdown timer
04107B             0224*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04107B             0225*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04107B             0226*   ;          sign flags: pos = time not expired,zero or neg = time expired
04107B             0227*   tmr_get:
04107B             0228*       MOSCALL mos_sysvars     ; ix points to syvars table
04107B 3E 08       0001*M1 			LD	A, function
04107D 5B CF       0002*M1 			RST.LIL	08h
04107F DD 17 00    0229*       ld de,(ix+sysvar_time)  ; get current time
041082 FD 27 00    0230*       ld hl,(iy+0)            ; get start time
041085 AF          0231*       xor a                   ; clear carry
041086 ED 52       0232*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041088 FD 17 03    0233*       ld de,(iy+3)            ; get timer set value
04108B AF          0234*       xor a                   ; clear carry
04108C ED 5A       0235*       adc hl,de               ; hl = time remaining
04108E             0236*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
04108E C9          0237*       ret
04108F             0238*   
04108F             0239*   tmr_test: ds 6 ; example of a buffer to hold timer data
041095             0240*   
       FF FF FF FF 
       FF FF 
041095 00 00 00    0241*   timestamp_now: dl 0
041098 00 00 00    0242*   timestamp_old: dl 0
04109B 00 00 00    0243*   timestamp_chg: dl 0
04109E             0244*   
04109E             0245*   ; update the global timestamp from the system clock
04109E             0246*   ; inputs: none
04109E             0247*   ; returns: hl = time elapsed in 1/120ths of a second
04109E             0248*   ;          ix = pointer to syvars table
04109E             0249*   ; destroys: af,hl,de,ix
04109E             0250*   timestamp_tick:
04109E ED 5B 95 10 0251*       ld de,(timestamp_now)   ; get previous time
       04          
0410A3 ED 53 98 10 0252*       ld (timestamp_old),de   ; save previous time
       04          
0410A8             0253*       MOSCALL mos_sysvars     ; ix points to syvars table
0410A8 3E 08       0001*M1 			LD	A, function
0410AA 5B CF       0002*M1 			RST.LIL	08h
0410AC DD 27 00    0254*       ld hl,(ix+sysvar_time)  ; get current time
0410AF 22 95 10 04 0255*       ld (timestamp_now),hl   ; save current time
0410B3 AF          0256*       xor a                   ; clear carry
0410B4 ED 52       0257*       sbc hl,de               ; hl = time elapsed
0410B6 22 9B 10 04 0258*       ld (timestamp_chg),hl   ; save elapsed time
0410BA C9          0259*       ret
0410BB             0260*   
0410BB             0261*   ; set a countdown timer
0410BB             0262*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0410BB             0263*   ; requires: timestamp_tick to be called at least once before this function
0410BB             0264*   ; returns: hl = current time
0410BB             0265*   ; destroys: hl
0410BB             0266*   timestamp_tmr_set:
0410BB FD 2F 03    0267*       ld (iy+3),hl            ; set time remaining
0410BE 2A 95 10 04 0268*       ld hl,(timestamp_now)   ; get current timestamp
0410C2 FD 2F 00    0269*       ld (iy+0),hl            ; set start time
0410C5 C9          0270*       ret
0410C6             0271*   
0410C6             0272*   ; gets time remaining on a countdown timer following the global timestamp
0410C6             0273*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0410C6             0274*   ; requires: timestamp_tick to be called at least once before this function
0410C6             0275*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0410C6             0276*   ;          sign flags: pos = time not expired,zero or neg = time expired
0410C6             0277*   ; destroys: af,hl,de
0410C6             0278*   timestamp_tmr_get:
0410C6 ED 5B 95 10 0279*       ld de,(timestamp_now)   ; get current timestamp
       04          
0410CB FD 27 00    0280*       ld hl,(iy+0)            ; get start time
0410CE AF          0281*       xor a                   ; clear carry
0410CF ED 52       0282*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0410D1 FD 17 03    0283*       ld de,(iy+3)            ; get timer set value
0410D4 AF          0284*       xor a                   ; clear carry
0410D5 ED 5A       0285*       adc hl,de               ; hl = time remaining
0410D7             0286*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0410D7 C9          0287*       ret
0410D8             0288*   
0410D8             0289*   ; set a stopwatch
0410D8             0290*   ; returns: hl = start time
0410D8             0291*   ; destroys: hl,ix
0410D8             0292*   stopwatch_set:
0410D8             0293*       MOSCALL mos_sysvars     ; ix points to syvars table
0410D8 3E 08       0001*M1 			LD	A, function
0410DA 5B CF       0002*M1 			RST.LIL	08h
0410DC DD 27 00    0294*       ld hl,(ix+sysvar_time)  ; get current time
0410DF 22 F4 10 04 0295*       ld (stopwatch_started),hl            ; set start time
0410E3 C9          0296*       ret
0410E4             0297*   
0410E4             0298*   ; gets time elapsed on a stopwatch
0410E4             0299*   ; returns: hl = time elapsed in 1/120ths of a second
0410E4             0300*   ; destroys: af,hl,de,ix
0410E4             0301*   stopwatch_get:
0410E4             0302*       MOSCALL mos_sysvars     ; ix points to syvars table
0410E4 3E 08       0001*M1 			LD	A, function
0410E6 5B CF       0002*M1 			RST.LIL	08h
0410E8 DD 27 00    0303*       ld hl,(ix+sysvar_time)  ; get current time
0410EB ED 5B F4 10 0304*       ld de,(stopwatch_started)            ; get start time
       04          
0410F0 AF          0305*       xor a                   ; clear carry
0410F1 ED 52       0306*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0410F3 C9          0307*       ret
0410F4             0308*   
0410F4             0309*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0410F7             0310*   
0410F7             0311*   ; ------------------
0410F7             0312*   ; delay routine
0410F7             0313*   ; Author: Richard Turrnidge
0410F7             0314*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0410F7             0315*   ; routine waits a fixed time,then returns
0410F7             0316*   ; arrive with A =  the delay byte. One bit to be set only.
0410F7             0317*   ; eg. ld A,00000100b
0410F7             0318*   
0410F7             0319*   multiPurposeDelay:
       FF FF FF 
0410F7 F5          0320*       push af
0410F8 C5          0321*       push bc
0410F9 DD E5       0322*       push ix
0410FB 47          0323*       ld b,a
0410FC 3E 08       0324*       ld a,$08
0410FE 5B CF       0325*       RST.LIL	08h                 ; get IX pointer to sysvars
041100             0326*   
041100             0327*   waitLoop:
041100             0328*   
041100 DD 7E 00    0329*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
041103             0330*   
041103             0331*                                   ;   we check if bit set is same as last time we checked.
041103             0332*                                   ;   bit 0 - don't use
041103             0333*                                   ;   bit 1 - changes 64 times per second
041103             0334*                                   ;   bit 2 - changes 32 times per second
041103             0335*                                   ;   bit 3 - changes 16 times per second
041103             0336*   
041103             0337*                                   ;   bit 4 - changes 8 times per second
041103             0338*                                   ;   bit 5 - changes 4 times per second
041103             0339*                                   ;   bit 6 - changes 2 times per second
041103             0340*                                   ;   bit 7 - changes 1 times per second
041103 A0          0341*       and b
041104 4F          0342*       ld c,a
041105 3A 16 11 04 0343*       ld a,(oldTimeStamp)
041109 B9          0344*       cp c                        ; is A same as last value?
04110A 28 F4       0345*       jr z,waitLoop              ; loop here if it is
04110C 79          0346*       ld a,c
04110D 32 16 11 04 0347*       ld (oldTimeStamp),a        ; set new value
041111             0348*   
041111 DD E1       0349*       pop ix
041113 C1          0350*       pop bc
041114 F1          0351*       pop af
041115 C9          0352*       ret
041116             0353*   
041116 00          0354*   oldTimeStamp:   .db 00h
041117             0038        include "vdu.inc"
041117             0001*   ; VDU 30: Home cursor
041117             0002*   vdu_home_cursor:
041117 3E 1E       0003*       ld a,30
041119 5B D7       0004*   	rst.lil $10
04111B C9          0005*   	ret
04111C             0006*   
04111C             0007*   vdu_cursor_on:
04111C 21 27 11 04 0008*   	ld hl,@cmd
041120 01 03 00 00 0009*   	ld bc,@end-@cmd
041124 5B DF       0010*   	rst.lil $18
041126 C9          0011*   	ret
041127             0012*   @cmd:
041127 17 01 01    0013*   	db 23,1,1
04112A             0014*   @end:
04112A             0015*   
04112A             0016*   vdu_cursor_off:
04112A 21 35 11 04 0017*   	ld hl,@cmd
04112E 01 03 00 00 0018*   	ld bc,@end-@cmd
041132 5B DF       0019*   	rst.lil $18
041134 C9          0020*   	ret
041135             0021*   @cmd:
041135 17 01 00    0022*   	db 23,1,0
041138             0023*   @end:
041138             0024*   
041138             0025*   ; VDU 5: Write text at graphics cursor
041138             0026*   ; inputs: a is the character to write to the screen
041138             0027*   ; prerequisites: the graphics cursor at the intended position on screen
041138             0028*   ; outputs: see the name of the function
041138             0029*   ; destroys: a, hl, bc
041138             0030*   vdu_char_to_gfx_cursor:
041138 32 48 11 04 0031*   	ld (@arg),a
04113C 21 47 11 04 0032*   	ld hl,@cmd
041140 01 02 00 00 0033*   	ld bc,@end-@cmd
041144 5B DF       0034*   	rst.lil $18
041146 C9          0035*   	ret
041147 05          0036*   @cmd: db 5
041148 00          0037*   @arg: db 0
041149             0038*   @end:
041149             0039*   ; VDU 9: Move cursor forward one character
041149             0040*   vdu_cursor_forward:
041149 3E 09       0041*       ld a,9
04114B 5B D7       0042*   	rst.lil $10
04114D C9          0043*   	ret
04114E             0044*   
04114E             0045*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
04114E             0046*   ; inputs: c=x, b=y 8-bit unsigned integers
04114E             0047*   vdu_move_cursor:
04114E ED 43 5F 11 0048*       ld (@x0),bc
       04          
041153 21 5E 11 04 0049*   	ld hl,@cmd
041157 01 03 00 00 0050*   	ld bc,@end-@cmd
04115B 5B DF       0051*   	rst.lil $18
04115D C9          0052*   	ret
04115E 1F          0053*   @cmd: 	db 31
04115F 00          0054*   @x0:	db 0
041160 00          0055*   @y0: 	db 0
041161 00          0056*   @end: 	db 0 ; padding
041162             0057*   
041162             0058*   ; VDU 12: Clear text area (CLS)
041162             0059*   vdu_cls:
041162 3E 0C       0060*       ld a,12
041164 5B D7       0061*   	rst.lil $10
041166 C9          0062*   	ret
041167             0063*   
041167             0064*   vdu_flip:
041167 21 72 11 04 0065*   	ld hl,@cmd
04116B 01 03 00 00 0066*   	ld bc,@end-@cmd
04116F 5B DF       0067*   	rst.lil $18
041171 C9          0068*   	ret
041172 17 00 C3    0069*   @cmd: db 23,0,0xC3
041175             0070*   @end:
041175             0071*   
041175             0072*   ; VDU 16: Clear graphics area (CLG)
041175             0073*   vdu_clg:
041175 3E 10       0074*       ld a,16
041177 5B D7       0075*   	rst.lil $10
041179 C9          0076*   	ret
04117A             0077*   
04117A             0078*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
04117A             0079*   ; VDU 23, 7: Scrolling
04117A             0080*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
04117A             0081*   ; inputs: a, extent; l, direction; h; speed
04117A             0082*   vdu_scroll_down:
04117A 32 8F 11 04 0083*   	ld (@extent),a
04117E 22 90 11 04 0084*   	ld (@dir),hl ; implicitly populates @speed
041182 21 8D 11 04 0085*   	ld hl,@cmd
041186 01 05 00 00 0086*   	ld bc,@end-@cmd
04118A 5B DF       0087*   	rst.lil $18     ;; Sending command to VDP
04118C C9          0088*   	ret
04118D 17 07       0089*   @cmd:       db 23,7
04118F 00          0090*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041190 00          0091*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041191 00          0092*   @speed:     db 0x00 ; pixels
041192 00          0093*   @end:		db 0x00 ; padding
041193             0094*   
041193             0095*   ; COLOUR MODES
041193             0096*   ; Mode	Effect
041193             0097*   ; 0	Set on-screen pixel to target colour value
041193             0098*   ; 1	OR value with the on-screen pixel
041193             0099*   ; 2	AND value with the on-screen pixel
041193             0100*   ; 3	XOR value with the on-screen pixel
041193             0101*   ; 4	Invert the on-screen pixel
041193             0102*   ; 5	No operation
041193             0103*   ; 6	AND the inverse of the specified colour with the on-screen pixel
041193             0104*   ; 7	OR the inverse of the specified colour with the on-screen pixel
041193             0105*   
041193             0106*   ; VDU 17, colour: Define text colour (COLOUR)
041193             0107*   vdu_colour_text:
041193 32 A3 11 04 0108*   	ld (@arg),a
041197 21 A2 11 04 0109*   	ld hl,@cmd
04119B 01 02 00 00 0110*   	ld bc,@end-@cmd
04119F 5B DF       0111*   	rst.lil $18
0411A1 C9          0112*   	ret
0411A2 11          0113*   @cmd: db 17
0411A3 00          0114*   @arg: db 0
0411A4             0115*   @end:
0411A4             0116*   
0411A4             0117*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0411A4             0118*   ; inputs: a=mode, c=colour (add 128 to set background colour)
0411A4             0119*   vdu_gcol:
0411A4 32 B9 11 04 0120*   	ld (@mode),a
0411A8 79          0121*       ld a,c
0411A9 32 BA 11 04 0122*       ld (@col),a
0411AD 21 B8 11 04 0123*   	ld hl,@cmd
0411B1 01 03 00 00 0124*   	ld bc,@end-@cmd
0411B5 5B DF       0125*   	rst.lil $18
0411B7 C9          0126*   	ret
0411B8 12          0127*   @cmd:  db 18
0411B9 00          0128*   @mode: db 0
0411BA 00          0129*   @col:  db 0
0411BB             0130*   @end:
0411BB             0131*   
0411BB             0132*   
0411BB             0133*   ; VDU 28, left, bottom, right, top: Set text viewport **
0411BB             0134*   ; MIND THE LITTLE-ENDIANESS
0411BB             0135*   ; inputs: c=left,b=bottom,e=right,d=top
0411BB             0136*   ; outputs; nothing
0411BB             0137*   ; destroys: a might make it out alive
0411BB             0138*   vdu_set_txt_viewport:
0411BB ED 43 D1 11 0139*       ld (@lb),bc
       04          
0411C0 ED 53 D3 11 0140*   	ld (@rt),de
       04          
0411C5 21 D0 11 04 0141*   	ld hl,@cmd
0411C9 01 05 00 00 0142*   	ld bc,@end-@cmd
0411CD 5B DF       0143*   	rst.lil $18
0411CF C9          0144*   	ret
0411D0 1C          0145*   @cmd:   db 28 ; set text viewport command
0411D1 00 00       0146*   @lb: 	dw 0x0000 ; set by bc
0411D3 00 00       0147*   @rt: 	dw 0x0000 ; set by de
0411D5 00          0148*   @end:   db 0x00	  ; padding
0411D6             0149*   
0411D6             0150*   ; Wait for VBLANK interrupt
0411D6             0151*   vdu_vblank:
0411D6 DD E5       0152*       PUSH 	IX
0411D8             0153*   	MOSCALL	mos_sysvars
0411D8 3E 08       0001*M1 			LD	A, function
0411DA 5B CF       0002*M1 			RST.LIL	08h
0411DC DD 7E 00    0154*   	LD	A, (IX + sysvar_time + 0)
0411DF             0155*   @wait:
0411DF DD BE 00    0156*       CP 	A, (IX + sysvar_time + 0)
0411E2 28 FB       0157*       JR	Z, @wait
0411E4 DD E1       0158*       POP	IX
0411E6 C9          0159*       RET
0411E7             0160*   
0411E7             0161*   ; VDU 29, x; y;: Set graphics origin
0411E7             0162*   ; This command sets the graphics origin.
0411E7             0163*   ; The origin is the point on the screen where the coordinates (0,0) are located.
0411E7             0164*   ; inputs: bc=x0,de=y0
0411E7             0165*   ; outputs; nothing
0411E7             0166*   ; destroys: a might make it out alive
0411E7             0167*   vdu_set_gfx_origin:
0411E7 ED 43 FD 11 0168*       ld (@x0),bc
       04          
0411EC ED 53 FF 11 0169*       ld (@y0),de
       04          
0411F1 21 FC 11 04 0170*       ld hl,@cmd
0411F5 01 05 00 00 0171*       ld bc,@end-@cmd
0411F9 5B DF       0172*       rst.lil $18
0411FB C9          0173*       ret
0411FC 1D          0174*   @cmd:   db 29 ; set graphics origin command
0411FD 00 00       0175*   @x0: 	dw 0x0000 ; set by bc
0411FF 00 00       0176*   @y0: 	dw 0x0000 ; set by de
041201 00          0177*   @end:   db 0x00	  ; padding
041202             0178*   
041202             0179*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
041202             0180*   ; NOTE: the order of the y-coordinate parameters are inverted
041202             0181*   ; 	because we have turned off logical screen scaling
041202             0182*   ; NOTE: coordinates are relative to current gfx origin
041202             0183*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041202             0184*   ; outputs; nothing
041202             0185*   ; destroys: a might make it out alive
041202             0186*   vdu_set_gfx_viewport:
041202 ED 43 22 12 0187*       ld (@x0),bc
       04          
041207 FD 22 24 12 0188*       ld (@y1),iy
       04          
04120C DD 22 26 12 0189*   	ld (@x1),ix
       04          
041211 ED 53 28 12 0190*   	ld (@y0),de
       04          
041216 21 21 12 04 0191*   	ld hl,@cmd
04121A 01 09 00 00 0192*   	ld bc,@end-@cmd
04121E 5B DF       0193*   	rst.lil $18
041220 C9          0194*   	ret
041221 18          0195*   @cmd:   db 24 ; set graphics viewport command
041222 00 00       0196*   @x0: 	dw 0x0000 ; set by bc
041224 00 00       0197*   @y1: 	dw 0x0000 ; set by iy
041226 00 00       0198*   @x1: 	dw 0x0000 ; set by ix
041228 00 00       0199*   @y0: 	dw 0x0000 ; set by de
04122A 00          0200*   @end:   db 0x00	  ; padding
04122B             0201*   
04122B             0202*   ; SCREEN MODES
04122B             0203*   ; ===============================
04122B             0204*   ; Mode  Horz  Vert  Cols  Refresh
04122B             0205*   ; ---   ----  ----  ----  -------
04122B             0206*   ; 11    320   240   2     60hz
04122B             0207*   ; 139   320   240   2     60hz
04122B             0208*   ; 23    512   384   2     60hz
04122B             0209*   ; 151   512   384   2     60hz
04122B             0210*   ; 6     640   240   2     60hz
04122B             0211*   ; 134   640   240   2     60hz
04122B             0212*   ; 2     640   480   2     60hz
04122B             0213*   ; 130   640   480   2     60hz
04122B             0214*   ; 17    800   600   2     60hz
04122B             0215*   ; 145   800   600   2     60hz
04122B             0216*   ; 18    1024  768   2     60hz
04122B             0217*   ; 146   1024  768   2     60hz
04122B             0218*   ; ---   ----  ----  ----  -------
04122B             0219*   ; 10    320   240   4     60hz
04122B             0220*   ; 138   320   240   4     60hz
04122B             0221*   ; 22    512   384   4     60hz
04122B             0222*   ; 150   512   384   4     60hz
04122B             0223*   ; 5     640   240   4     60hz
04122B             0224*   ; 133   640   240   4     60hz
04122B             0225*   ; 1     640   480   4     60hz
04122B             0226*   ; 129   640   480   4     60hz
04122B             0227*   ; 16    800   600   4     60hz
04122B             0228*   ; 19    1024  768   4     60hz
04122B             0229*   ; ---   ----  ----  ----  -------
04122B             0230*   ; 9     320   240   16    60hz
04122B             0231*   ; 137   320   240   16    60hz
04122B             0232*   ; 21    512   384   16    60hz
04122B             0233*   ; 149   512   384   16    60hz
04122B             0234*   ; 4     640   240   16    60hz
04122B             0235*   ; 132   640   240   16    60hz
04122B             0236*   ; 0     640   480   16    60hz
04122B             0237*   ; 7     n/a   n/a   16    60hz
04122B             0238*   ; ---   ----  ----  ----  -------
04122B             0239*   ; 8     320   240   64    60hz
04122B             0240*   ; 136   320   240   64    60hz
04122B             0241*   ; 20    512   384   64    60hz
04122B             0242*   ; 3     640   240   64    60hz
04122B             0243*   ; ---   ----  ----  ----  -------
04122B             0244*   vdu_set_screen_mode:
04122B 32 3B 12 04 0245*   	ld (@arg),a
04122F 21 3A 12 04 0246*   	ld hl,@cmd
041233 01 02 00 00 0247*   	ld bc,@end-@cmd
041237 5B DF       0248*   	rst.lil $18
041239 C9          0249*   	ret
04123A 16          0250*   @cmd: db 22 ; set screen mode
04123B 00          0251*   @arg: db 0  ; screen mode parameter
04123C             0252*   @end:
04123C             0253*   
04123C             0254*   ; get the current screen mode
04123C             0255*   ; inputs: none
04123C             0256*   ; outputs: a=screen mode
04123C             0257*   ; destroys: af, ix
04123C             0258*   vdu_get_screen_mode:
04123C             0259*       MOSCALL mos_sysvars
04123C 3E 08       0001*M1 			LD	A, function
04123E 5B CF       0002*M1 			RST.LIL	08h
041240 DD 7E 27    0260*       ld a,(IX+sysvar_scrMode)
041243 C9          0261*       ret
041244             0262*   ; end vdu_get_screen_mode
041244             0263*   
041244             0264*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041244             0265*   ; inputs: a is scaling mode, 1=on, 0=off
041244             0266*   ; note: default setting on boot is scaling ON
041244             0267*   vdu_set_scaling:
041244 32 56 12 04 0268*   	ld (@arg),a
041248 21 53 12 04 0269*   	ld hl,@cmd
04124C 01 04 00 00 0270*   	ld bc,@end-@cmd
041250 5B DF       0271*   	rst.lil $18
041252 C9          0272*   	ret
041253 17 00 C0    0273*   @cmd: db 23,0,0xC0
041256 00          0274*   @arg: db 0  ; scaling on/off
041257             0275*   @end:
041257             0276*   
041257             0277*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041257             0278*   ; inputs: hl=bufferId
041257             0279*   vdu_buff_select:
041257 22 69 12 04 0280*   	ld (@bufferId),hl
04125B 21 66 12 04 0281*   	ld hl,@cmd
04125F 01 05 00 00 0282*   	ld bc,@end-@cmd
041263 5B DF       0283*   	rst.lil $18
041265 C9          0284*   	ret
041266 17 1B 20    0285*   @cmd: db 23,27,0x20
041269 00 00       0286*   @bufferId: dw 0x0000
04126B 00          0287*   @end: db 0x00 ; padding
04126C             0288*   
04126C             0289*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
04126C             0290*   ; inputs: a=format; bc=width; de=height
04126C             0291*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
04126C             0292*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
04126C             0293*   ; 0 	RGBA8888 (4-bytes per pixel)
04126C             0294*   ; 1 	RGBA2222 (1-bytes per pixel)
04126C             0295*   ; 2 	Mono/Mask (1-bit per pixel)
04126C             0296*   ; 3 	Reserved for internal use by VDP (“native” format)
04126C             0297*   vdu_bmp_create:
04126C ED 43 88 12 0298*       ld (@width),bc
       04          
041271 ED 53 8A 12 0299*       ld (@height),de
       04          
041276 32 8C 12 04 0300*       ld (@fmt),a
04127A 21 85 12 04 0301*   	ld hl,@cmd
04127E 01 08 00 00 0302*   	ld bc,@end-@cmd
041282 5B DF       0303*   	rst.lil $18
041284 C9          0304*   	ret
041285 17 1B 21    0305*   @cmd:       db 23,27,0x21
041288 00 00       0306*   @width:     dw 0x0000
04128A 00 00       0307*   @height:    dw 0x0000
04128C 00          0308*   @fmt:       db 0x00
04128D             0309*   @end:
04128D             0310*   
04128D             0311*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
04128D             0312*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
04128D             0313*   vdu_load_img_rgba2_to_8:
04128D             0314*   ; backup the target buffer id and image dimensions
04128D E5          0315*       push hl
04128E D5          0316*       push de
04128F C5          0317*       push bc
041290             0318*   ; load the rgba2 image to working buffer 65534
041290 21 FE FF 00 0319*       ld hl,65534 ; temporary working buffer id
041294 CD 6B 13 04 0320*   	call vdu_load_buffer_from_file
041298             0321*   ; restore the image dimensions and target buffer id
041298 C1          0322*       pop bc
041299 D1          0323*       pop de
04129A E1          0324*       pop hl
04129B             0325*   ; fall through to vdu_rgba2_to_8
04129B             0326*   
04129B             0327*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
04129B             0328*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
04129B             0329*   ; the "expand bitmap" command is:
04129B             0330*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04129B             0331*   ; and then to reverse the byte order to fix endian-ness:
04129B             0332*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04129B             0333*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04129B             0334*   ; VDU 23,27,&20,targetBufferID%;
04129B             0335*   ; VDU 23,27,&21,width%;height%;0
04129B             0336*   ; -------------------------------------------------------------------
04129B             0337*   ; inputs: bc,de image width,height ; hl = targetBufferId
04129B             0338*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
04129B             0339*   vdu_rgba2_to_8:
04129B             0340*   ; load the image dimensions and buffer id parameters
04129B ED 43 F7 12 0341*       ld (@width),bc
       04          
0412A0 ED 53 F9 12 0342*       ld (@height),de
       04          
0412A5 22 DC 12 04 0343*       ld (@bufferId0),hl
0412A9 22 E9 12 04 0344*       ld (@bufferId2),hl
0412AD 22 F2 12 04 0345*       ld (@bufferId1),hl
0412B1             0346*   ; clean up bytes that got stomped on by the ID loads
0412B1 3E 48       0347*       ld a,0x48
0412B3 32 DE 12 04 0348*       ld (@bufferId0+2),a
0412B7 3E 17       0349*       ld a,23
0412B9 32 F4 12 04 0350*       ld (@bufferId1+2),a
0412BD 3E 18       0351*       ld a,24
0412BF 32 EB 12 04 0352*       ld (@bufferId2+2),a
0412C3 AF          0353*       xor a
0412C4 32 FB 12 04 0354*       ld (@height+2),a
0412C8             0355*   ; send the vdu command strings
0412C8 21 D3 12 04 0356*       ld hl,@beg
0412CC 01 29 00 00 0357*       ld bc,@end-@beg
0412D0 5B DF       0358*       rst.lil $18
0412D2 C9          0359*       ret
0412D3             0360*   @beg:
0412D3             0361*   ; Command 14: Consolidate blocks in a buffer
0412D3             0362*   ; VDU 23, 0, &A0, bufferId; 14
0412D3 17 00 A0    0363*       db 23,0,0xA0
0412D6 FE FF       0364*       dw 65534 ; workingBufferId
0412D8 0E          0365*       db 14 ; consolidate blocks
0412D9             0366*   ; the "expand bitmap" command is:
0412D9             0367*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0412D9 17 00 A0    0368*       db 23,0,0xA0
0412DC 00 00       0369*   @bufferId0: dw 0x0000 ; targetBufferId
0412DE 48          0370*       db 0x48 ; given as decimal command 72 in the docs
0412DF 02          0371*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0412E0 FE FF       0372*       dw 65534 ; sourceBufferId
0412E2 00 7F BF FF 0373*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0412E6             0374*   ; reverse the byte order to fix endian-ness:
0412E6             0375*   ; Command 24: Reverse the order of data of blocks within a buffer
0412E6             0376*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0412E6             0377*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0412E6 17 00 A0    0378*       db 23,0,0xA0
0412E9 00 00       0379*   @bufferId2:    dw 0x0000 ; targetBufferId
0412EB 18          0380*       db 24 ; reverse byte order
0412EC 04          0381*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0412ED 04 00       0382*       dw 4 ; size (4 bytes)
0412EF             0383*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0412EF             0384*   ; VDU 23,27,&20,targetBufferID%;
0412EF 17 1B 20    0385*       db 23,27,0x20 ; select bitmap
0412F2 00 00       0386*   @bufferId1: dw 0x0000 ; targetBufferId
0412F4             0387*   ; VDU 23,27,&21,width%;height%;0
0412F4 17 1B 21    0388*       db 23,27,0x21 ; create bitmap from buffer
0412F7 00 00       0389*   @width: dw 0x0000
0412F9 00 00       0390*   @height: dw 0x0000
0412FB 00          0391*       db 0x00 ; rgba8888 format
0412FC             0392*   @end:
0412FC             0393*   
0412FC             0394*   ; scratch variables
0412FC 00 00 00    0395*   bufferId0: dl 0x000000
0412FF 00 00 00    0396*   bufferId1: dl 0x000000
041302             0397*   
041302             0398*   ; load a vdu buffer from local memory
041302             0399*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041302             0400*   vdu_load_buffer:
041302 ED 43 2B 13 0401*       ld (@length),bc
       04          
041307 D5          0402*       push de ; save data pointer
041308             0403*   ; send the vdu command string
041308 7D          0404*       ld a,l
041309 32 28 13 04 0405*       ld (@bufferId),a
04130D 7C          0406*       ld a,h
04130E 32 29 13 04 0407*       ld (@bufferId+1),a
041312 21 25 13 04 0408*       ld hl,@cmd
041316 01 08 00 00 0409*       ld bc,@end-@cmd
04131A 5B DF       0410*       rst.lil $18
04131C             0411*   ; send the buffer data
04131C E1          0412*       pop hl ; pointer to data
04131D ED 4B 2B 13 0413*       ld bc,(@length)
       04          
041322 5B DF       0414*       rst.lil $18 ; send it
041324 C9          0415*       ret
041325             0416*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041325 17 00 A0    0417*   @cmd:       db 23,0,0xA0
041328 00 00       0418*   @bufferId:	dw 0x0000
04132A 00          0419*   		    db 0 ; load buffer
04132B 00 00       0420*   @length:	dw 0x0000
04132D 00          0421*   @end: db 0 ; padding
04132E             0422*   
04132E             0423*   ; Command 14: Consolidate blocks in a buffer
04132E             0424*   vdu_consolidate_buffer:
04132E             0425*   ; set parameters for vdu call
04132E 7D          0426*       ld a,l
04132F 32 46 13 04 0427*       ld (@bufferId),a
041333 7C          0428*       ld a,h
041334 32 47 13 04 0429*       ld (@bufferId+1),a
041338 21 43 13 04 0430*       ld hl,@beg
04133C 01 06 00 00 0431*       ld bc,@end-@beg
041340 5B DF       0432*       rst.lil $18
041342 C9          0433*       ret
041343             0434*   ; VDU 23, 0, &A0, bufferId; 14
041343 17 00 A0    0435*   @beg: db 23,0,0xA0
041346 00 00       0436*   @bufferId: dw 0x0000
041348 0E          0437*              db 14
041349             0438*   @end:
041349             0439*   
041349             0440*   ; load an image file to a buffer and make it a bitmap
041349             0441*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041349             0442*   vdu_load_img:
041349             0443*   ; back up image type and dimension parameters
041349 22 FC 12 04 0444*       ld (bufferId0),hl
04134D F5          0445*       push af
04134E C5          0446*   	push bc
04134F D5          0447*   	push de
041350             0448*   ; load the image
041350 CD 6B 13 04 0449*   	call vdu_load_buffer_from_file
041354             0450*   ; now make it a bitmap
041354 2A FC 12 04 0451*       ld hl,(bufferId0)
041358 CD 2E 13 04 0452*       call vdu_consolidate_buffer
04135C 2A FC 12 04 0453*       ld hl,(bufferId0)
041360 CD 57 12 04 0454*       call vdu_buff_select
041364 D1          0455*   	pop de ; image height
041365 C1          0456*   	pop bc ; image width
041366 F1          0457*   	pop af ; image type
041367 C3 6C 12 04 0458*   	jp vdu_bmp_create ; will return to caller from there
04136B             0459*   
04136B             0460*   ; inputs: hl = bufferId; iy = pointer to filename
04136B             0461*   vdu_load_buffer_from_file:
04136B 22 FC 12 04 0462*       ld (bufferId0),hl
04136F             0463*   
04136F             0464*   ; clear target buffer
04136F CD 17 15 04 0465*       call vdu_clear_buffer
041373             0466*   
041373             0467*   ; open the file in read mode
041373             0468*   ; Open a file
041373             0469*   ; HLU: Filename
041373             0470*   ;   C: Mode
041373             0471*   ; Returns:
041373             0472*   ;   A: Filehandle, or 0 if couldn't open
041373 FD E5       0473*   	push iy ; pointer to filename
041375 E1          0474*   	pop hl
041376 0E 01       0475*   	ld c,fa_read
041378             0476*       MOSCALL mos_fopen
041378 3E 0A       0001*M1 			LD	A, function
04137A 5B CF       0002*M1 			RST.LIL	08h
04137C 32 B7 13 04 0477*       ld (@filehandle),a
041380             0478*   
041380             0479*   @read_file:
041380             0480*   ; Read a block of data from a file
041380             0481*   ;   C: Filehandle
041380             0482*   ; HLU: Pointer to where to write the data to
041380             0483*   ; DEU: Number of bytes to read
041380             0484*   ; Returns:
041380             0485*   ; DEU: Number of bytes read
041380 3A B7 13 04 0486*       ld a,(@filehandle)
041384 4F          0487*       ld c,a
041385 21 00 E0 B7 0488*       ld hl,filedata
041389 11 00 20 00 0489*       ld de,8192 ; max we can read into onboard sram at one time
04138D             0490*       MOSCALL mos_fread
04138D 3E 1A       0001*M1 			LD	A, function
04138F 5B CF       0002*M1 			RST.LIL	08h
041391             0491*   
041391             0492*   ; test de for zero bytes read
041391 21 00 00 00 0493*       ld hl,0
041395 AF          0494*       xor a ; clear carry
041396 ED 52       0495*       sbc hl,de
041398 CA AE 13 04 0496*       jp z,@close_file
04139C             0497*   
04139C             0498*   ; load a vdu buffer from local memory
04139C             0499*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04139C 2A FC 12 04 0500*       ld hl,(bufferId0)
0413A0 D5          0501*       push de ; chunksize
0413A1 C1          0502*       pop bc
0413A2 11 00 E0 B7 0503*       ld de,filedata
0413A6 CD 02 13 04 0504*       call vdu_load_buffer
0413AA             0505*   
0413AA             0506*   ; read the next block
0413AA C3 80 13 04 0507*       jp @read_file
0413AE             0508*   
0413AE             0509*   ; close the file
0413AE             0510*   @close_file:
0413AE 3A B7 13 04 0511*       ld a,(@filehandle)
0413B2             0512*       MOSCALL mos_fclose
0413B2 3E 0B       0001*M1 			LD	A, function
0413B4 5B CF       0002*M1 			RST.LIL	08h
0413B6 C9          0513*       ret ; vdu_load_buffer_from_file
0413B7             0514*   
0413B7 00          0515*   @filehandle: db 0 ; file handle
0413B8 00 00 00    0516*   @fil: dl 0 ; pointer to FIL struct
0413BB             0517*   
0413BB 00 00 00    0518*   @chunkpointer: dl 0 ; pointer to current chunk
0413BE             0519*   
0413BE             0520*   ; File information structure (FILINFO)
0413BE             0521*   @filinfo:
0413BE 00 00 00 00 0522*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0413C2 00 00       0523*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0413C4 00 00       0524*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0413C6 00          0525*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0413C7 00 00 00 00 0526*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0413D4 00 00 00 00 0527*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414D4             0039        include "vdu_buffered_api.inc"
0414D4             0001*   ; https://agonconsole8.github.io/agon-docs/vdp/Buffered-Commands-API/
0414D4             0002*   
0414D4             0003*   ; Command 0: Write block to a buffer
0414D4             0004*   ; VDU 23, 0, &A0, bufferId; 0, length; <buffer-data>
0414D4             0005*   ; inputs: hl = bufferId, bc = length of data, de = pointer to data
0414D4             0006*   vdu_write_block_to_buffer:
0414D4             0007*   ; back up input parameters
0414D4 D5          0008*       push de ; pointer to data
0414D5 C5          0009*       push bc ; length of data
0414D6             0010*   ; set up the vdu command string
0414D6 22 F6 14 04 0011*       ld (@bufferId),hl
0414DA ED 43 F9 14 0012*       ld (@length),bc
       04          
0414DF AF          0013*       xor a ; load buffer
0414E0 32 F8 14 04 0014*       ld (@bufferId+2),a
0414E4 21 F3 14 04 0015*       ld hl,@cmd0
0414E8 01 08 00 00 0016*       ld bc,@end0-@cmd0
0414EC 5B DF       0017*       rst.lil $18
0414EE             0018*   ; send the buffer data
0414EE C1          0019*       pop bc ; length of data
0414EF E1          0020*       pop hl ; pointer to data (was de)
0414F0 5B DF       0021*       rst.lil $18 ; send it
0414F2 C9          0022*       ret
0414F3             0023*   ; command string data
0414F3 17 00 A0    0024*   @cmd0:      db 23,0,0xA0
0414F6 00 00       0025*   @bufferId:	dw 0x0000
0414F8 00          0026*               db 0 ; load buffer
0414F9 00 00       0027*   @length:	dw 0x0000
0414FB 00          0028*   @end0:      db 0x00 ; padding
0414FC             0029*   ; end vdu_write_block_to_buffer
0414FC             0030*   
0414FC             0031*   ; Command 1: Call a buffer
0414FC             0032*   ; VDU 23, 0, &A0, bufferId; 1
0414FC             0033*   ; inputs: hl = bufferId
0414FC             0034*   vdu_call_buffer:
0414FC 22 14 15 04 0035*       ld (@bufferId),hl
041500 3E 01       0036*       ld a,1 ; call buffer
041502 32 16 15 04 0037*       ld (@bufferId+2),a
041506 21 11 15 04 0038*       ld hl,@cmd
04150A 01 06 00 00 0039*       ld bc,@end-@cmd
04150E 5B DF       0040*       rst.lil $18
041510 C9          0041*       ret
041511 17 00 A0    0042*   @cmd:     db 23,0,0xA0
041514 00 00       0043*   @bufferId: dw 0x0000
041516 01          0044*              db 1 ; call buffer
041517             0045*   @end:
041517             0046*   ; end vdu_call_buffer
041517             0047*   
041517             0048*   ; Command 2: Clear a buffer
041517             0049*   ; VDU 23, 0 &A0, bufferId; 2
041517             0050*   ; inputs: hl = bufferId
041517             0051*   vdu_clear_buffer:
041517 22 2F 15 04 0052*       ld (@bufferId),hl
04151B 3E 02       0053*       ld a,2 ; clear buffer
04151D 32 31 15 04 0054*       ld (@bufferId+2),a
041521 21 2C 15 04 0055*       ld hl,@cmd
041525 01 06 00 00 0056*       ld bc,@end-@cmd
041529 5B DF       0057*       rst.lil $18
04152B C9          0058*       ret
04152C 17 00 A0    0059*   @cmd:     db 23,0,0xA0
04152F 00 00       0060*   @bufferId: dw 0x0000
041531 02          0061*              db 2 ; clear buffer
041532             0062*   @end:
041532             0063*   ; end vdu_clear_buffer
041532             0064*   
041532             0065*   ; Clear all buffers
041532             0066*   ; inputs: none
041532             0067*   vdu_clear_all_buffers:
041532             0068*   ; clear all buffers
041532 21 3D 15 04 0069*       ld hl,@beg
041536 01 06 00 00 0070*       ld bc,@end-@beg
04153A 5B DF       0071*       rst.lil $18
04153C C9          0072*       ret
04153D 17 00 A0    0073*   @beg: db 23,0,$A0
041540 FF FF       0074*         dw -1 ; bufferId -1 (65535) means clear all buffers
041542 02          0075*         db 2  ; command 2: clear a buffer
041543             0076*   @end:
041543             0077*   ; end vdu_clear_all_buffers
041543             0078*   
041543             0079*   ; Command 3: Create a writeable buffer
041543             0080*   ; VDU 23, 0 &A0, bufferId; 3, length;
041543             0081*   ; inputs: hl = bufferId, bc = length
041543             0082*   vdu_create_writeable_buffer:
041543 22 60 15 04 0083*       ld (@bufferId),hl
041547 ED 43 63 15 0084*       ld (@length),bc
       04          
04154C 3E 03       0085*       ld a,3 ; create writeable buffer
04154E 32 62 15 04 0086*       ld (@bufferId+2),a
041552 21 5D 15 04 0087*       ld hl,@cmd
041556 01 08 00 00 0088*       ld bc,@end-@cmd
04155A 5B DF       0089*       rst.lil $18
04155C C9          0090*       ret
04155D 17 00 A0    0091*   @cmd:     db 23,0,0xA0
041560 00 00       0092*   @bufferId: dw 0x0000
041562 03          0093*              db 3 ; create writeable buffer
041563 00 00       0094*   @length: dw 0x0000
041565 00          0095*   @end:     db 0x00 ; padding
041566             0096*   ; end vdu_create_writeable_buffer
041566             0097*   
041566             0098*   ; Command 4: Set output stream to a buffer
041566             0099*   ; VDU 23, 0 &A0, bufferId; 4
041566             0100*   ; inputs: hl = bufferId
041566             0101*   vdu_set_output_stream_buffer:
041566 22 7E 15 04 0102*       ld (@bufferId),hl
04156A 3E 04       0103*       ld a,4 ; set output stream to buffer
04156C 32 80 15 04 0104*       ld (@bufferId+2),a
041570 21 7B 15 04 0105*       ld hl,@cmd
041574 01 06 00 00 0106*       ld bc,@end-@cmd
041578 5B DF       0107*       rst.lil $18
04157A C9          0108*       ret
04157B 17 00 A0    0109*   @cmd:     db 23,0,0xA0
04157E 00 00       0110*   @bufferId: dw 0x0000
041580 04          0111*              db 4 ; set output stream to buffer
041581 00          0112*   @end:     db 0x00 ; padding
041582             0113*   ; end vdu_set_output_stream_buffer
041582             0114*   
041582             0115*   ; Command 5: Adjust buffer contents
041582             0116*   ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
041582             0117*   vdu_adjust_buffer:
041582 C9          0118*       ret ; TODO: implement
041583             0119*   ; end vdu_adjust_buffer
041583             0120*   
041583             0121*   ; Command 6: Conditionally call a buffer
041583             0122*   ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
041583             0123*   vdu_call_buffer_conditional:
041583 C9          0124*       ret ; TODO: implement
041584             0125*   ; end vdu_call_buffer_conditional
041584             0126*   
041584             0127*   ; Command 7: Jump to a buffer
041584             0128*   ; VDU 23, 0, &A0, bufferId; 7
041584             0129*   ; inputs: hl = bufferId
041584             0130*   vdu_jump_to_buffer:
041584 22 9C 15 04 0131*       ld (@bufferId),hl
041588 3E 07       0132*       ld a,7 ; jump to buffer
04158A 32 9E 15 04 0133*       ld (@bufferId+2),a
04158E 21 99 15 04 0134*       ld hl,@cmd
041592 01 06 00 00 0135*       ld bc,@end-@cmd
041596 5B DF       0136*       rst.lil $18
041598 C9          0137*       ret
041599 17 00 A0    0138*   @cmd:     db 23,0,0xA0
04159C 00 00       0139*   @bufferId: dw 0x0000
04159E 07          0140*              db 7 ; jump to buffer
04159F 00          0141*   @end:     db 0x00 ; padding
0415A0             0142*   ; end vdu_jump_to_buffer
0415A0             0143*   
0415A0             0144*   ; Command 8: Conditional Jump to a buffer
0415A0             0145*   ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
0415A0             0146*   vdu_jump_to_buffer_conditional:
0415A0 C9          0147*       ret ; TODO: implement
0415A1             0148*   ; end vdu_jump_to_buffer_conditional
0415A1             0149*   
0415A1             0150*   ; Command 9: Jump to an offset in a buffer
0415A1             0151*   ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
0415A1             0152*   vdu_jump_to_buffer_offset:
0415A1 C9          0153*       ret ; TODO: implement
0415A2             0154*   ; end vdu_jump_to_buffer_offset
0415A2             0155*   
0415A2             0156*   ; Command 10: Conditional jump to an offset in a buffer
0415A2             0157*   ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
0415A2             0158*   vdu_jump_to_buffer_offset_conditional:
0415A2 C9          0159*       ret ; TODO: implement
0415A3             0160*   ; end vdu_jump_to_buffer_offset_conditional
0415A3             0161*   
0415A3             0162*   ; Command 11: Call buffer with an offset
0415A3             0163*   ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
0415A3             0164*   vdu_call_buffer_offset:
0415A3 C9          0165*       ret ; TODO: implement
0415A4             0166*   ; end vdu_call_buffer_offset
0415A4             0167*   
0415A4             0040        include "vdu_fonts.inc"
0415A4             0001*   ; select font
0415A4             0002*   ; inputs: hl = bufferId, a = font flags
0415A4             0003*   ; Flags:
0415A4             0004*   ; Bit	Description
0415A4             0005*   ; 0	Adjust cursor position to ensure text baseline is aligned
0415A4             0006*   ;   0: Do not adjust cursor position (best for changing font on a new line)
0415A4             0007*   ;   1: Adjust cursor position (best for changing font in the middle of a line)
0415A4             0008*   ; 1-7	Reserved for future use
0415A4             0009*   ; VDU 23, 0, &95, 0, bufferId; flags: Select font
0415A4             0010*   vdu_font_select:
0415A4 22 BB 15 04 0011*       ld (@bufferId),hl
0415A8 32 BD 15 04 0012*       ld (@flags),a
0415AC 21 B7 15 04 0013*       ld hl,@cmd
0415B0 01 07 00 00 0014*       ld bc,@end-@cmd
0415B4 5B DF       0015*       rst.lil $18
0415B6 C9          0016*       ret
0415B7 17 00 95 00 0017*   @cmd: db 23, 0, 0x95, 0
0415BB 00 00       0018*   @bufferId: dw 0x0000
0415BD 00          0019*   @flags: db 0x00
0415BE             0020*   @end:
0415BE             0021*   
0415BE             0022*   ; create font from buffer
0415BE             0023*   ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
0415BE             0024*   ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
0415BE             0025*   vdu_font_create:
0415BE 22 E3 15 04 0026*       ld (@bufferId),hl
0415C2 ED 53 E5 15 0027*       ld (@width),de ; also loads height
       04          
0415C7 32 E8 15 04 0028*       ld (@flags),a
0415CB 7A          0029*       ld a,d ; height
0415CC 32 E7 15 04 0030*       ld (@ascent),a ; ascent = height
0415D0             0031*   ; consolidate buffer
0415D0 CD 2E 13 04 0032*       call vdu_consolidate_buffer
0415D4             0033*   ; create font
0415D4 21 DF 15 04 0034*       ld hl,@cmd
0415D8 01 0A 00 00 0035*       ld bc,@end-@cmd
0415DC 5B DF       0036*       rst.lil $18
0415DE C9          0037*       ret
0415DF 17 00 95 01 0038*   @cmd: db 23, 0, 0x95, 1
0415E3 00 00       0039*   @bufferId: dw 0x0000
0415E5 00          0040*   @width: db 0x00
0415E6 00          0041*   @height: db 0x00
0415E7 00          0042*   @ascent: db 0x00
0415E8 00          0043*   @flags: db 0x00
0415E9             0044*   @end:
0415E9             0045*   
0415E9             0046*   ; set or adjust font property
0415E9             0047*   ; inputs: hl = bufferId, a = field, de = value
0415E9             0048*   ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
0415E9             0049*   vdu_font_property:
0415E9 22 05 16 04 0050*       ld (@bufferId),hl
0415ED 32 07 16 04 0051*       ld (@field),a
0415F1 ED 53 08 16 0052*       ld (@value),de
       04          
0415F6 21 01 16 04 0053*       ld hl,@cmd
0415FA 01 09 00 00 0054*       ld bc,@end-@cmd
0415FE 5B DF       0055*       rst.lil $18
041600 C9          0056*       ret
041601 17 00 95 02 0057*   @cmd: db 23, 0, 0x95, 2
041605 00 00       0058*   @bufferId: dw 0x0000
041607 00          0059*   @field: db 0x00
041608 00 00       0060*   @value: dw 0x0000
04160A 00          0061*   @end: db 0x00 ; padding
04160B             0062*   
04160B             0063*   ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
04160B             0064*   
04160B             0065*   ; Clear/Delete font
04160B             0066*   ; inputs: hl = bufferId
04160B             0067*   ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
04160B             0068*   vdu_font_clear:
04160B 22 1E 16 04 0069*       ld (@bufferId),hl
04160F 21 1A 16 04 0070*       ld hl,@cmd
041613 01 06 00 00 0071*       ld bc,@end-@cmd
041617 5B DF       0072*       rst.lil $18
041619 C9          0073*       ret
04161A 17 00 95 04 0074*   @cmd: db 23, 0, 0x95, 4
04161E 00 00       0075*   @bufferId: dw 0x0000
041620 00          0076*   @end: db 0x00 ; padding
041621             0077*   
041621             0078*   ; Copy system font to buffer
041621             0079*   ; inputs: hl = bufferId
041621             0080*   ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
041621             0081*   vdu_font_copy_system:
041621 22 34 16 04 0082*       ld (@bufferId),hl
041625 21 30 16 04 0083*       ld hl,@cmd
041629 01 06 00 00 0084*       ld bc,@end-@cmd
04162D 5B DF       0085*       rst.lil $18
04162F C9          0086*       ret
041630 17 00 95 05 0087*   @cmd: db 23, 0, 0x95, 5
041634 00 00       0088*   @bufferId: dw 0x0000
041636 00          0089*   @end: db 0x00 ; padding
041637             0041        include "vdu_plot.inc"
041637             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041637             0002*   ; PLOT code 	(Decimal) 	Effect
041637             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
041637             0004*   plot_sl_both: equ 0x00
041637             0005*   
041637             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
041637             0007*   plot_sl_first: equ 0x08
041637             0008*   
041637             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
041637             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
041637             0011*   
041637             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
041637             0013*   plot_sl_last: equ 0x20
041637             0014*   
041637             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
041637             0016*   plot_sl_none: equ 0x28
041637             0017*   
041637             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
041637             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
041637             0020*   
041637             0021*   ; &40-&47 	64-71 	Point plot
041637             0022*   plot_pt: equ 0x40
041637             0023*   
041637             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background §§
041637             0025*   plot_lf_lr_non_bg: equ 0x48
041637             0026*   
041637             0027*   ; &50-&57 	80-87 	Triangle fill
041637             0028*   plot_tf: equ 0x50
041637             0029*   
041637             0030*   ; &58-&5F 	88-95 	Line fill right to background §§
041637             0031*   plot_lf_r_bg: equ 0x58
041637             0032*   
041637             0033*   ; &60-&67 	96-103 	Rectangle fill
041637             0034*   plot_rf: equ 0x60
041637             0035*   
041637             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground §§
041637             0037*   plot_lf_lr_fg: equ 0x60
041637             0038*   
041637             0039*   ; &70-&77 	112-119 	Parallelogram fill
041637             0040*   plot_pf: equ 0x70
041637             0041*   
041637             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground §§
041637             0043*   plot_lf_r_non_fg: equ 0x78
041637             0044*   
041637             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
041637             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
041637             0047*   
041637             0048*   ; &90-&97 	144-151 	Circle outline
041637             0049*   plot_co: equ 0x90
041637             0050*   
041637             0051*   ; &98-&9F 	152-159 	Circle fill
041637             0052*   plot_cf: equ 0x98
041637             0053*   
041637             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
041637             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
041637             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
041637             0057*   
041637             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
041637             0059*   plot_rcm: equ 0xB8
041637             0060*   
041637             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
041637             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
041637             0063*   ; &D0-&D7 	208-215 	Not defined
041637             0064*   ; &D8-&DF 	216-223 	Not defined
041637             0065*   ; &E0-&E7 	224-231 	Not defined
041637             0066*   
041637             0067*   ; &E8-&EF 	232-239 	Bitmap plot §
041637             0068*   plot_bmp: equ 0xE8
041637             0069*   
041637             0070*   ; &F0-&F7 	240-247 	Not defined
041637             0071*   ; &F8-&FF 	248-255 	Not defined
041637             0072*   
041637             0073*   ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
041637             0074*   ; Agon Console8 VDP 2.2.0
041637             0075*   
041637             0076*   ; Within each group of eight plot codes, the effects are as follows:
041637             0077*   ; Plot code 	Effect
041637             0078*   ; 0 	Move relative
041637             0079*   mv_rel: equ 0
041637             0080*   
041637             0081*   ; 1 	Plot relative in current foreground colour
041637             0082*   dr_rel_fg: equ 1
041637             0083*   
041637             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
041637             0085*   ; 3 	Plot relative in current background colour
041637             0086*   dr_rel_bg: equ 3
041637             0087*   
041637             0088*   ; 4 	Move absolute
041637             0089*   mv_abs: equ 4
041637             0090*   
041637             0091*   ; 5 	Plot absolute in current foreground colour
041637             0092*   dr_abs_fg: equ 5
041637             0093*   
041637             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
041637             0095*   ; 7 	Plot absolute in current background colour
041637             0096*   dr_abs_bg: equ 7
041637             0097*   
041637             0098*   ; Codes 0-3 use the position data provided as part of the command
041637             0099*   ; as a relative position, adding the position given to the current
041637             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
041637             0101*   ; as part of the command as an absolute position, setting the current
041637             0102*   ; graphical cursor position to the position given.
041637             0103*   
041637             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
041637             0105*   ; current pixel colour. These operations cannot currently be supported
041637             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
041637             0107*   ; supported. Support for these codes may be added in a future version
041637             0108*   ; of the VDP firmware.
041637             0109*   
041637             0110*   ; 16 colour palette constants
041637             0111*   c_black: equ 0
041637             0112*   c_red_dk: equ 1
041637             0113*   c_green_dk: equ 2
041637             0114*   c_yellow_dk: equ 3
041637             0115*   c_blue_dk: equ 4
041637             0116*   c_magenta_dk: equ 5
041637             0117*   c_cyan_dk: equ 6
041637             0118*   c_grey: equ 7
041637             0119*   c_grey_dk: equ 8
041637             0120*   c_red: equ 9
041637             0121*   c_green: equ 10
041637             0122*   c_yellow: equ 11
041637             0123*   c_blue: equ 12
041637             0124*   c_magenta: equ 13
041637             0125*   c_cyan: equ 14
041637             0126*   c_white: equ 15
041637             0127*   
041637             0128*   ; VDU 25, mode, x; y;: PLOT command
041637             0129*   ; inputs: a=mode, bc=x0, de=y0
041637             0130*   vdu_plot:
041637 32 51 16 04 0131*       ld (@mode),a
04163B ED 43 52 16 0132*       ld (@x0),bc
       04          
041640 ED 53 54 16 0133*       ld (@y0),de
       04          
041645 21 50 16 04 0134*   	ld hl,@cmd
041649 01 06 00 00 0135*   	ld bc,@end-@cmd
04164D 5B DF       0136*   	rst.lil $18
04164F C9          0137*   	ret
041650 19          0138*   @cmd:   db 25
041651 00          0139*   @mode:  db 0
041652 00 00       0140*   @x0: 	dw 0
041654 00 00       0141*   @y0: 	dw 0
041656 00          0142*   @end:   db 0 ; extra byte to soak up deu
041657             0143*   
041657             0144*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041657             0145*   ; &E8-&EF 	232-239 	Bitmap plot §
041657             0146*   ; VDU 25, mode, x; y;: PLOT command
041657             0147*   ; inputs: bc=x0, de=y0
041657             0148*   ; prerequisites: vdu_buff_select
041657             0149*   vdu_plot_bmp:
041657 ED 43 6E 16 0150*       ld (@x0),bc
       04          
04165C ED 53 70 16 0151*       ld (@y0),de
       04          
041661 21 6C 16 04 0152*   	ld hl,@cmd
041665 01 06 00 00 0153*   	ld bc,@end-@cmd
041669 5B DF       0154*   	rst.lil $18
04166B C9          0155*   	ret
04166C 19          0156*   @cmd:   db 25
04166D ED          0157*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
04166E 00 00       0158*   @x0: 	dw 0x0000
041670 00 00       0159*   @y0: 	dw 0x0000
041672 00          0160*   @end:   db 0x00 ; padding
041673             0161*   
041673             0162*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041673             0163*   ; &E8-&EF 	232-239 	Bitmap plot §
041673             0164*   ; VDU 25, mode, x; y;: PLOT command
041673             0165*   ; inputs: bc=x0, de=y0
041673             0166*   ; USING 16.8 FIXED POINT COORDINATES
041673             0167*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
041673             0168*   ;   the fractional portiion of the inputs are truncated
041673             0169*   ;   leaving only the 16-bit integer portion
041673             0170*   ; prerequisites: vdu_buff_select
041673             0171*   vdu_plot_bmp168:
041673             0172*   ; populate in the reverse of normal to keep the
041673             0173*   ; inputs from stomping on each other
041673 ED 53 91 16 0174*       ld (@y0-1),de
       04          
041678 ED 43 8F 16 0175*       ld (@x0-1),bc
       04          
04167D 3E ED       0176*       ld a,plot_bmp+dr_abs_fg ; 0xED
04167F 32 8F 16 04 0177*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
041683 21 8E 16 04 0178*   	ld hl,@cmd
041687 01 06 00 00 0179*   	ld bc,@end-@cmd
04168B 5B DF       0180*   	rst.lil $18
04168D C9          0181*   	ret
04168E 19          0182*   @cmd:   db 25
04168F ED          0183*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041690 00 00       0184*   @x0: 	dw 0x0000
041692 00 00       0185*   @y0: 	dw 0x0000
041694             0186*   @end:  ; no padding required b/c we shifted de right
041694             0187*   
041694             0188*   ; draw a filled rectangle
041694             0189*   vdu_plot_rf:
041694 ED 43 BB 16 0190*       ld (@x0),bc
       04          
041699 ED 53 BD 16 0191*       ld (@y0),de
       04          
04169E DD 22 C1 16 0192*       ld (@x1),ix
       04          
0416A3 FD 22 C3 16 0193*       ld (@y1),iy
       04          
0416A8 3E 19       0194*       ld a,25 ; we have to reload the 2nd plot command
0416AA 32 BF 16 04 0195*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0416AE 21 B9 16 04 0196*   	ld hl,@cmd0
0416B2 01 0C 00 00 0197*   	ld bc,@end-@cmd0
0416B6 5B DF       0198*   	rst.lil $18
0416B8 C9          0199*       ret
0416B9 19          0200*   @cmd0:  db 25 ; plot
0416BA 04          0201*   @arg0:  db plot_sl_both+mv_abs
0416BB 00 00       0202*   @x0:    dw 0x0000
0416BD 00 00       0203*   @y0:    dw 0x0000
0416BF 19          0204*   @cmd1:  db 25 ; plot
0416C0 65          0205*   @arg1:  db plot_rf+dr_abs_fg
0416C1 00 00       0206*   @x1:    dw 0x0000
0416C3 00 00       0207*   @y1:    dw 0x0000
0416C5 00          0208*   @end:   db 0x00 ; padding
0416C6             0209*   
0416C6             0210*   ; draw a filled circle
0416C6             0211*   vdu_plot_cf:
0416C6 ED 43 ED 16 0212*       ld (@x0),bc
       04          
0416CB ED 53 EF 16 0213*       ld (@y0),de
       04          
0416D0 DD 22 F3 16 0214*       ld (@x1),ix
       04          
0416D5 FD 22 F5 16 0215*       ld (@y1),iy
       04          
0416DA 3E 19       0216*       ld a,25 ; we have to reload the 2nd plot command
0416DC 32 F1 16 04 0217*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0416E0 21 EB 16 04 0218*   	ld hl,@cmd0
0416E4 01 0C 00 00 0219*   	ld bc,@end-@cmd0
0416E8 5B DF       0220*   	rst.lil $18
0416EA C9          0221*       ret
0416EB 19          0222*   @cmd0:  db 25 ; plot
0416EC 04          0223*   @arg0:  db plot_sl_both+mv_abs
0416ED 00 00       0224*   @x0:    dw 0x0000
0416EF 00 00       0225*   @y0:    dw 0x0000
0416F1 19          0226*   @cmd1:  db 25 ; plot
0416F2 9D          0227*   @arg1:  db plot_cf+dr_abs_fg
0416F3 00 00       0228*   @x1:    dw 0x0000
0416F5 00 00       0229*   @y1:    dw 0x0000
0416F7 00          0230*   @end:   db 0x00 ; padding
0416F8             0042        include "vdu_sound.inc"
0416F8             0001*   ; enable enough additional channels so that total enabled = max_channels
0416F8             0002*   ; inputs: max_channels set
0416F8             0003*   ; returns: nothing
0416F8             0004*   ; destroys: af, bc, hl
0416F8             0005*   vdu_enable_channels:
0416F8 3E 01       0006*       ld a,max_channels
0416FA D6 03       0007*       sub 3 ; subtract number of default channels already enabled
0416FC F2 03 17 04 0008*       jp p,@loop
041700 C9          0009*       ret
041701 3E 03       0010*       ld a,3 ; first non-default channel
041703             0011*   @loop:
041703 32 1E 17 04 0012*       ld (@channel),a
041707 21 1B 17 04 0013*       ld hl,@beg
04170B 01 05 00 00 0014*       ld bc,@end-@beg
04170F F5          0015*       push af
041710 5B DF       0016*       rst.lil $18
041712 F1          0017*       pop af
041713 3C          0018*       inc a
041714 FE 01       0019*       cp max_channels
041716 C2 03 17 04 0020*       jp nz,@loop
04171A C9          0021*       ret
04171B             0022*   @beg:
04171B 17 00 85    0023*               db 23, 0, $85
04171E 00          0024*   @channel:   db 0
04171F 08          0025*               db 8 ; command 8: enable channel
041720             0026*   @end:
041720             0027*   
041720             0028*   ; disable all but the three default sound channels
041720             0029*   ; inputs: max_channels set
041720             0030*   ; outputs: none
041720             0031*   ; destroys: ah,hl,bc
041720             0032*   vdu_disable_channels:
041720 3E 01       0033*       ld a,max_channels
041722 D6 03       0034*       sub 3 ; subtract number of default channels already enabled
041724 F2 2B 17 04 0035*       jp p,@loop
041728 C9          0036*       ret
041729 3E 03       0037*       ld a,3 ; first non-default channel
04172B             0038*   @loop:
04172B 32 46 17 04 0039*       ld (@channel),a
04172F 21 43 17 04 0040*       ld hl,@beg
041733 01 05 00 00 0041*       ld bc,@end-@beg
041737 F5          0042*       push af
041738 5B DF       0043*       rst.lil $18
04173A F1          0044*       pop af
04173B 3C          0045*       inc a
04173C FE 01       0046*       cp max_channels
04173E C2 2B 17 04 0047*       jp nz,@loop
041742 C9          0048*       ret
041743             0049*   @beg:
041743 17 00 85    0050*       db 23, 0, $85
041746 00          0051*   @channel: db 0
041747 09          0052*       db 9 ; command 9: disable channel
041748             0053*   @end:
041748             0054*   
041748             0055*   
041748             0056*   ; ############################################################
041748             0057*   ; VDU SOUND API
041748             0058*   ; ############################################################
041748             0059*   ; Command 0: Play note
041748             0060*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041748             0061*       MACRO PLAY_NOTE channel, volume, frequency, duration
041748             0062*       ld hl, @PLAY_NOTE_CMD        ; Start of command block
041748             0063*       ld bc, @PLAY_NOTE_END - @PLAY_NOTE_CMD  ; Command block size
041748             0064*       rst.lil $18
041748             0065*       jr @PLAY_NOTE_END
041748             0066*   @PLAY_NOTE_CMD:  db 23, 0, 0x85               ; Command header
041748             0067*                    db channel                  ; Channel, 0 (commented out)
041748             0068*                    db 0                        ; Play note command
041748             0069*                    db volume                   ; Volume
041748             0070*                    dw frequency                ; Frequency
041748             0071*                    dw duration                 ; Duration
041748             0072*   @PLAY_NOTE_END:
041748             0073*       ENDMACRO
041748             0074*   
041748             0075*       MACRO MUTE_CHANNEL channel
041748             0076*       ld hl, @MUTE_CHANNEL_CMD     ; Start of command block
041748             0077*       ld bc, @MUTE_CHANNEL_END - @MUTE_CHANNEL_CMD  ; Command block size
041748             0078*       rst.lil $18
041748             0079*       jr @MUTE_CHANNEL_END
041748             0080*   @MUTE_CHANNEL_CMD: db 23, 0, 0x85             ; Command header
041748             0081*                      db channel                ; Channel, 0 (commented out)
041748             0082*                      db 2                      ; Set volume command
041748             0083*                      db 0                      ; Volume (mute)
041748             0084*   @MUTE_CHANNEL_END:
041748             0085*       ENDMACRO
041748             0086*   
041748             0087*   ; inputs: c = channel, b = volume, hl = frequency; de = duration;
041748             0088*   vdu_play_note:
041748 79          0089*       ld a,c
041749 32 69 17 04 0090*       ld (@channel),a
04174D 78          0091*       ld a,b
04174E 32 6B 17 04 0092*       ld (@volume),a
041752 22 6C 17 04 0093*       ld (@frequency),hl
041756 ED 53 6E 17 0094*       ld (@duration),de
       04          
04175B 21 66 17 04 0095*       ld hl,@cmd
04175F 01 0A 00 00 0096*       ld bc,@end-@cmd
041763 5B DF       0097*       rst.lil $18
041765 C9          0098*       ret
041766 17 00 85    0099*   @cmd:       db 23, 0, 0x85
041769 00          0100*   @channel:   db 0x00
04176A 00          0101*               db 0x00 ; play note command
04176B 00          0102*   @volume:    db 0x00
04176C 00 00       0103*   @frequency: dw 0x0000
04176E 00 00       0104*   @duration:  dw 0x0000
041770 00          0105*   @end:       db 0x00 ; padding
041771             0106*   
041771             0107*   ; Command 1: Status
041771             0108*   ; VDU 23, 0, &85, channel, 1
041771             0109*   ; inputs: a = channel
041771             0110*   ; Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled. The bit mask is as follows:
041771             0111*   ; Bit 	Name 	Meaning
041771             0112*   ; 0 	Active 	When set this indicates the channel is in use (has an active waveform)
041771             0113*   ; 1 	Playing 	Indicates the channel is actively playing a note, and thus will reject calls to play a new note
041771             0114*   ; 2 	Indefinite 	Set if the channel is playing an indefinite duration note
041771             0115*   ; 3 	Has Volume Envelope 	Set if the channel has a volume envelope
041771             0116*   ; 4 	Has Frequency Envelope 	Set if the channel has a frequency envelope
041771             0117*   
041771             0118*   ; Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.
041771             0119*   vdu_channel_status:
041771 32 83 17 04 0120*       ld (@channel),a
041775 21 80 17 04 0121*       ld hl,@cmd
041779 01 05 00 00 0122*       ld bc,@end-@cmd
04177D 5B DF       0123*       rst.lil $18
04177F C9          0124*       ret
041780 17 00 85    0125*   @cmd:       db 23, 0, 0x85
041783 00          0126*   @channel:   db 0x00
041784 01          0127*               db 0x01 ; get channel status command
041785             0128*   @end:
041785             0129*   
041785             0130*   ; VDU 23, 0, &85, channel, 2, volume
041785             0131*   ; inputs: c = channel, b = volume
041785             0132*   ; Sets the volume of the specified channel. The volume is a value from 0 to 127, where 0 is silent and 127 is full volume. Values over 127 will be treated as 127 (with one exception described later).
041785             0133*   
041785             0134*   ; Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)
041785             0135*   
041785             0136*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the volume of a channel that is already playing a note.
041785             0137*   vdu_channel_volume:
041785 79          0138*       ld a,c
041786 32 9D 17 04 0139*       ld (@channel),a
04178A 78          0140*       ld a,b
04178B 32 9F 17 04 0141*       ld (@volume),a
04178F 21 9A 17 04 0142*       ld hl,@cmd
041793 01 06 00 00 0143*       ld bc,@end-@cmd
041797 5B DF       0144*       rst.lil $18
041799 C9          0145*       ret
04179A 17 00 85    0146*   @cmd:       db 23, 0, 0x85
04179D 00          0147*   @channel:   db 0x00
04179E 02          0148*               db 0x02 ; set volume command
04179F 00          0149*   @volume:    db 0x00
0417A0             0150*   @end:
0417A0             0151*   
0417A0             0152*   ; VDU 23, 0, &85, channel, 3, frequency;
0417A0             0153*   
0417A0             0154*   ; Sets the frequency of the specified channel. The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.
0417A0             0155*   
0417A0             0156*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the frequency of a channel that is already playing a note.
0417A0             0157*   
0417A0             0158*   ; Returns 1 on success, 0 for failure.
0417A0             0159*   vdu_channel_frequency:
0417A0 79          0160*       ld a,c
0417A1 32 B8 17 04 0161*       ld (@channel),a
0417A5 ED 53 BA 17 0162*       ld (@frequency),de
       04          
0417AA 21 B5 17 04 0163*       ld hl,@cmd
0417AE 01 07 00 00 0164*       ld bc,@end-@cmd
0417B2 5B DF       0165*       rst.lil $18
0417B4 C9          0166*       ret
0417B5 17 00 85    0167*   @cmd:       db 23, 0, 0x85
0417B8 00          0168*   @channel:   db 0x00
0417B9 03          0169*               db 0x03 ; set frequency command
0417BA 00 00       0170*   @frequency: dw 0x0000
0417BC 00          0171*   @end:       db 0x00 ; padding
0417BD             0172*   
0417BD             0173*   
0417BD             0174*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0417BD             0175*   ; inputs: c = channel, b = waveformOrSample, [hl = bufferId]
0417BD             0176*   ; Sets the waveform type for a channel to use. The waveformOrSample value is a single byte treated as a signed value.
0417BD             0177*   
0417BD             0178*   ; Using a negative value for the waveform indicates that a sample should be used instead. For more information see the documentation for the sample command.
0417BD             0179*   
0417BD             0180*   ; By default a channel is set to use waveform 0 (square wave).
0417BD             0181*   
0417BD             0182*   ; Valid waveform values are as follows:
0417BD             0183*   ; Value 	Waveform
0417BD             0184*   ; 0 	Square wave
0417BD             0185*   ; 1 	Triangle wave
0417BD             0186*   ; 2 	Sawtooth wave
0417BD             0187*   ; 3 	Sine wave
0417BD             0188*   ; 4 	Noise (simple white noise with no frequency support)
0417BD             0189*   ; 5 	VIC Noise (emulates a VIC6561; supports frequency)
0417BD             0190*   ; 8 	Sample (specifying a 16-bit buffer ID for sample data)
0417BD             0191*   
0417BD             0192*   vdu_channel_waveform:
0417BD 79          0193*       ld a,c
0417BE 32 E3 17 04 0194*       ld (@channel),a
0417C2 78          0195*       ld a,b
0417C3 32 E5 17 04 0196*       ld (@waveform),a
0417C7 FE 08       0197*       cp 8 ; check if the waveform is a sample
0417C9 28 06       0198*       jr z, @sample
0417CB 01 06 00 00 0199*       ld bc,@bufferId-@cmd
0417CF 18 08       0200*       jr @sendToVdu
0417D1             0201*   @sample:
0417D1 22 E6 17 04 0202*       ld (@bufferId),hl
0417D5 01 08 00 00 0203*       ld bc,@end-@cmd
0417D9             0204*   @sendToVdu:
0417D9 21 E0 17 04 0205*       ld hl,@cmd
0417DD 5B DF       0206*       rst.lil $18
0417DF C9          0207*       ret
0417E0 17 00 85    0208*   @cmd:       db 23, 0, 0x85
0417E3 00          0209*   @channel:   db 0x00
0417E4 04          0210*               db 0x04 ; set waveform command
0417E5 00          0211*   @waveform:  db 0x00
0417E6 00 00       0212*   @bufferId:  dw 0x0000
0417E8 00          0213*   @end:       db 0x00 ; padding
0417E9             0214*   
0417E9             0215*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
0417E9             0216*   ; inputs: hl = bufferId; a = format, de = sample rate in Hz
0417E9             0217*   ; The format is a single byte giving the format of the sample data. The following formats are supported:
0417E9             0218*   ; Value	Description
0417E9             0219*   ; 0	8-bit signed
0417E9             0220*   ; 1	8-bit unsigned
0417E9             0221*   ; The format value can also have modifier bits set to modify the behaviour of the sample. The following modifier bits are supported:
0417E9             0222*   ; Value	Description
0417E9             0223*   ; 8	sample rate is sent in the next 16-bits
0417E9             0224*   ; 16	sample is tuneable
0417E9             0225*   ; The default sample rate for samples on the VDP is 16kHz (actually 16.384kHz to be precise).
0417E9             0226*   vdu_buffer_to_sound:
0417E9 22 09 18 04 0227*       ld (@bufferId),hl
0417ED C6 08       0228*       add a,8 ; modify format byte to indicate sample rate argument is given
0417EF 32 0B 18 04 0229*       ld (@format),a
0417F3 ED 53 0C 18 0230*       ld (@sampleRate),de
       04          
0417F8 21 03 18 04 0231*       ld hl,@cmd
0417FC 01 0B 00 00 0232*       ld bc,@end-@cmd
041800 5B DF       0233*       rst.lil $18
041802 C9          0234*       ret
041803 17 00 85    0235*   @cmd:       db 23, 0, 0x85
041806 00          0236*   @channel:   db 0x00 ; ignored
041807 05          0237*               db 0x05 ; buffer to sound command
041808 02          0238*               db 0x02 ; command 2 create sample
041809 00 00       0239*   @bufferId:  dw 0x0000
04180B 00          0240*   @format:    db 0x00
04180C 00 00       0241*   @sampleRate: dw 0x0000
04180E 00          0242*   @end:       db 0x00 ; padding
04180F             0243*   
04180F             0244*   ; Command 13: Set sample rate
04180F             0245*   ; VDU 23, 0, &85, channel, 13, sampleRate;
04180F             0246*   ; inputs: c = channel, hl = sampleRate (Hz)
04180F             0247*   vdu_set_sample_rate:
04180F 79          0248*       ld a,c
041810 32 26 18 04 0249*       ld (@channel),a
041814 22 28 18 04 0250*       ld (@sampleRate),hl
041818 21 23 18 04 0251*       ld hl,@cmd
04181C 01 07 00 00 0252*       ld bc,@end-@cmd
041820 5B DF       0253*       rst.lil $18
041822 C9          0254*       ret
041823 17 00 85    0255*   @cmd:       db 23, 0, 0x85
041826 00          0256*   @channel:   db 0x00
041827 0D          0257*               db 13 ; set sample rate command
041828 00 00       0258*   @sampleRate: dw 0x0000
04182A 00          0259*   @end:       db 0x00 ; padding
04182B             0260*   
04182B             0261*   ; load a sound file to a buffer
04182B             0262*   ; inputs: hl = bufferId ; de = sampleRate in Hz ; iy = pointer to filename
04182B             0263*   vdu_load_sfx:
04182B             0264*   ; back up input parameters
04182B E5          0265*       push hl ; bufferId
04182C D5          0266*       push de ; sample rate
04182D             0267*   ; load the sound
04182D CD 6B 13 04 0268*       call vdu_load_buffer_from_file
041831             0269*   ; now make the buffer a sound sample
041831 D1          0270*       pop de ; sample rate
041832 E1          0271*       pop hl ; bufferId
041833 AF          0272*       xor a ; zero is the magic number for mono 8-bit signed PCM
041834 CD E9 17 04 0273*       call vdu_buffer_to_sound
041838 C9          0274*       ret
041839             0275*   
041839             0276*   
041839 00          0277*   last_channel: db 0
04183A             0278*   max_channels: equ 1
04183A             0279*   
04183A             0280*   ; play a sound effect from an already loaded buffer
04183A             0281*   ; inputs: hl = bufferId ; bc = duration in milliseconds
04183A             0282*   vdu_play_sfx:
04183A 22 72 18 04 0283*       ld (@bufferId),hl
04183E ED 43 7C 18 0284*       ld (@duration),bc
       04          
041843 3E 17       0285*       ld a,23
041845 32 74 18 04 0286*       ld (@bufferId+2),a
041849 3A 39 18 04 0287*       ld a,(last_channel)
04184D 3C          0288*       inc a
04184E             0289*       ; and 31 ; modulo 32
04184E FE 01       0290*       cp max_channels
041850 C2 55 18 04 0291*       jp nz,@load_channel
041854 AF          0292*       xor a
041855             0293*   @load_channel:
041855 32 39 18 04 0294*       ld (last_channel),a
041859 32 6F 18 04 0295*       ld (@channel0),a
04185D 32 77 18 04 0296*       ld (@channel1),a
041861 21 6C 18 04 0297*       ld hl, @sample
041865 01 12 00 00 0298*       ld bc, @sample_end - @sample
041869 5B DF       0299*       rst.lil $18
04186B C9          0300*       ret
04186C             0301*   @sample:
04186C             0302*   ; Command 4: Set waveform
04186C             0303*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
04186C 17 00 85    0304*       .db 23,0,$85                        ; do sound
04186F             0305*   @channel0:
04186F 00 04 08    0306*       .db 0,4,8 ; channel, command, waveform
041872             0307*   @bufferId:
041872 00 00       0308*       .dw 0x0000
041874             0309*   ; Command 0: Play note
041874             0310*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
041874 17 00 85    0311*       .db 23,0,$85                        ; do sound
041877             0312*   @channel1:
041877 00 00 7F    0313*       .db 0,0,127                ; channel, volume
04187A 00 00       0314*       .dw 0
04187C             0315*   @duration:                              ; freq (tuneable samples only)
04187C 00 00       0316*       .dw 0x0000                        ; duration
04187E             0317*   @sample_end:
04187E 00          0318*       .db 0x00 ; padding
04187F             0319*   
04187F             0320*   ; inputs: c = channel, b = volume, de = sample rate; hl = bufferId;
04187F             0321*   vdu_play_sample:
04187F             0322*       ; populate input parameters
04187F 79          0323*       ld a,c
041880 32 B2 18 04 0324*       ld (@channel0),a
041884 32 BA 18 04 0325*       ld (@channel1),a
041888 32 C1 18 04 0326*       ld (@channel2),a
04188C 78          0327*       ld a,b
04188D 32 C3 18 04 0328*       ld (@volume),a
041891 ED 53 BC 18 0329*       ld (@sampleRate),de
       04          
041896 22 B5 18 04 0330*       ld (@bufferId),hl
04189A 3E 17       0331*       ld a,23
04189C 32 B7 18 04 0332*       ld (@cmd1),a
0418A0 32 BE 18 04 0333*       ld (@cmd2),a
0418A4             0334*       ; prep the vdu command string
0418A4 21 AF 18 04 0335*       ld hl, @cmd0
0418A8 01 19 00 00 0336*       ld bc, @end - @cmd0
0418AC 5B DF       0337*       rst.lil $18
0418AE C9          0338*       ret
0418AF             0339*   ; set waveform command
0418AF 17 00 85    0340*   @cmd0:       db 23, 0, 0x85
0418B2 00          0341*   @channel0:   db 0x00
0418B3 04          0342*                db 0x04 ; set waveform command
0418B4 08          0343*   @waveform:   db 0x08 ; sample
0418B5 00 00       0344*   @bufferId:   dw 0x0000
0418B7             0345*   ; set sample rate command
0418B7 17 00 85    0346*   @cmd1:       db 23, 0, 0x85
0418BA 00          0347*   @channel1:   db 0x00
0418BB 0D          0348*               db 13 ; set sample rate command
0418BC 00 00       0349*   @sampleRate: dw 0x0000
0418BE             0350*   ; play note command
0418BE 17 00 85    0351*   @cmd2:       db 23, 0, 0x85
0418C1 00          0352*   @channel2:   db 0x00
0418C2 00          0353*                db 0x00 ; play note command
0418C3 00          0354*   @volume:     db 0x00
0418C4 00 00       0355*   @frequency:  dw 0x00 ; no effect unless buffer has been set to tuneable sample
0418C6 00 00       0356*   @duration:   dw 0x0000 ; milliseconds: set to -1 to loop indefinitely, 0 to play full duration once
0418C8 00          0357*   @end:        db 0x00 ; padding
0418C9             0043    
0418C9             0044    ; APPLICATION INCLUDES
0418C9             0045        include "music.inc"
0418C9             0001*   ; This file is created by build_98_asm_sfx.py, do not edit it!
0418C9             0002*   
0418C9             0003*   SFX_num_buffers: equ 9
0418C9             0004*   
0418C9             0005*   sample_rate: equ 15360
0418C9             0006*   ; SFX buffer ids:
0418C9             0007*   BUF_AFRICA: equ 0x3000
0418C9             0008*   BUF_ANYTIME: equ 0x3001
0418C9             0009*   BUF_BARRACUDA: equ 0x3002
0418C9             0010*   BUF_COME_UNDONE: equ 0x3003
0418C9             0011*   BUF_EVERY_BREATH_YOU_TAKE: equ 0x3004
0418C9             0012*   BUF_RHIANNON: equ 0x3005
0418C9             0013*   BUF_TAKE_A_RIDE: equ 0x3006
0418C9             0014*   BUF_AMBIENT_BEAT70: equ 0x3007
0418C9             0015*   BUF_SPACE_ADVENTURE: equ 0x3008
0418C9             0016*   
0418C9             0017*   ; SFX buffer id reverse lookup:
0418C9             0018*   SFX_buffer_id_lut:
0418C9 00 30 00    0019*   	dl BUF_AFRICA
0418CC 01 30 00    0020*   	dl BUF_ANYTIME
0418CF 02 30 00    0021*   	dl BUF_BARRACUDA
0418D2 03 30 00    0022*   	dl BUF_COME_UNDONE
0418D5 04 30 00    0023*   	dl BUF_EVERY_BREATH_YOU_TAKE
0418D8 05 30 00    0024*   	dl BUF_RHIANNON
0418DB 06 30 00    0025*   	dl BUF_TAKE_A_RIDE
0418DE 07 30 00    0026*   	dl BUF_AMBIENT_BEAT70
0418E1 08 30 00    0027*   	dl BUF_SPACE_ADVENTURE
0418E4             0028*   
0418E4             0029*   ; SFX duration lookup:
0418E4             0030*   SFX_duration_lut:
0418E4 ED 67 04    0031*   	dl 288749 ; AFRICA
0418E7 7C 20 03    0032*   	dl 204924 ; ANYTIME
0418EA 5C EC 03    0033*   	dl 257116 ; BARRACUDA
0418ED D8 D3 03    0034*   	dl 250840 ; COME_UNDONE
0418F0 33 C3 03    0035*   	dl 246579 ; EVERY_BREATH_YOU_TAKE
0418F3 79 C3 03    0036*   	dl 246649 ; RHIANNON
0418F6 D1 46 04    0037*   	dl 280273 ; TAKE_A_RIDE
0418F9 A9 75 00    0038*   	dl 30121 ; AMBIENT_BEAT70
0418FC DE F2 01    0039*   	dl 127710 ; SPACE_ADVENTURE
0418FF             0040*   
0418FF             0041*   ; SFX load routines jump table:
0418FF             0042*   SFX_load_routines_table:
0418FF 1A 19 04    0043*   	dl load_sfx_AFRICA
041902 2C 19 04    0044*   	dl load_sfx_ANYTIME
041905 3E 19 04    0045*   	dl load_sfx_BARRACUDA
041908 50 19 04    0046*   	dl load_sfx_COME_UNDONE
04190B 62 19 04    0047*   	dl load_sfx_EVERY_BREATH_YOU_TAKE
04190E 74 19 04    0048*   	dl load_sfx_RHIANNON
041911 86 19 04    0049*   	dl load_sfx_TAKE_A_RIDE
041914 98 19 04    0050*   	dl load_sfx_AMBIENT_BEAT70
041917 AA 19 04    0051*   	dl load_sfx_SPACE_ADVENTURE
04191A             0052*   
04191A             0053*   ; Import sfx .raw files and load them into VDP buffers
04191A             0054*   
04191A             0055*   load_sfx_AFRICA:
04191A 21 00 30 00 0056*   	ld hl,BUF_AFRICA
04191E 11 00 3C 00 0057*   	ld de,15360
041922 FD 21 BC 19 0058*   	ld iy,FAFRICA
       04          
041927 CD 2B 18 04 0059*   	call vdu_load_sfx
04192B C9          0060*   	ret
04192C             0061*   
04192C             0062*   load_sfx_ANYTIME:
04192C 21 01 30 00 0063*   	ld hl,BUF_ANYTIME
041930 11 00 3C 00 0064*   	ld de,15360
041934 FD 21 CD 19 0065*   	ld iy,FANYTIME
       04          
041939 CD 2B 18 04 0066*   	call vdu_load_sfx
04193D C9          0067*   	ret
04193E             0068*   
04193E             0069*   load_sfx_BARRACUDA:
04193E 21 02 30 00 0070*   	ld hl,BUF_BARRACUDA
041942 11 00 3C 00 0071*   	ld de,15360
041946 FD 21 DF 19 0072*   	ld iy,FBARRACUDA
       04          
04194B CD 2B 18 04 0073*   	call vdu_load_sfx
04194F C9          0074*   	ret
041950             0075*   
041950             0076*   load_sfx_COME_UNDONE:
041950 21 03 30 00 0077*   	ld hl,BUF_COME_UNDONE
041954 11 00 3C 00 0078*   	ld de,15360
041958 FD 21 F3 19 0079*   	ld iy,FCOME_UNDONE
       04          
04195D CD 2B 18 04 0080*   	call vdu_load_sfx
041961 C9          0081*   	ret
041962             0082*   
041962             0083*   load_sfx_EVERY_BREATH_YOU_TAKE:
041962 21 04 30 00 0084*   	ld hl,BUF_EVERY_BREATH_YOU_TAKE
041966 11 00 3C 00 0085*   	ld de,15360
04196A FD 21 09 1A 0086*   	ld iy,FEVERY_BREATH_YOU_TAKE
       04          
04196F CD 2B 18 04 0087*   	call vdu_load_sfx
041973 C9          0088*   	ret
041974             0089*   
041974             0090*   load_sfx_RHIANNON:
041974 21 05 30 00 0091*   	ld hl,BUF_RHIANNON
041978 11 00 3C 00 0092*   	ld de,15360
04197C FD 21 29 1A 0093*   	ld iy,FRHIANNON
       04          
041981 CD 2B 18 04 0094*   	call vdu_load_sfx
041985 C9          0095*   	ret
041986             0096*   
041986             0097*   load_sfx_TAKE_A_RIDE:
041986 21 06 30 00 0098*   	ld hl,BUF_TAKE_A_RIDE
04198A 11 00 3C 00 0099*   	ld de,15360
04198E FD 21 3C 1A 0100*   	ld iy,FTAKE_A_RIDE
       04          
041993 CD 2B 18 04 0101*   	call vdu_load_sfx
041997 C9          0102*   	ret
041998             0103*   
041998             0104*   load_sfx_AMBIENT_BEAT70:
041998 21 07 30 00 0105*   	ld hl,BUF_AMBIENT_BEAT70
04199C 11 00 3C 00 0106*   	ld de,15360
0419A0 FD 21 52 1A 0107*   	ld iy,FAMBIENT_BEAT70
       04          
0419A5 CD 2B 18 04 0108*   	call vdu_load_sfx
0419A9 C9          0109*   	ret
0419AA             0110*   
0419AA             0111*   load_sfx_SPACE_ADVENTURE:
0419AA 21 08 30 00 0112*   	ld hl,BUF_SPACE_ADVENTURE
0419AE 11 00 3C 00 0113*   	ld de,15360
0419B2 FD 21 6B 1A 0114*   	ld iy,FSPACE_ADVENTURE
       04          
0419B7 CD 2B 18 04 0115*   	call vdu_load_sfx
0419BB C9          0116*   	ret
0419BC             0117*   
0419BC             0118*   ; File name lookups:
0419BC 6D 75 73 69 0119*   FAFRICA: db "music/AFRICA.raw",0
       63 2F 41 46 
       52 49 43 41 
       2E 72 61 77 
       00          
0419CD 6D 75 73 69 0120*   FANYTIME: db "music/ANYTIME.raw",0
       63 2F 41 4E 
       59 54 49 4D 
       45 2E 72 61 
       77 00       
0419DF 6D 75 73 69 0121*   FBARRACUDA: db "music/BARRACUDA.raw",0
       63 2F 42 41 
       52 52 41 43 
       55 44 41 2E 
       72 61 77 00 
0419F3 6D 75 73 69 0122*   FCOME_UNDONE: db "music/COME_UNDONE.raw",0
       63 2F 43 4F 
       4D 45 5F 55 
       4E 44 4F 4E 
       45 2E 72 61 
       77 00       
041A09 6D 75 73 69 0123*   FEVERY_BREATH_YOU_TAKE: db "music/EVERY_BREATH_YOU_TAKE.raw",0
       63 2F 45 56 
       45 52 59 5F 
       42 52 45 41 
       54 48 5F 59 
       4F 55 5F 54 
       41 4B 45 2E 
       72 61 77 00 
041A29 6D 75 73 69 0124*   FRHIANNON: db "music/RHIANNON.raw",0
       63 2F 52 48 
       49 41 4E 4E 
       4F 4E 2E 72 
       61 77 00    
041A3C 6D 75 73 69 0125*   FTAKE_A_RIDE: db "music/TAKE_A_RIDE.raw",0
       63 2F 54 41 
       4B 45 5F 41 
       5F 52 49 44 
       45 2E 72 61 
       77 00       
041A52 6D 75 73 69 0126*   FAMBIENT_BEAT70: db "music/AMBIENT_BEAT70.raw",0
       63 2F 41 4D 
       42 49 45 4E 
       54 5F 42 45 
       41 54 37 30 
       2E 72 61 77 
       00          
041A6B 6D 75 73 69 0127*   FSPACE_ADVENTURE: db "music/SPACE_ADVENTURE.raw",0
       63 2F 53 50 
       41 43 45 5F 
       41 44 56 45 
       4E 54 55 52 
       45 2E 72 61 
       77 00       
041A85             0128*   
041A85             0129*   ; Play sfx routines
041A85             0130*   
041A85             0131*   sfx_play_AFRICA:
041A85 21 00 30 00 0132*   	ld hl,BUF_AFRICA
041A89 01 00 00 00 0133*   	ld bc,0
041A8D C3 3A 18 04 0134*   	jp vdu_play_sfx
041A91             0135*   
041A91             0136*   sfx_play_ANYTIME:
041A91 21 01 30 00 0137*   	ld hl,BUF_ANYTIME
041A95 01 00 00 00 0138*   	ld bc,0
041A99 C3 3A 18 04 0139*   	jp vdu_play_sfx
041A9D             0140*   
041A9D             0141*   sfx_play_BARRACUDA:
041A9D 21 02 30 00 0142*   	ld hl,BUF_BARRACUDA
041AA1 01 00 00 00 0143*   	ld bc,0
041AA5 C3 3A 18 04 0144*   	jp vdu_play_sfx
041AA9             0145*   
041AA9             0146*   sfx_play_COME_UNDONE:
041AA9 21 03 30 00 0147*   	ld hl,BUF_COME_UNDONE
041AAD 01 00 00 00 0148*   	ld bc,0
041AB1 C3 3A 18 04 0149*   	jp vdu_play_sfx
041AB5             0150*   
041AB5             0151*   sfx_play_EVERY_BREATH_YOU_TAKE:
041AB5 21 04 30 00 0152*   	ld hl,BUF_EVERY_BREATH_YOU_TAKE
041AB9 01 00 00 00 0153*   	ld bc,0
041ABD C3 3A 18 04 0154*   	jp vdu_play_sfx
041AC1             0155*   
041AC1             0156*   sfx_play_RHIANNON:
041AC1 21 05 30 00 0157*   	ld hl,BUF_RHIANNON
041AC5 01 00 00 00 0158*   	ld bc,0
041AC9 C3 3A 18 04 0159*   	jp vdu_play_sfx
041ACD             0160*   
041ACD             0161*   sfx_play_TAKE_A_RIDE:
041ACD 21 06 30 00 0162*   	ld hl,BUF_TAKE_A_RIDE
041AD1 01 00 00 00 0163*   	ld bc,0
041AD5 C3 3A 18 04 0164*   	jp vdu_play_sfx
041AD9             0165*   
041AD9             0166*   sfx_play_AMBIENT_BEAT70:
041AD9 21 07 30 00 0167*   	ld hl,BUF_AMBIENT_BEAT70
041ADD 01 00 00 00 0168*   	ld bc,0
041AE1 C3 3A 18 04 0169*   	jp vdu_play_sfx
041AE5             0170*   
041AE5             0171*   sfx_play_SPACE_ADVENTURE:
041AE5 21 08 30 00 0172*   	ld hl,BUF_SPACE_ADVENTURE
041AE9 01 00 00 00 0173*   	ld bc,0
041AED C3 3A 18 04 0174*   	jp vdu_play_sfx
041AF1             0046        include "debug.inc"
041AF1             0001*   printHexA:
041AF1 F5          0002*       push af
041AF2 C5          0003*       push bc
041AF3 CD AE 00 04 0004*       call printHex8
041AF7 3E 20       0005*       ld a,' '
041AF9 5B D7       0006*       rst.lil 10h
041AFB C1          0007*       pop bc
041AFC F1          0008*       pop af
041AFD C9          0009*       ret
041AFE             0010*   
041AFE             0011*   printHexHL:
041AFE F5          0012*       push af
041AFF C5          0013*       push bc
041B00 CD A8 00 04 0014*       call printHex16
041B04 3E 20       0015*       ld a,' '
041B06 5B D7       0016*       rst.lil 10h
041B08 C1          0017*       pop bc
041B09 F1          0018*       pop af
041B0A C9          0019*       ret
041B0B             0020*   
041B0B             0021*   printHexUHL:
041B0B F5          0022*       push af
041B0C C5          0023*       push bc
041B0D CD A0 00 04 0024*       call printHex24
041B11 3E 20       0025*       ld a,' '
041B13 5B D7       0026*       rst.lil 10h
041B15 C1          0027*       pop bc
041B16 F1          0028*       pop af
041B17 C9          0029*       ret
041B18             0030*   
041B18             0031*   printHexAUHL:
041B18 F5          0032*       push af
041B19 C5          0033*       push bc
041B1A CD AE 00 04 0034*       call printHex8
041B1E 3E 2E       0035*       ld a,'.'
041B20 5B D7       0036*       rst.lil 10h
041B22 CD A0 00 04 0037*       call printHex24
041B26 3E 20       0038*       ld a,' '
041B28 5B D7       0039*       rst.lil 10h
041B2A C1          0040*       pop bc
041B2B F1          0041*       pop af
041B2C C9          0042*       ret
041B2D             0043*   
041B2D             0044*   printHexABHL:
041B2D             0045*   ; preserve registers
041B2D C5          0046*       push bc ; b will be ok c will not
041B2E F5          0047*       push af ; will get totally destroyed
041B2F             0048*   ; print a
041B2F CD AE 00 04 0049*       call printHex8
041B33             0050*   ; print b
041B33 78          0051*       ld a,b
041B34 CD AE 00 04 0052*       call printHex8
041B38             0053*   ; print hl
041B38 CD A8 00 04 0054*       call printHex16
041B3C             0055*   ; restore registers
041B3C F1          0056*       pop af
041B3D C1          0057*       pop bc
041B3E C9          0058*       ret
041B3F             0059*   
041B3F             0060*   printHexBHL:
041B3F             0061*   ; preserve registers
041B3F C5          0062*       push bc ; b will be ok c will not
041B40 F5          0063*       push af ; will get totally destroyed
041B41             0064*   ; print b
041B41 78          0065*       ld a,b
041B42 CD AE 00 04 0066*       call printHex8
041B46             0067*   ; print hl
041B46 CD A8 00 04 0068*       call printHex16
041B4A             0069*   ; restore registers
041B4A F1          0070*       pop af
041B4B C1          0071*       pop bc
041B4C C9          0072*       ret
041B4D             0073*   
041B4D             0074*   printHexCDE:
041B4D             0075*   ; preserve registers
041B4D C5          0076*       push bc ; b will be ok c will not
041B4E F5          0077*       push af ; will get totally destroyed
041B4F             0078*   ; print c
041B4F 79          0079*       ld a,c
041B50 CD AE 00 04 0080*       call printHex8
041B54             0081*   ; print de
041B54 EB          0082*       ex de,hl
041B55 CD A8 00 04 0083*       call printHex16
041B59 EB          0084*       ex de,hl
041B5A             0085*   ; restore registers
041B5A F1          0086*       pop af
041B5B C1          0087*       pop bc
041B5C C9          0088*       ret
041B5D             0089*   
041B5D             0090*   printHexUIX:
041B5D             0091*   ; store everything in scratch
041B5D 22 35 03 04 0092*       ld (uhl),hl
041B61 ED 43 38 03 0093*       ld (ubc),bc
       04          
041B66 ED 53 3B 03 0094*       ld (ude),de
       04          
041B6B DD 22 3E 03 0095*       ld (uix),ix
       04          
041B70 FD 22 41 03 0096*       ld (uiy),iy
       04          
041B75 F5          0097*       push af ; fml
041B76             0098*   
041B76 21 CC 02 04 0099*       ld hl,str_ixu
041B7A CD 67 00 04 0100*       call printString
041B7E 2A 3E 03 04 0101*       ld hl,(uix)
041B82 CD A0 00 04 0102*       call printHex24
041B86 CD 7C 00 04 0103*       call printNewLine
041B8A             0104*   
041B8A             0105*   ; restore everything
041B8A 2A 35 03 04 0106*       ld hl, (uhl)
041B8E ED 4B 38 03 0107*       ld bc, (ubc)
       04          
041B93 ED 5B 3B 03 0108*       ld de, (ude)
       04          
041B98 DD 2A 3E 03 0109*       ld ix, (uix)
       04          
041B9D FD 2A 41 03 0110*       ld iy, (uiy)
       04          
041BA2 F1          0111*       pop af
041BA3             0112*   ; all done
041BA3 C9          0113*       ret
041BA4             0114*   
041BA4             0115*   
041BA4             0116*   ; print registers to screen in hexidecimal format
041BA4             0117*   ; inputs: none
041BA4             0118*   ; outputs: values of every register printed to screen
041BA4             0119*   ;    values of each register in global scratch memory
041BA4             0120*   ; destroys: nothing
041BA4             0121*   stepRegistersHex:
041BA4             0122*   ; store everything in scratch
041BA4 22 35 03 04 0123*       ld (uhl),hl
041BA8 ED 43 38 03 0124*       ld (ubc),bc
       04          
041BAD ED 53 3B 03 0125*       ld (ude),de
       04          
041BB2 DD 22 3E 03 0126*       ld (uix),ix
       04          
041BB7 FD 22 41 03 0127*       ld (uiy),iy
       04          
041BBC F5          0128*       push af ; fml
041BBD E1          0129*       pop hl ; thanks, zilog
041BBE 22 32 03 04 0130*       ld (uaf),hl
041BC2 F5          0131*       push af ; dammit
041BC3             0132*   
041BC3             0133*   ; home the cursor
041BC3             0134*       ; call vdu_home_cursor
041BC3             0135*   
041BC3             0136*   ; print each register
041BC3 21 B8 02 04 0137*       ld hl,str_afu
041BC7 CD 67 00 04 0138*       call printString
041BCB 2A 32 03 04 0139*       ld hl,(uaf)
041BCF CD A0 00 04 0140*       call printHex24
041BD3 CD 7C 00 04 0141*       call printNewLine
041BD7             0142*   
041BD7 21 BD 02 04 0143*       ld hl,str_hlu
041BDB CD 67 00 04 0144*       call printString
041BDF 2A 35 03 04 0145*       ld hl,(uhl)
041BE3 CD A0 00 04 0146*       call printHex24
041BE7 CD 7C 00 04 0147*       call printNewLine
041BEB             0148*   
041BEB 21 C2 02 04 0149*       ld hl,str_bcu
041BEF CD 67 00 04 0150*       call printString
041BF3 2A 38 03 04 0151*       ld hl,(ubc)
041BF7 CD A0 00 04 0152*       call printHex24
041BFB CD 7C 00 04 0153*       call printNewLine
041BFF             0154*   
041BFF 21 C7 02 04 0155*       ld hl,str_deu
041C03 CD 67 00 04 0156*       call printString
041C07 2A 3B 03 04 0157*       ld hl,(ude)
041C0B CD A0 00 04 0158*       call printHex24
041C0F CD 7C 00 04 0159*       call printNewLine
041C13             0160*   
041C13 21 CC 02 04 0161*       ld hl,str_ixu
041C17 CD 67 00 04 0162*       call printString
041C1B 2A 3E 03 04 0163*       ld hl,(uix)
041C1F CD A0 00 04 0164*       call printHex24
041C23 CD 7C 00 04 0165*       call printNewLine
041C27             0166*   
041C27 21 D1 02 04 0167*       ld hl,str_iyu
041C2B CD 67 00 04 0168*       call printString
041C2F 2A 41 03 04 0169*       ld hl,(uiy)
041C33 CD A0 00 04 0170*       call printHex24
041C37 CD 7C 00 04 0171*       call printNewLine
041C3B             0172*   
041C3B             0173*       ; call vsync
041C3B             0174*   
041C3B CD 7C 00 04 0175*       call printNewLine
041C3F             0176*   
041C3F             0177*   ; check for right shift key and quit if pressed
041C3F             0178*       MOSCALL mos_getkbmap
041C3F 3E 1E       0001*M1 			LD	A, function
041C41 5B CF       0002*M1 			RST.LIL	08h
041C43             0179*   @stayhere:
041C43             0180*   ; 7 RightShift
041C43 DD CB 00 76 0181*       bit 6,(ix+0)
041C47 20 02       0182*       jr nz,@RightShift
041C49 18 F8       0183*       jr @stayhere
041C4B             0184*   @RightShift:
041C4B DD CB 0E 86 0185*       res 0,(ix+14) ; debounce the key (hopefully)
041C4F 3E 80       0186*       ld a,%10000000
041C51             0187*       ; call multiPurposeDelay
041C51             0188*   
041C51             0189*   ; restore everything
041C51 2A 35 03 04 0190*       ld hl, (uhl)
041C55 ED 4B 38 03 0191*       ld bc, (ubc)
       04          
041C5A ED 5B 3B 03 0192*       ld de, (ude)
       04          
041C5F DD 2A 3E 03 0193*       ld ix, (uix)
       04          
041C64 FD 2A 41 03 0194*       ld iy, (uiy)
       04          
041C69 F1          0195*       pop af
041C6A             0196*   ; all done
041C6A C9          0197*       ret
041C6B             0198*   
041C6B             0199*   ; print registers to screen in hexidecimal format
041C6B             0200*   ; inputs: none
041C6B             0201*   ; outputs: values of every register printed to screen
041C6B             0202*   ;    values of each register in global scratch memory
041C6B             0203*   ; destroys: nothing
041C6B             0204*   dumpRegistersHex:
041C6B             0205*   ; store everything in scratch
041C6B 22 35 03 04 0206*       ld (uhl),hl
041C6F ED 43 38 03 0207*       ld (ubc),bc
       04          
041C74 ED 53 3B 03 0208*       ld (ude),de
       04          
041C79 DD 22 3E 03 0209*       ld (uix),ix
       04          
041C7E FD 22 41 03 0210*       ld (uiy),iy
       04          
041C83 F5          0211*       push af ; fml
041C84 E1          0212*       pop hl ; thanks, zilog
041C85 22 32 03 04 0213*       ld (uaf),hl
041C89 F5          0214*       push af ; dammit
041C8A             0215*   
041C8A             0216*   ; home the cursor
041C8A             0217*       ; call vdu_home_cursor
041C8A             0218*       ; call printNewLine
041C8A             0219*   
041C8A             0220*   ; print each register
041C8A 21 B8 02 04 0221*       ld hl,str_afu
041C8E CD 67 00 04 0222*       call printString
041C92 2A 32 03 04 0223*       ld hl,(uaf)
041C96 CD A0 00 04 0224*       call printHex24
041C9A CD 7C 00 04 0225*       call printNewLine
041C9E             0226*   
041C9E 21 BD 02 04 0227*       ld hl,str_hlu
041CA2 CD 67 00 04 0228*       call printString
041CA6 2A 35 03 04 0229*       ld hl,(uhl)
041CAA CD A0 00 04 0230*       call printHex24
041CAE CD 7C 00 04 0231*       call printNewLine
041CB2             0232*   
041CB2 21 C2 02 04 0233*       ld hl,str_bcu
041CB6 CD 67 00 04 0234*       call printString
041CBA 2A 38 03 04 0235*       ld hl,(ubc)
041CBE CD A0 00 04 0236*       call printHex24
041CC2 CD 7C 00 04 0237*       call printNewLine
041CC6             0238*   
041CC6 21 C7 02 04 0239*       ld hl,str_deu
041CCA CD 67 00 04 0240*       call printString
041CCE 2A 3B 03 04 0241*       ld hl,(ude)
041CD2 CD A0 00 04 0242*       call printHex24
041CD6 CD 7C 00 04 0243*       call printNewLine
041CDA             0244*   
041CDA 21 CC 02 04 0245*       ld hl,str_ixu
041CDE CD 67 00 04 0246*       call printString
041CE2 2A 3E 03 04 0247*       ld hl,(uix)
041CE6 CD A0 00 04 0248*       call printHex24
041CEA CD 7C 00 04 0249*       call printNewLine
041CEE             0250*   
041CEE 21 D1 02 04 0251*       ld hl,str_iyu
041CF2 CD 67 00 04 0252*       call printString
041CF6 2A 41 03 04 0253*       ld hl,(uiy)
041CFA CD A0 00 04 0254*       call printHex24
041CFE             0255*   
041CFE CD 7C 00 04 0256*       call printNewLine
041D02 CD 7C 00 04 0257*       call printNewLine
041D06             0258*   ; restore everything
041D06 2A 35 03 04 0259*       ld hl, (uhl)
041D0A ED 4B 38 03 0260*       ld bc, (ubc)
       04          
041D0F ED 5B 3B 03 0261*       ld de, (ude)
       04          
041D14 DD 2A 3E 03 0262*       ld ix, (uix)
       04          
041D19 FD 2A 41 03 0263*       ld iy, (uiy)
       04          
041D1E F1          0264*       pop af
041D1F             0265*   ; all done
041D1F C9          0266*       ret
041D20             0267*   
041D20             0268*   dumpRegistersHexPrime:
041D20 D9          0269*       exx
041D21 08          0270*       ex af,af'
041D22 CD 6B 1C 04 0271*       call dumpRegistersHex
041D26 08          0272*       ex af,af'
041D27 D9          0273*       exx
041D28 C9          0274*       ret
041D29             0275*   
041D29             0276*   ; additionally dump prime registers
041D29             0277*   ; inputs: none
041D29             0278*   ; outputs: values of every register printed to screen
041D29             0279*   ; destroys: nothing
041D29             0280*   dumpRegistersHexAll:
041D29 CD 6B 1C 04 0281*       call dumpRegistersHex
041D2D 08          0282*       ex af,af'
041D2E D9          0283*       exx
041D2F CD 6B 1C 04 0284*       call dumpRegistersHex
041D33 08          0285*       ex af,af'
041D34 D9          0286*       exx
041D35 C9          0287*       ret
041D36             0288*   
041D36             0289*   ; print hlu to screen in hexidecimal format
041D36             0290*   ; inputs: none
041D36             0291*   ; destroys: nothing
041D36             0292*   print_hex_hl:
041D36 F5          0293*       push af
041D37 E5          0294*       push hl
041D38 21 BD 02 04 0295*       ld hl,str_hlu
041D3C CD 67 00 04 0296*       call printString
041D40 E1          0297*       pop hl
041D41 E5          0298*       push hl
041D42 CD A0 00 04 0299*       call printHex24
041D46 3E 20       0300*       ld a,' '
041D48 5B D7       0301*       rst.lil 10h
041D4A E1          0302*       pop hl
041D4B F1          0303*       pop af
041D4C C9          0304*       ret
041D4D             0305*   
041D4D             0306*   ; print bcu to screen in hexidecimal format
041D4D             0307*   ; inputs: none
041D4D             0308*   ; destroys: nothing
041D4D             0309*   print_hex_bc:
041D4D F5          0310*       push af
041D4E E5          0311*       push hl
041D4F C5          0312*       push bc
041D50 21 C2 02 04 0313*       ld hl,str_bcu
041D54 CD 67 00 04 0314*       call printString
041D58 E1          0315*       pop hl
041D59 E5          0316*       push hl
041D5A CD A0 00 04 0317*       call printHex24
041D5E 3E 20       0318*       ld a,' '
041D60 5B D7       0319*       rst.lil 10h
041D62 C1          0320*       pop bc
041D63 E1          0321*       pop hl
041D64 F1          0322*       pop af
041D65 C9          0323*       ret
041D66             0324*   
041D66             0325*   ; print deu to screen in hexidecimal format
041D66             0326*   ; inputs: none
041D66             0327*   ; destroys: nothing
041D66             0328*   print_hex_de:
041D66 F5          0329*       push af
041D67 E5          0330*       push hl
041D68 D5          0331*       push de
041D69 21 C7 02 04 0332*       ld hl,str_deu
041D6D CD 67 00 04 0333*       call printString
041D71 E1          0334*       pop hl
041D72 E5          0335*       push hl
041D73 CD A0 00 04 0336*       call printHex24
041D77 3E 20       0337*       ld a,' '
041D79 5B D7       0338*       rst.lil 10h
041D7B D1          0339*       pop de
041D7C E1          0340*       pop hl
041D7D F1          0341*       pop af
041D7E C9          0342*       ret
041D7F             0343*   
041D7F             0344*   
041D7F             0345*   ; inputs: whatever is in the flags register
041D7F             0346*   ; outputs: binary representation of flags
041D7F             0347*   ;          with a header so we know which is what
041D7F             0348*   ; destroys: nothing
041D7F             0349*   ; preserves: everything
041D7F             0350*   dumpFlags:
041D7F             0351*   ; first we curse zilog for not giving direct access to flags
041D7F F5          0352*       push af ; this is so we can send it back unharmed
041D80 F5          0353*       push af ; this is so we can pop it to hl
041D81             0354*   ; store everything in scratch
041D81 22 35 03 04 0355*       ld (uhl),hl
041D85 ED 43 38 03 0356*       ld (ubc),bc
       04          
041D8A ED 53 3B 03 0357*       ld (ude),de
       04          
041D8F DD 22 3E 03 0358*       ld (uix),ix
       04          
041D94 FD 22 41 03 0359*       ld (uiy),iy
       04          
041D99             0360*   ; next we print the header
041D99 21 C5 1D 04 0361*       ld hl,@header
041D9D CD 67 00 04 0362*       call printString
041DA1 E1          0363*       pop hl ; flags are now in l
041DA2 7D          0364*       ld a,l ; flags are now in a
041DA3 CD 6E 02 04 0365*       call printBin8
041DA7 CD 7C 00 04 0366*       call printNewLine
041DAB             0367*   ; restore everything
041DAB 2A 35 03 04 0368*       ld hl, (uhl)
041DAF ED 4B 38 03 0369*       ld bc, (ubc)
       04          
041DB4 ED 5B 3B 03 0370*       ld de, (ude)
       04          
041DB9 DD 2A 3E 03 0371*       ld ix, (uix)
       04          
041DBE FD 2A 41 03 0372*       ld iy, (uiy)
       04          
041DC3 F1          0373*       pop af ; send her home the way she came
041DC4 C9          0374*       ret
041DC5             0375*   ; Bit 7 (S): Sign flag
041DC5             0376*   ; Bit 6 (Z): Zero flag
041DC5             0377*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041DC5             0378*   ; Bit 4 (H): Half Carry flag
041DC5             0379*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041DC5             0380*   ; Bit 2 (PV): Parity/Overflow flag
041DC5             0381*   ; Bit 1 (N): Subtract flag
041DC5             0382*   ; Bit 0 (C): Carry flag
041DC5 53 5A 78 48 0383*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041DD0             0384*   
041DD0             0385*   
041DD0             0386*   ; print bytes from an address to the screen in hexidecimal format
041DD0             0387*   ; inputs: hl = address of first byte to print, a = number of bytes to print
041DD0             0388*   ; outputs: values of each byte printed to screen separated by spaces
041DD0             0389*   ; destroys: nothing
041DD0             0390*   dumpMemoryHex:
041DD0             0391*   ; save registers to the stack
041DD0 C5          0392*       push bc
041DD1 E5          0393*       push hl
041DD2 F5          0394*       push af
041DD3             0395*   
041DD3             0396*   ; print the address and separator
041DD3 CD A0 00 04 0397*       call printHex24
041DD7 3E 3A       0398*       ld a,':'
041DD9 5B D7       0399*       rst.lil 10h
041DDB 3E 20       0400*       ld a,' '
041DDD 5B D7       0401*       rst.lil 10h
041DDF             0402*   
041DDF             0403*   ; set b to be our loop counter
041DDF F1          0404*       pop af
041DE0 47          0405*       ld b,a
041DE1 E1          0406*       pop hl
041DE2 E5          0407*       push hl
041DE3 F5          0408*       push af
041DE4             0409*   @loop:
041DE4             0410*   ; print the byte
041DE4 7E          0411*       ld a,(hl)
041DE5 CD AE 00 04 0412*       call printHex8
041DE9             0413*   ; print a space
041DE9 3E 20       0414*       ld a,' '
041DEB 5B D7       0415*       rst.lil 10h
041DED 23          0416*       inc hl
041DEE 10 F4       0417*       djnz @loop
041DF0 CD 7C 00 04 0418*       call printNewLine
041DF4             0419*   
041DF4             0420*   ; restore everything
041DF4 F1          0421*       pop af
041DF5 E1          0422*       pop hl
041DF6 C1          0423*       pop bc
041DF7             0424*   
041DF7             0425*   ; all done
041DF7 C9          0426*       ret
041DF8             0427*   
041DF8             0428*   
041DF8             0429*   ; print bytes from an address to the screen in binary format
041DF8             0430*   ; inputs: hl = address of first byte to print, a = number of bytes to print
041DF8             0431*   ; outputs: values of each byte printed to screen separated by spaces
041DF8             0432*   ; destroys: nothing
041DF8             0433*   dumpMemoryBin:
041DF8             0434*   ; save all registers to the stack
041DF8 F5          0435*       push af
041DF9 C5          0436*       push bc
041DFA D5          0437*       push de
041DFB E5          0438*       push hl
041DFC DD E5       0439*       push ix
041DFE FD E5       0440*       push iy
041E00             0441*   
041E00             0442*   ; set b to be our loop counter
041E00 47          0443*       ld b,a
041E01             0444*   @loop:
041E01             0445*   ; print the byte
041E01 7E          0446*       ld a,(hl)
041E02 E5          0447*       push hl
041E03 C5          0448*       push bc
041E04 CD 6E 02 04 0449*       call printBin8
041E08 C1          0450*       pop bc
041E09             0451*   ; print a space
041E09 3E 20       0452*       ld a,' '
041E0B 5B D7       0453*       rst.lil 10h
041E0D E1          0454*       pop hl
041E0E 23          0455*       inc hl
041E0F 10 F0       0456*       djnz @loop
041E11 CD 7C 00 04 0457*       call printNewLine
041E15             0458*   
041E15             0459*   ; restore everything
041E15 FD E1       0460*       pop iy
041E17 DD E1       0461*       pop ix
041E19 E1          0462*       pop hl
041E1A D1          0463*       pop de
041E1B C1          0464*       pop bc
041E1C F1          0465*       pop af
041E1D             0466*   ; all done
041E1D C9          0467*       ret
041E1E             0468*   
041E1E             0469*   ; print bytes from an address to the screen in binary format
041E1E             0470*   ; with the bits of each byte in reverse order (lsb first)
041E1E             0471*   ; inputs: hl = address of first byte to print, a = number of bytes to print
041E1E             0472*   ; outputs: values of each byte printed to screen separated by spaces
041E1E             0473*   ; destroys: nothing
041E1E             0474*   dumpMemoryBinRev:
041E1E             0475*   ; save all registers to the stack
041E1E F5          0476*       push af
041E1F C5          0477*       push bc
041E20 D5          0478*       push de
041E21 E5          0479*       push hl
041E22 DD E5       0480*       push ix
041E24 FD E5       0481*       push iy
041E26             0482*   
041E26             0483*   ; set b to be our loop counter
041E26 47          0484*       ld b,a
041E27             0485*   @loop:
041E27             0486*   ; print the byte
041E27 7E          0487*       ld a,(hl)
041E28 E5          0488*       push hl
041E29 C5          0489*       push bc
041E2A CD 93 02 04 0490*       call printBin8Rev
041E2E C1          0491*       pop bc
041E2F             0492*   ; print a space
041E2F 3E 20       0493*       ld a,' '
041E31 5B D7       0494*       rst.lil 10h
041E33 E1          0495*       pop hl
041E34 23          0496*       inc hl
041E35 10 F0       0497*       djnz @loop
041E37 CD 7C 00 04 0498*       call printNewLine
041E3B             0499*   
041E3B             0500*   ; restore everything
041E3B FD E1       0501*       pop iy
041E3D DD E1       0502*       pop ix
041E3F E1          0503*       pop hl
041E40 D1          0504*       pop de
041E41 C1          0505*       pop bc
041E42 F1          0506*       pop af
041E43             0507*   ; all done
041E43 C9          0508*       ret
041E44             0509*   
041E44             0510*   DEBUG_PRINT:
041E44             0511*       PUSH_ALL
041E44 08          0001*M1     ex af,af'
041E45 D9          0002*M1     exx
041E46 F5          0003*M1     push af
041E47 E5          0004*M1     push hl
041E48 C5          0005*M1     push bc
041E49 D5          0006*M1     push de
041E4A             0007*M1 
041E4A 08          0008*M1     ex af,af'
041E4B D9          0009*M1     exx
041E4C F5          0010*M1     push af
041E4D E5          0011*M1     push hl
041E4E C5          0012*M1     push bc
041E4F D5          0013*M1     push de
041E50 DD E5       0014*M1     push ix
041E52 FD E5       0015*M1     push iy
041E54             0512*       ; ld c,0 ; X
041E54             0513*       ; ld b,0 ; Y
041E54             0514*       ; call vdu_move_cursor
041E54 CD 7C 00 04 0515*       call printNewLine
041E58             0516*       POP_ALL
041E58 FD E1       0001*M1     pop iy
041E5A DD E1       0002*M1     pop ix
041E5C D1          0003*M1     pop de
041E5D C1          0004*M1     pop bc
041E5E E1          0005*M1     pop hl
041E5F F1          0006*M1     pop af
041E60 08          0007*M1     ex af,af'
041E61 D9          0008*M1     exx
041E62             0009*M1 
041E62 D1          0010*M1     pop de
041E63 C1          0011*M1     pop bc
041E64 E1          0012*M1     pop hl
041E65 F1          0013*M1     pop af
041E66 08          0014*M1     ex af,af'
041E67 D9          0015*M1     exx
041E68             0517*       PUSH_ALL
041E68 08          0001*M1     ex af,af'
041E69 D9          0002*M1     exx
041E6A F5          0003*M1     push af
041E6B E5          0004*M1     push hl
041E6C C5          0005*M1     push bc
041E6D D5          0006*M1     push de
041E6E             0007*M1 
041E6E 08          0008*M1     ex af,af'
041E6F D9          0009*M1     exx
041E70 F5          0010*M1     push af
041E71 E5          0011*M1     push hl
041E72 C5          0012*M1     push bc
041E73 D5          0013*M1     push de
041E74 DD E5       0014*M1     push ix
041E76 FD E5       0015*M1     push iy
041E78 CD 7F 1D 04 0518*       call dumpFlags
041E7C             0519*       POP_ALL
041E7C FD E1       0001*M1     pop iy
041E7E DD E1       0002*M1     pop ix
041E80 D1          0003*M1     pop de
041E81 C1          0004*M1     pop bc
041E82 E1          0005*M1     pop hl
041E83 F1          0006*M1     pop af
041E84 08          0007*M1     ex af,af'
041E85 D9          0008*M1     exx
041E86             0009*M1 
041E86 D1          0010*M1     pop de
041E87 C1          0011*M1     pop bc
041E88 E1          0012*M1     pop hl
041E89 F1          0013*M1     pop af
041E8A 08          0014*M1     ex af,af'
041E8B D9          0015*M1     exx
041E8C             0520*       PUSH_ALL
041E8C 08          0001*M1     ex af,af'
041E8D D9          0002*M1     exx
041E8E F5          0003*M1     push af
041E8F E5          0004*M1     push hl
041E90 C5          0005*M1     push bc
041E91 D5          0006*M1     push de
041E92             0007*M1 
041E92 08          0008*M1     ex af,af'
041E93 D9          0009*M1     exx
041E94 F5          0010*M1     push af
041E95 E5          0011*M1     push hl
041E96 C5          0012*M1     push bc
041E97 D5          0013*M1     push de
041E98 DD E5       0014*M1     push ix
041E9A FD E5       0015*M1     push iy
041E9C CD 6B 1C 04 0521*       call dumpRegistersHex
041EA0             0522*       ; call waitKeypress
041EA0 CD 7C 00 04 0523*       call printNewLine
041EA4             0524*       POP_ALL
041EA4 FD E1       0001*M1     pop iy
041EA6 DD E1       0002*M1     pop ix
041EA8 D1          0003*M1     pop de
041EA9 C1          0004*M1     pop bc
041EAA E1          0005*M1     pop hl
041EAB F1          0006*M1     pop af
041EAC 08          0007*M1     ex af,af'
041EAD D9          0008*M1     exx
041EAE             0009*M1 
041EAE D1          0010*M1     pop de
041EAF C1          0011*M1     pop bc
041EB0 E1          0012*M1     pop hl
041EB1 F1          0013*M1     pop af
041EB2 08          0014*M1     ex af,af'
041EB3 D9          0015*M1     exx
041EB4 C9          0525*       ret
041EB5             0526*   DEBUG_WAITKEYPRESS:
041EB5             0527*       PUSH_ALL
041EB5 08          0001*M1     ex af,af'
041EB6 D9          0002*M1     exx
041EB7 F5          0003*M1     push af
041EB8 E5          0004*M1     push hl
041EB9 C5          0005*M1     push bc
041EBA D5          0006*M1     push de
041EBB             0007*M1 
041EBB 08          0008*M1     ex af,af'
041EBC D9          0009*M1     exx
041EBD F5          0010*M1     push af
041EBE E5          0011*M1     push hl
041EBF C5          0012*M1     push bc
041EC0 D5          0013*M1     push de
041EC1 DD E5       0014*M1     push ix
041EC3 FD E5       0015*M1     push iy
041EC5 CD 5A 03 04 0528*       call waitKeypress
041EC9             0529*       POP_ALL
041EC9 FD E1       0001*M1     pop iy
041ECB DD E1       0002*M1     pop ix
041ECD D1          0003*M1     pop de
041ECE C1          0004*M1     pop bc
041ECF E1          0005*M1     pop hl
041ED0 F1          0006*M1     pop af
041ED1 08          0007*M1     ex af,af'
041ED2 D9          0008*M1     exx
041ED3             0009*M1 
041ED3 D1          0010*M1     pop de
041ED4 C1          0011*M1     pop bc
041ED5 E1          0012*M1     pop hl
041ED6 F1          0013*M1     pop af
041ED7 08          0014*M1     ex af,af'
041ED8 D9          0015*M1     exx
041ED9 C9          0530*       RET
041EDA             0531*   
041EDA             0532*   dumpVduCmdStr:
041EDA             0533*       PUSH_ALL
041EDA 08          0001*M1     ex af,af'
041EDB D9          0002*M1     exx
041EDC F5          0003*M1     push af
041EDD E5          0004*M1     push hl
041EDE C5          0005*M1     push bc
041EDF D5          0006*M1     push de
041EE0             0007*M1 
041EE0 08          0008*M1     ex af,af'
041EE1 D9          0009*M1     exx
041EE2 F5          0010*M1     push af
041EE3 E5          0011*M1     push hl
041EE4 C5          0012*M1     push bc
041EE5 D5          0013*M1     push de
041EE6 DD E5       0014*M1     push ix
041EE8 FD E5       0015*M1     push iy
041EEA 79          0534*       ld a,c
041EEB CD D0 1D 04 0535*       call dumpMemoryHex
041EEF CD 5A 03 04 0536*       call waitKeypress
041EF3             0537*       POP_ALL
041EF3 FD E1       0001*M1     pop iy
041EF5 DD E1       0002*M1     pop ix
041EF7 D1          0003*M1     pop de
041EF8 C1          0004*M1     pop bc
041EF9 E1          0005*M1     pop hl
041EFA F1          0006*M1     pop af
041EFB 08          0007*M1     ex af,af'
041EFC D9          0008*M1     exx
041EFD             0009*M1 
041EFD D1          0010*M1     pop de
041EFE C1          0011*M1     pop bc
041EFF E1          0012*M1     pop hl
041F00 F1          0013*M1     pop af
041F01 08          0014*M1     ex af,af'
041F02 D9          0015*M1     exx
041F03 C9          0538*       ret
041F04             0539*   ; end dumpVduCmdStr
041F04             0047    
041F04             0048    ; --- MAIN PROGRAM FILE ---
041F04             0049    init:
041F04 CD 5B 21 04 0050        call load_command_buffer
041F08 C9          0051        ret
041F09             0052    ; end init
041F09             0053    
041F09             0054    ch0_buffer: equ 0x3000
041F09             0055    ch1_buffer: equ 0x3001
041F09             0056    cmd0_buffer: equ 0x3002
041F09             0057    cmd1_buffer: equ 0x3003
041F09             0058    
041F09             0059    get_input:
041F09 FD 21 AA 1F 0060        ld iy,tmr_input
       04          
041F0E 21 6E 00 00 0061        ld hl,110 ; 1 second
041F12 CD 6D 10 04 0062        call tmr_set
041F16             0063    @loop:
041F16             0064    ; check timer expired
041F16 FD 21 AA 1F 0065        ld iy,tmr_input
       04          
041F1B CD 7B 10 04 0066        call tmr_get
041F1F C8          0067        ret z ; yes, so return
041F20 F8          0068        ret m ; way expired, so return
041F21             0069    
041F21             0070    ; check for keyboard input
041F21             0071        MOSCALL mos_getkbmap ; IX points to keyboard map
041F21 3E 1E       0001M1  			LD	A, function
041F23 5B CF       0002M1  			RST.LIL	08h
041F25 21 00 00 00 0072        ld hl,0 ; clear hl
041F29             0073    ; 49 Num1
041F29 DD CB 06 46 0074        bit 0,(ix+6)
041F2D CA 35 1F 04 0075        jp z,@F
041F31 21 BC 19 04 0076        ld hl,FAFRICA
041F35             0077    @@:
041F35             0078    ; 50 Num2
041F35 DD CB 06 4E 0079        bit 1,(ix+6)
041F39 CA 41 1F 04 0080        jp z,@F
041F3D 21 CD 19 04 0081        ld hl,FANYTIME
041F41             0082    @@:
041F41             0083    ; 18 Num3
041F41 DD CB 02 4E 0084        bit 1,(ix+2)
041F45 CA 4D 1F 04 0085        jp z,@F
041F49 21 DF 19 04 0086        ld hl,FBARRACUDA
041F4D             0087    @@:
041F4D             0088    ; 19 Num4
041F4D DD CB 02 56 0089        bit 2,(ix+2)
041F51 CA 59 1F 04 0090        jp z,@F
041F55 21 F3 19 04 0091        ld hl,FCOME_UNDONE
041F59             0092    @@:
041F59             0093    ; 20 Num5
041F59 DD CB 02 5E 0094        bit 3,(ix+2)
041F5D CA 65 1F 04 0095        jp z,@F
041F61 21 09 1A 04 0096        ld hl,FEVERY_BREATH_YOU_TAKE
041F65             0097    @@:
041F65             0098    ; 53 Num6
041F65 DD CB 06 66 0099        bit 4,(ix+6)
041F69 CA 71 1F 04 0100        jp z,@F
041F6D 21 29 1A 04 0101        ld hl,FRHIANNON
041F71             0102    @@:
041F71             0103    ; 37 Num7
041F71 DD CB 04 66 0104        bit 4,(ix+4)
041F75 CA 7D 1F 04 0105        jp z,@F
041F79 21 3C 1A 04 0106        ld hl,FTAKE_A_RIDE
041F7D             0107    @@:
041F7D             0108    ; 22 Num8
041F7D DD CB 02 6E 0109        bit 5,(ix+2)
041F81 CA 89 1F 04 0110        jp z,@F
041F85 21 52 1A 04 0111        ld hl,FAMBIENT_BEAT70
041F89             0112    @@:
041F89             0113    ; 39 Num9
041F89 DD CB 04 76 0114        bit 6,(ix+4)
041F8D CA 95 1F 04 0115        jp z,@F
041F91 21 6B 1A 04 0116        ld hl,FSPACE_ADVENTURE
041F95             0117    @@:
041F95             0118    ; 40 Num0
041F95 DD CB 04 7E 0119        bit 7,(ix+4)
041F99 CA 9D 1F 04 0120        jp z,@F
041F9D             0121    @@:
041F9D             0122    
041F9D             0123    ; if hl is non-zero we have a song request
041F9D             0124        SIGN_HLU
041F9D 19          0001M1      add hl,de ; 1 cycle
041F9E B7          0002M1      or a ; clear flags ; 1 cycle
041F9F ED 52       0003M1      sbc hl,de ; 2 cycles
041FA1             0004M1      ; 4 cycles total
041FA1 CA 16 1F 04 0125        jp z,@loop ; no request so loop
041FA5 C1          0126        pop bc ; dummy pop to balance stack
041FA6 C3 B8 1F 04 0127        jp play_song ; play the requested song
041FAA             0128    ; end get_input
041FAA             0129    
041FAA             0130    tmr_input: ds 6 ; input timer buffer
041FB0             0131    
041FB0             0132    
041FB0             0133    main:
       FF FF FF FF 
       FF FF 
041FB0 CD 7C 00 04 0134        call printNewLine
041FB4             0135    ; default song
041FB4 21 29 1A 04 0136        ld hl,FRHIANNON
041FB8             0137    
041FB8             0138    ; stream a song from the SD card
041FB8             0139    ; inputs: hl = pointer to filename
041FB8             0140    ; requirements: the file must be 8-bit signed PCM mono sampled at 15360 Hz
041FB8             0141    ; uses: sound channels 0 and 1, buffers 0x3000 and 0x3001
041FB8             0142    play_song:
041FB8             0143    ; tell the user what they've won
041FB8 E5          0144        push hl
041FB9 CD 60 00 04 0145        call printInline
041FBD 50 6C 61 79 0146        asciz "Playing song: "
       69 6E 67 20 
       73 6F 6E 67 
       3A 20 00    
041FCC E1          0147        pop hl
041FCD E5          0148        push hl
041FCE CD 67 00 04 0149        call printString ; print the song filename
041FD2 CD 7C 00 04 0150        call printNewLine
041FD6             0151    
041FD6             0152    ; debounce keypress
041FD6 3E 80       0153        ld a,%10000000 ; 1 second
041FD8 CD F7 10 04 0154        call multiPurposeDelay
041FDC             0155    
041FDC             0156    ; finally play the song
041FDC E1          0157        pop hl
041FDD             0158    
041FDD             0159    ; open the file in read mode
041FDD             0160    ; Open a file
041FDD             0161    ; HLU: Filename
041FDD             0162    ;   C: Mode
041FDD             0163    ; Returns:
041FDD             0164    ;   A: Filehandle, or 0 if couldn't open
041FDD 0E 01       0165    	ld c,fa_read
041FDF             0166        MOSCALL mos_fopen
041FDF 3E 0A       0001M1  			LD	A, function
041FE1 5B CF       0002M1  			RST.LIL	08h
041FE3 32 3E 20 04 0167        ld (@filehandle),a
041FE7             0168    
041FE7             0169    @read_file:
041FE7             0170    
041FE7             0171    ; Read a block of data from a file
041FE7             0172    ;   C: Filehandle
041FE7             0173    ; HLU: Pointer to where to write the data to
041FE7             0174    ; DEU: Number of bytes to read
041FE7             0175    ; Returns:
041FE7             0176    ; DEU: Number of bytes read
041FE7 3A 3E 20 04 0177        ld a,(@filehandle)
041FEB 4F          0178        ld c,a
041FEC 21 00 22 04 0179        ld hl,song_data
041FF0 11 00 3C 00 0180        ld de,256*60
041FF4             0181        MOSCALL mos_fread
041FF4 3E 1A       0001M1  			LD	A, function
041FF6 5B CF       0002M1  			RST.LIL	08h
041FF8             0182    
041FF8             0183    ; test de for zero bytes read
041FF8 21 00 00 00 0184        ld hl,0
041FFC AF          0185        xor a ; clear carry
041FFD ED 52       0186        sbc hl,de
041FFF CA 33 20 04 0187        jp z,@close_file
042003             0188    
042003             0189    ; load a vdu buffer from local memory
042003             0190    ; inputs: hl = bufferId ; bc = length ; de = pointer to data
042003 3A 3D 20 04 0191        ld a,(@channel)
042007 3C          0192        inc a
042008 E6 01       0193        and 1
04200A 32 3D 20 04 0194        ld (@channel),a
04200E 21 00 30 00 0195        ld hl,ch0_buffer
042012 6F          0196        ld l,a
042013 E5          0197        push hl ; sample bufferId
042014 CD 17 15 04 0198        call vdu_clear_buffer
042018 E1          0199        pop hl
042019 E5          0200        push hl
04201A D5          0201        push de ; chunksize
04201B C1          0202        pop bc
04201C 11 00 22 04 0203        ld de,song_data
042020 CD 02 13 04 0204        call vdu_load_buffer
042024             0205    
042024 CD 09 1F 04 0206        call get_input
042028             0207    
042028 E1          0208        pop hl
042029 2C          0209        inc l
04202A 2C          0210        inc l ; play commmand bufferId
04202B CD FC 14 04 0211        call vdu_call_buffer
04202F             0212    
04202F             0213    ; read the next block
04202F C3 E7 1F 04 0214        jp @read_file
042033             0215    
042033             0216    ; close the file
042033             0217    @close_file:
042033 F1          0218        pop af ; dummy pop to balance stack
042034 3A 3E 20 04 0219        ld a,(@filehandle)
042038             0220        MOSCALL mos_fclose
042038 3E 0B       0001M1  			LD	A, function
04203A 5B CF       0002M1  			RST.LIL	08h
04203C C9          0221        ret
04203D             0222    
04203D 00          0223    @channel: db 0 ; channel number
04203E             0224    
04203E 00          0225    @filehandle: db 0 ; file handle
04203F 00 00 00    0226    @fil: dl 0 ; pointer to FIL struct
042042             0227    
042042 00 00 00    0228    @chunkpointer: dl 0 ; pointer to current chunk
042045             0229    
042045             0230    ; File information structure (FILINFO)
042045             0231    @filinfo:
042045 00 00 00 00 0232    @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
042049 00 00       0233    @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
04204B 00 00       0234    @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
04204D 00          0235    @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
04204E 00 00 00 00 0236    @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
04205B 00 00 00 00 0237    @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04215B             0238    
04215B             0239    
04215B             0240    load_command_buffer:
04215B 21 02 30 00 0241        ld hl,cmd0_buffer
04215F CD 17 15 04 0242        call vdu_clear_buffer
042163 21 02 30 00 0243        ld hl,cmd0_buffer
042167 01 1D 00 00 0244        ld bc,@cmd0_end-@cmd0
04216B 11 8C 21 04 0245        ld de,@cmd0
04216F CD D4 14 04 0246        call vdu_write_block_to_buffer
042173             0247    
042173 21 03 30 00 0248        ld hl,cmd1_buffer
042177 CD 17 15 04 0249        call vdu_clear_buffer
04217B 21 03 30 00 0250        ld hl,cmd1_buffer
04217F 01 1D 00 00 0251        ld bc,@cmd1_end-@cmd1
042183 11 A9 21 04 0252        ld de,@cmd1
042187 CD D4 14 04 0253        call vdu_write_block_to_buffer
04218B C9          0254        ret
04218C             0255    
04218C             0256    @cmd0:
04218C             0257    ; vdu_buffer_to_sound command string
04218C             0258    ; Command 5: Buffer to sound
04218C 17 00 85    0259        db 23,0,0x85 ; vdu sound command header
04218F 00          0260        db 0x00 ; channel (ignored)
042190 05          0261        db 0x05 ; buffer to sound command
042191 02          0262        db 0x02 ; command 2 create sample
042192 00 30       0263        dw ch0_buffer
042194 08          0264        db 0+8 ; 0 = 8-bit signed PCM mono, 8 = sample rate argument follows
042195 00 3C       0265        dw sample_rate
042197             0266    ; vdu_play_sfx command string
042197             0267    ; Command 4: Set waveform
042197             0268    ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
042197 17 00 85    0269        db 23,0,$85 ; vdu sound command header
04219A 00          0270        db 0 ; channel
04219B 04          0271        db 4 ; set waveform command
04219C 08          0272        db 8 ; waveform 8 = sample
04219D 00 30       0273        dw ch0_buffer ; sample bufferId
04219F             0274    ; Command 0: Play note
04219F             0275    ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
04219F 17 00 85    0276        db 23,0,$85 ; vdu sound command header
0421A2 00          0277        db 0 ; channel
0421A3 00          0278        db 0 ; play note command
0421A4 7F          0279        db 127  ; volume 127 = max
0421A5 00 00       0280        dw 0 ; frequency (relevant only for tuneable samples)
0421A7 00 00       0281        dw 0 ; duration (ms), zero means play one time in full
0421A9             0282    @cmd0_end:
0421A9             0283    
0421A9             0284    @cmd1:
0421A9             0285    ; vdu_buffer_to_sound command string
0421A9             0286    ; Command 5: Buffer to sound
0421A9 17 00 85    0287        db 23,0,0x85 ; vdu sound command header
0421AC 00          0288        db 0x00 ; channel (ignored)
0421AD 05          0289        db 0x05 ; buffer to sound command
0421AE 02          0290        db 0x02 ; command 2 create sample
0421AF 01 30       0291        dw ch1_buffer
0421B1 08          0292        db 0+8 ; 0 = 8-bit signed PCM mono, 8 = sample rate argument follows
0421B2 00 3C       0293        dw sample_rate
0421B4             0294    ; vdu_play_sfx command string
0421B4             0295    ; Command 4: Set waveform
0421B4             0296    ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
0421B4 17 00 85    0297        db 23,0,$85 ; vdu sound command header
0421B7 01          0298        db 1 ; channel
0421B8 04          0299        db 4 ; set waveform command
0421B9 08          0300        db 8 ; waveform 8 = sample
0421BA 01 30       0301        dw ch1_buffer ; sample bufferId
0421BC             0302    ; Command 0: Play note
0421BC             0303    ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
0421BC 17 00 85    0304        db 23,0,$85 ; vdu sound command header
0421BF 01          0305        db 1 ; channel
0421C0 00          0306        db 0 ; play note command
0421C1 7F          0307        db 127  ; volume 127 = max
0421C2 00 00       0308        dw 0 ; frequency (relevant only for tuneable samples)
0421C4 00 00       0309        dw 0 ; duration (ms), zero means play one time in full
0421C6             0310    @cmd1_end:
0421C6             0311    ; end load_command_buffers
0421C6             0312    
0421C6 FF FF FF FF 0313        align 256 ; align to 256-byte boundary (may be helpful ... or not)
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF       
042200             0314    song_data: ; blkw 6556,0 ; buffer for sound data
